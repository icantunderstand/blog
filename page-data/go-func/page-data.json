{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/go-func",
    "result": {"data":{"markdownRemark":{"html":"<h2>函数</h2>\n<h3>函数声明</h3>\n<p>函数声明包含函数的名字,形参列表,返回值列表(可选)以及函数体构成.</p>\n<pre><code>func name(parameter-list) (result-list) {\n  body\n}\n</code></pre>\n<p>需要注意一下几点:</p>\n<ol>\n<li>\n<p>函数的形参列表和返回值列表组成函数的签名,函数的签名会在函数被调用的时候做校验是否调用合法.</p>\n</li>\n<li>\n<p>参数的传递是按值传递的.当传递引用类型作为实参的时候,可能会修改实参变量.</p>\n</li>\n<li>\n<p>支持多返回值.</p>\n<p>func test(a [3]int) (int x, int y) {\nreturn x, y\n}\nfunc add(vals ...int) int {  // 变长参数声明\nsum := 0\nfor _, v := range vals {\nsum += v\n}\nreturn sum\n}</p>\n</li>\n</ol>\n<h4>函数变量声明</h4>\n<p>函数声明只能定义在包级别的作用域,函数变量声明可以在任何表达式内指定.函数变量生命能获取到整个词法环境(可以访问外部的变量)</p>\n<pre><code>func test() func(int) int {\n  x := 2\n  return func (y int) int {\n    return x * y\n  } // 这里的函数变量(匿名函数)可以访问到外部的x\n}\n</code></pre>\n<h3>函数流程控制</h3>\n<h4>defer</h4>\n<p>defer语句是普通的函数调用,defer语句能确保函数的return语句或函数执行完毕之后执行对应的defer函数.主要为了在函数的执行完毕后做特定的行为.</p>\n<pre><code>func test(x int) int {\n    defer func() { fmt.Print(x) }() // defer语句必须返回一个可执行的语句\n    return x\n} // 这个函数会在返回后打印入参\n</code></pre>\n<h2>方法</h2>\n<h3>方法声明</h3>\n<p>方法是声明特定类型(对象)上可以执行的函数. 通常可以使用如下的方式声明:</p>\n<pre><code>func (p structName) funcName(parameter-list) (result-list) {\n  body\n}  \n// 声明可以在p类型上调用funcName的方法 \nfunc (p Point) add() int {\n  return p.x + p.y\n}\np := Point{ 2, 3}\n  p.add()\n</code></pre>\n<p>注意:</p>\n<ol>\n<li>由于方法的调用是p.funcName和获取p结构体上的属性一致,要注意同一类型上的命名冲突.</li>\n</ol>\n<h3>指针接收者方法</h3>\n<p>由于方法会复制实参,当需要方法的调用对外界产生影响的时候,就需要通过指针类型来完成方法的声明,如下面的例子:</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10} // 获取指针\n  p.ScaleBy(2) // p{20, 20}\n  q := Point{1,2}\n  q.ScaleBy(3)  // q{3,6} 当类型符合的时候,会进行隐式转换 相当于 (&#x26;q).ScaleBy(3)\n}  \n</code></pre>\n<h3>方法变量和方法表达式</h3>\n<h4>方法变量</h4>\n<p>可以将一个特定类型的方法赋值给一个变量,这个变量称为方法变量.该方法变量已绑定到特定的接收者上(caller),通过传递形参就可以完成方法的调用.通常用于绑定特定的接受者.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := p.ScaleBy\n  scaleBy(2) // p{20, 20}\n}  \n</code></pre>\n<h4>方法表达式</h4>\n<p>方便表达式必须在调用的时候,提供接受者.方法表达式是把对应结构的函数行为进行声明.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := (*Point).ScaleBy // 方法表达式\n  scaleBy(p,2)\n}\n</code></pre>","frontmatter":{"date":"2019-04-19","path":"/go-func","title":"go语言入门之-函数和方法"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}