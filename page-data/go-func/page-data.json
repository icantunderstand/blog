{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/go-func",
    "result": {"data":{"markdownRemark":{"html":"<h2>函数</h2>\n<h3>函数声明</h3>\n<p>函数声明包含函数的名字,形参列表,返回值列表(可选)以及函数体构成.</p>\n<pre><code>func name(parameter-list) (result-list) {\r\n  body\r\n}\n</code></pre>\n<p>需要注意一下几点:</p>\n<ol>\n<li>\n<p>函数的形参列表和返回值列表组成函数的签名,函数的签名会在函数被调用的时候做校验是否调用合法.</p>\n</li>\n<li>\n<p>参数的传递是按值传递的.当传递引用类型作为实参的时候,可能会修改实参变量.</p>\n</li>\n<li>\n<p>支持多返回值.</p>\n<p>func test(a [3]int) (int x, int y) {\r\nreturn x, y\r\n}\r\nfunc add(vals ...int) int {  // 变长参数声明\r\nsum := 0\r\nfor _, v := range vals {\r\nsum += v\r\n}\r\nreturn sum\r\n}</p>\n</li>\n</ol>\n<h4>函数变量声明</h4>\n<p>函数声明只能定义在包级别的作用域,函数变量声明可以在任何表达式内指定.函数变量生命能获取到整个词法环境(可以访问外部的变量)</p>\n<pre><code>func test() func(int) int {\r\n  x := 2\r\n  return func (y int) int {\r\n    return x * y\r\n  } // 这里的函数变量(匿名函数)可以访问到外部的x\r\n}\n</code></pre>\n<h3>函数流程控制</h3>\n<h4>defer</h4>\n<p>defer语句是普通的函数调用,defer语句能确保函数的return语句或函数执行完毕之后执行对应的defer函数.主要为了在函数的执行完毕后做特定的行为.</p>\n<pre><code>func test(x int) int {\r\n    defer func() { fmt.Print(x) }() // defer语句必须返回一个可执行的语句\r\n    return x\r\n} // 这个函数会在返回后打印入参\n</code></pre>\n<h2>方法</h2>\n<h3>方法声明</h3>\n<p>方法是声明特定类型(对象)上可以执行的函数. 通常可以使用如下的方式声明:</p>\n<pre><code>func (p structName) funcName(parameter-list) (result-list) {\r\n  body\r\n}  \r\n// 声明可以在p类型上调用funcName的方法 \r\nfunc (p Point) add() int {\r\n  return p.x + p.y\r\n}\r\np := Point{ 2, 3}\r\n  p.add()\n</code></pre>\n<p>注意:</p>\n<ol>\n<li>由于方法的调用是p.funcName和获取p结构体上的属性一致,要注意同一类型上的命名冲突.</li>\n</ol>\n<h3>指针接收者方法</h3>\n<p>由于方法会复制实参,当需要方法的调用对外界产生影响的时候,就需要通过指针类型来完成方法的声明,如下面的例子:</p>\n<pre><code>type Point struct {\r\n  x, y int\r\n}\r\n\r\nfunc (p *Point) ScaleBy(factor int) {\r\n  p.x *= factor\r\n  p.y *= factor\r\n}\r\n\r\nfunc main() {\r\n  p := &#x26;Point{10, 10} // 获取指针\r\n  p.ScaleBy(2) // p{20, 20}\r\n  q := Point{1,2}\r\n  q.ScaleBy(3)  // q{3,6} 当类型符合的时候,会进行隐式转换 相当于 (&#x26;q).ScaleBy(3)\r\n}  \n</code></pre>\n<h3>方法变量和方法表达式</h3>\n<h4>方法变量</h4>\n<p>可以将一个特定类型的方法赋值给一个变量,这个变量称为方法变量.该方法变量已绑定到特定的接收者上(caller),通过传递形参就可以完成方法的调用.通常用于绑定特定的接受者.</p>\n<pre><code>type Point struct {\r\n  x, y int\r\n}\r\n\r\nfunc (p *Point) ScaleBy(factor int) {\r\n  p.x *= factor\r\n  p.y *= factor\r\n}\r\n\r\nfunc main() {\r\n  p := &#x26;Point{10, 10}\r\n  scaleBy := p.ScaleBy\r\n  scaleBy(2) // p{20, 20}\r\n}  \n</code></pre>\n<h4>方法表达式</h4>\n<p>方便表达式必须在调用的时候,提供接受者.方法表达式是把对应结构的函数行为进行声明.</p>\n<pre><code>type Point struct {\r\n  x, y int\r\n}\r\n\r\nfunc (p *Point) ScaleBy(factor int) {\r\n  p.x *= factor\r\n  p.y *= factor\r\n}\r\n\r\nfunc main() {\r\n  p := &#x26;Point{10, 10}\r\n  scaleBy := (*Point).ScaleBy // 方法表达式\r\n  scaleBy(p,2)\r\n}\n</code></pre>","frontmatter":{"date":"2019-04-19","path":"/go-func","title":"go语言入门之-函数和方法"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}