{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/javascript-call",
    "result": {"data":{"markdownRemark":{"html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有先入先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这个在一定程度上也解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定(<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>).</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a></p>\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a></p>\n<p><a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a></p>\n<p><a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","frontmatter":{"date":"2019-01-15","path":"/javascript-call","title":"深入理解javascript系列之执行环境"}}},"pageContext":{"readingTime":"6 min read"}},
    "staticQueryHashes": []}