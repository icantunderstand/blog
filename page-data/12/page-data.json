{"componentChunkName":"component---src-templates-index-js","path":"/12","result":{"pageContext":{"pageAllCount":89,"group":[{"node":{"id":"912d5b0a-962a-594b-b556-032a8ee38a39","html":"<h2>前言</h2>\n<p>在react最新的reconciliation使用的是Fiber架构.Fiber使用的增量渲染的模式,具体的实现是渲染的任务可以被拆分,在页面更新的时候具体的任务可以被打断,复用.这些特性无疑对页面交互是有很大的提升.下面通过React Fiber Architecture这篇文章来对Fiber有个大体的认识.之后的系列我会深入react的源码来仔细学习Fiber的具体实现.</p>\n<h2>基础知识</h2>\n<h3>What is reconciliation?</h3>\n<h4>reconciliation</h4>\n<p>react通过Virtual Dom和真实Dom之间建立缓冲,通过diff出变化前后virtual Dom的差异来将差异更新到真实Dom上.reconciliation正是对比Virtual Dom差异的实现.</p>\n<h4>update(更新)</h4>\n<p>渲染页面的数据发生变化导致页面更新</p>\n<p>在没有reconciliation(调和)的情况下,数据的变动将会导致整个页面重新绘制.通过Virtual Dom来代表将要渲染的页面,将Virtual Dom交给对应的renderer(react-dom, react native)来进行页面的绘制.在页面更新的时候通过调和来生成前后Virtual Dom树的差异来进行页面的更新.这样一定程度上提高了页面的性能.React的更新策略是在下面的假设下进行的:</p>\n<ol>\n<li>组件很少进行跨层级的移动</li>\n<li>不同类型的组件生成的结构是不同的</li>\n<li>相同类型的列表元素可以通过唯一的标识来进行复用</li>\n</ol>\n<h3>Scheduling(调度)</h3>\n<h4>scheduling</h4>\n<p>确定哪些更新的任务需要执行</p>\n<h4>work(更新任务)</h4>\n<p>需要执行的任务,通常是页面的更新\nReact的构建UI的库,它采取pull(拉)的模式来处理页面的更新交互.在push(推)的模式中数据(更新)推动整个页面的更新.React对更新的任务进行了一定的调度,来达到更好的页面交互.React采用这种策略主要有以下的原因:</p>\n<ol>\n<li>在处理UI界面的时候,通常上不是所有的更新都需要立刻被执行的.(可以类比图片的懒加载)</li>\n<li>不同的类型更新应该有优先级.为了更好的交互体验,通过优先级可以提供更好的页面交互.(比如动画的优先级更高,页面会更加流畅)</li>\n<li>push的模式需要开发者组织页面的更新,pull的模式使得React可以帮助开发者实现更好的页面交互.</li>\n</ol>\n<h2>what is Fiber?</h2>\n<p>通过Fiber使得React可以更好的调度任务.主要有以下的功能:</p>\n<ol>\n<li>暂停任务并且在之后继续执行</li>\n<li>对不同的任务设置优先级</li>\n<li>复用之前完成的任务的结果</li>\n<li>丢弃不需要的任务</li>\n</ol>\n<p>在这里可以简单的将fiber理解为需要做的任务.在进行页面绘制的时候组件更新和函数执行的任务都会被推进执行的栈结构.这种模式当太多任务需要执行的时候会导致页面的交互变的卡顿.浏览器提供了两个api来处理上面的问题.</p>\n<ol>\n<li>requestIdleCallback 通过requestIdleCallback可以在空闲的时候执行一个低优先级的任务</li>\n<li>requestAnimationFrame 可以在浏览器下次重绘之前执行一个较高优先级的任务</li>\n</ol>\n<p>为了利用上面的函数来实现页面的更新,就需要将渲染的任务拆分成多个任务.Fiber架构可以理解为重新实现的栈而fiber节点是一个虚拟的栈帧.Fiber架构通过调度帧的执行逻辑来完成页面的更新.</p>\n<h3>fiber结构</h3>\n<p>一个fiber节点代表一个栈帧,也代表一个组件的实例.下面是fiber结构一些重要的属性:</p>\n<h4>type  key</h4>\n<p>type和key对于fiber节点的作用跟type和key对React element的作用一致. type可以判断fiber节点对应的是React组件还是宿主环境的组件(div).key用于调和的时候复用fiber.</p>\n<h4>child sibling  return</h4>\n<p>fiber是通过单链表进行关联的.fiber节点的return指向它的parent.child指向fiber第一个子节点.sibling指向当前fiber节点的兄弟节点.</p>\n<pre><code>function Parent() {\n  return [&#x3C;Child1 />, &#x3C;Child2 />]\n}\n</code></pre>\n<p>上面的结构Child1是Parent的child,Child2是Child1的sibling,Parent是Child1和Child2的return.</p>\n<h4>pendingWorkPriority</h4>\n<p>优先级</p>\n<h3>alternate</h3>\n<p>一个组件至多有两个fiber结构与它对应: 当前的fiber(正在处理的fiber),flushed fiber(处理完毕,准备渲染(commit)的fiber), alternate(当前fiber的替身).</p>\n<h2>参考</h2>\n<p><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a>\n<a href=\"http://www.ayqy.net/blog/dive-into-react-fiber/\">完全理解React Fiber</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"React Fiber Architecture(译)","date":"2019-05-09","tags":"React","path":"/react-fiber","top":null,"summary":null}}},{"node":{"id":"8095c680-f29b-500f-a6f9-84c1231b004a","html":"<h2>为什么使用容器技术</h2>\n<p>在传统的软件部署方式中，开发者需要在不同的主机之前同步配置来确保应用运行环境的一致性。通过容器技术能有效的优化集群环境的部署，极大的改变软件开发和发布的方式。下面从容器与传统的虚拟化技术对比来揭开容器的面纱。</p>\n<h3>docker与传统的虚拟机方案的对比</h3>\n<p><img src=\"./frontendtoolstatic/docker/different.png\" alt=\"different\"></p>\n<ol>\n<li>传统的虚拟机技术主要通过虚拟机监控器完成虚拟操作系统和宿主操作系统之间的交互.docker容器直接与宿主系统通信，减少了语言转换的过程,因此在启动速度和运行效率上更胜一筹.</li>\n<li>容器技术更加偏向于程序的移植和依赖的打包而虚拟机技术则是侧重于完全的虚拟出一个另一个虚拟环境。</li>\n<li>docker能提供更快的交付过程.通过合理的对宿主操作系统资源的划分,能有效地提高系统的资源利用率。</li>\n</ol>\n<h2>核心技术介绍</h2>\n<h3>namespace(隔离)</h3>\n<p>通过NameSpace技术可以修改容器的视图.</p>\n<pre><code>int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);\n</code></pre>\n<p>在linux中可以通过系统调用clone来创建新的进程,当第三个参数flags指定CLONE_NEWNS就会在新的namespace下启动新进程.<br>\n<img src=\"./frontendtoolstatic/docker/namespace.png\" alt=\"namespace\"><br>\n在上面的例子中系统本身有已经运行的很多进程,通过运行镜像并且执行bin/sh进程可以进入容器的交互界面.在容器中只能看到root进程和ps进程.这样通过namespace技术就实现了不同进程间的隔离.</p>\n<h3>Control Groups(限制)</h3>\n<p>namespace创建的进程与其他进程之前对主机的资源是竞争关系的.Linux Control Group技术就是限制进程组能够使用资源上限的一种技术.通过对容器使用资源的上线进行设置能有效地使用主机的资源和防止资源的过渡占用。</p>\n<h3>联合文件系统(Union File System)</h3>\n<p>联合文件系统可以同时挂载不同的实际文件或者目录到同一目录.Docker基于联合文件系统提出AUFS(Advanced Union File System).AUFS通过将新的镜像层挂载到老的镜像层之上,通过共享基础镜像和增量更新可以使docker的镜像管理更加快速。</p>\n<h2>docker核心概念介绍</h2>\n<h3>镜像</h3>\n<p>镜像是封装了虚拟环境的运行内容的文件包,docker通过利用AUFS实现了增量的镜像结构.</p>\n<h3>容器</h3>\n<p>容器是隔离的虚拟环境,里面运行着docker镜像.容器有以下的运行状态:</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Created</td>\n<td align=\"center\">容器已经被创建资源已经就绪,应用程序未运行</td>\n</tr>\n<tr>\n<td>Running</td>\n<td align=\"center\">容器中的应用容器处于运行中</td>\n</tr>\n<tr>\n<td>Paused</td>\n<td align=\"center\">容器暂停</td>\n</tr>\n<tr>\n<td>Stopped</td>\n<td align=\"center\">容器停止</td>\n</tr>\n<tr>\n<td>Deleted</td>\n<td align=\"center\">容器被删除,占有的资源以及资源的的管理信息已经被删除</td>\n</tr>\n<tr>\n<td>### 数据卷</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>docker运行时的持久化目录,通过将外部目录挂载到容器中,来实现数据的持久化.</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<h3>docker engine</h3>\n<p><img src=\"./frontendtoolstatic/docker/dockerEngine.png\" alt=\"dockerEngine\">\ndocker engine是负责启动镜像的服务,通过docker client提供的指令调用docker server提供的接口来实现对镜像和容器的操作.</p>\n<h2>使用镜像</h2>\n<h3>启动指令</h3>\n<pre><code>docker run --name nginx -p 80:80 -d nginx // --name 执行容器名 -p 宿主端口:容器端口 将宿主端口映射到容器的端口 -d 后台的方式启动 \n\ndocker run --name myredis redis\ndocekr run --name test --link  myredis:redis debian  // --link Container:Alias 目标容器的名称:目标容器的别名 建立容器之间的链接\n</code></pre>\n<h3>操作容器指令</h3>\n<pre><code>docker ps -a // 查看所有的容器  \ndocker images // 查看所有本地镜像 \ndocker stop name/ID  // 停止某个容器 \ndocker rm name/ID // 删除容器\ndocker rm $(docker ps -aq) // 删除所有容器\ndocker rmi $(docker images -q) // 删除所有本地镜像\n</code></pre>\n<h3>使用docker创建一个hello world应用</h3>\n<h4>编写程序文件</h4>\n<p>创建一个目录结构如下:<br>\n<img src=\"./frontendtoolstatic/docker/category.png\" alt=\"category\"><br>\n在index.py中编写程序的主要功能如下:</p>\n<pre><code>from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n  return 'Hello world\\n'\n\nif __name__ == '__main__':\n  app.run(debug=True,host=\"0.0.0.0\") // 创建一个服务 在/路径下返回Hello world\n</code></pre>\n<h4>编写Dockerfile</h4>\n<p>镜像的构建可以通过Dockerfile和构建环境的上下文来完成.通过Dockerfile可以将镜像的构建过程持久化.</p>\n<pre><code>From python:3.4 // 从某一个基础镜像开始 From语句必须是Dockerfile的第一条语句\nRun pip install Flask==0.10.1 // 执行指定的指令  由于每次执行的执行都会行成新的镜像层,可以将多个指令进行合并\nWORKDIR /app // 执行Dockerfile指令执行的工作目录\nCOPY app /app  // src dest 这个指令将上下文的app目录复制到容器的app目录\nCMD python index.py // 容器启动时执行的指令\n</code></pre>\n<h4>构建镜像和启动容器</h4>\n<pre><code>docker build -t hello . //在当前目录的上下文上构建镜像\ndocker run --name haha -p 5000:5000 hello // 以haha容器名字启动helloword镜像 并且将容器的5000端口映射到外部的5000端口\n</code></pre>\n<p><img src=\"./frontendtoolstatic/docker/run.png\" alt=\"run\"></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"docker入门","date":"2019-04-28","tags":"工程化","path":"/docker","top":null,"summary":null}}},{"node":{"id":"90a974f9-2094-555f-8e7b-5b57b6e455b7","html":"<h2>简介</h2>\n<p>　　WEB同构应用指的是通过代码的编译转换手段(通常借助于babel)来让代码在不同端client(浏览器), server(服务器)运行.同构的web应用主要有以下的优点:</p>\n<ol>\n<li>一套代码多处运行减少维护成本</li>\n<li>任务拆分,通过同构可以实现更多的功能(SSR, fetchData)</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/isomorphism.png\" alt=\"isomorphism\"></p>\n<h2>简单的实现思路</h2>\n<ol>\n<li>将client端的代码转换成server可以执行的代码(es6 => commonjs).</li>\n<li>在两端组合出一套模式相同的代码逻辑.下面的例子中在server和client端使用不同的react-router提供的组件.</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/app.png\" alt=\"App\"><br>\n3. server端路由匹配,组装资源(css, js, data), 可以通过不同的中间件根据请求信息来组装.<br>\n4. client端路由匹配,匹配资源(data, 检查页面渲染结果是否正确).</p>\n<h2>过程</h2>\n<h3>代码转换</h3>\n<p>　　在进行代码转换的时候,首先要明白代码转换的目的才能明确对不同文件的转换策略.比如为了实现同构将client端的代码转换成server端可以运行的代码,对不同类型CSS文件的不同处理策略.通常借助于webpack来实现代码的转换功能.webpack会根据入口文件依次的解析引用的各种文件类型,通过配置的webpack loader可以实现对应文件类型的转换.以下主要从不同类型文件处理的角度进行介绍:</p>\n<h4>javascript</h4>\n<p>转换的目标是client端的代码(排除node_modules).\n将client转换成server端可以运行的代码\n<img src=\"./javascriptbasestatic/isomorphism/srctolib.png\" alt=\"srcToLib\"></p>\n<h4>css</h4>\n<p>对于CSS可以有以下两种的处理方法:</p>\n<ol>\n<li>css-in-js (css-loader style-loader)处理,包括node_modules,client端不需要提取的CSS</li>\n<li>client端全局样式或者通过mini-css-extract-plugin提取的样式</li>\n</ol>\n<h4>代码转换优化</h4>\n<h5>公有代码提取</h5>\n<p>可以使用DllPlugin对使用的基础组件库进行统一的提取和引用.提取公有模块代码主要有以下的好处:</p>\n<ol>\n<li>通过DllPlugin对公有代码的提取,能一定程度上加快webpack构建代码的速度</li>\n<li>公有部分的逻辑相对来说是变化的较少,可以充分的利用缓存</li>\n<li>减少其他bundle的体积,页面加载的资源更少</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/dll.png\" alt=\"dll\"></p>\n<h5>加快编译速度</h5>\n<p>可以使用happyPack加快编译速度,happyPack通过多进程的方式来加快代码的打包过程.\n使用happyPack的例子:\n<img src=\"./javascriptbasestatic/isomorphism/happy1.png\" alt=\"happyPack\">\n<img src=\"./javascriptbasestatic/isomorphism/happy2.png\" alt=\"happyPack\"></p>\n<h3>资源匹配</h3>\n<h4>静态资源(CSS js)</h4>\n<p>可以通过webpack-manifest-plugin生成资源的位置信息文件,然后通过该文件查找资源的位置.\n资源位置文件\n<img src=\"./javascriptbasestatic/isomorphism/manifest1.png\" alt=\"manifest\">\n通过manifest查找资源的位置\n<img src=\"./javascriptbasestatic/isomorphism/manifest2.png\" alt=\"manifest\"></p>\n<h4>data</h4>\n<ol>\n<li>server端执行匹配到组件的获取数据的方法(返回promise),primose执行完毕获取到最新的数据储存.将数据通过脚本挂载到window上的属性上.</li>\n<li>client端通过window属性的获取,生成存储数据.</li>\n</ol>\n<p>服务端获取数据和注入数据\n<img src=\"./javascriptbasestatic/isomorphism/serverStore.png\" alt=\"serverStore\">\nclient端提取数据\n<img src=\"./javascriptbasestatic/isomorphism/clientStore.png\" alt=\"clientStore\"></p>\n<h2>扩展性</h2>\n<h3>配置单页是否支持服务端渲染</h3>\n<p>通过中间项配置是否支持服务端渲染\n<img src=\"./javascriptbasestatic/isomorphism/configServerRender.png\" alt=\"configServerRender\"></p>\n<h2>思考</h2>\n<p>在是否在项目中使用同构应用的时候,还是要结合具体的场景.可以有以下的几点考虑:</p>\n<ol>\n<li>项目中是否需要进行服务端渲染 => 使用者角度</li>\n<li>是否有引入node中间层(api转发)的必要, 其他的替代方案是否可行(nginx) => 整体设计的角度</li>\n</ol>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"如何构建一个WEB同构应用","date":"2019-04-24","tags":"工程化","path":"/iosmorphism","top":null,"summary":null}}},{"node":{"id":"8ffc1de2-ace1-5c44-a4a5-a422b43a1af7","html":"<h2>函数</h2>\n<h3>函数声明</h3>\n<p>函数声明包含函数的名字,形参列表,返回值列表(可选)以及函数体构成.</p>\n<pre><code>func name(parameter-list) (result-list) {\n  body\n}\n</code></pre>\n<p>需要注意一下几点:</p>\n<ol>\n<li>\n<p>函数的形参列表和返回值列表组成函数的签名,函数的签名会在函数被调用的时候做校验是否调用合法.</p>\n</li>\n<li>\n<p>参数的传递是按值传递的.当传递引用类型作为实参的时候,可能会修改实参变量.</p>\n</li>\n<li>\n<p>支持多返回值.</p>\n<p>func test(a [3]int) (int x, int y) {\nreturn x, y\n}\nfunc add(vals ...int) int {  // 变长参数声明\nsum := 0\nfor _, v := range vals {\nsum += v\n}\nreturn sum\n}</p>\n</li>\n</ol>\n<h4>函数变量声明</h4>\n<p>函数声明只能定义在包级别的作用域,函数变量声明可以在任何表达式内指定.函数变量生命能获取到整个词法环境(可以访问外部的变量)</p>\n<pre><code>func test() func(int) int {\n  x := 2\n  return func (y int) int {\n    return x * y\n  } // 这里的函数变量(匿名函数)可以访问到外部的x\n}\n</code></pre>\n<h3>函数流程控制</h3>\n<h4>defer</h4>\n<p>defer语句是普通的函数调用,defer语句能确保函数的return语句或函数执行完毕之后执行对应的defer函数.主要为了在函数的执行完毕后做特定的行为.</p>\n<pre><code>func test(x int) int {\n    defer func() { fmt.Print(x) }() // defer语句必须返回一个可执行的语句\n    return x\n} // 这个函数会在返回后打印入参\n</code></pre>\n<h2>方法</h2>\n<h3>方法声明</h3>\n<p>方法是声明特定类型(对象)上可以执行的函数. 通常可以使用如下的方式声明:</p>\n<pre><code>func (p structName) funcName(parameter-list) (result-list) {\n  body\n}  \n// 声明可以在p类型上调用funcName的方法 \nfunc (p Point) add() int {\n  return p.x + p.y\n}\np := Point{ 2, 3}\n  p.add()\n</code></pre>\n<p>注意:</p>\n<ol>\n<li>由于方法的调用是p.funcName和获取p结构体上的属性一致,要注意同一类型上的命名冲突.</li>\n</ol>\n<h3>指针接收者方法</h3>\n<p>由于方法会复制实参,当需要方法的调用对外界产生影响的时候,就需要通过指针类型来完成方法的声明,如下面的例子:</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10} // 获取指针\n  p.ScaleBy(2) // p{20, 20}\n  q := Point{1,2}\n  q.ScaleBy(3)  // q{3,6} 当类型符合的时候,会进行隐式转换 相当于 (&#x26;q).ScaleBy(3)\n}  \n</code></pre>\n<h3>方法变量和方法表达式</h3>\n<h4>方法变量</h4>\n<p>可以将一个特定类型的方法赋值给一个变量,这个变量称为方法变量.该方法变量已绑定到特定的接收者上(caller),通过传递形参就可以完成方法的调用.通常用于绑定特定的接受者.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := p.ScaleBy\n  scaleBy(2) // p{20, 20}\n}  \n</code></pre>\n<h4>方法表达式</h4>\n<p>方便表达式必须在调用的时候,提供接受者.方法表达式是把对应结构的函数行为进行声明.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := (*Point).ScaleBy // 方法表达式\n  scaleBy(p,2)\n}\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"go语言入门之-函数和方法","date":"2019-04-19","tags":"Go","path":"/go-func","top":null,"summary":null}}},{"node":{"id":"3ea7527a-ad27-58ee-b153-3d20f4d97a51","html":"<h2>前言</h2>\n<p>React在处理界面更新的时候,是通过对比虚拟DOM(js对象)之间的差异来更新UI的.这种方式能一定程度上的减少对DOM的操作.通过虚拟DOM这个中间层结合多平台的renderer使React实现了跨平台.本文梳理了在medium上关于Virtual DOM的两篇文章来介绍如何简单实现一个Virtual DOM.</p>\n<h2>为什么虚拟DOM</h2>\n<ol>\n<li>UI = F(data)  Virtual DOM使数据,操作,属性可以集中在一起,这种方式能一定程度上降低项目长期维护的复杂性.</li>\n<li>页面性能 通过虚拟DOM的对比,进行差异的更新能提升页面的性能.</li>\n</ol>\n<h2>如何实现虚拟DOM</h2>\n<p>虚拟DOM可以理解是真实DOM的映射,如何实现虚拟DOM主要需要考虑一下几点:</p>\n<ol>\n<li>如何描述虚拟DOM(create)</li>\n<li>如何绘制虚拟DOM(render)</li>\n<li>如何差异化的更新虚拟DOM并且更新UI(update)</li>\n</ol>\n<p>下面主要从上面的三点来逐步实现一个简易版的虚拟DOM实现.</p>\n<h3>创建Virtual DOM</h3>\n<p>DOM的节点可以通过type(节点类型),props(styles, event), children(子元素)来描述.可以通过下面的函数来创建虚拟节点.</p>\n<pre><code>// 创建虚拟节点\nfunction h(type, props, children) {\n  return { type, props: props || [], children: children || [] };\n}\nconst root = h('ul', { name: 100, onClick: () => { console.log(1); } }, [\n  h('li', {}, ['sss'])\n])\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVQY022PyW7DMAxE8/8/1muBXtogrpN4k0wvihfJm/SK2EUPQQcYgCQGj+RJa839fkeXmjRL6Jqaoevo+x7TthhjdidJglKKqqrI8wLnHEPf77lxHBmtZZpXTiEE8jwn+vymVQ32mjHVDWmW8nU+01tLKYK1lsfjgYhQliVN26JESLKMNE3JC01nAyeAVgzqXaM/hCIS4vjGJbpglGITwTtHPww7TBUFTdPgrcWLMImwLAuHfoHzOHN/Symjik4KsujCYB1+npmrisW5/cInqK5rWmPY5pm1bZiMYV3XAxfC8bKzjkfW0ekeWw0sbiKOY663G90w8J/Cax/CAVy2Z+GPgQ/4LeB92Lc+X/He/4Wffu1f/QOtmsze8Gl17gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"virtualDom\"\n        title=\"virtualDom\"\n        src=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n        srcset=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/63868/virtualDom.png 250w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/0b533/virtualDom.png 500w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>绘制Virtual DOM</h3>\n<p>在下面的实现中,以$开头的元素指代真实的DOM节点,node指代虚拟节点.</p>\n<h4>绘制元素</h4>\n<p>在绘制元素的时候,如果节点的内容是文本,就直接创建文本节点.否则就创建当前类型的DOM节点并且遍历它的children节点递归的调用自身并且添加到创建的节点.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\nconst root = h(\"ul\", { name: '111', className: 'test' }, [\n  h('li', { name: 'child' }, ['text'])\n]);\n// app是页面中已经存在的容器节点\nconst container = document.getElementById('app');\ncontainer.appendChild(createElement(root)); // 已经能绘制到页面\n</code></pre>\n<h4>添加属性</h4>\n<p>在添加属性的时候,有以下的节点需要注意:</p>\n<ul>\n<li>对DOM节点上不存在的属性名字进行转换,例如ClassName</li>\n<li>布尔属性值的设置</li>\n<li>增加属性过滤功能来实现特有的实现</li>\n</ul>\n<h5>实现</h5>\n<pre><code>//设置布尔属性\nfunction setBooleanProp($target, name, value) {\n  if(value) {\n    $target.setAttribute(name, value);\n    $target[name] = value;\n  } else {\n    $target[name] = false;\n  }\n}\n// 属性过滤\nfunction isCustomProp(name) {\n  return false;\n}\n// 设置所有属性的入口\nfunction setProps($target, props) {\n  Object.keys(props).forEach(name => {\n    setProp($target, name, props[name]);\n  });\n}\n// 对单一属性的设置,实现过滤,转换\nfunction setProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.setAttribute('class', value);\n  } else if(typeof value === 'boolean') {\n    setBooleanProp(name, value);\n  } else {\n    $target.setAttribute(name, value);\n  }\n}\n</code></pre>\n<p>通过将设置属性的操作加入到之前的createElement函数中,来实现DOM属性的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n} \n</code></pre>\n<p>通过运行之前的代码,发现属性已经添加到DOM中了.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABIElEQVQoz6XO207CQBSF4b7/I3nphcSEKFAoyqkoh0Kn9DhMp8PM/IYYTUw8XLiSL3tf7bWD8UtJv7dlOBaMJnOGjyPuh4LbfspTIgl3NQ+rjCg5syo9i9z+KmjOkmR2IO6tOb4KmkohZimnWGCdx3vw3uOcx33Mj/0bQWc6xEtKfBdT7E50Mke1jv1e0umOP/Pe+CkAj9Yt2aug3Obk6wnJckk0EazjHK00phFIscN2LVmmSMX5x7Kgbi2VupCViu3yxHax4rl3w2GzIZwWjKOMKFwTDQaE0ZzpNCXs7zkeaxrtqJX9ImiNo7Oe6nrw6UBVKGRV0tQNUllORUclHVJbsqKh1QZ9Nqj2gr54tHFfBNc3rTEcnxPSRcrFGP6TN4i4F/4kEuvBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domWithProp\"\n        title=\"domWithProp\"\n        src=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n        srcset=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/63868/propShow.png 250w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/0b533/propShow.png 500w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>添加事件</h4>\n<p>在对事件的添加上,由于具体的事件也是在创建Virtual DOM的时候添加到props的,如果不想通过之前声明的setProps函数进行事件的处理,就需要将这些属性过滤出来,具体实现如下:</p>\n<pre><code>//判断是否是event属性\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n// 获取属性的后缀  例如 onClick => click\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n// 修改之前的过滤属性函数,加入对event属性的过滤\nfunction isCustomProp(name) {\n  return isEventProp(name)\n}\n// 添加属性函数\nfunction addEventListeners($target, props) {\n  Object.keys(props).forEach(name => {\n    if(isEventProp(name)) {\n      $target.addEventListener(extractEventName(name), props[name]);\n    }\n  })\n}\n</code></pre>\n<p>将添加事件的函数增加到createElement函数中,完成对事件的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  addEventListeners($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\n</code></pre>\n<h3>对比差异更新UI</h3>\n<p>如果完全的对比两个树形结构的差异,时间复杂度是O(n^3)的.为了一定的性能优化,可以有以下的假设:</p>\n<ol>\n<li>节点的类型变更,两个DOM的结构就是不同的.这种情况可以直接进行替换操作.</li>\n<li>很少存在跨层级的节点移动</li>\n<li>同一类型的节点的DOM结构是相同的</li>\n</ol>\n<p>通过对上面假设的分析,在更新Virtual DOM的时候,主要有以下几种情况</p>\n<ol>\n<li>对比两个node的类型不同,直接替换</li>\n<li>最新的node中没有元素和属性,需要删除对应的节点的属性</li>\n<li>最新的node中增加了元素和属性,需要添加对应的属性和节点</li>\n<li>节点类型相同,对子节点实现1 2 3的操作</li>\n</ol>\n<h4>更新节点</h4>\n<pre><code>// 判断两个node是否是同一个节点\nfunction changed(node1, node2) {\n  return typeof node1 !== typeof node2 || typeof node1 === 'string' &#x26;&#x26; node1 !== node2 || node1.type !== node2.type;\n}\n\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  // index是子元素的位置\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新属性</h4>\n<p>在更新属性的时候跟更新节点的步骤类似</p>\n<pre><code>// 删除布尔属性\nfunction removeBooleanProp($target, name) {\n  $target.removeAttribute(name);\n  $target[name] = false;\n}\n// 移除属性\nfunction removeProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.removeAttribute('class');\n  } else if(typeof value === 'boolean') {\n    removeBooleanProp($target, name);\n  } else {\n    $target.removeAttribute(name);\n  }\n}\n// 当不存在newVal的时候,remove对应的属性.其他情况进行覆盖\nfunction updateProp($target, name, newVal, oldVal) {\n  if(!newVal) {\n    removeProp($target, name, oldVal);\n  } else {\n    setProp($target, name, newVal);\n  }\n}\nfunction updateProps($target, newProps, oldProps = {}) {\n  const props = Object.assign({}, newProps, oldProps);\n  Object.keys(props).forEach(name => {\n    updateProp($target, name, newProps[name], oldProps[name]);\n  });\n}\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    // 增加属性的更新\n    updateProps($parent.childNodes[index], newNode.props, oldNode.props)\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新事件</h4>\n<p>函数是不好判断是否有变化的,可以通过一些参数来完成事件的更新(触发重新更新,通过节点替换来完成事件的更新这样不好)</p>\n<pre><code>function changed(node1, node2) {\n  return typeof node1 !== typeof node2 ||\n      typeof node1 === ‘string’ &#x26;&#x26; node1 !== node2 ||\n      node1.type !== node2.type ||\n      node1.props.forceUpdate;\n}\nfunction isCustomProp(name) {\n  return isEventProp(name) || name === ‘forceUpdate’;\n}\n</code></pre>\n<h3>参考</h3>\n<p><a href=\"https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060\">How to write your own Virtual DOM\n</a><br>\n<a href=\"https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76\">Write your Virtual DOM 2: Props &#x26; Events</a><br>\n<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"How to wirte your own Virtual DOM(译)","date":"2019-04-02","tags":"React","path":"/react-virtual-dom","top":null,"summary":null}}},{"node":{"id":"7e5d1f2a-ee54-59e1-a3fd-71ffbe5c68a5","html":"<h2>go数据类型</h2>\n<p>go语言数据类型主要分为以下的四个大类:</p>\n<ol>\n<li>基础类型(整数,浮点数,负数,布尔值等)</li>\n<li>聚合类型(数组,结构体)</li>\n<li>引用类型(slice,指针,map,函数,通道)</li>\n<li>接口类型</li>\n</ol>\n<p>go语言是拥有类型系统的语言,相对于笔者最熟悉的javascript这种动态且无类型的语言来说有着长远的好处.通过类型系统能在编译阶段减少一定的运行时错误.例如在go语言中不同类型值之间必须通过显示转换来进行赋值操作.本文主要从go语言中的基础类型开始,逐步的讲解go语言中几种基本的引用类型.</p>\n<h2>基础类型</h2>\n<h3>字符串</h3>\n<p>字符串是不可改变的字节序列.可以通过[i:j]操作符截取对应字符串的子串.由于字符串不可改变的特点,子串和母串共用一端底层内存.</p>\n<pre><code>s := \"hello world\"\nb := s[6:] // [i:j] 从i开始不包括j 注意越界 b world\nb[0] = 'a' // 错误 \n</code></pre>\n<h3>常量</h3>\n<p>常量是一种表达式,可以在编译的阶段来确定相应的值.在声明常量的时候可以指定类型和值(如果没有指定类型会通过值来推断常量的类型).在连续声明多个常量的时候,主要有以下两种方式:</p>\n<ol>\n<li>\n<p>在声明枚举值的时候,可以通过iota常量生成器来实现.iota从0开始,逐项加1</p>\n</li>\n<li>\n<p>省略赋值语句的一项会复用前一项的表达式和类型</p>\n<pre><code> const (\n a  = iota\n b\n c\n d\n )\n // a b c d 0 1 2 3\n const (\n a = 1\n b\n c = 2\n d\n )\n // a b c d 1 1 2 2\n</code></pre>\n</li>\n</ol>\n<h4>无类型常量</h4>\n<p>无类型常量(常量字面量)是还没有确定从属类型的常量值.无类型常量相对于同样的有类型的常量有更大的精度.例如0.0相对有浮点数拥有更大的精度.在将无类型常量复制给对应的变量的时候,赋值的变量会转换为无类型常量默认的类型.</p>\n<pre><code>i := 0 // int(0)\nb := 0.0 // float64(0.0)\n</code></pre>\n<h2>聚合类型</h2>\n<h3>数组</h3>\n<p>数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列.由于数组在声明的时候对长度有限制,当存储元素到达数组的容量的时候就需要申请新的内存空间来进行数据的存储.所以在存储数据上一般不会使用数组.数组元素的初始值是该类型的零值.在声明数组的时候需要显示的指定长度和类型.</p>\n<ol>\n<li>\n<p>声明数组需要有长度的定义和类型定义,可以通过定义长度或者数据数量来确定数组的长度.元素类型和长度相同的数组是可以比较和复制的</p>\n</li>\n<li>\n<p>数组元素的初始值为该数组元素类型的初值</p>\n</li>\n<li>\n<p>在函数中使用数组指针来完成对原数组的修改</p>\n<p>b := [...]int{1,2,3}  // 通过初始化数组元素的个数决定数组的长度\na := [3]int{1,2,3}\na == b // true\nr := [...]int{99: -1} // 定义一个含100元素的数组r 最后一个元素是-1 其余都初始化int类型的零值 0</p>\n</li>\n</ol>\n<h3>结构体</h3>\n<p>结构体是将多个命名变量组合到一起的聚合数据类型.可以通过下面的方式声明一个结构体:</p>\n<pre><code>type Person struct {\n    name string\n    id int\n}\n</code></pre>\n<p>在声明结构体的时候需要注意以下的几点:</p>\n<ol>\n<li>结构体变量的大小写决定变量是否可以导出(可以被其他导出的包读写),</li>\n<li>结构体变量不可以拥有自己本身的结构体类型,可以通过自身结构体类型的指针来实现递归结构</li>\n</ol>\n<h4>结构体字面量</h4>\n<ol>\n<li>\n<p>可以按照声明的顺序来初始化结构体变量或者指定变量名称来初始化结构体字面量</p>\n</li>\n<li>\n<p>可以获取结构体指针来设置结构体的值</p>\n<pre><code> a := Person{ name: \"haha\" } // 指定变量名声明\n b := Person{ \"haha\", 20 }\n var copyPerson *Person = &#x26;a // 获取结构体指针\n copyPerson.name = \"100\"\n</code></pre>\n</li>\n</ol>\n<h4>结构体嵌套</h4>\n<p>在定义结构体的成员的时候,go允许只指定成员的类型来实现成员的声明.通过这种方式定义的结构体成员成为匿名成员.匿名成员的类型必须是一种命名类型或者指向命名类型的指针.匿名成员可以为方便变量提供便捷的操作.</p>\n<pre><code>type Circle struct {\n    x int\n    y int \n    radius int\n}\ntype Wheel struct {\t\n  Circle\n  color string\n}\nwheel := Wheel{Circle{ 10, 10, 19}, \"red\"}\n// wheel.x = 10\n</code></pre>\n<h2>引用类型</h2>\n<h3>slice(切片)</h3>\n<p>slice是用相同类型元素的可变长度序列.可以基于一个已有的数组来创建这个数组的slice.slice有三个属性:指针,容量,长度.可以在一个数组的基础上产生多个slice,它们共享内存空间.需要注意的是slice可以理解为对原数组的引用,通过对slice的修改是会影响到底层数组的.</p>\n<h4>声明切片</h4>\n<p>主要有以下两种方式声明切片:</p>\n<ol>\n<li>\n<p>通过切片字面量和内置的make函数</p>\n</li>\n<li>\n<p>slice的操作符[i:j]操作数组或者切片字面量</p>\n<pre><code> var b = make(int[], 3, 5) // make(type[], len, cap) 声明一个长度为3容量为5的切片\n var b = []int{1,2} // 声明一个长度和容量都为2的切片\n var c = []int{ 99: 1 } // 声明一个长度和容量为100的切片,初始化第100的元素为1\n slice := []int{1,2,3,4,5}\n newSlice := slice[1:3]  // 通过切片创建切片\n var num = [10]int{1,2,3,4,5,6,7,8,9,10}\n a := num[1:4] // 操作符[i:j]创建一个新的slice,引用原数组i到j-1个元素.slice的容量是slice起始元素到底层数组最后一个元素之间的个数,切片a只能看到底层数组i以及之后的元素\n len(a) // 3 获取切片的长度\n cap(a) // 9 获取切片的容量\n b := a[:5] // 可以在一个已有的slice上扩充容量,产生新的slice\n len(b) // 4\n cap(b) // 9\n</code></pre>\n</li>\n</ol>\n<h4>操作切片</h4>\n<ol>\n<li>\n<p>slice相当于对底层数组的引用,通过操作slice可以修改底层数组</p>\n<pre><code> a := [3]int{1,2,3}  \n b := a[:2]\n b[0] = 100  // a[0]也是100\n</code></pre>\n</li>\n<li>\n<p>append函数可以动态的添加元素到slice.append函数会返回一个新的slice</p>\n<pre><code> slice := []int{1,2,3,4,5}\n newSlice := slice[1:2] \n newSlice = append(newSlice, 10) // newSlice容量足够,修改底层数组返回新的slice. a[2] = 10\n a := slice[1:2]\n b := slice[2:3]\n c = append(a, b...) // 支持批量添加\n</code></pre>\n</li>\n</ol>\n<h3>map</h3>\n<p>在go中map是对散列表的引用.散列表是无序的键值的结合.可以通过如下的方式创建map:</p>\n<pre><code>var test = make(map[string]int) // 声明map的键值的类型 \ntest[\"name\"] = 100  // 赋值\nvar person = map[string]int{ \"card\": 1, id: \"2\" }  //声明并初始map\nperson[\"card\"] // 1\n</code></pre>\n<p>map有以下几点需要特别注意:</p>\n<ol>\n<li>在赋值map类型的值的时候,需要对map进行初始化.初始化的map的值是对应类型的零值.</li>\n<li>map是引用类型,在函数间传递的时候会对原值进行修改.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":12,"pageCount":15,"additionalContext":{"pageAllCount":89}}},"staticQueryHashes":[]}