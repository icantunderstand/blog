{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/12",
    "result": {"pageContext":{"pageAllCount":91,"group":[{"node":{"id":"a75da308-1935-501a-8291-43665a2911c1","html":"<h2>概要</h2>\n<p>本文主要梳理前端路由的实现方案，按照如下的逻辑进行梳理：\n前置知识 => 路由方案现状 => 从源码的解读理解前端路由的实现过程</p>\n<h2>前置知识</h2>\n<h3>history</h3>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>history.length</td>\n<td>只读, 代表当前会话历史的长度</td>\n</tr>\n<tr>\n<td>history.state</td>\n<td>只读, 代表当前会话栈顶的state</td>\n</tr>\n<tr>\n<td>history.go(number) history.forward() history.back()</td>\n<td>从当前会话加载特定的页面,会触发popstate事件</td>\n</tr>\n<tr>\n<td>pushState(state, title, url)</td>\n<td>在当前会话的添加一个新的记录(关联state) url参数需要保证同源策略</td>\n</tr>\n<tr>\n<td>replaceState(state, title, url)</td>\n<td>替换当前会话栈顶的记录(不会增加history长度,关联state) url参数需要保证同源策略</td>\n</tr>\n</tbody>\n</table>\n<h4>history相关事件</h4>\n<p>当用户触发浏览器动作或者js调用history.back/history.forward/history.go方法时,会触发popstate事件。</p>\n<h3>hash相关事件</h3>\n<ol>\n<li>当url片段标识符改变(#xxx), 会触发hashchange事件。</li>\n<li>当设置与当前不同的hash片段的时候，会在当前会话中添加一个新的记录。</li>\n</ol>\n<h2>路由方案现状</h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>原理</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于history实现的路由方案</td>\n<td>使用history相关事件和方法完成路由的切换</td>\n<td>history可以设置同源下的任意url，需要注意与服务端结合的场景，防止出现404</td>\n</tr>\n<tr>\n<td>基于hash实现的路由方案</td>\n<td>使用hash相关事件完成路由的切换</td>\n<td>hash只能改变当前url的#，有局限性</td>\n</tr>\n</tbody>\n</table>\n<h2>从源码的了解路由的实现过程</h2>\n<p>以下源码分析了history路由的实现过程,源码涉及<a href=\"https://github.com/ReactTraining/history\">history</a>, <a href=\"https://github.com/ReactTraining/react-router\">react-router</a>.整体的实现逻辑如下</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 424px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 172%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC8UlEQVRIx62W6U5yMRCGuf/rIPzgF3dgQgCDyCIoyL7JjrKobAo1zyRz0gOFD83XZNKeLtN3+r6dnsB2uzVfX19ms9mY9XottRrfjO92O6/+lwW+v7/NaDQytVrNtFot02w2PeP7+fnZfHx8yKbXOA3s93tZDCJX6ff7ZjabGTa+2mG73ZbwDoeDmc/n4uDz8/P/OHx5eZHwB4PB3x0SMpNdBcdvb28+h9TnyBJShsOhoAJpo9Ew8XhcCOl2u6ZcLgspbGw7OEdSQDtXq5UQ8/r6akKhkHl/f5dQF4uFtDHGmUvNJk6Ex53s3Ov15OwymYxJp9MmkUhI/fT0ZKrVqle7ztVDyCBhsXsul/NNBg2hwzzkEQ31WYQMTqdTCZFzDAaD0qYPQpiDs+PFzjNU2UDAeDwWgyQMh6VSSbTJPGX3IstMhFHOzlW4lsc6vKRHcdjpdIRdkNIGGdoENUIH4Z9uihqLNSG4EF51U1iIE3QHImqIqFQqv3MICkSL7tTQn/19TiJOh5pgSQygpXButLXvVwnWztjUkBOJRLw+W3O2MeaSkCSHyWTisUpyuLm5Ebb55opxtsxT00g0CjsCIQUny+XSm0BhIQUFQBJO2RgjpdXrdakZhzzNPp5s9AmAXe4qpvmQzbhBJAXu9MPDg7m/v5c2NeOqAp8OtQ1iwqWQediEq8g1BBnJ4/HxUdr0oQQfQs4Ph+cyNmFyPdmIVzCVSokVCgVxWiwW/aSwyH5G2Z0atExGp4pAVcE6zZ929g643gmQqCyOZeOSkE829hNAm8MPh8PShj3VosuJaxPvz4GzIETqWCwm4fPNmWnImtlVixq2D+E1zyjJAX1qZkcmEEU0RGAnjpOHnpSPA4RsP/QswBGIIQrpZLNZkZX9Ap44BBGkoDt1yCZcRdhHdzjN5/MmGo2a29tbEfhJyJd+lrh6jPMDcHd3JxrkWU0mk/LEcgzeTTn+nQOdGshBZOvw+NWz5eXJ5rc/nK7cqKT8ABAkKsYiO95UAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"route\"\n        title=\"route\"\n        src=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n        srcset=\"/blog/static/b70462c5399fc0b238df6097205f72be/63868/route.png 250w,\n/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png 424w\"\n        sizes=\"(max-width: 424px) 100vw, 424px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>下面代码是在react项目中使用history路由实现的一个例子，它能实现根据特定的path来渲染对应的组件。</p>\n<pre><code>import './App.css';\nimport React from 'react'\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nfunction App() {\n  return (\n    &#x3C;Router >\n      &#x3C;Switch>\n        &#x3C;Route exact path=\"/\">\n            &#x3C;div>home&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/about\">\n            &#x3C;div>about&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/dashboard\">\n            &#x3C;div>dashboard&#x3C;/div>\n          &#x3C;/Route>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  );\n}\nexport default App;\n</code></pre>\n<p>react-router/packages/react-router-dom/modules/BrowserRouter.js</p>\n<pre><code>import React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    // 初始化browser history 可以推断出路由的切换逻辑是history与Router结合的实现\n    return &#x3C;Router history={this.history} children={this.props.children} />;\n  }\n}\nexport default BrowserRouter;\n</code></pre>\n<p>packages/index.ts</p>\n<pre><code>// 在最后执行跳转的时候 会执行所有的listen函数\nfunction applyTx(nextAction: Action) {\n  action = nextAction;\n  [index, location] = getIndexAndLocation();\n  listeners.call({ action, location });\n}\nlet history: BrowserHistory = {\n  // 以下为主要的跳转函数，在实现跳转逻辑的时候都调用了applyT方法。\n  push,\n  replace,\n  go,\n  back() {\n    go(-1);\n  },\n  forward() {\n    go(1);\n  },\n  // listion方法用于增加路由切换的监听函数\n  listen(listener) {\n    return listeners.push(listener);\n  },\n  // block方法允许传入一个block函数,在路由跳转的时候会执行所有的blocker函数\n  block(blocker) {\n    let unblock = blockers.push(blocker);\n    if (blockers.length === 1) {\n      window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n    }\n    return function() {\n      unblock();\n      if (!blockers.length) {\n        window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n    };\n  }\n};\nreturn history;\n</code></pre>\n<p>从上面history源码看出，history这个库主要是维护history的相关状态(state, location, hash)并且增加路由跳转的告知能力.</p>\n<p>react-router/packages/react-router/modules/Router.js</p>\n<pre><code>import React from \"react\";\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.history.location\n    };\n    this._isMounted = false;\n    this._pendingLocation = null;\n    if (!props.staticContext) {\n      // 这里订阅了history的变化并且在变化的之后更新location\n      this.unlisten = props.history.listen(location => {\n        if (this._isMounted) {\n          this.setState({ location });\n        } else {\n          this._pendingLocation = location;\n        }\n      });\n    }\n  }\n  componentDidMount() {\n    this._isMounted = true;\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n  render() {\n    return (\n      // 将location作为context 在需要订阅的位置获取   Route消费location完成特定children的渲染。\n      &#x3C;RouterContext.Provider\n        value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      >\n        &#x3C;HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      &#x3C;/RouterContext.Provider>\n    );\n  }\n}\nexport default Router;\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊前端的路由方案","date":"2020-12-15","tags":"JavaScript","path":"/history","top":null,"summary":null}}},{"node":{"id":"be69e5b2-aefc-53f5-a712-d24f2d40c7ba","html":"<h2>为什么开启设计模式系列</h2>\n<p>在业务压力下，仓库的代码量是快速增长的。最近在思考如何能让代码有灵活性和扩展性。随着产品的迭代，一部分业务逻辑需要重新实现，那一种良好的设计是否能在重构代码中帮助我们呢？答案是确定的。开启这个系列主要有这两方面的原因:</p>\n<ol>\n<li>在翻译业务的时候更高效和优雅</li>\n<li>通过对模式的学习能加强思考</li>\n</ol>\n<p>设计模式是解决一类问题的通用的方案，希望通过对设计模式的学习能完善解决问题的能力，本系列会结合《设计模式-可复用面向对象软件的基础》来对设计模式进行比较全面的梳理。</p>\n<h2>创建型模式</h2>\n<p>创建型模式通过对实例化过程进行抽象，隐藏了底层的具体实现，从而实现更多的灵活性。创建型模式有以下几种:</p>\n<ol>\n<li>Abstract Factory(抽象工厂)</li>\n<li>Builder(生成器)</li>\n<li>Factory Method(工厂方法)</li>\n<li>Prototype(原型)</li>\n<li>Singleton(单例)</li>\n</ol>\n<p>本文会结合一个创建迷宫的示例来介绍以上几种设计模式.通常实现一个迷宫会定义以下基类:</p>\n<pre><code>// 方向枚举\nenum Direction { North, South, East, West };\n// 迷宫组件的公用抽象类\nclass MapSite {\n  public: virtual void Enter() = 0;\n}  \n// 房间  保存其他MapSite的引用\nclass Room: public MapSite {\n  public: \n    Room(int roomNo);\n    MapSite* GetSide(Direction) const;\n    void SetSide(Direction, MapSite*)\n  private:\n    MapSite* _sides[4];\n    int _roomNumber;\n}  \n// 墙 \nclass Wall : public MapSite {\n  public: \n    Wall();\n    virtual void Enter();\n}\n// 门\nclass Door : public MapSite {\n  public: \n    Door(Room* = 0, Room*  = 0);\n    virtual void Enter();\n    Room* OthersSideFrom(Room*);\n  private: \n    Room* _room1;\n    Room* _room2;\n    bool _isOpen;\n}\n// 迷宫类\nclass Maze {\n  public: \n    Maze();\n    // 在迷宫中添加Room\n    voidb AddRoom(Room *);\n    // 根据RoomNo查找Room\n    Room* RoomNo(int) const;\n  private:\n}\n// 一个可能的迷宫生成代码\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room* r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n</code></pre>\n<p>上面代码在定义迷宫布局的时候对布局过程进行了硬编码，在未来需要对迷宫布局进行修改的时候就需要修改硬编码逻辑。通过创建型模式可以实现将实现的细节封装起来，给予代码一定的可变化性。</p>\n<h3>Abstract Factory(抽象工厂) - 对象创建型模式</h3>\n<p>抽象工厂提供一个创建一系列相关或相互依赖对象的接口而无需指定他们具体的类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 891px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABK0lEQVQoz41S147DMAzL//9gkYHMZu80O01UkAcd0ocDToBgW5ZpkrYhInJdl7zfb9n3XZZlkW3buP5v4LyGoYWqqsT3fXk8HuK6rqRpKl3XyXEcvACX6fh6vbjfNA3376CGTnA4CAI2Pp9P5rqu3APb8zyZiGmaSKBt2y8lwCJDNCoT3cAazfcDd1t0Pc8ze/UyoyxLSjVNkwyLoqCUMAzFsixxHEeSJKHMKIq4hiUIMLRtm7W6rn8AIc3zPAIAGIcAeq9hDkAo6Puec2U4jiNrYP77KGhUc++ButoAmQCHd/A5jmPOcRkIQB1Y8lHQjFTP9BHgDx5Ae/I8p0wkQIZhkCzLOOqagGr0PcEMLw8/AYzUOkZcBFUq9UvyXwGmCoIvpKk1BVRr8G0+DjIE5/TLV5AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"抽象工厂结构\"\n        title=\"抽象工厂结构\"\n        src=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n        srcset=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/63868/abstractFactory.png 250w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/0b533/abstractFactory.png 500w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png 891w\"\n        sizes=\"(max-width: 891px) 100vw, 891px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>AbstractFactory</li>\n</ul>\n<p>声明一个创建抽象产品对象的操作接口</p>\n<ul>\n<li>ConcreteFactory</li>\n</ul>\n<p>实现创建具体产品对象的操作</p>\n<ul>\n<li>AbstractProduct</li>\n</ul>\n<p>为一类产品对象声明接口</p>\n<ul>\n<li>ConcreteProduct</li>\n</ul>\n<p>定义一个将被相应具体工厂创建的产品对象，实现AbstractProduct接口</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>仅使用由AbstractFactory和AbstractProduct类声明的接口</p>\n<h4>适用性</h4>\n<p>抽象工厂通过将具体的对象创建延迟到ConcreteFactory中，能提供丰富的灵活性，适用于以下场景:</p>\n<ol>\n<li>一个系统要独立于它的产品的创建，组合和表示时</li>\n<li>一个系统要由多个产品系列中的一个来配置时</li>\n<li>需要对一系列相关产品对象设计进行联合使用时</li>\n<li>对外提供产品类库，提供统一的接口</li>\n</ol>\n<h4>优点&#x26;缺点</h4>\n<ul>\n<li>分离了具体类的实现，通过具体工厂封装对具体产品实现的细节。</li>\n<li>通过具体工厂的实现，将具体产品的实现逻辑封装在一起，增加了整体的一致性。但是在增加新的种类的产品的时候需要实现新的具体工厂。</li>\n</ul>\n<h4>代码示例</h4>\n<p>下面的代码使用Abstract Factory模式来创建一个迷宫。</p>\n<pre><code>// 定义抽象方法类\nclass MazeFactory {\n  public: \n    MazeFactory()\n  \n  virtual Maze* MakeMaze() const { return new Maze; }\n  virtual Wall* MakeWall() const { return new Wall; }\n  virtual Room* MakeRoom(int n) const { return new Room(n); }\n  virtual Door* MakeDoor(Room* r1, Room* r2) { return new Door(r1, r2); }\n}\n// 通过传递具体的工厂实现迷宫的创建\nMaze* MazeGame::CreateMaze(MazeFactory&#x26; factory) {\n  Maze* aMaze = factory.MakeMaze();\n  Room* r1 = factory.MakeRoom(1);\n  Room* r2 = factory.MakeRoom(2);\n  Door* aDoor = factory.MakeDoor(r1, r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  \n  r1.SetSide(North, factory.MakeWall())\n  r2.SetSide(North, factory.MakeWall());\n  // 省略很多的SetSide操作\n  return aMaze;\n} \n\n// 创建过程\nMazeGame game;\nMazeFactory factory\ngame.CreateMaze(factory)\n</code></pre>\n<p>通过传递ConcreteFactory,上面的代码将创建逻辑都封装在具体工厂中，这样通过传递不同的工厂就能完成不同类型对象的创建。</p>\n<h3>Builder(生成器) - 对象创建型模式</h3>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Builder模式能更好的封装产品的内部表示。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 871px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuTSRRX//EABcQAQADAAAAAAAAAAAAAAAAAAEAICH/2gAIAQEAAQUCBg7T/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABUQAQEAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Aqv/xAAYEAEBAQEBAAAAAAAAAAAAAAABABEhEP/aAAgBAQABPyED3cSusO+EX//aAAwDAQACAAMAAAAQpA//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCn/8QAFhEAAwAAAAAAAAAAAAAAAAAAECEx/9oACAECAQE/EEg//8QAGxAAAwACAwAAAAAAAAAAAAAAAAERMVEQIYH/2gAIAQEAAT8QqGJomDZtdCEqvvGTMD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"生成器结构\"\n        title=\"生成器结构\"\n        src=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n        srcset=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/0479a/builder.jpg 250w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/41099/builder.jpg 500w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg 871w\"\n        sizes=\"(max-width: 871px) 100vw, 871px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Builder</li>\n</ul>\n<p>为创建一个Product对象的各个部件指定抽象接口</p>\n<ul>\n<li>ConcreteBuilder</li>\n</ul>\n<p>实现Builder的接口来完成对象的创建\n定义并明确它所创建的表示\n提供一个检索产品的接口</p>\n<ul>\n<li>Director</li>\n</ul>\n<p>构建一个使用Builder的接口对象</p>\n<ul>\n<li>Product</li>\n</ul>\n<p>被构造的复杂对象</p>\n<p>抽象的Builder类为Director要创建的对象定义操作。ConcreteBuilder实现Builder定义的方法</p>\n<h4>适用性</h4>\n<p>通过生成器可以把复杂的对象创建过程隐藏，通过不同的Builder来完成系统的创建, 适用于以下场景：</p>\n<ol>\n<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li>\n<li>当构造过程必须允许被构造的对象有不同的表示时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeBuilder {\n  public:\n    virtual void BuildMaze() {};\n    virtual void BuildRoom(int room) {};\n    virtual void BuildDoor(int roomFrom, int roomTo) {};\n    virtual Maze* GetMaze() { return 0  };\n  protected: \n    MazeBuilder();\n}\n// 在具体调用的时候 可以传递一个实现了抽象类builder的ConcreteBuilder\nMaze* MazeGame::CreateMaze(MazeBuilder&#x26; builder) {\n  builder.BuildMaze();\n  builder.BuildRoom(1);\n  builder.BuildRoom(2);\n  builder.BuildDoor(1,2);\n  return builder.GetMaze();\n}\n\n// 创建过程\nMaze* maze\nMazeGame game\nMazeBuilder builder\nmaze = game.CreateMaze(builder)\n</code></pre>\n<p>对比抽象工厂,Builder模式封装了创建过程的细节，通过不同的builder实现可以创建出不同的对象。</p>\n<h3>Factory Method(工厂方法) - 对象创建型模式</h3>\n<p>工厂方法定义一个用于创建对象的接口，让子类来实现对应的接口来创建对象。Factory Method使一个类的实例化延迟到其子类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 818px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABdUlEQVQoz5XRwY6DIBAG4L7/g/XQSisJcTSgoIK12GqtgDXadlPd3Zi97XeawPwBhs00TcYYa61zbhgG55yZTdP0/tH3fdd1fd8/Hg9rbdd1y+6mKAohhNaac04IWWo5m6bpMWOMaa0ZY0EQFEWRpmlZlp8w5/x0Oo3jqJTCGOd5boxpmoZS2vf9/X5vmuZ4PDZNQwjxPE8pJYSI4/g7jDEmhPi+DwBKqSzLktly59frxRiL45hzDgBZlgFAVVWf8HKg7/sIoe12myRJnudJkiilluTvy8dxbNt2vbh5rxhj1t1/PJ9P59x6ZWOt1VrXs/P5vBRa63Xf9Xqt67qqKinl7XbTWltrP2EhhJQSAA6HA0Jot9uFYXi5XBhjbduWZVnXte/7QRAghPb7ved5GGMp5ffAOOdpmgJAGIZxHAsh8jynlI4zYwxCiFK6NERRhDEWQnzCZVkCQBRFABAEAWOMUkoIWX5yYX+4Wdd1wzD8Hdh/fQFNImIPdtdAXwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"工厂方法\"\n        title=\"工厂方法\"\n        src=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n        srcset=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/63868/factoryMethod.png 250w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/0b533/factoryMethod.png 500w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png 818w\"\n        sizes=\"(max-width: 818px) 100vw, 818px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Product</li>\n</ul>\n<p>定义工厂方法所创建对象的接口(抽象产品)</p>\n<ul>\n<li>ConcreateProduct</li>\n</ul>\n<p>实现Product的接口(具体产品)</p>\n<ul>\n<li>Creator</li>\n</ul>\n<p>声明工厂方法(抽象工厂)</p>\n<ul>\n<li>ConcreteCreator</li>\n</ul>\n<p>实现工厂方法，返回ConcreateProduct实例</p>\n<p>工厂方法依赖它的子类来实现工厂方法来完成对象的创建。</p>\n<h4>适用性</h4>\n<p>工厂方法适用于以下场景:</p>\n<ol>\n<li>父类不知道它需要创建的对象的类的时候</li>\n<li>当一个类希望它的子类来指定创建对象的时候</li>\n<li>当类将创建对象的职责委托给多个帮助子类中的某一个并且希望某一个帮助子类代理这个创建过程</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeGame {\n  public: \n    Maze* CreateMaze();\n\n    // factory method;\n    virtual Maze* MakeMaze() const { return new Maze(); };\n    virtual Room* MakeRoom(int n ) const { return new Room(n); };\n    virtual Wall* MakeWall() const { return new Wall; };\n    virtual Door* MakeDoor(Room* r1, Room* r2) const { return new Door(r1,r2);  };  \n}\n\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room&#x26; r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n// 子类实现工厂方法来完成对象的创建\nclass BombedMazeGame : public MazeGame {\n  public:\n    BombedMazeGame()\n    virtual Room* MakeRoom(int n) const  { return new RoomWithBomb(n); };\n}\n</code></pre>\n<h3>PROTOTYPE（原型) - 对象创建型模式</h3>\n<p>原型模式通过原型实例指定创建对象的种类，通过拷贝原型来创建新的对象</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 747px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY03XQ224EIQiA4Xn/x5wLKzr1iA6guG3cbA9p+l0S/pBw1FpjjABQSqm1Pl7GGMwsGxGFEGKMPyeqepznaYwJIVzXZa3tvRMRM8cYvfcppbC9bYhYa0XElNIY40gplVJ67601Zv66rKrMXEpBRGaem6q21u77VtW11vFcXWs9fltriQgiEpGIrI2Z28bM3/FfRAQA1loAcM6NMUTEGOOcs9uc89+Ymb33Oef3bc4pIgCQc34+6DP+AFoUWqjoiPwWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"原型方法\"\n        title=\"原型方法\"\n        src=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n        srcset=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/63868/prototype.png 250w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/0b533/prototype.png 500w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png 747w\"\n        sizes=\"(max-width: 747px) 100vw, 747px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Prototype</li>\n</ul>\n<p>声明一个克隆自身的接口</p>\n<ul>\n<li>ConcretePrototype</li>\n</ul>\n<p>实现一个克隆自身的操作</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>让一个原型克隆自身从而创建一个新的对象</p>\n<h4>适用性</h4>\n<p>原型模式适用于以下场景:</p>\n<ol>\n<li>实例化的类需要在运行时刻指定</li>\n<li>类的实例状态是相似的，通过原型的克隆能减少类的创建</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazePrototypeFactory : public MazeFactory {\n  public :\n    MazePrototypeFactory(Maze* , Wall*, Room*, Door*);\n\n    virtual Maze* MakeMaze() const;\n    virtual Room* MakeRoom(int) const;\n    virtual Wall* MakeWall() const;\n    virtual Door* MakeDoor(Room*, Room*) const;\n\n  private:\n    Maze* _prototypeMaze;\n    Room* _prototypeRoom;\n    Wall* _prototypeWall;\n    Door* _prototypeDoor;\n}\n\nMazePrototypeFactory::MazePrototypeFactory (\n  Maze* m, Wall* w, Room* r,Door* d\n) {\n  _prototypeMaze = m;\n  _prototypeRoom = r;\n  _prototypeWall = w;\n  _prototypeDoor = d;\n}\n\nWall* MazePrototypeFactory::MakeWall() const {\n  return _prototypeWall->Clone();\n}\nMazeGame game;\n// 需要初始化传入的实例支持clone操作，可以通过传递不同的实例完成不同的对象创建\nMazePrototypeFactory simpleMazeFactory(new Maze, new Wall, new Room, new Door);\nMaze* maze = game.CreateMaze(simpleMazeFactory)\n</code></pre>\n<h3>SINGLETON（单例）- 对象创建型模式</h3>\n<p>保证一个类仅有一个实例，并提供一个访问他的全局访问点</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu6QD//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARIUFR/9oACAEBAAE/IVnbLE7KXJ//2gAMAwEAAgADAAAAENDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECExkf/aAAgBAQABPxB7NzXBiTW+QRKuDzP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"单例模式\"\n        title=\"单例模式\"\n        src=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n        srcset=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/0479a/singleton.jpg 250w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/41099/singleton.jpg 500w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg 750w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Singleton</li>\n</ul>\n<p>定义一个Instance操作，允许客户访问它的唯一实例</p>\n<h4>适用性</h4>\n<p>单例模式适用于以下场景:</p>\n<ol>\n<li>唯一的实例需要全局访问时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class Singleton {\n  public: \n    static Singleton* Instance();\n  protected:\n    Singleton();\n  private:\n    static Singleton* _instance;\n}\n\nSingleton* Singleton::_instance = 0;\n// 对成员初始化未空，第一次访问的时候创建成员，再次访问直接范返回成员\nSingleton* Singleton::Instance() {\n  if(_instance == 0) {\n    _instance = new Singleton();\n  }\n  return _instance;\n}\n</code></pre>\n<p>在单例模式中，想要实现动态的确定单例的类型方式，可以通过维护单例注册表的方式来实现。</p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"编程拾遗系列设计模式-创建型模式","date":"2020-07-06","tags":"设计模式","path":"/build-pattern","top":null,"summary":null}}},{"node":{"id":"dbb428a4-60cc-51c9-bbb6-74a94c623175","html":"<h2>前言</h2>\n<p>在react native开发中通常会使用Touchable<em>组件来实现对用户手势的处理.本篇文章从Touchable</em>组件的基本使用出发,逐步深入到react native中手势处理的原理.</p>\n<h2>Touchable*组件</h2>\n<h3>基本使用</h3>\n<p>在react native中通常使用一下几种组件来实现点击的处理</p>\n<ol>\n<li>TouchableOpacity</li>\n<li>TouchableHighlight</li>\n<li>TouchableWithoutFeedback</li>\n</ol>\n<p>对于TouchableOpacity的基本使用如下,通过绑定onPress事件就能获取到用户的点击行为进行处理</p>\n<pre><code>    &#x3C;TouchableOpacity\n      style={styles.button}\n      onPress={(evt => { this.onPressEvt(evt)  })}\n    >\n      &#x3C;Text>Press Here&#x3C;/Text>\n    &#x3C;/TouchableOpacity>\n</code></pre>\n<p>在开发中不禁会有这样的疑问,为什么TouchableOpacity能响应用户的手势点击而普通的View组件却不行.这就引出了React Native中的手势处理流程</p>\n<h2>手势处理流程</h2>\n<p>React Native中组件对手势的响应是通过如下的阶段来实现:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 862px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAEWH/2gAIAQEAAT8hVFRU/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAABEAASFR/9oACAEBAAE/EH3VNXZv1f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 手势\"\n        title=\"react native 手势\"\n        src=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n        srcset=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/0479a/gesturelifecycle.jpg 250w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/41099/gesturelifecycle.jpg 500w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg 862w\"\n        sizes=\"(max-width: 862px) 100vw, 862px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在每个阶段会有相应的处理函数来处理当前阶段的行为</p>\n<h3>手势响应的阶段</h3>\n<h4>申请阶段</h4>\n<ol>\n<li>View.props.onStartShouldSetResponder: (evt) => bool(返回true 代表当前组件申请在触摸手势的时候成为响应者)</li>\n<li>View.props.onMoveShouldSetResponder: (evt) => true(返回true 代表当前组件申请在移动手势的时候成为响应者)</li>\n</ol>\n<h4>通知阶段</h4>\n<ol>\n<li>View.props.onResponderGrant: (evt) => {}(获取手势处理回调)</li>\n<li>View.props.onResponderReject: (evt) => {}(获取手势处理失败回调)</li>\n</ol>\n<h4>响应阶段</h4>\n<ol>\n<li>View.props.onResponderMove: (evt) => { }(手势移动回调)</li>\n<li>View.props.onResponderRelease: (evt) => { }(手势行为结束(touchUp)回调)</li>\n</ol>\n<h4>释放阶段</h4>\n<ol>\n<li>View.props.onResponderTerminationRequest: (evt) => bool (当其他组件想成为当前手势的处理者时会触发,返回true表示释放)</li>\n<li>View.props.onResponderTerminate: (evt) => {} (当前组件失去响应者身份触发）</li>\n</ol>\n<h3>手势拦截</h3>\n<p>手势的响应是冒泡的,父元素可以使用如下的方法来实现对手势的拦截处理.</p>\n<ol>\n<li>View.props.onStartShouldSetResponderCapture: (evt)=> bool (返回true成为手势的处理者, 子元素不响应)</li>\n<li>View.props.onMoveShouldSetResponderCapture: (evt)=> bool ((返回true成为手势的处理者, 子元素不响应))</li>\n</ol>\n<h3>自定义响应组件实现</h3>\n<p>通过对手势处理阶段的了解,在定义响应组件的时候可以通过添加相应的函数来实现,react native定义了PanResponder.create()方法来快速的实现组件的定义.PanResponder响应回调函数中封装了事件和手势的状态信息,能更细致的实现对手势的处理.</p>\n<pre><code>class App extends Component {\n  constructor(props) {\n    super(props)\n    this.PanResponder = PanResponder.create({\n      onStartShouldSetPanResponder: (evt, gestureState) => true, // 触摸的时候成为手势响应者\n      onPanResponderStart: (evt, gestureState) => { console.log('someone touch me') }, // 触摸时间回调\n    })\n  }\n  render() {\n    return (\n      &#x3C;View style={styles.container} {...this.PanResponder.panHandlers} >&#x3C;/View>\n    )\n  }\n}\n</code></pre>\n<h2>后记</h2>\n<p>后面会按照下面的思路逐步的梳理下React Native相关入门与实践的一些知识.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/098f83ac1e178157d52feb66022c929c/5c263/reactNativeBasic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABmklEQVQ4y5VTW0rDQBTtOlyAPyJuxA24C/8E0TX46ToEERTRUv8UaUMihUKCsa9kkraTJs17cmSupLZNH3Tg5P5Mzj3n3Ds1bDhFUczrIsqT5zmyLK/cre0iWj1CCAyHFrrdHjzPq9ytbVK3SJxlGSmSiKII36YJXTcwnkwwm82WFcqPEAXyNQijmFQYhgFFUaBpGhhjcEcjIuv1+5hwviSitilDiATIE2oWxzEpkwjDkEg598i6zRjyXCxn+G5wPCgMT5qDR1WC4e6ji6Y5rfSRtoMgIOI0TcmBtD0nFEWB05sPHF7UcXTZwMn1G46vGjg4f8HZbfOPRIjKpC3bhmXZlWGSwqbp4fnLRb09wmvbJdx/dqH2/LVpyCExx0G/PwBjzva1+W+ZoMjieYZljrJKu3IYvu9Tjo7jUBNSuGvKnHPouo5OpwNVVdFqtTAYDGDbDJZlEXkYRpTtXntYQv4oVbruCH4QYDqdwvcDpKXCfV9KOWlJNB5PqMoll/Y3Ktz2lktEUUzrIolM8wdJkmwn3NVoNZ5ybX4B7cM55EqQKNkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 入门\"\n        title=\"react native 入门\"\n        src=\"/blog/static/098f83ac1e178157d52feb66022c929c/00d43/reactNativeBasic.png\"\n        srcset=\"/blog/static/098f83ac1e178157d52feb66022c929c/63868/reactNativeBasic.png 250w,\n/blog/static/098f83ac1e178157d52feb66022c929c/0b533/reactNativeBasic.png 500w,\n/blog/static/098f83ac1e178157d52feb66022c929c/00d43/reactNativeBasic.png 1000w,\n/blog/static/098f83ac1e178157d52feb66022c929c/aa440/reactNativeBasic.png 1500w,\n/blog/static/098f83ac1e178157d52feb66022c929c/5c263/reactNativeBasic.png 1636w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"react-native中的手势处理","date":"2020-04-15","tags":"跨端技术","path":"/rn-gesture","top":null,"summary":null}}},{"node":{"id":"8376f00f-727a-5a04-bb7e-2e8e1c1c9067","html":"<h2>前言</h2>\n<p>长列表优化是一个老生常谈问题,优化的方案也是相似的(减少内存占用,复用渲染结果,可视区域渲染,预渲染),在跨端开发的React Native中列表主要有FlatList和SectionList两种,以下主要通过对FlatList的介绍来了解React Native中的长列表.</p>\n<h2>FlatList</h2>\n<p>FlatList通过预渲染和可视区域渲染的方案,来降低列表渲染时候的内存占用从而提升页面的性能.下面从FlatList的基础使用来逐渐展开.</p>\n<h3>基本使用</h3>\n<pre><code>renderItem = ({ item, index }) => {\n  return &#x3C;View>&#x3C;Text style={{ color: 'white' }}>{item.name}&#x3C;/Text>&#x3C;/View>\n}\nrender() {\n  return (\n    &#x3C;FlatList\n      data={[{ name: 'a' }, { name: 'b' }, { name: 'c' }, { name: 'd' }]}\n      renderItem={this.renderItem}\n      keyExtractor={item => `${item.name}`}\n    />\n  )\n}\n</code></pre>\n<p>在上面的例子中通过设置data, renderItem(条目渲染函数)就完成了列表的渲染功能</p>\n<h3>结构</h3>\n<p>FlatList数据渲染的原理是通过数据项和底层容器ScrollView的布局事件计算出需要渲染的条目,在滚动过程中动态的更新渲染条目来完成列表的绘制.FlatList渲染的内部结构如下:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/flatList.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 157.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsTAAALEwEAmpwYAAADeElEQVRIx6VWS4/TZhS1xKhQsUfqhkUXlUCCUhYUqZVaCQmVAv+jSEjdTIuEkKpu2k2X7T9ohbqoVAQbEBKLMu9h3knITDJ24vgR5+XxK4kd56BzwenAamJs3Xyfbfn43nPPd74ocRwjDEP0ej0cHBxIuK4r1/1+H3w+HA5lPEoofEnXdTQaDezt7WF/fx+1Wg31eh22bWM0Gk0HGAQBLMtCs9nE7u6uAJZKJZimKfdyATITZrm1tSVZbmxsCHir1UKSJNMBkj+WR2BmtrCwIOUzO8Mwps8wiiIpk80gCMHZEM7JZZqm+UrmwRdZImMwGAi3uThkNr7vo1gsolqtTjLOBUgOydV4PJaXGZyTitwcMivKJJMKM9M0TficmkNmSKBMLmzE+vr6pNPTlxyEMEwDcRqj8LKA+aV56JaOcBCiYTQmgEcJAfQDHx2zg9iJ4Rs+AjOA1/AQ2REcy0E6TpHEiZTO7mc8Z0GQTBkEVRABv1f+wJf2V7hu3cQ31re4Zt/AFfUqnqnPkIQJ3AMX7XZblECNZkZCE6G8OOczgioIgNv2d1AOn66Cr9cv4f7cX3ix+AJaTRN+V1ZWsLS0hLW1NSwvL2N1dVWkVigUZJkyY8nwzv5vUNyzONn9Ase7l3HCvYwZ+yIe1Z8iDRMM4oFkUC6XJ86kqqoogWBUyqGSQ/xY0aH4wAc+MOMBygBQemM81HRZQYM3HPKgRhnZnAcz+x8wDDGra1AwwgzIQYqPWgY+L23iz+f/QS3vouk42N7eFmnRQFgm3YjBe1y6XAT8qIIwwA81C8oYmEkh4ykPuGCGeLBdhKPr8IJAyqM+yeHc3JzwSF4XFxdRqVTE9UU26AN3yn9DMWdx0vwJH5r3cKz1M5TGXTzSVl6bRvJatFz35JJdJQCvOSeHmV6ly983b73dZZ4jBf9a/wAjIBpGb+nt3Ti870iXf1F/xengY3zqXcTZ3jmcDz7DJ60zeFx/AqRAf9g/0iqRDMMoRF2rQ91ToVZUtO02quUqtIoG0zDzb1JOy8Hm1iZ2Cjsoloroub332/W4nbJb7BxNwfM9caHcewplQfXTAzkSnKtiaj8kIMEycrnY+YAGkAuQJTuOg2w7pasw+KFcewqFSkACEJBzOkduQL5I26fiPc+bjLR/usrUJfOHWXY6nUl0u10Jfmzaf1+vACaDAH8XnMbBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listSection\"\n        title=\"listSection\"\n        src=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/flatList.png\"\n        srcset=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/63868/flatList.png 250w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/0b533/flatList.png 500w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/flatList.png 523w\"\n        sizes=\"(max-width: 523px) 100vw, 523px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>FlatList性能优化</h3>\n<h4>减少更新时列表项总体数目和条目的重渲染,</h4>\n<ol>\n<li>列表条目使用PureComponent或者shouldComponentUpdate来减少条目的更新.</li>\n<li>调整windowSize大小(默认是21)</li>\n<li>调整maxToRenderPerBatch的大小,控制每次更新的最大条目</li>\n</ol>\n<h4>减少内存的占用</h4>\n<ol>\n<li>减少匿名函数的使用</li>\n<li>列表条目的渲染逻辑尽量简单</li>\n</ol>\n<h4>减少渲染过程中的计算</h4>\n<ol>\n<li>使用getItemLayout减少列表条目的计算过程</li>\n<li>调整滚动事件的触发频次(scrollEventThrottle)</li>\n<li>在列表项中合理的使用缓存</li>\n<li>渲染过程中减少与Native通信过程,可以使用InteractionManager优化</li>\n</ol>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"聊聊React Native中的长列表","date":"2020-03-22","tags":"跨端技术","path":"/rn-list","top":null,"summary":null}}},{"node":{"id":"0c99cf00-4347-5d99-b7b8-9d89fd0054d1","html":"<h2>前言</h2>\n<p>最近这半年从原来的PC转到了移动端开发(主要使用React Native),在跨端开发的时候需要与端上进行交互(jsBridge,使用端上的组件等).通过对端上知识的学习能在业务开发中知其所以然,也能更好的把一个方案落地.这篇简单梳理了第一行代码-Android的总体大纲.</p>\n<h2>读书导图</h2>\n<h3>笔记图片</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/6f464/android.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 124.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAACt0lEQVQ4y41Vy5KbMBDk//MT+Yoccs8hx1Tl6N31Az+wAYEkQBhwp3rYYbGNq6IqWbI06ul5Et1uN3AMw4Dr9Sqz63ro0HuunH3fo65rNCGgLEs45zAfEX8IYq1DHO9xOBwRQhBBPp6DKpi1FpdLijzP5b8q4hqpYNM0uKQp0ixD27YoikJWBeN9VVWyJ0iSnJGcz0Li7f1d2NLKiA/40JgcqSlQ1Q26rpvcoJq99zL1XBUYYxDH8aQsorb1ZoPNZismUFjNVEBVwH1ZWgFRAHFZ102WRKO5QfxGM2n23FSCcZIdgQ7HI3ZxjCRJJsbzAEb6h4+OxyNWq9VdQAhOZbxXpfQXA1PXzV0GCEPd0AQKn04nZFku5tNPCqjgPGcglN0c7A6QK5lx5rn5NBsorUUI7QS4P10EsG6apzyd8nCuwXkv5tAs3AYMgUzGoARf4pLFTyCLDMcIljifzzCmgHcWcerw888ev99ytD3QtQGuSBeBngA1edM0Q1GU8LbA322Obz9W+P4rxikrUXmHqjRw1k3l+eTDz1MpPzrfOifBIctb3wEdfXUTGSosyhKr1RtMUSyyFEBGbLvdSXKnaTqrFAbKS+JqzefG4P3jY/TxK4ZkxmQlKItemForjLjXnCQgFZLhfn+YwO7yUNOBJtB/WZYJmArwTgEJzqbwsV5L6lDBU5S1e1RVLaWlbUmFx/741SyodH84SPIvJXf02AikjV2+6llrWbIgBHELWZLtvJEsVMp4cCkbFK7GMPTo+1GJdvOxDybSILT8Hptw9EjZFB5t2wnDtr1OLFjr9C2bKtOKvmZVPfrxCTA1O9TBwvtKQOfCVuo8n2r78buzCJikG1iXv/xIaXAe0+WO4fzA+1qmBuLx4StmLxmWhzWulcVww2JXecXsCVAjHSqHaxswLJj6P+MfteqgdEuoDakAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"安卓基础知识\"\n        title=\"安卓基础知识\"\n        src=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/00d43/android.png\"\n        srcset=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/63868/android.png 250w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/0b533/android.png 500w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/00d43/android.png 1000w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/6f464/android.png 1464w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>笔记导图</h3>\n<p><a href=\"https://github.com/icantunderstand/learnStuff/blob/master/androidBase.xmind\">第一行代码笔记</a></p>\n<h2>后记</h2>\n<p>后续会逐步更新react native和跨端开发的基础知识,希望能坚持下来.</p>","fields":{"readingTime":{"text":"1 min read"}},"frontmatter":{"title":"第一行代码-Android读书笔记","date":"2020-02-01","tags":"跨端技术","path":"/android-basic","top":null,"summary":null}}},{"node":{"id":"30a870e5-267a-5478-80ae-3d922926fb74","html":"<p>本文主要对EcmaScript规范中函数对象解读。</p>\n<h2>函数对象</h2>\n<p>函数对象是对外部的词法环境和有一定入参的代码进行封装后的对象.函数对象的调用支持动态的绑定执行环境.在javascript函数执行的时候,实际上是调用当前函数对象的一些内置方法来实现的.下面是函数对象的一些内部实现:</p>\n<table>\n<thead>\n<tr>\n<th>内部实现</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[Environment]]</td>\n<td>Lexical Environment(词法环境)</td>\n<td>词法环境定义当前函数对象生成时候的外部环境,例如引用的外部变量等</td>\n</tr>\n<tr>\n<td>[[FormalParameters]]</td>\n<td>Parse Node</td>\n<td>定义函数的参数列表</td>\n</tr>\n<tr>\n<td>[[FunctionKind]]</td>\n<td>String</td>\n<td>函数类型(normal, classConstructor, generator, async, async generator)</td>\n</tr>\n<tr>\n<td>[[ECMAScriptCode]]</td>\n<td>Parse Node</td>\n<td>代码体</td>\n</tr>\n<tr>\n<td>[[ConstructorKind]]</td>\n<td>String</td>\n<td>构造类型,当函数通过new操作符进行调用的时候,会用到这个属性.(base derived)</td>\n</tr>\n<tr>\n<td>[[Realm]]</td>\n<td>Realm Record</td>\n<td>当前函数对象的Realm记录,在函数执行的时候需要将函数与Realm进行绑定,由Realm提供全局的环境对象等</td>\n</tr>\n<tr>\n<td>[[ScriptOrModule]]</td>\n<td>Script Record or Module Record</td>\n<td>记录当前函数对象不同创建方式的记录</td>\n</tr>\n<tr>\n<td>[[ThisMode]]</td>\n<td>(lexical, strict, global)</td>\n<td>this会在进入函数的执行环境时进行绑定.lexical代表着this的确定规则是由外部的词法环境决定的(箭头函数),strict代表this是由函数的调用者提供的,global代表着this由外部的全局对象指定(需要区分严格和非严格模式).</td>\n</tr>\n<tr>\n<td>[[Strict]]</td>\n<td>Boolean</td>\n<td>确定当前函数是否是一个在严格模式下执行的函数</td>\n</tr>\n<tr>\n<td>[[IsClassConstructor]]</td>\n<td>Boolean</td>\n<td>是否是构造函数，如果是构造函数通过[[Call]]方式会报类型错误</td>\n</tr>\n</tbody>\n</table>\n<h2>规范详细解读</h2>\n<h3>[[Call]]</h3>\n<p>当通过指定this调用函数对象的时候，实际上会执行内部定义的[[Call]]方法。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/da952/Call.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACJUlEQVQ4y42SC4+tKBCE/f9/cHfmzpnjG48KKiIgoN9GZ242+7ib7aRIA6Horq6s719UVUn+fFJ1glpJKiVplaSUI41eEXrF7gG/71hrcc7hY8SnhN8Dbk+4kDjOk6wUA3nT0/aSVggaOdIpieh66qqmrBrK5kVeC4qiuD/O85xCCIpOkFcVz6rlWQs268jmZcG4nZgOnPd3FXsIhHTi48F5nnAenMfBX+I+P7/z6+5rn3nv6aeFblkQQ09ZljTDRKs2WmWQqyOk45vj/BNfFJw/+b+RGWNohpHKrLSrpnqNFK+JYtCU0lKOmkdRk1cNKaV/Ev8N2SXwpc97UfCjKvl4PHh/e+O3t3c+niWjmpn0hg+J/xPZtax6oShLummiapo7z9uGZyco64au75FS0Q2SfjaMq2VPiRgjIaZb/wvpOL8IQ4jU4sViLWvcWTeD1prVxRvaBqbVotSEVAplLcvuWbRmWS3TtjMZj9sj2XEc9P3A74+Cclip5UY+GGo1M7sNnyI2BmyKpJ9T/a+Wr0o+i5yi7/l4TfwQirey50MoHv1EriY+p5l8HNDriosBl+JtMef8bWi7R/b4pXF26dDLmdVa/BFxu2dbNZsPbD5iXMC4iDEbyzyjncXEgLEbZrNoF9B2v9u9CZdl4dFJ3quOz6KmaMU9ADktSO1Qxt9enJ1lGMeb9Fdx2+ZquREvhFqplaGdDXI21HWFlPKXD/8NV4V/AHQW58QcFWiNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Call步骤\"\n        title=\"Call步骤\"\n        src=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/00d43/Call.png\"\n        srcset=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/63868/Call.png 250w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/0b533/Call.png 500w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/00d43/Call.png 1000w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/aa440/Call.png 1500w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/da952/Call.png 1872w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>将执行上下文切换到当前的执行上下文并对当前的执行上下文做基础的设置</li>\n<li>如果当前函数是类构造函数报错并退出</li>\n<li>在执行上下文上绑定this</li>\n<li>执行函数</li>\n<li>恢复执行上下文，如果有返回值返回结果</li>\n</ol>\n<h3>[[Construct]]</h3>\n<p>当通过new操作符调用一个函数对象的时候,实际上会执行内部定义的[[Construct]]方法,下面从规范上理解[[Construct]]方法从而理解调用构造函数的实际行为.<br>\n在通过new调用构造函数的时候会进行一些参数的修正然后调用构造函数的[[Construct]]\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/5068c/newBefore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABlklEQVQoz42Su27cMBBF9f9t+nxG6sCt26RJvGuJEiW+RFLUY7VriSeQErsL4AEOwEvM3JkBWUgpEULw+lpifY8eBsQQkWlAx4j2jtJ1SN0xpkTOmW3b2Pf8l5zZD71t5H2nkI1EdR1N02CtRWlNpxRKK3QYaH58p3v6ivz5hAkDSim01tg4YdOKiQsuBFqtSdNEIQ4za88pGymRbUdVVVRCIFR3UoqSsqkpmwZR12fzqpaUdUvVKoT3VKEnLQvF78vlTKrKksv1SlW3XF5esMYweI+PETtN9N5jtcaHcOKspXcO73uMtYQY2Y+VjwIzJlwMWKMxWtPHiFtm0u3Gtu+w7+S885kotA80Q6IbbnRmoq47tFL4ZaFfZoZpIqWE73timnjb9vNh/kchtacxA7X+RdU9I+wV4Xpc71gfD7acPzVZ/pdXaGOIw0hrvlG3X2jtM2a8YWLApYQbE/f7ncfjcXKcj29zX1fWdf3Q76bFcXHE9IDpDR73zDJPrLeVZZ5P5mVhHEfmeT7XP2pijIQQPvS74R+Y/K4/ae/U/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"newBefore\"\n        title=\"newBefore\"\n        src=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/00d43/newBefore.png\"\n        srcset=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/63868/newBefore.png 250w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/0b533/newBefore.png 500w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/00d43/newBefore.png 1000w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/aa440/newBefore.png 1500w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/5068c/newBefore.png 1917w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/9efb3/new.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIklEQVQ4y42T2Y7bMBRD8/+/VxQoWkydWNa+Wd5i2UlO4Uy36cxDBRDSiwjykveUc0Z2EqUUnRBIrZExYnJ+RYrInEnjwlJ31roxzzPLsjBPM8v1yrJvXPf9+T7lcUDlhCsZ02d8SqhOouUBhVQG0Qo65bh0GtFJRNvSdR3n85lWCIS1CGNIOXPat400LLh+xsWIdPap0oRMnipLvfF6HvzPOdW6YqznHBJtSjRKcu40L60ijVfytDIslcfj8V841VqJOeNK/7RhteaYaykD9/v9nbjnxw+U/SbctkouBeEsX7Xiu7Eol1BxQoYRGQZ0HpFpJA4Tpa44759ztNbS/rx/kT4VGh8RMXOJAeE9rTQ0KnC2I40ttKHQxp65Vrb7jXq7sd1ub6z+IVxXYt8TxwFpLSEGnDHYkLAho13C50JY5iemulLWlWldD4b3oRydUkcQKdA4T+MT343jpbN8bS3fWk3jEnGeqfv+4dz+Vnm6LgttJ2mNxZSCGSa0C+hQUGnB9jO6zJiYSSGQx5G+rvTzRN8X8rg+21Dm+kq4Xq/kccKm8kx3GAopRa7L/K5/h4j748G27xz9ffxj+WfKG/tWMSFysY6mvXBpGkSnEMrRaY/wBRELIhTCMNIPAzHG37V6Y/lIuT8KrS3fpObT5y80QtCcW17OAmUDnTK8tBeUs3jv36l6E8qx5FJKrI+4cUZaj9CaEDw87h+u10d1+UX4A21fMqcRX5VbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"new\"\n        title=\"new\"\n        src=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/00d43/new.png\"\n        srcset=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/63868/new.png 250w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/0b533/new.png 500w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/00d43/new.png 1000w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/aa440/new.png 1500w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/9efb3/new.png 1894w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/161ec/createObj.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQoz3WS646kIBBGff/368kmCiLSAord4/3aezYwmZ9byUlRX6Coj5BJY3jkOX+kJBcCXWmMMdR1nei6Dj9PuGWmW2bcHJkw00gzTzTjwHEe/EZWhQ4dOqrWY71jnibWdWVZFuZ5Zt02tuNg3Xf242DZtrT+JdXryr7vnOdJJqREx2kaj7YBqTRfXw8ejwdCiISuKkqlkJGypCxVQhQFpZR47wkhpCEy5R3Ke+ouYBr3c1AIpJQoVaUcNWVtclHZJu3TpkGVJZWuecZaa8ZxJHNNg7cNMbfO4Z3DWUfbtolo575vrvPkvi6O4+A8D67r+tHvD+f9SXoka/sB17/x32+efaAdvulCoHmaRB8CXWzufSLWfegTzvlkN178er24rpusfloKrSlKRVFbRG1RxiGUoVCGsjbkukJoTfwRea3JtaY2T5y1OOfS+8WmwzCQNdHqe8C/V/x7wY8zYVnxy0o7LeznxQcSN3Dxl4v/xz9Dj1l5z6jTKAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"objCreate\"\n        title=\"objCreate\"\n        src=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/00d43/createObj.png\"\n        srcset=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/63868/createObj.png 250w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/0b533/createObj.png 500w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/00d43/createObj.png 1000w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/aa440/createObj.png 1500w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/161ec/createObj.png 1840w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n[[Construct]]主要分为一下几个步骤:</p>\n<ol>\n<li>将执行上下文定义为当前的执行上下文</li>\n<li>获取当前函数对象的[[ConstructorKind]], 如果是base类型, 将当前的执行环境的this设置为以构造函数为原型创建的对象</li>\n<li>创建新的执行上下文将2中的this绑定到当前的执行上下文</li>\n<li>在当前的词法环境和环境记录上执行构造函数</li>\n<li>退出当前的执行上下文,返回到上次的执行上下文</li>\n<li>如果执行构造函数的结果是有返回值的,当返回一个对象的时候直接将执行结果返回.当有返回结果但是不是对象的时候返回之前创建的this</li>\n<li>没有返回值的时候,返回之前创建的this.</li>\n</ol>\n<h4>简单实现一个new的调用过程</h4>\n<pre><code>function myNew(Con, ...args) {\n  const obj = Object.create(Con.prototype);\n  const ret = Con.call(obj, args);\n  if(ret instanceof Object &#x26;&#x26; ret !== null) {\n    return ret;\n  }\n  return obj;\n}\n</code></pre>\n<h3>Object.create</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6cf0fab11d6071570431a07fe120598e/019a6/ObjectCreate.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+klEQVQY032QW26DMBBF2f93V9Bt9Ct7aKUooQ8IoRA/iAUo4NepbLVRko9auhpd2XfmeAohJX3bUG2eaV6e6F43qNXSjoZhnoghEGO8KoRwp9u7pEJKyaGuqD92HKuSrm0YjEFojVQKYwxaa4ZhuCr5lOv7Pvvz+Zz9PM8UKdD1J3qhSLRaKZxdcdayXC4sy8I0Tfnx5dffEnrv72ph15VDd6KWmqrt2X81bN8ryqqh7TqmccxDhBDoYcjE/50ikZy0Yn885IbbzyNvZU1ZfyPMxOwso7WEGK+hx73d7dB5h5IKoRTWe1wAH8l1sZ7Fuaz0pb/QbeNHwh/2uc30ZuRRvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Object.create\"\n        title=\"Object.create\"\n        src=\"/blog/static/6cf0fab11d6071570431a07fe120598e/00d43/ObjectCreate.png\"\n        srcset=\"/blog/static/6cf0fab11d6071570431a07fe120598e/63868/ObjectCreate.png 250w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/0b533/ObjectCreate.png 500w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/00d43/ObjectCreate.png 1000w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/aa440/ObjectCreate.png 1500w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/019a6/ObjectCreate.png 1818w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>判断传入的原型是否是Object/Null，不是的话抛出异常</li>\n<li>根据传入的原型创建对象(如果传入的原型参数是空那么创建的对象没有原型)</li>\n<li>在创建的对象上定义属性并返回结果</li>\n</ol>\n<h3>规范示例</h3>\n<p>[[Environment]]定义函数对象创建时候的外部词法环境.实际上在javascript中函数就是闭包的概念.函数在创建的时候就已经跟外部的词法环境进行了绑定,在调用的时候并不会改变函数的外部的词法环境.</p>\n<pre><code>const a = 100;\nfunction test() {\n  console.log(a);\n}\nfunction test2() {\n  const a = 200;\n  test();\n}\nconst obj = {\n  a: function() {\n    test();\n  }\n}\ntest2() // 100\nobj.a(); // 100\n</code></pre>\n<p>在一个构造函数中返回一个非对象:</p>\n<pre><code>function Person(name) {\n  this.name = name;\n  return 1;\n}\nconst person = new Person('ss'); // { name: 'ss' }\n</code></pre>\n<p>对于this的确定,可以参考下面的确定规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://tc39.github.io/ecma262/#sec-ecmascript-function-objects\">ECMAScript2020</a><br>\n<a href=\"http://ldllidonglin.github.io/blog/2019/04/26/2019-04-26-ECMAScript2016%E8%A7%84%E8%8C%83%E7%90%86%E8%A7%A3%EF%BC%888%EF%BC%89-new%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/\">ECMAScript2016规范理解（8）-new表达式的执行过程</a><br>\n<a href=\"https://icantunderstand.github.io/blog/javascript-call\">深入理解javascript系列之执行环境</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"ECMAScript规范-函数对象","date":"2019-05-29","tags":"JavaScript","path":"/ecmascript-function","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":12,"pageCount":16,"additionalContext":{"pageAllCount":91}}},
    "staticQueryHashes": []}