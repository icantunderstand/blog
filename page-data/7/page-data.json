{"componentChunkName":"component---src-templates-index-js","path":"/7","result":{"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"78fb9a8d-a295-5d20-8c43-9a4a98d296ef","html":"<h2>1. <a name=''></a>跨端相关</h2>\n<h3>1.1. <a name='Flipperhttps:fbflipper.com'></a><a href=\"https://fbflipper.com/\">Flipper</a></h3>\n<p>Flipper是调试react native的桌面工具，相对于之前的远程调试(模拟JS运行在本地浏览器)，Flipper的调试都基于当前react native的运行环境，使用体验上也比远程调试的方式好一些.</p>\n<h3>1.2. <a name='Elecruehttps:github.comRajvirSingh1313Elecrue'></a><a href=\"https://github.com/RajvirSingh1313/Elecrue\">Elecrue</a></h3>\n<p>Elecrue是一个生成Electron模板应用的工具，做一些辅助的Electron应用可以尝试使用这个工具</p>\n<h2>2. <a name='React'></a>React相关</h2>\n<h3>2.1. <a name='whatsnewinreact18https:yagmurcetintas.comjournalwhats-new-in-react-18'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-react-18\">what's new in react 18?</a></h3>\n<p>这篇文章介绍了React 18的新特性，其中<a href=\"https://github.com/reactwg/react-18/discussions/21\">Automatic batching</a>值得关注</p>\n<h3>2.2. <a name='react-usehttps:github.comstreamichreact-use'></a><a href=\"https://github.com/streamich/react-use\">react-use</a></h3>\n<p>react-use是一个hooks的工具函数库，需要对应的hooks实现的时候可以参考</p>\n<h3>2.3. <a name='react-loadablehttps:github.comjamiebuildsreact-loadable'></a><a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a></h3>\n<p>react-loadable是基于webpack dynamic import实现的动态加载组件的库，看它的实现其实不难，感悟是要到通用的问题要学会抽象的提取并且设计解决方案，比如loadable的loading设置时间，超时时间等，都是在解决开发中的问题。webpack还有splitChunk实现chunk的拆分。</p>\n<h3>2.4. <a name='react-queryhttps:react-query.tanstack.comoverview'></a><a href=\"https://react-query.tanstack.com/overview\">react-query</a></h3>\n<p>相对于Redux，react-query减少了很多模板代码的编写，减少了代码的理解成本。能让你falling into the pit of success.<a href=\"https://tkdodo.eu/blog/react-query-as-a-state-manager\">React Query as a State Manager</a>这篇是在官网上看到的react-query做状态管理的例子。</p>\n<h2>3. <a name='Javascript'></a>Javascript相关</h2>\n<h3>3.1. <a name='whatsnewines2022https:yagmurcetintas.comjournalwhats-new-in-es2022'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-es2022\">what's new in es2022?</a></h3>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null}}},{"node":{"id":"f8414df6-bcbe-5abe-af66-071c3b4aa351","html":"<h3>基础知识</h3>\n<h2><a href=\"https://jakearchibald.com/2021/cors/\">How to win at CORS</a></h2>\n<p>CROS看这篇就够了</p>\n<h2>React Native相关</h2>\n<p><a href=\"https://formidable.com/blog/2019/react-codegen-part-1/\">The New React Native Architecture Explained</a>这个系列文章介绍了React Native架构升级的一些核心概念，包括Turbo Modules,Fabric, JSI等，可以快速的了解架构升级背后的原理。可以结合<a href=\"https://www.cnblogs.com/ludashi/p/15381067.html\">React Native之新架构中的Turbo Module实现原理分析</a>来深入到原理部分。</p>\n<h2>项目管理&#x26;设计</h2>\n<h3><a href=\"https://blog.codinghorror.com/falling-into-the-pit-of-success/\">Falling Into The Pit of Success</a></h3>\n<p>一篇关于系统设计的文章，在进行系统设计的时候我们要思考在使用系统的时候如何让用户获得使用上的收益而不是通过一些手段去弥补系统的漏洞</p>\n<h3><a href=\"https://yonigoldberg.medium.com/fighting-javascript-tests-complexity-with-the-basic-principles-87b7622eac9a\">Writing clean JavaScript tests with the BASIC principles</a></h3>\n<p>在业务开发中，会因为业务的压力导致单测执行粒度不够，KPI式的单测覆盖率目标并不能保证有效的单测。比如前端做单测，在哪些维度做单测的尝试是值得考虑的(基础组件，核心api处理逻辑等)，这边文章讨论了单测执行过程中的一些问题并且给出了如何写单测的原则建议，很有意义。在附一个<a href=\"https://www.zhihu.com/question/27081528/answer/1872155062\">知乎关于单测的讨论</a></p>\n<h3><a href=\"https://mp.weixin.qq.com/s/g5ZjQt9F1UUryisEW1csSA\">这可能是大型复杂项目下数据流的最佳实践</a></h3>\n<p>这篇是关于项目治理的文档，数据流的设计与拆分，领域模块的隔离都有借鉴意义值得学习。项目的治理要早否则根深蒂固就积重难返了。</p>\n<h2>React</h2>\n<h3>hooks实践</h3>\n<p><a href=\"https://devtrium.com/posts/react-typescript-how-to-type-hooks\">React &#x26; TypeScript: how to type hooks (a complete guide)</a><br>\n<a href=\"https://thoughtspile.github.io/2021/10/18/non-react-state/\">How to replace useState with useRef and be a winner</a></p>\n<h3><a href=\"https://www.zhihu.com/question/468249924/answer/1968728853\">知乎上关于hooks的讨论</a></h3>\n<p>其中beeplin的回答有很多借鉴意义，思考到项目的设计问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-11-1-前端快报","date":"2021-11-03","tags":"前端快报","path":"/2021-11-03","top":null,"summary":null}}},{"node":{"id":"ea186f12-6741-57d1-9751-230edd265c28","html":"<h2><a href=\"https://blog.openreplay.com/using-recoil-instead-of-redux-for-state-management-in-react-applications\">Recoil</a></h2>\n<p><a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>是facebook出品的react状态管理库,这篇文章介绍了Recoil的简单使用。Recoil的特点是它通过写react的方式完成了状态管理，不像redux会在代码中引入更多的概念，值得一试</p>\n<h2><a href=\"http://www.ayqy.net/blog/cross-platform-pains/\">跨端方案的三大困境</a></h2>\n<p>跨端开发是主流app都会采用的方案，跨端的方式在短时间内可以尽快的试错跑通流程，相对于纯h5方案也有一定的性能优势，这篇文档主要介绍跨端开发中的一些思考点，对这些问题深入的思考能帮助更好的发展跨端技术。</p>\n<h2><a href=\"https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838\">React Native at Airbnb: The Technology</a></h2>\n<p>Airbnb关于React Native实践的系列文章，从中也能启发出很多跨端开发的思考点</p>\n<h2><a href=\"https://dev.to/adamdbradley/introducing-partytown-run-third-party-scripts-from-a-web-worker-2cnp\">Introducing Partytown 🎉: Run Third-Party Scripts From a Web Worker</a></h2>\n<p>现在的web开发通常需要引入很多第三方sdk来统计业务信息等，这些sdk的执行会增长用户的可交互时间，<a href=\"https://github.com/BuilderIO/partytown\">partytown</a>可以通过worker来运行第三方sdk来减少主页面js的执行时间，现阶段partytown还处于实验阶段，值得后续关注</p>\n<h2><a href=\"https://calibreapp.com/blog/bundle-size-optimization#lazy-load-third-party-resources-with-facades\">Small Bundles, Fast Pages: What To Do With Too Much JavaScript</a></h2>\n<p>这篇文章介绍系统的介绍了优化js包体积大小的方式，其实对momentjs使用的例子很有意思，优化其实不是一蹴而就的，废弃项目这个的momentjs可以从禁止momentjs使用的提示开始</p>\n<h2><a href=\"https://prateeksurana.me/blog/javascript-developer-guide-to-browser-cookies/\">A JavaScript developer’s guide to browser cookies</a></h2>\n<p>cookie拿来吧你</p>\n<h2><a href=\"https://github.com/mithi/react-philosophies\">https://github.com/mithi/react-philosophies</a></h2>\n<p>这篇文章介绍react中组件设计，性能优化的一些最佳实践方式，很有借鉴意义的文章。相关的文档还有<a href=\"https://kentcdodds.com/blog/dont-sync-state-derive-it\">Don't Sync State. Derive It!</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null}}},{"node":{"id":"64678155-c9b4-55b6-99e9-eb857c53bb98","html":"<p>责任链模式将多个处理对象连成一条链并且沿着链传递该请求，直到有一个对象处理它为止。它实现了请求的发送者和接收者之间的解耦合。</p>\n<h2>结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVQ4y42TWauFMAyE/f+/0PMiiPu+70IPXyDi8Va4D0PbNB0nk+js+24U27Zd6xu4P89TwHmapp93zp3wTnochxXzPJskSUxZliZNU9M0zV/CuwIejeNoiqKQZBQAiPI8N1VVGd/3hTCOY1F6F+LoRoMQdl0nKiDt+14wDIMJw9BEUSSAjDj5PwqVgAf3SwUx9Y078rIsE7I7kbXkt8ZABkHbtrJSLiuWLMtyfcxa8vMD67qKh5RY17V4yR0+4ym2EPuXQiX0PE/guq4QaOzz+QjwVu2yEj7PkOAbjVLv6DYKAVZcCm0l24hts2qLvSp8DveT4C0uY0O3KEv3lKejAZg7yuXPwC9ytSlBEEguOayXQoxmz5zRTXyhe4A9MXzTkWFcyCXGHXHyvvBK7ODndxtOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"责任链结构\"\n        title=\"责任链结构\"\n        src=\"/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png\"\n        srcset=\"/blog/static/cd8a720c52b440ad2410037748a084bd/63868/chainstruct.png 250w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/0b533/chainstruct.png 500w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png 1000w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png 1225w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Handler</li>\n</ul>\n<p>定义一个处理请求的接口，实现后继链</p>\n<ul>\n<li>ConcreteHandler</li>\n</ul>\n<p>实现Handler接口，如果可以处理该请求就处理否则将该请求转发给它的后继者</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>向链上的具体ConcreteHandler提交请求</p>\n<h2>适用性</h2>\n<ul>\n<li>当多个对象都可以处理请求且哪个对象处理请求是运行时刻动态确定的</li>\n<li>在不想明确指定接收者的情况下，向多个对象的中的一个提交请求</li>\n<li>可处理一个请求的对象集合应是动态指定的</li>\n</ul>\n<h2>优缺点</h2>\n<ul>\n<li>降低耦合度 请求对象无需知道是其他哪个对象在处理其请求</li>\n<li>增强了给对象指派职责的灵活性  可以在运行中动态的对责任链中的对象进行添加或删除</li>\n<li>不保证被接受</li>\n</ul>\n<h2>实现</h2>\n<ul>\n<li>\n<p>实现后继者链</p>\n</li>\n<li>\n<p>连接后继者</p>\n</li>\n<li>\n<p>表示请求</p>\n<pre><code>  class Handler {\n  public:\n      virtual void handleRequest(Request* theRequest)\n      // _successor 实现后继链\n      Handler(Handler* s) : _successor(s) {}\n  private:\n      Handler*  _successor\n  }\n\n  class ConcreteHandler: public Handler {\n      public:\n      handleRequest(Request* theRequest) {\n          case:\n          /* 省略若干判断*/\n          default:\n          /*转发给后继处理*/    \n      }\n  }\n</code></pre>\n</li>\n</ul>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"10分钟设计模式-责任链","date":"2021-09-06","tags":"设计模式","path":"/chain-responsibility","top":null,"summary":null}}},{"node":{"id":"c80ebb07-77d9-57e3-ba47-f4deb2833ddd","html":"<p>页面开发中数据在组件之间共享和同步是一个比较常见的问题，通过状态管理可以实现清晰的数据流和组件状态同步能一定程度上减少业务的复杂度。本文主要对比Redux和Mobx的实现细节来深入状态管理的技术实现，这样在做技术选型的时候能有一定的考量</p>\n<h2>1. <a name='reduxhttps:github.comreduxjsredux'></a><a href=\"https://github.com/reduxjs/redux\">redux</a></h2>\n<h3>1.1. <a name='redux'></a>redux的思路</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQ4y32U666CQAyEef9HxIAxBgLeuIqCQs3XZMjKufxolu2205l2l6jrOsPatrX7/W7P59Pqura+761pGpumyb85ZyUW3ziOvm4tqqrKbrebsRIM4OVycYDr9Wqv18v9fFOIuH8BYQUABiP2RVFYlmUOwB7wsiwdjH0IuAWOYIBT0gEF7Hg8OivA8COXBOKV/BvLSE4C3++3PR4PZwI7gCVfclnxhUxD4Ch0Yurh6XRaexqeU1ispe6L4Zb+PM9eHel8S6LOUUBB2qE2hAWjMBggXRekDcPgbGCptuhc/d7KXgEJBoQrxETp3/l8XpPFlCK0gxj5Zc4wRAcARkx4t9t5InuGwcCIow0Uwdjv93s7HA6WJIkTcoZIIgBASV2WxRloQJKOAvpHEXLCFqw9DK8KRjISSJZPzzHPcy8sUJhL8tc9hJVMPhgBgJw4jtenyPCIg8iPKf/1JvFTHWZpmnqv9GPYxoX38ANpAjjKavX2CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"redux实现思路\"\n        title=\"redux实现思路\"\n        src=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png\"\n        srcset=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/63868/redux.png 250w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/0b533/redux.png 500w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png 1000w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png 1189w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>redux通过全局的store来统一管理数据，通过订阅机制实现数据变更的通知</li>\n<li>redux引入函数式编程的概念，约定通过action来触发全局store的更新，单向数据流能一定程度上降低业务的复杂度</li>\n</ol>\n<h3>1.2. <a name='redux-1'></a>redux简单使用</h3>\n<pre><code>import { createStore } from 'redux';\nconst action_type = 'test';\nconst init = {\n  count : 1,\n}\nconst reducer = (state = init, action) => {\n  switch(action.type) {\n    case action_type: {\n      return { count: state.count + 1  }; \n    }\n    default: {\n      return state;\n    }\n  }\n}\nconst store = createStore(reducer);\nstore.subscribe(() => {\n  console.log(store.getState()); // { count: 2 }\n})\nstore.dispatch({\n  type: action_type,\n})\n</code></pre>\n<ul>\n<li>redux通过createStore(reducer, preloadState, storeEnhancer)函数来生成状态管理的store.</li>\n<li>store提供getState()来获取当前的状态</li>\n<li>dispath(action)更新应用的状态</li>\n<li>subscribe(listener)来订阅状态变更时触发的事件.</li>\n</ul>\n<p>通过上面的分析可以看出redux实现了一套发布订阅的机制来实现状态的变更和通知,下面将深入redux的源码来了解redux的具体实现</p>\n<h3>1.3. <a name='redux-1'></a>redux源码解析</h3>\n<p>以下源码部分基于<a href=\"mailto:redux@4.0.1\">redux@4.0.1</a>,为了整体介绍redux的整体流程,只保留了关键的部分并且进行了一部分修改.</p>\n<h4>1.3.1. <a name='createStore'></a>createStore</h4>\n<p>createStore(reducer, preloadedState, enhancer)接受reducer,状态初始值,store增强函数来生成应用的store</p>\n<pre><code>export default function createStore(reducer,preloadedState, enhancer) { \n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  // 如果存在enhancer函数,通过enhancer函数创建store\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  // 获取当前应用的状态\n  function getState() {\n    return currentState;\n  }\n  \n  // 订阅当状态更新的监听函数.\n  // 返回取消当前监听函数的方法,用于取消订阅对应监听函数\n  function subscribe(listener) {\n    nextListeners.push(listener);\n    return () {\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    }\n  }\n\n  // 执行action的变更并且执行监听函数\n  function dispatch(action) {\n    currentState = currentReducer(currenState, action);\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i &#x3C; listeners.length; i++) {\n      const listener = listeners[i]\n      listener();\n    }\n    return action;\n  }\n\n  return {\n    getState,\n    cubscribe,\n    dispatch,\n  }\n}\n</code></pre>\n<h4>1.3.2. <a name='combineReducer'></a>combineReducer</h4>\n<p>combineReucer(reducer)可以将多个reducer函数组合起来,接受action并改变状态.combineReducer解决了将所有的更新逻辑写到一个文件的问题</p>\n<pre><code>export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  // 生成finalReducers\n  for (let i = 0; i &#x3C; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  //  返回的函数是实际调用creaStore()的第一个入参,这样就能接受action来改变应用的状态了\n  return function combination(state = {}, action) {\n\n    let hasChanged = false;\n    const nextState = {};\n    // 对action执行所有的传入的reducer函数\n    for (let i = 0; i &#x3C; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]  // 对应reducer之前的state\n      const nextStateForKey = reducer(previousStateForKey, action) // 对应reducer接受action之后的状态\n      nextState[key] = nextStateForKey  // 将处理过后的值存储\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 如果改变返回nextState, 否则返回之前的状态\n    return hasChanged ? nextState : state\n  }\n}\n</code></pre>\n<h4>1.3.3. <a name='applyMiddleware'></a>applyMiddleware</h4>\n<p>applyMiddleware是redux提供对外部进行扩展的途径,通常情况下dispacth只能接受一个对象来对状态进行修改,通过添加不同的中间件,对dispatch进行增强,可以使它接受更多的类型(function, promise)和实现更多的功能, 下面先从一个使用中间件的实例来了解appleMiddleware到底做了什么.</p>\n<pre><code>function thunkMiddleware({ dispatch, getState }) {\n  return  next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState);\n    }\n\n    return next(action);\n  };\n}\nconst store = createStore(reducer, { count: 1 }, applyMiddleware(thunkMiddleware))\nstore.subscribe(() => {\n  console.log(store.getState());\n})\nstore.dispatch(() => {\n  console.log(1);\n  return { type: action_type };\n});\n</code></pre>\n<p>通过上面的例子,dispatch就能接受函数类型并且执行对应的函数,下面来了解appleMiddleware的源码是怎样实现的.applyMiddleware返回的是store的enhancer,在createStore的代码部,在传入enhancer的时候,执行的是enhancer(createStore)(reducer, preloadedState).</p>\n<pre><code>function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    // ..args 是传入的reducer, proloadedState 来生成store\n    const store = createStore(...args);\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n\n    // 将middlewareAPI注入到每个middleware\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    // next的注入,将多个中间件关联,返回的dispatch已经被增强\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre>\n<h4>1.3.4. <a name='reduxreact'></a>redux结合react</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 430px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 148%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTklEQVRIx6WVV4sCMRSF5///GNFnH0QRFLtYsVes2HvL8l24wyi6zuwGws1kkpNzy0msy+VivvXz+Sz2drt9XHO9XmWd5QZMAbvdrmm1WqbdbovVcbPZNJPJREAtt+yOx6MA0O73u9jH4yFjOqCs8wQIQwXUeW0wde2yAnY6Hdm82WxMpVKxWcH0T4DK8F0jHJ4AsY1Gw/R6PTMcDk2xWJTvwWAgBzHvOikKejgczHK5lPLx+/0mlUrJv9VqZa+x3NShkyksaLAjlsSPOV3jiSH2dDpJluv1ugBqQT8x1IlvXdfCigxvt1tbPbrG0oUqLU6k61itbtrtduJyIBAwpVJJwImtYtgM9/u9WSwW4gZBpjNmToNerVal3shoOp2Wb6cc7SwDxmQ0GpWF8XjcJJNJCXwikTD5fF7cc1WHuDSfz00oFBLAcDhsYrGYiUQiJpfLiSI4HUCY4fJsNrPZsxcgVGRnmRhQoADAKJPJCNNCoSAH4BrrAKQOYYodjUYyZj/WToomBiZszmazwhBXx+OxbEB6ZPZdo4wIjyRFAQmo0w3uN1zjH2HBavCRnh6IZzr3JD0FZTNd77lXlcCUFgwGJb40il1Ly3ot2t8KWjsHwZYEOWv0X9JTLb+VntvLQdnQyuWyZPpflwMu6vXl8/mkzPT6Uvl5umDRLlmlE0Pqst/vi63Vat5fPTZ+an9+U/jWax+XYUocsZ6fUYBo6/VaMowA9Dp70rIbQMqFhwklkRg6wFgURZF7fqSm06lIUq1zzEGe61Dl+K6r3n8A1lgA1sQPbKMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-redux\"\n        title=\"react-redux\"\n        src=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n        srcset=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/63868/reactRedux.png 250w,\n/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png 430w\"\n        sizes=\"(max-width: 430px) 100vw, 430px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact-Redux的作用是将React组件和Redux绑定，React组件可以通过react-reudx完成数据的获取和更新。其中connect函数就是这个功能，通过下面的代码可以看出connect主要是从redux或者context中获取属性通过高阶组件的方式返回包裹组件。</p>\n<pre><code>const Connect = _Connect as ConnectedComponent&#x3C;\n  typeof WrappedComponent,\n  WrappedComponentProps\n>\nConnect.WrappedComponent = WrappedComponent\nConnect.displayName = ConnectFunction.displayName = displayName\n\nif (forwardRef) {\n  const _forwarded = React.forwardRef(function forwardConnectRef(\n    props,\n    ref\n  ) {\n    // @ts-ignore\n    return &#x3C;Connect {...props} reactReduxForwardedRef={ref} />\n  })\n\n  const forwarded = _forwarded as ConnectedWrapperComponent\n  forwarded.displayName = displayName\n  forwarded.WrappedComponent = WrappedComponent\n  return hoistStatics(forwarded, WrappedComponent)\n}\n</code></pre>\n<h2>2. <a name='Mobx'></a>Mobx</h2>\n<p>mobx将响应式编程的概念引入到状态管理的实现上，通过观察者模式实现组件的更新。相比redux他的优势在于:</p>\n<ol>\n<li>在组件更新上性能更好 redux通过发布订阅的模式会在所有的组件上进行Prop的脏检查，mbox通过proxy依赖收集能更精确的控制组件的更新</li>\n<li>长期维护上存在一定优势 mbox基于proxy内部维护了更新的机制，redux需要通过mapStateTpProps来主动告知订阅的属性存在一定维护成本</li>\n</ol>\n<h3>mobx背景介绍</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQY00WQ3UrDQBSE8/6PIPgcuRItBqEgXpSQWqvGRpsfgrvFppvdPdl8ktTiwDA383M4Udu2KK05VVsOmwd+ioyyLFHqm7us4ermheW2pakrlFK8lk8ss5ha5RTFF9VuR54kpHFMk6ZE3ntOxtDtn9HZArNfIyI4a0k2Lde3bzy+K8Ig9H3PZ7sm/bhHH2tEBkzXcchz6tWKY10T8QcJI1prvARkGBjHERhhDEAghDPFD3gnZ/V+9joRhtkP0RS8hKdF5yzW2vkaYwzG9PTWMr1mHvQe59w/rZ310vMLZFMvcH+PNUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx\"\n        title=\"mobx\"\n        src=\"/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png\"\n        srcset=\"/blog/static/1f17685984e130f52da0a236b2dcae30/63868/mobx.png 250w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/0b533/mobx.png 500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png 1000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/aa440/mobx.png 1500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/e8950/mobx.png 2000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png 3445w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Observable  定义可观察的值，当observable值变化的时候会触发Derivations</li>\n<li>Derivations Derivations主要为Computed values和Reactions，可观察值的改变会触发对应的Derivations触发</li>\n<li>Actions actions触发Observable值的更改进而触发Derivations</li>\n</ul>\n<h3>mobx简单使用</h3>\n<pre><code>import { observable } from \"mobx\";\nimport { observer } from 'mobx-react'\n// 定义一个可观察的值\nvar timerData = observable({\n  secondsPassed: 0\n});\n// 定义了观察者 当secondsPassed发生变化的时候会触发组件更新\nconst Timer = observer(({ timerData }) =>\n    &#x3C;span>Seconds passed: { timerData.secondsPassed } &#x3C;/span>\n);\nsetTimeout(() => { timerData.secondsPassed = 33 }, 2000)\n\nfunction App() {\n  return &#x3C;Timer timerData={timerData} />\n}\n</code></pre>\n<h3>mobx源码解析</h3>\n<p>使用mobx实现组件更新的方式如下:</p>\n<ul>\n<li>mobx实现创建Observable值和触发Derivations</li>\n<li>mobx-react实现对react组件的封装，创建基于组件的Derivations从而在对应的Observable值修改的时候完成组件的更新</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 852px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVQ4y62Ta8uCQBCF/f9/rehD+EEysjAzKtO8ZdeJZ2CkZHkvkDDMMmf3nDM7q3e9XuWb4X2d8HK5iCtsw38xp0PX4b9gfcvn8/kjDLzdbtJ13QdGzTBI27bVOlkdNk0ju91O8jzXsDVEdV1LHMeSZZnW0jSV/X6vWFVVstlstH48HmW73ep+ryxLgfR+v6sySuv1Wk6nk+bFYtE7OBwOEgSBFEUhq9VKoiiS5/OpROxBxGOBA4IDZGoIPB4PVccFAmDU7cOMYXSGMc8uGjJaGk6N9tiIQw4ul0t1RiRJoqRgRP9sTA0VPtckGQKt+b4vk8lEptOphGGoRHZdOhRzhxoOyabmcouz+XyumaE43yEXPxqNZDwey2w20xaN8P39kc0Njt+d9e8QAEdMDWLaYqOL7Ke/yrI3vKchwW+kQ4cvCws6rZketdUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx原理\"\n        title=\"mobx原理\"\n        src=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n        srcset=\"/blog/static/28f13754dd42663bf2a3b517779e126f/63868/mobxlogic.png 250w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/0b533/mobxlogic.png 500w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png 852w\"\n        sizes=\"(max-width: 852px) 100vw, 852px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>mobx生成Observable</h4>\n<p>Observable会根据传入的值类型包装生成代理，在对观察值获取和设置的时候都是调用代理的方法</p>\n<pre><code>// mobx暴露的observable调用的入口函数 \nfunction createObservable(v: any, arg2?: any, arg3?: any) {\n  // @observable someProp;\n  if (isStringish(arg2)) {\n      storeAnnotation(v, arg2, observableAnnotation)\n      return\n  }\n  // 如果已经是可观察值忽略\n  if (isObservable(v)) return v\n  if (isPlainObject(v)) return observable.object(v, arg2, arg3)\n  // 这里省略了其他数据类型的包装 \n  // 调用工厂方法对不同类型的值包装成可观察值\n  if (typeof v === \"object\" &#x26;&#x26; v !== null) return v\n  // anything else\n  return observable.box(v, arg2)\n}\n// 观察值封装的工厂方法\n// 省略若干其他类型的封装\nobject&#x3C;T = any>(\n    props: T,\n    decorators?: AnnotationsMap&#x3C;T, never>,\n    options?: CreateObservableOptions\n): T {\n    return extendObservable(\n        globalState.useProxies === false || options?.proxy === false\n            ? asObservableObject({}, options)\n            : asDynamicObservableObject({}, options),\n        props,\n        decorators\n    )\n},\n//extendObservable通过创建一个代理(管家)来代理属性的访问和设置，这里关注在没有proxy设置的场景asObservableObject在内部创建了代理\nconst adm = new ObservableObjectAdministration(\n    target,\n    new Map(),\n    String(name),\n    getAnnotationFromOptions(options)\n)\n在ObservableObjectAdministration内部维护了维护了获取属性的get和set方法\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAChElEQVQ4y5WT3Y7bNhCF/RjdtSj+ir+iJEv22t6sHaQ3RZs0RVr0/R/lK6RNFynaAu3FhyGH4JkZ4nB3mArHy51yeSbeboT7jXK9ki4X6vkZF8tG5wMpBvo+4ENE2rjlrY8Yt+YSsm3ZiabFGktZFsbzvJEPI2ka6E8zaR7Jy0ide4Y5M86JXBN+6CnHiVDXWOnnni4ZdkopWiVpfaYOgToVQt/T7L9DiD1t29DKFYGQgkYIRCuQUmxnQjRIJbZzqVp2RhvGUAku0bpMGGbiMJOnhS5ERLNear8iaN/W7V/yf8adlBItFVoZpDJo614xFqnUq0jb/md2xmuEVAgpt9GFbDek1v9L6E3QlZ5uesEMI3oZ6E4Ldp7oco9Smv3DA83jI83+kaYRiK80e/G2X9dbfh25Gw7E60fc0wX7ciLf78TrFTMNmKkSDzN5edre1SWLdop1Kt9bXDLYqOnyGtfnUuxsrvjle8w4Y5+P6MtMvFwoL3fK+UQ6ROKU8H2gK5YwuE0gTo44uk14ZS2ktGTnS8KWBR16dM2Yw4CqBRU8Nlh0pzCdwiWH6V47McFgNxzWG1y22GwxnWZXa6AcJnQOtH3CTBlXI6FUQh2QqSPUcRu7zAu6JPRUMd6j/YDzaWtEDT3Gd+yUVNRauLxMPF0raZnpzwvjuyuhFsbriTJlfLa4aFBGbZ5r23+206sPlab0kTwVfC3EqRJKxjqP85m16P5hz+PDnmYzuvhXNsEVZzr8MDJcjkz3Zw6nnvPtyPzuiX6MxNqRJ4+xGrF2s937u/HfBNdN7xNDqsiQuX+48+W3j3z6/AM///Ijn7/8xK+/f+L24T1dGUjjQhqm7Wt+K/gHXJGxoBKDACIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setAndGet\"\n        title=\"setAndGet\"\n        src=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png\"\n        srcset=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/63868/setAndGet.png 250w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/0b533/setAndGet.png 500w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png 1000w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png 1322w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子对观察值进行修改的时候，会最终走入observablevalue的更新值并且触发Derivations</p>\n<pre><code>setNewValue_(newValue: T) {\n  const oldValue = this.value_\n  this.value_ = newValue\n  this.reportChanged()\n  if (hasListeners(this)) {\n      notifyListeners(this, {\n          type: UPDATE,\n          object: this,\n          newValue,\n          oldValue\n      })\n  }\n}\nexport function endBatch() {\n  if (--globalState.inBatch === 0) {\n      // 触发Derivations\n      runReactions()\n      // 省略若干逻辑\n      globalState.pendingUnobservations = []\n  }\n}\n</code></pre>\n<h4>mobx-react生成Derivations</h4>\n<p>这里主要从包装函数式组件来看Derivations的生成过程，函数式组件的封装方法主要做了:</p>\n<ul>\n<li>\n<p>定义更新逻辑并与生成的Reaction绑定</p>\n</li>\n<li>\n<p>通过运行函数 将observable值与Reaction绑定</p>\n<pre><code>export function useObserver&#x3C;T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    const [, setState] = React.useState()\n    // 定义刷新组件逻辑\n    const forceUpdate = () => setState([] as any)\n    const reactionTrackingRef = React.useRef&#x3C;IReactionTracking | null>(null)\n    if (!reactionTrackingRef.current) {\n        // 创建Derivations 在设置observable的时候会触发相应的newReaction\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n          if (trackingData.mounted) {\n            forceUpdate()\n          } else {\n              trackingData.changedBeforeMount = true\n          }\n        })\n    }\n    const { reaction } = reactionTrackingRef.current!\n    let rendering!: T\n    let exception\n    // track通过运行组件 走入组件的get方法 将reaction跟observable值关联起来\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n    return rendering\n}\n</code></pre>\n</li>\n</ul>\n<p>这样当observable更改的时候会触发对应的Reaction执行从而达到组件刷新的目的</p>\n<p>在业务开发中最开始引入状态管理是为了实现组件之间的状态共享，而使用Redux或者Mobx是引入不同的编程范式来实现这种共享的行为。不同的编程范式能给予项目一定的约束从而实现业务开发的规范。但是范式的引入也一定程度上增加了项目的复杂度，比如redux的依赖管理、中间件概念、mobx跟踪性较弱的更新逻辑等。在考虑引入具体方案的时候应该考虑整个项目的现状和成本，是不是有更轻量化的实现，比如React Hooks。</p>\n<h2>3. <a name=''></a>参考</h2>\n<p><a href=\"https://tech.youzan.com/mobx_vs_redux/\">我为什么从Redux迁移到了Mobx</a><br>\n<a href=\"https://github.com/reduxjs/react-redux\">react-redux</a><br>\n<a href=\"https://github.com/reduxjs/redux\">redux</a><br>\n<a href=\"https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\">Becoming fully reactive: an in-depth explanation of MobX</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/85720939\">mobx 源码解读（一）：从零到 observable 一个 object 如何</a></p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null}}},{"node":{"id":"9cf87650-c261-51d7-b150-77bfa90feef5","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#-\">深度思考-不断逼近问题的本质</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#12\">大败局(1 2)</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#--1\">增长黑客-如何低成本实现爆发式成长</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#\">看不见的心</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li><a href=\"#-1\">思考，快与慢</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li><a href=\"#--1\">结构性改革-中国经济的问题与对策</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>这里记录下自己读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>推荐指数0 - 5</p>\n<h2>1. <a name='-'></a>深度思考-不断逼近问题的本质</h2>\n<p>推荐指数 0.5<br>\n书名与内容严重不符的一本书，内容是作者的个人自传性质，在陈述的过程中并没有很好的结合书名进行深度解读，作为自传的话推荐指数很一般</p>\n<h2>2. <a name='12'></a>大败局(1 2)</h2>\n<p>推荐指数 4.5<br>\n大败局记录了多个企业的发展历史，从中能看到许多的无奈，作者的叙述也比较引人入胜，商业的发展历史很有意思，有机缘巧合也充满着时代的背景。</p>\n<h2>3. <a name='--1'></a>增长黑客-如何低成本实现爆发式成长</h2>\n<p>推荐指数 4<br>\n增长黑客主要介绍一个产品实现快速增长的方式，可以从多个角度去了解产品生命周期的一些行为，本书整体大纲如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 817px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 174.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAIAAAAblL1PAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVRIx5WV+26cOhCH8/7P0r5C1UdIJRQpkUo4sMYB4wv4fqUNcw7ZJXTVM38gG/bzzPxmxvuw3jUppdb6T18f/vQhpRRjRAhhjP8fnHOWmxFCOOd/C+ecnXMhBFj3fT8MA6xjjDnne7BzbhxHY8z1WTHGtm3f3t729ydwKQXOTimFELz3KSUppVIKY0wpvRc2wPBclkUI4b2HbdM0n2U/97xbCIFzboxpmkYpBZmnlO55LqWs6+q9n+eZUtq2bdd1hJB5noUQ8zzDDz7g4OwyvRmtGWPTNAkhQHPOOaillCKbSSlvPJdSYgjeqBgjbEspIQRjTNjMe48Q6vs+pbSn9rD3EwCHnFNKzjm72eVyYYzB6Uf4VDCovNrs+fm567obuJS1lDXGtC3eQ7XWaq2ttaUUzjn0TEoJ1Nql/tczhAt7rTVCiFI6jiPnHCH0+vo6DMM18wHbUBaTZ5OtLxC/tRaKxBgbx5ExBoWB5w1c/eO+fm++fPv5o/G78lprIQTGmHNurd3fH2Hjs1CJq6jde+TWWigjTIjb7LOKNznnnGCGwLTWzrllWUBkrXUpRSl1cP4O51Ri+oD3awTmUQhBCJmmqW1bQshR7c91LqV476FPvfd1XVdV1battfY6hSMMCyklY6zdzDln/rOTsHd4XVdjDAimtX7dDMZjF3y3I5xzhr43xmitMcbQ2NM0XXfl0TNIteecc/be930PDVdV1TRNzjmtNYS2LEuM8WOevdXz2Mfw3ip7h0zTNAzDOI4Y42EYjDHWWqWUlPIGzjk5o2H6GGMIISnl3qeEEEqp9/7eHea9d86BJOAEY3y5XCilIYTrq+II75lzzqWUAMNUEkIYY0IIzjljjHOeUjq/PffBhuS7rnt6enp8fKyqyhgDRSmlHGGYBKXUMAx1Xfd937bty8tL0zQg23XZT3IGzZRSdV1rrZdlwRjfq/PnsGOMQghK6bIsf/svaa3lnIcQCCHe+67rEEKnN8EJDD5zznBXg9Sn5G/4F0b698mAfDLQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"增长黑客\"\n        title=\"增长黑客\"\n        src=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png\"\n        srcset=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/63868/increase.png 250w,\n/blog/static/5386809516d54d0978bc47eaf65fdf8d/0b533/increase.png 500w,\n/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png 817w\"\n        sizes=\"(max-width: 817px) 100vw, 817px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>4. <a name=''></a>看不见的心</h2>\n<p>推荐指数 4<br>\n通过两个人的爱情故事阐述了很多经济学的视角，很有意思的一本经济学读物</p>\n<h2>5. <a name='-1'></a>思考，快与慢</h2>\n<p>推荐指数 4<br>\n虽然有些中文翻译增加了阅读上的困难但整体上还是值得阅读的一本书，书中介绍了思维的快思考方式和慢思考方式、常见的思维误区等，阅读之后还是有一定的启发</p>\n<h2>6. <a name='--1'></a>结构性改革-中国经济的问题与对策</h2>\n<p>推荐指数 4.5<br>\n可以结合分析与思考一起阅读，这两本书总结了黄齐帆对中国经济问题的一些长远的思考，对于中国的一些问题通过结构性的方式去优化。黄奇帆通过结构性的梳理问题并且比较创造性的提出解决方案都体现出他对中国特色社会主义制度的深入思考，书读起来特别引人入胜</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":7,"pageCount":15,"additionalContext":{"pageAllCount":87}}},"staticQueryHashes":[]}