{"componentChunkName":"component---src-templates-index-js","path":"/7","result":{"pageContext":{"pageAllCount":90,"group":[{"node":{"id":"ea186f12-6741-57d1-9751-230edd265c28","html":"<h2><a href=\"https://blog.openreplay.com/using-recoil-instead-of-redux-for-state-management-in-react-applications\">Recoil</a></h2>\n<p><a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>是facebook出品的react状态管理库,这篇文章介绍了Recoil的简单使用。Recoil的特点是它通过写react的方式完成了状态管理，不像redux会在代码中引入更多的概念，值得一试</p>\n<h2><a href=\"http://www.ayqy.net/blog/cross-platform-pains/\">跨端方案的三大困境</a></h2>\n<p>跨端开发是主流app都会采用的方案，跨端的方式在短时间内可以尽快的试错跑通流程，相对于纯h5方案也有一定的性能优势，这篇文档主要介绍跨端开发中的一些思考点，对这些问题深入的思考能帮助更好的发展跨端技术。</p>\n<h2><a href=\"https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838\">React Native at Airbnb: The Technology</a></h2>\n<p>Airbnb关于React Native实践的系列文章，从中也能启发出很多跨端开发的思考点</p>\n<h2><a href=\"https://dev.to/adamdbradley/introducing-partytown-run-third-party-scripts-from-a-web-worker-2cnp\">Introducing Partytown 🎉: Run Third-Party Scripts From a Web Worker</a></h2>\n<p>现在的web开发通常需要引入很多第三方sdk来统计业务信息等，这些sdk的执行会增长用户的可交互时间，<a href=\"https://github.com/BuilderIO/partytown\">partytown</a>可以通过worker来运行第三方sdk来减少主页面js的执行时间，现阶段partytown还处于实验阶段，值得后续关注</p>\n<h2><a href=\"https://calibreapp.com/blog/bundle-size-optimization#lazy-load-third-party-resources-with-facades\">Small Bundles, Fast Pages: What To Do With Too Much JavaScript</a></h2>\n<p>这篇文章介绍系统的介绍了优化js包体积大小的方式，其实对momentjs使用的例子很有意思，优化其实不是一蹴而就的，废弃项目这个的momentjs可以从禁止momentjs使用的提示开始</p>\n<h2><a href=\"https://prateeksurana.me/blog/javascript-developer-guide-to-browser-cookies/\">A JavaScript developer’s guide to browser cookies</a></h2>\n<p>cookie拿来吧你</p>\n<h2><a href=\"https://github.com/mithi/react-philosophies\">https://github.com/mithi/react-philosophies</a></h2>\n<p>这篇文章介绍react中组件设计，性能优化的一些最佳实践方式，很有借鉴意义的文章。相关的文档还有<a href=\"https://kentcdodds.com/blog/dont-sync-state-derive-it\">Don't Sync State. Derive It!</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null}}},{"node":{"id":"64678155-c9b4-55b6-99e9-eb857c53bb98","html":"<p>责任链模式将多个处理对象连成一条链并且沿着链传递该请求，直到有一个对象处理它为止。它实现了请求的发送者和接收者之间的解耦合。</p>\n<h2>结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVQ4y42TWauFMAyE/f+/0PMiiPu+70IPXyDi8Va4D0PbNB0nk+js+24U27Zd6xu4P89TwHmapp93zp3wTnochxXzPJskSUxZliZNU9M0zV/CuwIejeNoiqKQZBQAiPI8N1VVGd/3hTCOY1F6F+LoRoMQdl0nKiDt+14wDIMJw9BEUSSAjDj5PwqVgAf3SwUx9Y078rIsE7I7kbXkt8ZABkHbtrJSLiuWLMtyfcxa8vMD67qKh5RY17V4yR0+4ym2EPuXQiX0PE/guq4QaOzz+QjwVu2yEj7PkOAbjVLv6DYKAVZcCm0l24hts2qLvSp8DveT4C0uY0O3KEv3lKejAZg7yuXPwC9ytSlBEEguOayXQoxmz5zRTXyhe4A9MXzTkWFcyCXGHXHyvvBK7ODndxtOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"责任链结构\"\n        title=\"责任链结构\"\n        src=\"/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png\"\n        srcset=\"/blog/static/cd8a720c52b440ad2410037748a084bd/63868/chainstruct.png 250w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/0b533/chainstruct.png 500w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png 1000w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png 1225w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Handler</li>\n</ul>\n<p>定义一个处理请求的接口，实现后继链</p>\n<ul>\n<li>ConcreteHandler</li>\n</ul>\n<p>实现Handler接口，如果可以处理该请求就处理否则将该请求转发给它的后继者</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>向链上的具体ConcreteHandler提交请求</p>\n<h2>适用性</h2>\n<ul>\n<li>当多个对象都可以处理请求且哪个对象处理请求是运行时刻动态确定的</li>\n<li>在不想明确指定接收者的情况下，向多个对象的中的一个提交请求</li>\n<li>可处理一个请求的对象集合应是动态指定的</li>\n</ul>\n<h2>优缺点</h2>\n<ul>\n<li>降低耦合度 请求对象无需知道是其他哪个对象在处理其请求</li>\n<li>增强了给对象指派职责的灵活性  可以在运行中动态的对责任链中的对象进行添加或删除</li>\n<li>不保证被接受</li>\n</ul>\n<h2>实现</h2>\n<ul>\n<li>\n<p>实现后继者链</p>\n</li>\n<li>\n<p>连接后继者</p>\n</li>\n<li>\n<p>表示请求</p>\n<pre><code>  class Handler {\n  public:\n      virtual void handleRequest(Request* theRequest)\n      // _successor 实现后继链\n      Handler(Handler* s) : _successor(s) {}\n  private:\n      Handler*  _successor\n  }\n\n  class ConcreteHandler: public Handler {\n      public:\n      handleRequest(Request* theRequest) {\n          case:\n          /* 省略若干判断*/\n          default:\n          /*转发给后继处理*/    \n      }\n  }\n</code></pre>\n</li>\n</ul>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"10分钟设计模式-责任链","date":"2021-09-06","tags":"设计模式","path":"/chain-responsibility","top":null,"summary":null}}},{"node":{"id":"c80ebb07-77d9-57e3-ba47-f4deb2833ddd","html":"<p>页面开发中数据在组件之间共享和同步是一个比较常见的问题，通过状态管理可以实现清晰的数据流和组件状态同步能一定程度上减少业务的复杂度。本文主要对比Redux和Mobx的实现细节来深入状态管理的技术实现，这样在做技术选型的时候能有一定的考量</p>\n<h2>1. <a name='reduxhttps:github.comreduxjsredux'></a><a href=\"https://github.com/reduxjs/redux\">redux</a></h2>\n<h3>1.1. <a name='redux'></a>redux的思路</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQ4y32U666CQAyEef9HxIAxBgLeuIqCQs3XZMjKufxolu2205l2l6jrOsPatrX7/W7P59Pqura+761pGpumyb85ZyUW3ziOvm4tqqrKbrebsRIM4OVycYDr9Wqv18v9fFOIuH8BYQUABiP2RVFYlmUOwB7wsiwdjH0IuAWOYIBT0gEF7Hg8OivA8COXBOKV/BvLSE4C3++3PR4PZwI7gCVfclnxhUxD4Ch0Yurh6XRaexqeU1ispe6L4Zb+PM9eHel8S6LOUUBB2qE2hAWjMBggXRekDcPgbGCptuhc/d7KXgEJBoQrxETp3/l8XpPFlCK0gxj5Zc4wRAcARkx4t9t5InuGwcCIow0Uwdjv93s7HA6WJIkTcoZIIgBASV2WxRloQJKOAvpHEXLCFqw9DK8KRjISSJZPzzHPcy8sUJhL8tc9hJVMPhgBgJw4jtenyPCIg8iPKf/1JvFTHWZpmnqv9GPYxoX38ANpAjjKavX2CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"redux实现思路\"\n        title=\"redux实现思路\"\n        src=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png\"\n        srcset=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/63868/redux.png 250w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/0b533/redux.png 500w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png 1000w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png 1189w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>redux通过全局的store来统一管理数据，通过订阅机制实现数据变更的通知</li>\n<li>redux引入函数式编程的概念，约定通过action来触发全局store的更新，单向数据流能一定程度上降低业务的复杂度</li>\n</ol>\n<h3>1.2. <a name='redux-1'></a>redux简单使用</h3>\n<pre><code>import { createStore } from 'redux';\nconst action_type = 'test';\nconst init = {\n  count : 1,\n}\nconst reducer = (state = init, action) => {\n  switch(action.type) {\n    case action_type: {\n      return { count: state.count + 1  }; \n    }\n    default: {\n      return state;\n    }\n  }\n}\nconst store = createStore(reducer);\nstore.subscribe(() => {\n  console.log(store.getState()); // { count: 2 }\n})\nstore.dispatch({\n  type: action_type,\n})\n</code></pre>\n<ul>\n<li>redux通过createStore(reducer, preloadState, storeEnhancer)函数来生成状态管理的store.</li>\n<li>store提供getState()来获取当前的状态</li>\n<li>dispath(action)更新应用的状态</li>\n<li>subscribe(listener)来订阅状态变更时触发的事件.</li>\n</ul>\n<p>通过上面的分析可以看出redux实现了一套发布订阅的机制来实现状态的变更和通知,下面将深入redux的源码来了解redux的具体实现</p>\n<h3>1.3. <a name='redux-1'></a>redux源码解析</h3>\n<p>以下源码部分基于<a href=\"mailto:redux@4.0.1\">redux@4.0.1</a>,为了整体介绍redux的整体流程,只保留了关键的部分并且进行了一部分修改.</p>\n<h4>1.3.1. <a name='createStore'></a>createStore</h4>\n<p>createStore(reducer, preloadedState, enhancer)接受reducer,状态初始值,store增强函数来生成应用的store</p>\n<pre><code>export default function createStore(reducer,preloadedState, enhancer) { \n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  // 如果存在enhancer函数,通过enhancer函数创建store\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  // 获取当前应用的状态\n  function getState() {\n    return currentState;\n  }\n  \n  // 订阅当状态更新的监听函数.\n  // 返回取消当前监听函数的方法,用于取消订阅对应监听函数\n  function subscribe(listener) {\n    nextListeners.push(listener);\n    return () {\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    }\n  }\n\n  // 执行action的变更并且执行监听函数\n  function dispatch(action) {\n    currentState = currentReducer(currenState, action);\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i &#x3C; listeners.length; i++) {\n      const listener = listeners[i]\n      listener();\n    }\n    return action;\n  }\n\n  return {\n    getState,\n    cubscribe,\n    dispatch,\n  }\n}\n</code></pre>\n<h4>1.3.2. <a name='combineReducer'></a>combineReducer</h4>\n<p>combineReucer(reducer)可以将多个reducer函数组合起来,接受action并改变状态.combineReducer解决了将所有的更新逻辑写到一个文件的问题</p>\n<pre><code>export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  // 生成finalReducers\n  for (let i = 0; i &#x3C; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  //  返回的函数是实际调用creaStore()的第一个入参,这样就能接受action来改变应用的状态了\n  return function combination(state = {}, action) {\n\n    let hasChanged = false;\n    const nextState = {};\n    // 对action执行所有的传入的reducer函数\n    for (let i = 0; i &#x3C; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]  // 对应reducer之前的state\n      const nextStateForKey = reducer(previousStateForKey, action) // 对应reducer接受action之后的状态\n      nextState[key] = nextStateForKey  // 将处理过后的值存储\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 如果改变返回nextState, 否则返回之前的状态\n    return hasChanged ? nextState : state\n  }\n}\n</code></pre>\n<h4>1.3.3. <a name='applyMiddleware'></a>applyMiddleware</h4>\n<p>applyMiddleware是redux提供对外部进行扩展的途径,通常情况下dispacth只能接受一个对象来对状态进行修改,通过添加不同的中间件,对dispatch进行增强,可以使它接受更多的类型(function, promise)和实现更多的功能, 下面先从一个使用中间件的实例来了解appleMiddleware到底做了什么.</p>\n<pre><code>function thunkMiddleware({ dispatch, getState }) {\n  return  next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState);\n    }\n\n    return next(action);\n  };\n}\nconst store = createStore(reducer, { count: 1 }, applyMiddleware(thunkMiddleware))\nstore.subscribe(() => {\n  console.log(store.getState());\n})\nstore.dispatch(() => {\n  console.log(1);\n  return { type: action_type };\n});\n</code></pre>\n<p>通过上面的例子,dispatch就能接受函数类型并且执行对应的函数,下面来了解appleMiddleware的源码是怎样实现的.applyMiddleware返回的是store的enhancer,在createStore的代码部,在传入enhancer的时候,执行的是enhancer(createStore)(reducer, preloadedState).</p>\n<pre><code>function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    // ..args 是传入的reducer, proloadedState 来生成store\n    const store = createStore(...args);\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n\n    // 将middlewareAPI注入到每个middleware\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    // next的注入,将多个中间件关联,返回的dispatch已经被增强\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre>\n<h4>1.3.4. <a name='reduxreact'></a>redux结合react</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 430px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 148%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTklEQVRIx6WVV4sCMRSF5///GNFnH0QRFLtYsVes2HvL8l24wyi6zuwGws1kkpNzy0msy+VivvXz+Sz2drt9XHO9XmWd5QZMAbvdrmm1WqbdbovVcbPZNJPJREAtt+yOx6MA0O73u9jH4yFjOqCs8wQIQwXUeW0wde2yAnY6Hdm82WxMpVKxWcH0T4DK8F0jHJ4AsY1Gw/R6PTMcDk2xWJTvwWAgBzHvOikKejgczHK5lPLx+/0mlUrJv9VqZa+x3NShkyksaLAjlsSPOV3jiSH2dDpJluv1ugBqQT8x1IlvXdfCigxvt1tbPbrG0oUqLU6k61itbtrtduJyIBAwpVJJwImtYtgM9/u9WSwW4gZBpjNmToNerVal3shoOp2Wb6cc7SwDxmQ0GpWF8XjcJJNJCXwikTD5fF7cc1WHuDSfz00oFBLAcDhsYrGYiUQiJpfLiSI4HUCY4fJsNrPZsxcgVGRnmRhQoADAKJPJCNNCoSAH4BrrAKQOYYodjUYyZj/WToomBiZszmazwhBXx+OxbEB6ZPZdo4wIjyRFAQmo0w3uN1zjH2HBavCRnh6IZzr3JD0FZTNd77lXlcCUFgwGJb40il1Ly3ot2t8KWjsHwZYEOWv0X9JTLb+VntvLQdnQyuWyZPpflwMu6vXl8/mkzPT6Uvl5umDRLlmlE0Pqst/vi63Vat5fPTZ+an9+U/jWax+XYUocsZ6fUYBo6/VaMowA9Dp70rIbQMqFhwklkRg6wFgURZF7fqSm06lIUq1zzEGe61Dl+K6r3n8A1lgA1sQPbKMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-redux\"\n        title=\"react-redux\"\n        src=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n        srcset=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/63868/reactRedux.png 250w,\n/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png 430w\"\n        sizes=\"(max-width: 430px) 100vw, 430px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact-Redux的作用是将React组件和Redux绑定，React组件可以通过react-reudx完成数据的获取和更新。其中connect函数就是这个功能，通过下面的代码可以看出connect主要是从redux或者context中获取属性通过高阶组件的方式返回包裹组件。</p>\n<pre><code>const Connect = _Connect as ConnectedComponent&#x3C;\n  typeof WrappedComponent,\n  WrappedComponentProps\n>\nConnect.WrappedComponent = WrappedComponent\nConnect.displayName = ConnectFunction.displayName = displayName\n\nif (forwardRef) {\n  const _forwarded = React.forwardRef(function forwardConnectRef(\n    props,\n    ref\n  ) {\n    // @ts-ignore\n    return &#x3C;Connect {...props} reactReduxForwardedRef={ref} />\n  })\n\n  const forwarded = _forwarded as ConnectedWrapperComponent\n  forwarded.displayName = displayName\n  forwarded.WrappedComponent = WrappedComponent\n  return hoistStatics(forwarded, WrappedComponent)\n}\n</code></pre>\n<h2>2. <a name='Mobx'></a>Mobx</h2>\n<p>mobx将响应式编程的概念引入到状态管理的实现上，通过观察者模式实现组件的更新。相比redux他的优势在于:</p>\n<ol>\n<li>在组件更新上性能更好 redux通过发布订阅的模式会在所有的组件上进行Prop的脏检查，mbox通过proxy依赖收集能更精确的控制组件的更新</li>\n<li>长期维护上存在一定优势 mbox基于proxy内部维护了更新的机制，redux需要通过mapStateTpProps来主动告知订阅的属性存在一定维护成本</li>\n</ol>\n<h3>mobx背景介绍</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQY00WQ3UrDQBSE8/6PIPgcuRItBqEgXpSQWqvGRpsfgrvFppvdPdl8ktTiwDA383M4Udu2KK05VVsOmwd+ioyyLFHqm7us4ermheW2pakrlFK8lk8ss5ha5RTFF9VuR54kpHFMk6ZE3ntOxtDtn9HZArNfIyI4a0k2Lde3bzy+K8Ig9H3PZ7sm/bhHH2tEBkzXcchz6tWKY10T8QcJI1prvARkGBjHERhhDEAghDPFD3gnZ/V+9joRhtkP0RS8hKdF5yzW2vkaYwzG9PTWMr1mHvQe59w/rZ310vMLZFMvcH+PNUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx\"\n        title=\"mobx\"\n        src=\"/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png\"\n        srcset=\"/blog/static/1f17685984e130f52da0a236b2dcae30/63868/mobx.png 250w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/0b533/mobx.png 500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png 1000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/aa440/mobx.png 1500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/e8950/mobx.png 2000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png 3445w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Observable  定义可观察的值，当observable值变化的时候会触发Derivations</li>\n<li>Derivations Derivations主要为Computed values和Reactions，可观察值的改变会触发对应的Derivations触发</li>\n<li>Actions actions触发Observable值的更改进而触发Derivations</li>\n</ul>\n<h3>mobx简单使用</h3>\n<pre><code>import { observable } from \"mobx\";\nimport { observer } from 'mobx-react'\n// 定义一个可观察的值\nvar timerData = observable({\n  secondsPassed: 0\n});\n// 定义了观察者 当secondsPassed发生变化的时候会触发组件更新\nconst Timer = observer(({ timerData }) =>\n    &#x3C;span>Seconds passed: { timerData.secondsPassed } &#x3C;/span>\n);\nsetTimeout(() => { timerData.secondsPassed = 33 }, 2000)\n\nfunction App() {\n  return &#x3C;Timer timerData={timerData} />\n}\n</code></pre>\n<h3>mobx源码解析</h3>\n<p>使用mobx实现组件更新的方式如下:</p>\n<ul>\n<li>mobx实现创建Observable值和触发Derivations</li>\n<li>mobx-react实现对react组件的封装，创建基于组件的Derivations从而在对应的Observable值修改的时候完成组件的更新</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 852px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVQ4y62Ta8uCQBCF/f9/rehD+EEysjAzKtO8ZdeJZ2CkZHkvkDDMMmf3nDM7q3e9XuWb4X2d8HK5iCtsw38xp0PX4b9gfcvn8/kjDLzdbtJ13QdGzTBI27bVOlkdNk0ju91O8jzXsDVEdV1LHMeSZZnW0jSV/X6vWFVVstlstH48HmW73ep+ryxLgfR+v6sySuv1Wk6nk+bFYtE7OBwOEgSBFEUhq9VKoiiS5/OpROxBxGOBA4IDZGoIPB4PVccFAmDU7cOMYXSGMc8uGjJaGk6N9tiIQw4ul0t1RiRJoqRgRP9sTA0VPtckGQKt+b4vk8lEptOphGGoRHZdOhRzhxoOyabmcouz+XyumaE43yEXPxqNZDwey2w20xaN8P39kc0Njt+d9e8QAEdMDWLaYqOL7Ke/yrI3vKchwW+kQ4cvCws6rZketdUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx原理\"\n        title=\"mobx原理\"\n        src=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n        srcset=\"/blog/static/28f13754dd42663bf2a3b517779e126f/63868/mobxlogic.png 250w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/0b533/mobxlogic.png 500w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png 852w\"\n        sizes=\"(max-width: 852px) 100vw, 852px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>mobx生成Observable</h4>\n<p>Observable会根据传入的值类型包装生成代理，在对观察值获取和设置的时候都是调用代理的方法</p>\n<pre><code>// mobx暴露的observable调用的入口函数 \nfunction createObservable(v: any, arg2?: any, arg3?: any) {\n  // @observable someProp;\n  if (isStringish(arg2)) {\n      storeAnnotation(v, arg2, observableAnnotation)\n      return\n  }\n  // 如果已经是可观察值忽略\n  if (isObservable(v)) return v\n  if (isPlainObject(v)) return observable.object(v, arg2, arg3)\n  // 这里省略了其他数据类型的包装 \n  // 调用工厂方法对不同类型的值包装成可观察值\n  if (typeof v === \"object\" &#x26;&#x26; v !== null) return v\n  // anything else\n  return observable.box(v, arg2)\n}\n// 观察值封装的工厂方法\n// 省略若干其他类型的封装\nobject&#x3C;T = any>(\n    props: T,\n    decorators?: AnnotationsMap&#x3C;T, never>,\n    options?: CreateObservableOptions\n): T {\n    return extendObservable(\n        globalState.useProxies === false || options?.proxy === false\n            ? asObservableObject({}, options)\n            : asDynamicObservableObject({}, options),\n        props,\n        decorators\n    )\n},\n//extendObservable通过创建一个代理(管家)来代理属性的访问和设置，这里关注在没有proxy设置的场景asObservableObject在内部创建了代理\nconst adm = new ObservableObjectAdministration(\n    target,\n    new Map(),\n    String(name),\n    getAnnotationFromOptions(options)\n)\n在ObservableObjectAdministration内部维护了维护了获取属性的get和set方法\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAChElEQVQ4y5WT3Y7bNhCF/RjdtSj+ir+iJEv22t6sHaQ3RZs0RVr0/R/lK6RNFynaAu3FhyGH4JkZ4nB3mArHy51yeSbeboT7jXK9ki4X6vkZF8tG5wMpBvo+4ENE2rjlrY8Yt+YSsm3ZiabFGktZFsbzvJEPI2ka6E8zaR7Jy0ide4Y5M86JXBN+6CnHiVDXWOnnni4ZdkopWiVpfaYOgToVQt/T7L9DiD1t29DKFYGQgkYIRCuQUmxnQjRIJbZzqVp2RhvGUAku0bpMGGbiMJOnhS5ERLNear8iaN/W7V/yf8adlBItFVoZpDJo614xFqnUq0jb/md2xmuEVAgpt9GFbDek1v9L6E3QlZ5uesEMI3oZ6E4Ldp7oco9Smv3DA83jI83+kaYRiK80e/G2X9dbfh25Gw7E60fc0wX7ciLf78TrFTMNmKkSDzN5edre1SWLdop1Kt9bXDLYqOnyGtfnUuxsrvjle8w4Y5+P6MtMvFwoL3fK+UQ6ROKU8H2gK5YwuE0gTo44uk14ZS2ktGTnS8KWBR16dM2Yw4CqBRU8Nlh0pzCdwiWH6V47McFgNxzWG1y22GwxnWZXa6AcJnQOtH3CTBlXI6FUQh2QqSPUcRu7zAu6JPRUMd6j/YDzaWtEDT3Gd+yUVNRauLxMPF0raZnpzwvjuyuhFsbriTJlfLa4aFBGbZ5r23+206sPlab0kTwVfC3EqRJKxjqP85m16P5hz+PDnmYzuvhXNsEVZzr8MDJcjkz3Zw6nnvPtyPzuiX6MxNqRJ4+xGrF2s937u/HfBNdN7xNDqsiQuX+48+W3j3z6/AM///Ijn7/8xK+/f+L24T1dGUjjQhqm7Wt+K/gHXJGxoBKDACIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setAndGet\"\n        title=\"setAndGet\"\n        src=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png\"\n        srcset=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/63868/setAndGet.png 250w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/0b533/setAndGet.png 500w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png 1000w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png 1322w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子对观察值进行修改的时候，会最终走入observablevalue的更新值并且触发Derivations</p>\n<pre><code>setNewValue_(newValue: T) {\n  const oldValue = this.value_\n  this.value_ = newValue\n  this.reportChanged()\n  if (hasListeners(this)) {\n      notifyListeners(this, {\n          type: UPDATE,\n          object: this,\n          newValue,\n          oldValue\n      })\n  }\n}\nexport function endBatch() {\n  if (--globalState.inBatch === 0) {\n      // 触发Derivations\n      runReactions()\n      // 省略若干逻辑\n      globalState.pendingUnobservations = []\n  }\n}\n</code></pre>\n<h4>mobx-react生成Derivations</h4>\n<p>这里主要从包装函数式组件来看Derivations的生成过程，函数式组件的封装方法主要做了:</p>\n<ul>\n<li>\n<p>定义更新逻辑并与生成的Reaction绑定</p>\n</li>\n<li>\n<p>通过运行函数 将observable值与Reaction绑定</p>\n<pre><code>export function useObserver&#x3C;T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    const [, setState] = React.useState()\n    // 定义刷新组件逻辑\n    const forceUpdate = () => setState([] as any)\n    const reactionTrackingRef = React.useRef&#x3C;IReactionTracking | null>(null)\n    if (!reactionTrackingRef.current) {\n        // 创建Derivations 在设置observable的时候会触发相应的newReaction\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n          if (trackingData.mounted) {\n            forceUpdate()\n          } else {\n              trackingData.changedBeforeMount = true\n          }\n        })\n    }\n    const { reaction } = reactionTrackingRef.current!\n    let rendering!: T\n    let exception\n    // track通过运行组件 走入组件的get方法 将reaction跟observable值关联起来\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n    return rendering\n}\n</code></pre>\n</li>\n</ul>\n<p>这样当observable更改的时候会触发对应的Reaction执行从而达到组件刷新的目的</p>\n<p>在业务开发中最开始引入状态管理是为了实现组件之间的状态共享，而使用Redux或者Mobx是引入不同的编程范式来实现这种共享的行为。不同的编程范式能给予项目一定的约束从而实现业务开发的规范。但是范式的引入也一定程度上增加了项目的复杂度，比如redux的依赖管理、中间件概念、mobx跟踪性较弱的更新逻辑等。在考虑引入具体方案的时候应该考虑整个项目的现状和成本，是不是有更轻量化的实现，比如React Hooks。</p>\n<h2>3. <a name=''></a>参考</h2>\n<p><a href=\"https://tech.youzan.com/mobx_vs_redux/\">我为什么从Redux迁移到了Mobx</a><br>\n<a href=\"https://github.com/reduxjs/react-redux\">react-redux</a><br>\n<a href=\"https://github.com/reduxjs/redux\">redux</a><br>\n<a href=\"https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\">Becoming fully reactive: an in-depth explanation of MobX</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/85720939\">mobx 源码解读（一）：从零到 observable 一个 object 如何</a></p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null}}},{"node":{"id":"9cf87650-c261-51d7-b150-77bfa90feef5","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#-\">深度思考-不断逼近问题的本质</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#12\">大败局(1 2)</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#--1\">增长黑客-如何低成本实现爆发式成长</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#\">看不见的心</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li><a href=\"#-1\">思考，快与慢</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li><a href=\"#--1\">结构性改革-中国经济的问题与对策</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>这里记录下自己读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>推荐指数0 - 5</p>\n<h2>1. <a name='-'></a>深度思考-不断逼近问题的本质</h2>\n<p>推荐指数 0.5<br>\n书名与内容严重不符的一本书，内容是作者的个人自传性质，在陈述的过程中并没有很好的结合书名进行深度解读，作为自传的话推荐指数很一般</p>\n<h2>2. <a name='12'></a>大败局(1 2)</h2>\n<p>推荐指数 4.5<br>\n大败局记录了多个企业的发展历史，从中能看到许多的无奈，作者的叙述也比较引人入胜，商业的发展历史很有意思，有机缘巧合也充满着时代的背景。</p>\n<h2>3. <a name='--1'></a>增长黑客-如何低成本实现爆发式成长</h2>\n<p>推荐指数 4<br>\n增长黑客主要介绍一个产品实现快速增长的方式，可以从多个角度去了解产品生命周期的一些行为，本书整体大纲如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 817px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 174.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAIAAAAblL1PAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVRIx5WV+26cOhCH8/7P0r5C1UdIJRQpkUo4sMYB4wv4fqUNcw7ZJXTVM38gG/bzzPxmxvuw3jUppdb6T18f/vQhpRRjRAhhjP8fnHOWmxFCOOd/C+ecnXMhBFj3fT8MA6xjjDnne7BzbhxHY8z1WTHGtm3f3t729ydwKQXOTimFELz3KSUppVIKY0wpvRc2wPBclkUI4b2HbdM0n2U/97xbCIFzboxpmkYpBZmnlO55LqWs6+q9n+eZUtq2bdd1hJB5noUQ8zzDDz7g4OwyvRmtGWPTNAkhQHPOOaillCKbSSlvPJdSYgjeqBgjbEspIQRjTNjMe48Q6vs+pbSn9rD3EwCHnFNKzjm72eVyYYzB6Uf4VDCovNrs+fm567obuJS1lDXGtC3eQ7XWaq2ttaUUzjn0TEoJ1Nql/tczhAt7rTVCiFI6jiPnHCH0+vo6DMM18wHbUBaTZ5OtLxC/tRaKxBgbx5ExBoWB5w1c/eO+fm++fPv5o/G78lprIQTGmHNurd3fH2Hjs1CJq6jde+TWWigjTIjb7LOKNznnnGCGwLTWzrllWUBkrXUpRSl1cP4O51Ri+oD3awTmUQhBCJmmqW1bQshR7c91LqV476FPvfd1XVdV1battfY6hSMMCyklY6zdzDln/rOTsHd4XVdjDAimtX7dDMZjF3y3I5xzhr43xmitMcbQ2NM0XXfl0TNIteecc/be930PDVdV1TRNzjmtNYS2LEuM8WOevdXz2Mfw3ip7h0zTNAzDOI4Y42EYjDHWWqWUlPIGzjk5o2H6GGMIISnl3qeEEEqp9/7eHea9d86BJOAEY3y5XCilIYTrq+II75lzzqWUAMNUEkIYY0IIzjljjHOeUjq/PffBhuS7rnt6enp8fKyqyhgDRSmlHGGYBKXUMAx1Xfd937bty8tL0zQg23XZT3IGzZRSdV1rrZdlwRjfq/PnsGOMQghK6bIsf/svaa3lnIcQCCHe+67rEEKnN8EJDD5zznBXg9Sn5G/4F0b698mAfDLQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"增长黑客\"\n        title=\"增长黑客\"\n        src=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png\"\n        srcset=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/63868/increase.png 250w,\n/blog/static/5386809516d54d0978bc47eaf65fdf8d/0b533/increase.png 500w,\n/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png 817w\"\n        sizes=\"(max-width: 817px) 100vw, 817px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>4. <a name=''></a>看不见的心</h2>\n<p>推荐指数 4<br>\n通过两个人的爱情故事阐述了很多经济学的视角，很有意思的一本经济学读物</p>\n<h2>5. <a name='-1'></a>思考，快与慢</h2>\n<p>推荐指数 4<br>\n虽然有些中文翻译增加了阅读上的困难但整体上还是值得阅读的一本书，书中介绍了思维的快思考方式和慢思考方式、常见的思维误区等，阅读之后还是有一定的启发</p>\n<h2>6. <a name='--1'></a>结构性改革-中国经济的问题与对策</h2>\n<p>推荐指数 4.5<br>\n可以结合分析与思考一起阅读，这两本书总结了黄齐帆对中国经济问题的一些长远的思考，对于中国的一些问题通过结构性的方式去优化。黄奇帆通过结构性的梳理问题并且比较创造性的提出解决方案都体现出他对中国特色社会主义制度的深入思考，书读起来特别引人入胜</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null}}},{"node":{"id":"10f3ddbf-187f-554e-88b0-cfec4ae36045","html":"<p>写这个主题是比较忐忑的，自己有一段时间会规划小组内下个阶段的工作目标，现在看当时做的阶段目标其实谈不上技术规划，本文主要结合自身的一些案例总结做技术规划上的一些思考。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQoz2VSQW6DMBD0/w+9VVXUa/qQ9AFRq36ghyRSMZhgSIzXJlONiYlpkUbgnfXsLLtKRBBCwDAM6LoOfd/De79gHMf0Zl4Z5zmj5NXlcsH1eoXWGlVVoWmaVTILlZdKYRb7yyu6MsbgdDolMZ6ZZK1Nbgl+szDjLE4451KMHOMZigQTKEpQMItmMX5P04QYA+pao+vOS1GC9/mwgKLNGGMi6rpeBCnetu0dBt4LnAvQ+gxjLIyZOXbFu9ShAZV7Z5Akk+h6DQ/nWoi8A9ghhF06Mz6Oc07+DctQOBAOhoLlUERYMCLGM/p+i8PhGU2zgUgFkdudf+Sr3OLxeExidFqux4yQBLV+w37/hO/vlyTo/fQvV+W22G6ecrkadOB9RAgthmELrTew9hUiP4vgymFebDorF/uxW7NDEU76C8AnbrcPiNh7fC34C+UwAiFBmhIuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png\"\n        srcset=\"/blog/static/19e59b526f6f15361b687635a5717660/63868/plan.png 250w,\n/blog/static/19e59b526f6f15361b687635a5717660/0b533/plan.png 500w,\n/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png 1000w,\n/blog/static/19e59b526f6f15361b687635a5717660/aa440/plan.png 1500w,\n/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png 1747w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>自身案例分析</h2>\n<p>在做下个阶段目标的时候经常会有如下的一些疑问:</p>\n<ol>\n<li>下个阶段做什么(来源)</li>\n<li>怎么做(过程)</li>\n<li>完成的总结</li>\n</ol>\n<p>在反思自己之前的制定目标的时候有以下的问题:</p>\n<ol>\n<li>多数在关注1阶段而弱化了2，3阶段的思考，这样会导致在下一次做规划的时候还是很挣扎跳不出这个圈。</li>\n<li>没有一个完整的全局视角 这个导致我的一个疑问是业务侧做这个为啥，看着很分散</li>\n<li>没有一个长期的视角，导致阶段性目标不明确</li>\n</ol>\n<h3>下个阶段做什么(来源)</h3>\n<p>在这个阶段我的思路是关注业务侧的规划文档，但是在看业务侧的文档会存在以下的\"问题\":</p>\n<ul>\n<li>某些目标比较泛并不能准确的落实到技术目标上 比如收入增加XXX</li>\n<li>可以收集到下个阶段的业务目标比如需求A，需求B，需求C，但是A，B，C有可能之间关联性不大，当然这可能跟当前的业务现状有关</li>\n</ul>\n<p>虽然通过看业务侧文档可以整理出下个阶段的业务目标，但是每次都感觉没有所谓的抓手，有种隔靴搔痒的感觉，其实从现在来看之前的我，可以看出很多思考上不足的点，才导致每次都很痛苦的想下个阶段要做啥。\n在思考上可以有两个思路:</p>\n<ol>\n<li>从上往下视角 从全局视角看不同模块的关系，建立联系和目标</li>\n<li>从下往上视角 为什么会有这样的关系，基于已有的关系是否会衍生出新的关系，在新的模块上能做什么</li>\n</ol>\n<h4>下个阶段业务目标</h4>\n<p>在梳理业务目标的时候可以从以下几点考虑:</p>\n<ol>\n<li>熟悉业务的现状  熟悉业务现状才能有目的性的查看业务侧的规划来反推出更多的思路来推动业务目标，比如\n<ul>\n<li>后续会发力营销但是现有的营销页面并不支持配置化那是否可以尝试推动业务侧一起建立配置平台</li>\n<li>业务侧要对存量的业务有一系列的优化，存量的业务还是老旧的技术栈，那么提前对技术栈进行迁移和统一</li>\n</ul>\n</li>\n<li>多与业务侧沟通，建立正向的连接  可以跟业务侧一起建立双向的规划分享，这样互相都比较了解对方做事的思路，团队每人也更有全局的意识</li>\n<li>数据思维 关注产品数据，业务数据促进对业务的反思，可以养成一个思维习惯就是产品的数据怎么能映射到我当前开发的具体业务上</li>\n</ol>\n<h4>下个阶段技术目标</h4>\n<p>在梳理技术目标可以从以下几点考虑:</p>\n<ol>\n<li>流程优化 梳理业务开发的流程针对性解决，比如:\n<ul>\n<li>规范 技术栈统一，代码规范，开发上线流程，Code Review(思考中，如何建立有效的Code Review)</li>\n<li>质量 性能，监控</li>\n<li>效率 通过工具、库来实现提效，已有业务的抽象组合</li>\n</ul>\n</li>\n<li>了解团队成员能力和诉求 可以针对不同阶段的团队成员制定不同的规划，比如工作年限相对短的可以多从一些复杂的业务中成长，年限久的赋予更多的自由度，实现自治</li>\n<li>技术储备(分享输出等) 技术储备可以为团队输入新的血液，分享和输出可以建立团队的整体意识和对外的口碑</li>\n</ol>\n<h3>怎么做(过程)</h3>\n<ul>\n<li>里程碑 每个目标阶段要有里程碑，比如做页面性能监控:\n<ol>\n<li>已有业务接入性能监控</li>\n<li>主要业务首屏优化达到XXX</li>\n<li>性能优化总结，推动上下游进行优化，新技术探索</li>\n</ol>\n</li>\n<li>可调整 在具体实现上因为优先级或者当前目标实现的结果不理想及时调整当前或者下个阶段目标</li>\n<li>多阶段完成 一个大的目标可以拆分成多个子目标在规划的多个阶段落实，需要建立多个目标之间的关系，保证规划的整体性</li>\n</ul>\n<h3>完成的总结</h3>\n<p>这个阶段可以结合上面的两个阶段来看:</p>\n<ul>\n<li>完成了哪些业务目标，技术目标，产生了哪些收益</li>\n<li>过程中产生了哪些问题，是否在下个阶段可以进行优化和避免(下个阶段目标)</li>\n<li>下个阶段目标调整</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844904201160491016\">技术管理- 怎样做好技术规划</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null}}},{"node":{"id":"2aa1bc1b-e5e4-51e4-950f-0ffc8b5a36cd","html":"<p>使用<a href=\"https://icantunderstand.github.io/blog/webview-store\">缓存</a>和<a href=\"https://icantunderstand.github.io/blog/cross-platform-offline\">离线包</a>可以一定程度上提前页面展示的时间，但是页面的展示依赖具体的数据加载，Webview在加载h5的时间线可以做如下简化:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAa0lEQVQY05WPSwrAIAxEvf9RjSL4w7hJmcAUkW66eEw+JhmDqtrJ3tvGGJZztlqr03u3UoqTUvKaiFhrzXXO6XOYDwhu1lq+FA9O5bG7TiMgfDnEQrhCDmWOHlyhTmX/dUjb+OJJjPGXMn4AApw0UHe2ZIsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png\"\n        srcset=\"/blog/static/0ce30849a4870d72a825560fed237688/63868/timeLine.png 250w,\n/blog/static/0ce30849a4870d72a825560fed237688/0b533/timeLine.png 500w,\n/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png 1000w,\n/blog/static/0ce30849a4870d72a825560fed237688/aa440/timeLine.png 1500w,\n/blog/static/0ce30849a4870d72a825560fed237688/fd8a5/timeLine.png 1659w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Webview初始化 Webview在首次初始化会占用相对长的时间进行初始化(可以通过Webview池的方式来优化)</li>\n<li>DNS TCP TLS 建立与服务器的连接，可以通过html的预加载标签来优化(dns-prefetch, preconnect)</li>\n<li>数据请求响应阶段 在解析响应的html的时候会解析到js代码下载并执行发起数据请求(可以通过服务端渲染方案优化但是也增加了服务端成本需要考量)</li>\n</ul>\n<p>从上面的分析可以看出在发起数据请求之前通过Native并行提前完成数据的读取就能换取页面提前展示给用户的时间，下面介绍一种可能的预取方案。</p>\n<h2>实现方案</h2>\n<p>本方案通过配置维护了对应url下需要预取的配置，在初始Webview的时候客户端并行完成数据获取，最后通过jsbridge获取数据。</p>\n<h3>预取配置</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 775px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA60lEQVQoz3WRx6rFMAxE8/8/l1VIyCINQnrvVZcjMOQt3mKwNZJmBts6jkPAdV1ynqfeOQ1M/4v/eGAhtO+7FEUh8zzLfd9/lujDGXxNvzxzKrhtm4zjKHVdyzAMKvpNOE2TdF0nfd8rMIdnz3AADXiL4SiKJMsyieNYkiSRdV3VETGMlmVRIwzLstRE8OzCA3jmLNR93xfXdcXzPHEcR+8MB0Ggok3TSBiG8jyP2LYtaZqqMTV30hGCWattW8nzXIVIiBNNUuBcVZUKmkTU7/tq/eX5A01o3hARBHD5/qbhOJlj3rwhtembvR/OZxjL3yVM2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n        srcset=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/63868/config.png 250w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0b533/config.png 500w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png 775w\"\n        sizes=\"(max-width: 775px) 100vw, 775px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>配置侧 提供配置能力，需要对配置有准入审核，管理(下线，上线)</li>\n<li>服务侧 根据配置提供获取配置服务</li>\n<li>Native 动态拉取配置更新本地数据</li>\n</ul>\n<h3>加载流程</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 923px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 115.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y42VV47DMAxEff/T5Su9996c3hg8AmPIJWUBQo5EDodDShvdbjcL7Xq9Jutms7HdbudrHMd2v9+T808WZcEUcDqdbL1e236/dwM0m7AIPCpi9ng87HK5OBAMD4eDf79er5xvDrAoIyCLxcKGw6F1Oh3r9Xo2m81sPp/b+Xz+WnqUzcQfAJSr0o/Hoy2XS2s2mw4M20+gCUNK3G63zqrRaHgwbCifFQ1hiA/2E5AgAgaDgYPV63X/DSAsp9OpJ+r3+w7+FZBDhF+tVg4MS8oMk6EpySaTyW+GHNIIldRutxOtxJBvZhHD9y8NYQi7VqvloLASIAnYH41Gv0sOy6KbdBlgAkNAtO12uynArEXhzZCGBAHMHoHscYaGJPu7y4AgOkwomd9iCEi5XLbxeOw6sq84WYqhACm7Vqu5Xgy3mLAPczRkItQcpIC9GporGSfAYMI3TFgrlYpVq1VnSdn44ocMpVLJ9/BLdZnssIQZAWKoc5Jwzh6JYIoP7NhntCJ1Byc9Agx1eMWQg2B0pft86w0gEYBIkHscyBo+qhpggjSf2bEhBpYkLXy+cAxNDdPQMwXhTWEFkB7kGBYNavgSUTKPBJJobMQwBfjJwpECCK0wWOqd1A1LSv4HUBrSZZrGM4YEaAk7JCj8J/UNkJLpLivsns9nTmtuyhvVnukgKd1z8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载流程\"\n        title=\"加载流程\"\n        src=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n        srcset=\"/blog/static/b70892349e045d91bae6d4a918265e42/63868/prefetch.png 250w,\n/blog/static/b70892349e045d91bae6d4a918265e42/0b533/prefetch.png 500w,\n/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png 923w\"\n        sizes=\"(max-width: 923px) 100vw, 923px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在加载h5的时候</p>\n<ul>\n<li>Native会在初始化Webview的时候并行的根据配置加载数据(动态参数根据页面url和配置完成映射)</li>\n<li>Webview展示的时候触发jsbridge请求，普通请求jsb与prefetch jsb的区别在于prefetch有一层从本地获取数据的步骤和数据的重置操作。</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":7,"pageCount":15,"additionalContext":{"pageAllCount":90}}},"staticQueryHashes":[]}