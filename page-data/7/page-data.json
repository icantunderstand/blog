{"componentChunkName":"component---src-templates-index-js","path":"/7","result":{"pageContext":{"pageAllCount":88,"group":[{"node":{"id":"c80ebb07-77d9-57e3-ba47-f4deb2833ddd","html":"<p>页面开发中数据在组件之间共享和同步是一个比较常见的问题，通过状态管理可以实现清晰的数据流和组件状态同步能一定程度上减少业务的复杂度。本文主要对比Redux和Mobx的实现细节来深入状态管理的技术实现，这样在做技术选型的时候能有一定的考量</p>\n<h2>1. <a name='reduxhttps:github.comreduxjsredux'></a><a href=\"https://github.com/reduxjs/redux\">redux</a></h2>\n<h3>1.1. <a name='redux'></a>redux的思路</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQ4y32U666CQAyEef9HxIAxBgLeuIqCQs3XZMjKufxolu2205l2l6jrOsPatrX7/W7P59Pqura+761pGpumyb85ZyUW3ziOvm4tqqrKbrebsRIM4OVycYDr9Wqv18v9fFOIuH8BYQUABiP2RVFYlmUOwB7wsiwdjH0IuAWOYIBT0gEF7Hg8OivA8COXBOKV/BvLSE4C3++3PR4PZwI7gCVfclnxhUxD4Ch0Yurh6XRaexqeU1ispe6L4Zb+PM9eHel8S6LOUUBB2qE2hAWjMBggXRekDcPgbGCptuhc/d7KXgEJBoQrxETp3/l8XpPFlCK0gxj5Zc4wRAcARkx4t9t5InuGwcCIow0Uwdjv93s7HA6WJIkTcoZIIgBASV2WxRloQJKOAvpHEXLCFqw9DK8KRjISSJZPzzHPcy8sUJhL8tc9hJVMPhgBgJw4jtenyPCIg8iPKf/1JvFTHWZpmnqv9GPYxoX38ANpAjjKavX2CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"redux实现思路\"\n        title=\"redux实现思路\"\n        src=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png\"\n        srcset=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/63868/redux.png 250w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/0b533/redux.png 500w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png 1000w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png 1189w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>redux通过全局的store来统一管理数据，通过订阅机制实现数据变更的通知</li>\n<li>redux引入函数式编程的概念，约定通过action来触发全局store的更新，单向数据流能一定程度上降低业务的复杂度</li>\n</ol>\n<h3>1.2. <a name='redux-1'></a>redux简单使用</h3>\n<pre><code>import { createStore } from 'redux';\nconst action_type = 'test';\nconst init = {\n  count : 1,\n}\nconst reducer = (state = init, action) => {\n  switch(action.type) {\n    case action_type: {\n      return { count: state.count + 1  }; \n    }\n    default: {\n      return state;\n    }\n  }\n}\nconst store = createStore(reducer);\nstore.subscribe(() => {\n  console.log(store.getState()); // { count: 2 }\n})\nstore.dispatch({\n  type: action_type,\n})\n</code></pre>\n<ul>\n<li>redux通过createStore(reducer, preloadState, storeEnhancer)函数来生成状态管理的store.</li>\n<li>store提供getState()来获取当前的状态</li>\n<li>dispath(action)更新应用的状态</li>\n<li>subscribe(listener)来订阅状态变更时触发的事件.</li>\n</ul>\n<p>通过上面的分析可以看出redux实现了一套发布订阅的机制来实现状态的变更和通知,下面将深入redux的源码来了解redux的具体实现</p>\n<h3>1.3. <a name='redux-1'></a>redux源码解析</h3>\n<p>以下源码部分基于<a href=\"mailto:redux@4.0.1\">redux@4.0.1</a>,为了整体介绍redux的整体流程,只保留了关键的部分并且进行了一部分修改.</p>\n<h4>1.3.1. <a name='createStore'></a>createStore</h4>\n<p>createStore(reducer, preloadedState, enhancer)接受reducer,状态初始值,store增强函数来生成应用的store</p>\n<pre><code>export default function createStore(reducer,preloadedState, enhancer) { \n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  // 如果存在enhancer函数,通过enhancer函数创建store\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  // 获取当前应用的状态\n  function getState() {\n    return currentState;\n  }\n  \n  // 订阅当状态更新的监听函数.\n  // 返回取消当前监听函数的方法,用于取消订阅对应监听函数\n  function subscribe(listener) {\n    nextListeners.push(listener);\n    return () {\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    }\n  }\n\n  // 执行action的变更并且执行监听函数\n  function dispatch(action) {\n    currentState = currentReducer(currenState, action);\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i &#x3C; listeners.length; i++) {\n      const listener = listeners[i]\n      listener();\n    }\n    return action;\n  }\n\n  return {\n    getState,\n    cubscribe,\n    dispatch,\n  }\n}\n</code></pre>\n<h4>1.3.2. <a name='combineReducer'></a>combineReducer</h4>\n<p>combineReucer(reducer)可以将多个reducer函数组合起来,接受action并改变状态.combineReducer解决了将所有的更新逻辑写到一个文件的问题</p>\n<pre><code>export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  // 生成finalReducers\n  for (let i = 0; i &#x3C; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  //  返回的函数是实际调用creaStore()的第一个入参,这样就能接受action来改变应用的状态了\n  return function combination(state = {}, action) {\n\n    let hasChanged = false;\n    const nextState = {};\n    // 对action执行所有的传入的reducer函数\n    for (let i = 0; i &#x3C; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]  // 对应reducer之前的state\n      const nextStateForKey = reducer(previousStateForKey, action) // 对应reducer接受action之后的状态\n      nextState[key] = nextStateForKey  // 将处理过后的值存储\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 如果改变返回nextState, 否则返回之前的状态\n    return hasChanged ? nextState : state\n  }\n}\n</code></pre>\n<h4>1.3.3. <a name='applyMiddleware'></a>applyMiddleware</h4>\n<p>applyMiddleware是redux提供对外部进行扩展的途径,通常情况下dispacth只能接受一个对象来对状态进行修改,通过添加不同的中间件,对dispatch进行增强,可以使它接受更多的类型(function, promise)和实现更多的功能, 下面先从一个使用中间件的实例来了解appleMiddleware到底做了什么.</p>\n<pre><code>function thunkMiddleware({ dispatch, getState }) {\n  return  next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState);\n    }\n\n    return next(action);\n  };\n}\nconst store = createStore(reducer, { count: 1 }, applyMiddleware(thunkMiddleware))\nstore.subscribe(() => {\n  console.log(store.getState());\n})\nstore.dispatch(() => {\n  console.log(1);\n  return { type: action_type };\n});\n</code></pre>\n<p>通过上面的例子,dispatch就能接受函数类型并且执行对应的函数,下面来了解appleMiddleware的源码是怎样实现的.applyMiddleware返回的是store的enhancer,在createStore的代码部,在传入enhancer的时候,执行的是enhancer(createStore)(reducer, preloadedState).</p>\n<pre><code>function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    // ..args 是传入的reducer, proloadedState 来生成store\n    const store = createStore(...args);\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n\n    // 将middlewareAPI注入到每个middleware\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    // next的注入,将多个中间件关联,返回的dispatch已经被增强\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre>\n<h4>1.3.4. <a name='reduxreact'></a>redux结合react</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 430px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 148%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTklEQVRIx6WVV4sCMRSF5///GNFnH0QRFLtYsVes2HvL8l24wyi6zuwGws1kkpNzy0msy+VivvXz+Sz2drt9XHO9XmWd5QZMAbvdrmm1WqbdbovVcbPZNJPJREAtt+yOx6MA0O73u9jH4yFjOqCs8wQIQwXUeW0wde2yAnY6Hdm82WxMpVKxWcH0T4DK8F0jHJ4AsY1Gw/R6PTMcDk2xWJTvwWAgBzHvOikKejgczHK5lPLx+/0mlUrJv9VqZa+x3NShkyksaLAjlsSPOV3jiSH2dDpJluv1ugBqQT8x1IlvXdfCigxvt1tbPbrG0oUqLU6k61itbtrtduJyIBAwpVJJwImtYtgM9/u9WSwW4gZBpjNmToNerVal3shoOp2Wb6cc7SwDxmQ0GpWF8XjcJJNJCXwikTD5fF7cc1WHuDSfz00oFBLAcDhsYrGYiUQiJpfLiSI4HUCY4fJsNrPZsxcgVGRnmRhQoADAKJPJCNNCoSAH4BrrAKQOYYodjUYyZj/WToomBiZszmazwhBXx+OxbEB6ZPZdo4wIjyRFAQmo0w3uN1zjH2HBavCRnh6IZzr3JD0FZTNd77lXlcCUFgwGJb40il1Ly3ot2t8KWjsHwZYEOWv0X9JTLb+VntvLQdnQyuWyZPpflwMu6vXl8/mkzPT6Uvl5umDRLlmlE0Pqst/vi63Vat5fPTZ+an9+U/jWax+XYUocsZ6fUYBo6/VaMowA9Dp70rIbQMqFhwklkRg6wFgURZF7fqSm06lIUq1zzEGe61Dl+K6r3n8A1lgA1sQPbKMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-redux\"\n        title=\"react-redux\"\n        src=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n        srcset=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/63868/reactRedux.png 250w,\n/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png 430w\"\n        sizes=\"(max-width: 430px) 100vw, 430px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact-Redux的作用是将React组件和Redux绑定，React组件可以通过react-reudx完成数据的获取和更新。其中connect函数就是这个功能，通过下面的代码可以看出connect主要是从redux或者context中获取属性通过高阶组件的方式返回包裹组件。</p>\n<pre><code>const Connect = _Connect as ConnectedComponent&#x3C;\n  typeof WrappedComponent,\n  WrappedComponentProps\n>\nConnect.WrappedComponent = WrappedComponent\nConnect.displayName = ConnectFunction.displayName = displayName\n\nif (forwardRef) {\n  const _forwarded = React.forwardRef(function forwardConnectRef(\n    props,\n    ref\n  ) {\n    // @ts-ignore\n    return &#x3C;Connect {...props} reactReduxForwardedRef={ref} />\n  })\n\n  const forwarded = _forwarded as ConnectedWrapperComponent\n  forwarded.displayName = displayName\n  forwarded.WrappedComponent = WrappedComponent\n  return hoistStatics(forwarded, WrappedComponent)\n}\n</code></pre>\n<h2>2. <a name='Mobx'></a>Mobx</h2>\n<p>mobx将响应式编程的概念引入到状态管理的实现上，通过观察者模式实现组件的更新。相比redux他的优势在于:</p>\n<ol>\n<li>在组件更新上性能更好 redux通过发布订阅的模式会在所有的组件上进行Prop的脏检查，mbox通过proxy依赖收集能更精确的控制组件的更新</li>\n<li>长期维护上存在一定优势 mbox基于proxy内部维护了更新的机制，redux需要通过mapStateTpProps来主动告知订阅的属性存在一定维护成本</li>\n</ol>\n<h3>mobx背景介绍</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQY00WQ3UrDQBSE8/6PIPgcuRItBqEgXpSQWqvGRpsfgrvFppvdPdl8ktTiwDA383M4Udu2KK05VVsOmwd+ioyyLFHqm7us4ermheW2pakrlFK8lk8ss5ha5RTFF9VuR54kpHFMk6ZE3ntOxtDtn9HZArNfIyI4a0k2Lde3bzy+K8Ig9H3PZ7sm/bhHH2tEBkzXcchz6tWKY10T8QcJI1prvARkGBjHERhhDEAghDPFD3gnZ/V+9joRhtkP0RS8hKdF5yzW2vkaYwzG9PTWMr1mHvQe59w/rZ310vMLZFMvcH+PNUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx\"\n        title=\"mobx\"\n        src=\"/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png\"\n        srcset=\"/blog/static/1f17685984e130f52da0a236b2dcae30/63868/mobx.png 250w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/0b533/mobx.png 500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png 1000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/aa440/mobx.png 1500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/e8950/mobx.png 2000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png 3445w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Observable  定义可观察的值，当observable值变化的时候会触发Derivations</li>\n<li>Derivations Derivations主要为Computed values和Reactions，可观察值的改变会触发对应的Derivations触发</li>\n<li>Actions actions触发Observable值的更改进而触发Derivations</li>\n</ul>\n<h3>mobx简单使用</h3>\n<pre><code>import { observable } from \"mobx\";\nimport { observer } from 'mobx-react'\n// 定义一个可观察的值\nvar timerData = observable({\n  secondsPassed: 0\n});\n// 定义了观察者 当secondsPassed发生变化的时候会触发组件更新\nconst Timer = observer(({ timerData }) =>\n    &#x3C;span>Seconds passed: { timerData.secondsPassed } &#x3C;/span>\n);\nsetTimeout(() => { timerData.secondsPassed = 33 }, 2000)\n\nfunction App() {\n  return &#x3C;Timer timerData={timerData} />\n}\n</code></pre>\n<h3>mobx源码解析</h3>\n<p>使用mobx实现组件更新的方式如下:</p>\n<ul>\n<li>mobx实现创建Observable值和触发Derivations</li>\n<li>mobx-react实现对react组件的封装，创建基于组件的Derivations从而在对应的Observable值修改的时候完成组件的更新</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 852px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVQ4y62Ta8uCQBCF/f9/rehD+EEysjAzKtO8ZdeJZ2CkZHkvkDDMMmf3nDM7q3e9XuWb4X2d8HK5iCtsw38xp0PX4b9gfcvn8/kjDLzdbtJ13QdGzTBI27bVOlkdNk0ju91O8jzXsDVEdV1LHMeSZZnW0jSV/X6vWFVVstlstH48HmW73ep+ryxLgfR+v6sySuv1Wk6nk+bFYtE7OBwOEgSBFEUhq9VKoiiS5/OpROxBxGOBA4IDZGoIPB4PVccFAmDU7cOMYXSGMc8uGjJaGk6N9tiIQw4ul0t1RiRJoqRgRP9sTA0VPtckGQKt+b4vk8lEptOphGGoRHZdOhRzhxoOyabmcouz+XyumaE43yEXPxqNZDwey2w20xaN8P39kc0Njt+d9e8QAEdMDWLaYqOL7Ke/yrI3vKchwW+kQ4cvCws6rZketdUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx原理\"\n        title=\"mobx原理\"\n        src=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n        srcset=\"/blog/static/28f13754dd42663bf2a3b517779e126f/63868/mobxlogic.png 250w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/0b533/mobxlogic.png 500w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png 852w\"\n        sizes=\"(max-width: 852px) 100vw, 852px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>mobx生成Observable</h4>\n<p>Observable会根据传入的值类型包装生成代理，在对观察值获取和设置的时候都是调用代理的方法</p>\n<pre><code>// mobx暴露的observable调用的入口函数 \nfunction createObservable(v: any, arg2?: any, arg3?: any) {\n  // @observable someProp;\n  if (isStringish(arg2)) {\n      storeAnnotation(v, arg2, observableAnnotation)\n      return\n  }\n  // 如果已经是可观察值忽略\n  if (isObservable(v)) return v\n  if (isPlainObject(v)) return observable.object(v, arg2, arg3)\n  // 这里省略了其他数据类型的包装 \n  // 调用工厂方法对不同类型的值包装成可观察值\n  if (typeof v === \"object\" &#x26;&#x26; v !== null) return v\n  // anything else\n  return observable.box(v, arg2)\n}\n// 观察值封装的工厂方法\n// 省略若干其他类型的封装\nobject&#x3C;T = any>(\n    props: T,\n    decorators?: AnnotationsMap&#x3C;T, never>,\n    options?: CreateObservableOptions\n): T {\n    return extendObservable(\n        globalState.useProxies === false || options?.proxy === false\n            ? asObservableObject({}, options)\n            : asDynamicObservableObject({}, options),\n        props,\n        decorators\n    )\n},\n//extendObservable通过创建一个代理(管家)来代理属性的访问和设置，这里关注在没有proxy设置的场景asObservableObject在内部创建了代理\nconst adm = new ObservableObjectAdministration(\n    target,\n    new Map(),\n    String(name),\n    getAnnotationFromOptions(options)\n)\n在ObservableObjectAdministration内部维护了维护了获取属性的get和set方法\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAChElEQVQ4y5WT3Y7bNhCF/RjdtSj+ir+iJEv22t6sHaQ3RZs0RVr0/R/lK6RNFynaAu3FhyGH4JkZ4nB3mArHy51yeSbeboT7jXK9ki4X6vkZF8tG5wMpBvo+4ENE2rjlrY8Yt+YSsm3ZiabFGktZFsbzvJEPI2ka6E8zaR7Jy0ide4Y5M86JXBN+6CnHiVDXWOnnni4ZdkopWiVpfaYOgToVQt/T7L9DiD1t29DKFYGQgkYIRCuQUmxnQjRIJbZzqVp2RhvGUAku0bpMGGbiMJOnhS5ERLNear8iaN/W7V/yf8adlBItFVoZpDJo614xFqnUq0jb/md2xmuEVAgpt9GFbDek1v9L6E3QlZ5uesEMI3oZ6E4Ldp7oco9Smv3DA83jI83+kaYRiK80e/G2X9dbfh25Gw7E60fc0wX7ciLf78TrFTMNmKkSDzN5edre1SWLdop1Kt9bXDLYqOnyGtfnUuxsrvjle8w4Y5+P6MtMvFwoL3fK+UQ6ROKU8H2gK5YwuE0gTo44uk14ZS2ktGTnS8KWBR16dM2Yw4CqBRU8Nlh0pzCdwiWH6V47McFgNxzWG1y22GwxnWZXa6AcJnQOtH3CTBlXI6FUQh2QqSPUcRu7zAu6JPRUMd6j/YDzaWtEDT3Gd+yUVNRauLxMPF0raZnpzwvjuyuhFsbriTJlfLa4aFBGbZ5r23+206sPlab0kTwVfC3EqRJKxjqP85m16P5hz+PDnmYzuvhXNsEVZzr8MDJcjkz3Zw6nnvPtyPzuiX6MxNqRJ4+xGrF2s937u/HfBNdN7xNDqsiQuX+48+W3j3z6/AM///Ijn7/8xK+/f+L24T1dGUjjQhqm7Wt+K/gHXJGxoBKDACIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setAndGet\"\n        title=\"setAndGet\"\n        src=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png\"\n        srcset=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/63868/setAndGet.png 250w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/0b533/setAndGet.png 500w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png 1000w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png 1322w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子对观察值进行修改的时候，会最终走入observablevalue的更新值并且触发Derivations</p>\n<pre><code>setNewValue_(newValue: T) {\n  const oldValue = this.value_\n  this.value_ = newValue\n  this.reportChanged()\n  if (hasListeners(this)) {\n      notifyListeners(this, {\n          type: UPDATE,\n          object: this,\n          newValue,\n          oldValue\n      })\n  }\n}\nexport function endBatch() {\n  if (--globalState.inBatch === 0) {\n      // 触发Derivations\n      runReactions()\n      // 省略若干逻辑\n      globalState.pendingUnobservations = []\n  }\n}\n</code></pre>\n<h4>mobx-react生成Derivations</h4>\n<p>这里主要从包装函数式组件来看Derivations的生成过程，函数式组件的封装方法主要做了:</p>\n<ul>\n<li>\n<p>定义更新逻辑并与生成的Reaction绑定</p>\n</li>\n<li>\n<p>通过运行函数 将observable值与Reaction绑定</p>\n<pre><code>export function useObserver&#x3C;T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    const [, setState] = React.useState()\n    // 定义刷新组件逻辑\n    const forceUpdate = () => setState([] as any)\n    const reactionTrackingRef = React.useRef&#x3C;IReactionTracking | null>(null)\n    if (!reactionTrackingRef.current) {\n        // 创建Derivations 在设置observable的时候会触发相应的newReaction\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n          if (trackingData.mounted) {\n            forceUpdate()\n          } else {\n              trackingData.changedBeforeMount = true\n          }\n        })\n    }\n    const { reaction } = reactionTrackingRef.current!\n    let rendering!: T\n    let exception\n    // track通过运行组件 走入组件的get方法 将reaction跟observable值关联起来\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n    return rendering\n}\n</code></pre>\n</li>\n</ul>\n<p>这样当observable更改的时候会触发对应的Reaction执行从而达到组件刷新的目的</p>\n<p>在业务开发中最开始引入状态管理是为了实现组件之间的状态共享，而使用Redux或者Mobx是引入不同的编程范式来实现这种共享的行为。不同的编程范式能给予项目一定的约束从而实现业务开发的规范。但是范式的引入也一定程度上增加了项目的复杂度，比如redux的依赖管理、中间件概念、mobx跟踪性较弱的更新逻辑等。在考虑引入具体方案的时候应该考虑整个项目的现状和成本，是不是有更轻量化的实现，比如React Hooks。</p>\n<h2>3. <a name=''></a>参考</h2>\n<p><a href=\"https://tech.youzan.com/mobx_vs_redux/\">我为什么从Redux迁移到了Mobx</a><br>\n<a href=\"https://github.com/reduxjs/react-redux\">react-redux</a><br>\n<a href=\"https://github.com/reduxjs/redux\">redux</a><br>\n<a href=\"https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\">Becoming fully reactive: an in-depth explanation of MobX</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/85720939\">mobx 源码解读（一）：从零到 observable 一个 object 如何</a></p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null}}},{"node":{"id":"9cf87650-c261-51d7-b150-77bfa90feef5","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#-\">深度思考-不断逼近问题的本质</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#12\">大败局(1 2)</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#--1\">增长黑客-如何低成本实现爆发式成长</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#\">看不见的心</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li><a href=\"#-1\">思考，快与慢</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li><a href=\"#--1\">结构性改革-中国经济的问题与对策</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>这里记录下自己读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>推荐指数0 - 5</p>\n<h2>1. <a name='-'></a>深度思考-不断逼近问题的本质</h2>\n<p>推荐指数 0.5<br>\n书名与内容严重不符的一本书，内容是作者的个人自传性质，在陈述的过程中并没有很好的结合书名进行深度解读，作为自传的话推荐指数很一般</p>\n<h2>2. <a name='12'></a>大败局(1 2)</h2>\n<p>推荐指数 4.5<br>\n大败局记录了多个企业的发展历史，从中能看到许多的无奈，作者的叙述也比较引人入胜，商业的发展历史很有意思，有机缘巧合也充满着时代的背景。</p>\n<h2>3. <a name='--1'></a>增长黑客-如何低成本实现爆发式成长</h2>\n<p>推荐指数 4<br>\n增长黑客主要介绍一个产品实现快速增长的方式，可以从多个角度去了解产品生命周期的一些行为，本书整体大纲如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 817px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 174.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAIAAAAblL1PAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVRIx5WV+26cOhCH8/7P0r5C1UdIJRQpkUo4sMYB4wv4fqUNcw7ZJXTVM38gG/bzzPxmxvuw3jUppdb6T18f/vQhpRRjRAhhjP8fnHOWmxFCOOd/C+ecnXMhBFj3fT8MA6xjjDnne7BzbhxHY8z1WTHGtm3f3t729ydwKQXOTimFELz3KSUppVIKY0wpvRc2wPBclkUI4b2HbdM0n2U/97xbCIFzboxpmkYpBZmnlO55LqWs6+q9n+eZUtq2bdd1hJB5noUQ8zzDDz7g4OwyvRmtGWPTNAkhQHPOOaillCKbSSlvPJdSYgjeqBgjbEspIQRjTNjMe48Q6vs+pbSn9rD3EwCHnFNKzjm72eVyYYzB6Uf4VDCovNrs+fm567obuJS1lDXGtC3eQ7XWaq2ttaUUzjn0TEoJ1Nql/tczhAt7rTVCiFI6jiPnHCH0+vo6DMM18wHbUBaTZ5OtLxC/tRaKxBgbx5ExBoWB5w1c/eO+fm++fPv5o/G78lprIQTGmHNurd3fH2Hjs1CJq6jde+TWWigjTIjb7LOKNznnnGCGwLTWzrllWUBkrXUpRSl1cP4O51Ri+oD3awTmUQhBCJmmqW1bQshR7c91LqV476FPvfd1XVdV1battfY6hSMMCyklY6zdzDln/rOTsHd4XVdjDAimtX7dDMZjF3y3I5xzhr43xmitMcbQ2NM0XXfl0TNIteecc/be930PDVdV1TRNzjmtNYS2LEuM8WOevdXz2Mfw3ip7h0zTNAzDOI4Y42EYjDHWWqWUlPIGzjk5o2H6GGMIISnl3qeEEEqp9/7eHea9d86BJOAEY3y5XCilIYTrq+II75lzzqWUAMNUEkIYY0IIzjljjHOeUjq/PffBhuS7rnt6enp8fKyqyhgDRSmlHGGYBKXUMAx1Xfd937bty8tL0zQg23XZT3IGzZRSdV1rrZdlwRjfq/PnsGOMQghK6bIsf/svaa3lnIcQCCHe+67rEEKnN8EJDD5zznBXg9Sn5G/4F0b698mAfDLQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"增长黑客\"\n        title=\"增长黑客\"\n        src=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png\"\n        srcset=\"/blog/static/5386809516d54d0978bc47eaf65fdf8d/63868/increase.png 250w,\n/blog/static/5386809516d54d0978bc47eaf65fdf8d/0b533/increase.png 500w,\n/blog/static/5386809516d54d0978bc47eaf65fdf8d/98314/increase.png 817w\"\n        sizes=\"(max-width: 817px) 100vw, 817px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>4. <a name=''></a>看不见的心</h2>\n<p>推荐指数 4<br>\n通过两个人的爱情故事阐述了很多经济学的视角，很有意思的一本经济学读物</p>\n<h2>5. <a name='-1'></a>思考，快与慢</h2>\n<p>推荐指数 4<br>\n虽然有些中文翻译增加了阅读上的困难但整体上还是值得阅读的一本书，书中介绍了思维的快思考方式和慢思考方式、常见的思维误区等，阅读之后还是有一定的启发</p>\n<h2>6. <a name='--1'></a>结构性改革-中国经济的问题与对策</h2>\n<p>推荐指数 4.5<br>\n可以结合分析与思考一起阅读，这两本书总结了黄齐帆对中国经济问题的一些长远的思考，对于中国的一些问题通过结构性的方式去优化。黄奇帆通过结构性的梳理问题并且比较创造性的提出解决方案都体现出他对中国特色社会主义制度的深入思考，书读起来特别引人入胜</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null}}},{"node":{"id":"10f3ddbf-187f-554e-88b0-cfec4ae36045","html":"<p>写这个主题是比较忐忑的，自己有一段时间会规划小组内下个阶段的工作目标，现在看当时做的阶段目标其实谈不上技术规划，本文主要结合自身的一些案例总结做技术规划上的一些思考。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQoz2VSQW6DMBD0/w+9VVXUa/qQ9AFRq36ghyRSMZhgSIzXJlONiYlpkUbgnfXsLLtKRBBCwDAM6LoOfd/De79gHMf0Zl4Z5zmj5NXlcsH1eoXWGlVVoWmaVTILlZdKYRb7yyu6MsbgdDolMZ6ZZK1Nbgl+szDjLE4451KMHOMZigQTKEpQMItmMX5P04QYA+pao+vOS1GC9/mwgKLNGGMi6rpeBCnetu0dBt4LnAvQ+gxjLIyZOXbFu9ShAZV7Z5Akk+h6DQ/nWoi8A9ghhF06Mz6Oc07+DctQOBAOhoLlUERYMCLGM/p+i8PhGU2zgUgFkdudf+Sr3OLxeExidFqux4yQBLV+w37/hO/vlyTo/fQvV+W22G6ecrkadOB9RAgthmELrTew9hUiP4vgymFebDorF/uxW7NDEU76C8AnbrcPiNh7fC34C+UwAiFBmhIuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png\"\n        srcset=\"/blog/static/19e59b526f6f15361b687635a5717660/63868/plan.png 250w,\n/blog/static/19e59b526f6f15361b687635a5717660/0b533/plan.png 500w,\n/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png 1000w,\n/blog/static/19e59b526f6f15361b687635a5717660/aa440/plan.png 1500w,\n/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png 1747w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>自身案例分析</h2>\n<p>在做下个阶段目标的时候经常会有如下的一些疑问:</p>\n<ol>\n<li>下个阶段做什么(来源)</li>\n<li>怎么做(过程)</li>\n<li>完成的总结</li>\n</ol>\n<p>在反思自己之前的制定目标的时候有以下的问题:</p>\n<ol>\n<li>多数在关注1阶段而弱化了2，3阶段的思考，这样会导致在下一次做规划的时候还是很挣扎跳不出这个圈。</li>\n<li>没有一个完整的全局视角 这个导致我的一个疑问是业务侧做这个为啥，看着很分散</li>\n<li>没有一个长期的视角，导致阶段性目标不明确</li>\n</ol>\n<h3>下个阶段做什么(来源)</h3>\n<p>在这个阶段我的思路是关注业务侧的规划文档，但是在看业务侧的文档会存在以下的\"问题\":</p>\n<ul>\n<li>某些目标比较泛并不能准确的落实到技术目标上 比如收入增加XXX</li>\n<li>可以收集到下个阶段的业务目标比如需求A，需求B，需求C，但是A，B，C有可能之间关联性不大，当然这可能跟当前的业务现状有关</li>\n</ul>\n<p>虽然通过看业务侧文档可以整理出下个阶段的业务目标，但是每次都感觉没有所谓的抓手，有种隔靴搔痒的感觉，其实从现在来看之前的我，可以看出很多思考上不足的点，才导致每次都很痛苦的想下个阶段要做啥。\n在思考上可以有两个思路:</p>\n<ol>\n<li>从上往下视角 从全局视角看不同模块的关系，建立联系和目标</li>\n<li>从下往上视角 为什么会有这样的关系，基于已有的关系是否会衍生出新的关系，在新的模块上能做什么</li>\n</ol>\n<h4>下个阶段业务目标</h4>\n<p>在梳理业务目标的时候可以从以下几点考虑:</p>\n<ol>\n<li>熟悉业务的现状  熟悉业务现状才能有目的性的查看业务侧的规划来反推出更多的思路来推动业务目标，比如\n<ul>\n<li>后续会发力营销但是现有的营销页面并不支持配置化那是否可以尝试推动业务侧一起建立配置平台</li>\n<li>业务侧要对存量的业务有一系列的优化，存量的业务还是老旧的技术栈，那么提前对技术栈进行迁移和统一</li>\n</ul>\n</li>\n<li>多与业务侧沟通，建立正向的连接  可以跟业务侧一起建立双向的规划分享，这样互相都比较了解对方做事的思路，团队每人也更有全局的意识</li>\n<li>数据思维 关注产品数据，业务数据促进对业务的反思，可以养成一个思维习惯就是产品的数据怎么能映射到我当前开发的具体业务上</li>\n</ol>\n<h4>下个阶段技术目标</h4>\n<p>在梳理技术目标可以从以下几点考虑:</p>\n<ol>\n<li>流程优化 梳理业务开发的流程针对性解决，比如:\n<ul>\n<li>规范 技术栈统一，代码规范，开发上线流程，Code Review(思考中，如何建立有效的Code Review)</li>\n<li>质量 性能，监控</li>\n<li>效率 通过工具、库来实现提效，已有业务的抽象组合</li>\n</ul>\n</li>\n<li>了解团队成员能力和诉求 可以针对不同阶段的团队成员制定不同的规划，比如工作年限相对短的可以多从一些复杂的业务中成长，年限久的赋予更多的自由度，实现自治</li>\n<li>技术储备(分享输出等) 技术储备可以为团队输入新的血液，分享和输出可以建立团队的整体意识和对外的口碑</li>\n</ol>\n<h3>怎么做(过程)</h3>\n<ul>\n<li>里程碑 每个目标阶段要有里程碑，比如做页面性能监控:\n<ol>\n<li>已有业务接入性能监控</li>\n<li>主要业务首屏优化达到XXX</li>\n<li>性能优化总结，推动上下游进行优化，新技术探索</li>\n</ol>\n</li>\n<li>可调整 在具体实现上因为优先级或者当前目标实现的结果不理想及时调整当前或者下个阶段目标</li>\n<li>多阶段完成 一个大的目标可以拆分成多个子目标在规划的多个阶段落实，需要建立多个目标之间的关系，保证规划的整体性</li>\n</ul>\n<h3>完成的总结</h3>\n<p>这个阶段可以结合上面的两个阶段来看:</p>\n<ul>\n<li>完成了哪些业务目标，技术目标，产生了哪些收益</li>\n<li>过程中产生了哪些问题，是否在下个阶段可以进行优化和避免(下个阶段目标)</li>\n<li>下个阶段目标调整</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844904201160491016\">技术管理- 怎样做好技术规划</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null}}},{"node":{"id":"2aa1bc1b-e5e4-51e4-950f-0ffc8b5a36cd","html":"<p>使用<a href=\"https://icantunderstand.github.io/blog/webview-store\">缓存</a>和<a href=\"https://icantunderstand.cn/cross-platform-offline\">离线包</a>可以一定程度上提前页面展示的时间，但是页面的展示依赖具体的数据加载，Webview在加载h5的时间线可以做如下简化:<br>\n<img src=\"./crossPlatformPrefetch/timeLine.png\" alt=\"时间线\"></p>\n<ul>\n<li>Webview初始化 Webview在首次初始化会占用相对长的时间进行初始化(可以通过Webview池的方式来优化)</li>\n<li>DNS TCP TLS 建立与服务器的连接，可以通过html的预加载标签来优化(dns-prefetch, preconnect)</li>\n<li>数据请求响应阶段 在解析响应的html的时候会解析到js代码下载并执行发起数据请求(可以通过服务端渲染方案优化但是也增加了服务端成本需要考量)</li>\n</ul>\n<p>从上面的分析可以看出在发起数据请求之前通过Native并行提前完成数据的读取就能换取页面提前展示给用户的时间，下面介绍一种可能的预取方案。</p>\n<h2>实现方案</h2>\n<p>本方案通过配置维护了对应url下需要预取的配置，在初始Webview的时候客户端并行完成数据获取，最后通过jsbridge获取数据。</p>\n<h3>预取配置</h3>\n<p><img src=\"./crossPlatformPrefetch/config.png\" alt=\"时间线\"></p>\n<ul>\n<li>配置侧 提供配置能力，需要对配置有准入审核，管理(下线，上线)</li>\n<li>服务侧 根据配置提供获取配置服务</li>\n<li>Native 动态拉取配置更新本地数据</li>\n</ul>\n<h3>加载流程</h3>\n<p><img src=\"./crossPlatformPrefetch/prefetch.png\" alt=\"加载流程\"><br>\n在加载h5的时候</p>\n<ul>\n<li>Native会在初始化Webview的时候并行的根据配置加载数据(动态参数根据页面url和配置完成映射)</li>\n<li>Webview展示的时候触发jsbridge请求，普通请求jsb与prefetch jsb的区别在于prefetch有一层从本地获取数据的步骤和数据的重置操作。</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null}}},{"node":{"id":"b01b3c20-e1da-5302-8c89-7076361a2c51","html":"<p>在<a href=\"https://icantunderstand.github.io/blog/webview-store\">一起学跨端技术-Webview缓存</a>中介绍了几种常用的缓存实现方案，几种方案都各有优缺点。其实h5页面加载过程可以类比成CPU在运行时动态获取数据，从寄存器中读取数据对比从磁盘中读取数据的时间是相差极大的。那h5页面加载的时候有没有一种方案可以绕过耗时较大的网络获取数据阶段直接加载内容展示呢？离线化就是这种解决方案。通过离线包的动态下发可以让用户在打开页面的时候直接加载已经在app中存储的离线化资源从而加速页面的展示。本文从以下两个方面介绍离线包的实现过程:</p>\n<ul>\n<li>离线包分发过程</li>\n<li>端内加载离线包过程</li>\n</ul>\n<h2>离线包分发过程</h2>\n<p>离线包的分发流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 907px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnElEQVQ4y4WS167CQAxE8/8/h0QEQfReQk0oSSjy1RnJuStA4sFa72Z9PONNVFWV3e93ez6fCvLj8Whpmtput7PtdluH71n3+319Tr7ZbOx8PlsEoCgKW6/XOjydTrqwWq2053w+n6sB++l0aqPRyLrdro3HY+v3+4rZbGaLxeIfyGWKALJOJhMVAGClgBUYZwBpxNlwOJQAzqNvlh36btWDbx4uBCey7MDH46Eoy1JFXAzDQRR6E/YoY0ScHw4Hi4DwCFhEMuoAYKXVaqmAvNPpyCb3yOM4ltVer2fNZlPfGEs9wzzPJfl6varbcrnUBeAMm2IaMjdyoP4YQJktdR+WyS+Xi2VZpias3ogcheS32033uOMrwqQQaBgOJl6vl2aGdVQnSSLV5ED8Ib0m8kKHkaMACwyZi1hpNBqyyYzb7bZs8yh8D8XUwBAc7ilA0WAwUBNy/xe9YVgTfYOFagms8Sfwe2CZWQJjZu8iPoAhlMGzAvJHAETOWH4qDLtRhD1UUMjwUQocGHvyn8AQ6i8HkOBBPIDxO71b/gMnvXNQcp6IjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"分发\"\n        title=\"分发\"\n        src=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n        srcset=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/63868/broadcast.png 250w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/0b533/broadcast.png 500w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png 907w\"\n        sizes=\"(max-width: 907px) 100vw, 907px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n分发流程中主要涉及4种角色:</p>\n<ul>\n<li>离线配置平台 配置平台可以提供离线配置能力、离线包管理(上传、禁用、清空)、离线包使用统计、离线包准入审核(自动(包大小限制)+人工(解决特殊case))</li>\n<li>离线配置服务 配置服务主要提供服务层能力，实现离线配置服务，离线包更新服务，离线资源长传下载服务、离线资源使用统计服务</li>\n<li>离线SDK 端内接入离线SDK，SDK主要与离线配置服务进行交互，完成离线资源的管理和接入配置能力</li>\n<li>Native侧  实现拦截请求在特定的协议下接入离线资源</li>\n</ul>\n<h2>离线包加载过程</h2>\n<p>离线包的加载流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQ4y32UWa+CQAyF5///Mx95IMYouKOouOKGS83XpDfDON6HpjDLOaenBdc0jRD3+/0vn89n8df9PTL7l8ultWbhwksc3G63crvdvojIrC+XS6mq6ouwBWiHZ7OZ5Hku4/G4BUY8Hg85HA6yXq8V1Fdp4XwGAKfTqSRJoqAxwLquZT6fa3CeNc5YdiaVBfOvKAo5Ho8S8/f1eklZlrLb7RQQxfv9Xm2CzAHACwAc4BJlxzyElPP9fl+yLFPi4XAok8lEA3AHOhssrFYr6fV6qgDQ0B/zEDsABJx3BKGYd3e9XlUdGZM3m40SLBYLXQtVvt9vbQpdhoA7NIjQks0/gjJRl6apmh5TCDkKKRWQ0WgknU5HgwpbXUYRyiiHHHaZZ5QNBgMFPJ1O2hDsYTrUQ78kACmZC7CHgDYFANgcovr5fGpEBxvmbrf7s9MoZA+facTXYIcKMZwL5BggJeIVwDarPz89AGFlhCg95iEkNhHhd94CtKFFgeXwjxL+Wf792xg7CukWOabQ9yum8AMub8+9QkzZbwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载\"\n        title=\"加载\"\n        src=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png\"\n        srcset=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/63868/load.png 250w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/0b533/load.png 500w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png 1000w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png 1113w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在端加载离线资源的过程中可以分为两个方面:</p>\n<ul>\n<li>离线SDK更新离线配置和离线资源 离线SDK通过与离线配置服务交互完成离线配置和离线包资源更新</li>\n<li>Web容器加载离线资源</li>\n</ul>\n<p>下面从代码层面简单介绍下加载离线资源的实现</p>\n<h3>离线配置</h3>\n<p>离线需要有一定的配置能力，比如禁用、特定的前缀支持离线化等。通过对离线配置的解析，Web容器就知道在打开对应页面是否的具体行为。这个过程是约定协议的过程。</p>\n<h3>加载离线资源</h3>\n<p>在<a href=\"https://icantunderstand.github.io/blog/jsbridge\">Hybrid开发-JSBridge原理</a>中通过拦截请求在特定的协议下可以实现javascript和Native的通信，那么在特定的协议下其实也可以实现离线包的加载能力。</p>\n<pre><code>// 定义请求资源类型映射\nprivate HashMap&#x3C;String, String > resourceMimeTypeMap  = new HashMap&#x3C;String, String>();\npublic CustomWebViewClient() {\n    super();\n    resourceMimeTypeMap.put(\"html\", \"text/html\");\n    resourceMimeTypeMap.put(\"js\", \"application/javascript\");\n}\n@Override\npublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n    Uri uri = request.getUrl();\n    String scheme = uri.getScheme();\n    String host = uri.getHost();\n    String path = uri.getPath();\n    // 处理资源加载离线包场景\n    // 协定 域名为www.test.com 且 path是local的走加载离线包逻辑\n    if(host.equals(new String(\"www.test.com\")) &#x26;&#x26; path.startsWith(\"/local\")) {\n        InputStream in = null;\n        String pageNamePath = path.split(\"/\")[2];\n        String type = pageNamePath.split(\"\\\\.\")[1];\n        String mimeType = \"text/plain\";\n        if(resourceMimeTypeMap.containsKey(type)) {\n            mimeType = resourceMimeTypeMap.get(type);\n        }\n        try {\n            // 加载本地离线资源\n            in = view.getContext().getAssets().open(pageNamePath);\n        } catch(IOException e) {\n          // 处理处理本地无离线资源 请求网络\n          return super.shouldInterceptRequest(view, request);\n        }\n        // 将本地读取的的内容进行类型映射后通过WebResourceResponse返回\n        WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", in);\n        return response;\n    }\n    return super.shouldInterceptRequest(view, request);\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADg0lEQVRIx+WWXUybZRTHn5WvQaFv2/ft2kIFRqgbHWbqHGGBTnEujdNIBpRBgjcmBo0yJ4lZskggfBhCsuxiiUYIXHJrwsW80HhhHBfTzGnQaLYJLZJsYx/EOIW29Geep5Z0fExJXhONJ/nl/J9zzvPvafopXnz5JH7/XoqLSzAMVwo9I+sGum6ovNbP6LndHnwlj1Bbe4ipqSmEXSvAphXgLXbj9rhw6DZ0w47T0NANDaeuUbbbh6c43fuzLrPLjlO3Y+xyICyCUCiE8Bi78Tqq8BkBfK4AXseeDfiMfRTrVZv2Sj1VlBgBnNZSGhqOIJ4ofIeOskuEfZ/S+eRFXj84zWFxgWd3fEyDSPGMuLCm08i+nOs88AVdh76iY/9HPBc8jjiaf54uEeNVscgbOXfp2nmPTnGH13b8TSy3ObXzPh1ihiO1xxEhyyhn98C5g79z7qkY5+tivC1W6BIrvKWIZeSNnBTLnBJJXhFRHq88jHjJMcpIBQwHYgxVxnjPn+BdI64441jhtO03TmsP4z5ntDhvFs2xr7wWcXbwfeau/MqXn8zy/fRNLn8WYWZ6gSufR7j+9V3u/JTk1rU4i9cTm3LrapylKHx7MUro6POID0c/4ObtBS5/c4kbiz/z47Xv+OGqZIZ7vyySiiRbR6q3cCNKuDWMmJiY4GGxmkiSXE2yugWJ+Kqam5uN0NbWhhgfH1eFeDxOMimHVlVOo3ZIbr2hnJcRiawzTCQSDxiZZrjd+EcNT5wwe0MzDaPRKOFw2FzDlpYWsw1N3rCpqen/Zmj6q9zc3PwvNzT9KZtqKD/LphrOz8/T2Nj4X3wfbpcN3zZjY2OqsLy8rH6otkssFlP3Z2dnU4aTk5OYEUtLS7S2tiLk8x4ZGaG/v5+hoSH6+vro7e1VenBwUNHT06P66bPUsib1wMAAw8PDdHd3p/4fCiHIpLCwkIqKigdqdXV1ZGdnr52lbm9vZ/3dmpoahNVqVQO5ublYLBYcDgcej0dpWcvKyqK8vJyioiKlJVJXV1erezk5OeTl5SnD+vp6hK7rOJ1OhdSapmGz2UjXZZZb2+12pSVSFxQUrN0zDIP8/HyCwSBCNwxcLpcqpvmr8/qa2+3Gai1MGe4ydOyatrZNJnJ4K515luTl5vLCsWOIygNPszdQTVlpqXqkzbZZb5S5pdfrxe9/FH9gPyWPBfkD9GZ9jWzUPEsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"成功加载离线资源\"\n        title=\"成功加载离线资源\"\n        src=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n        srcset=\"/blog/static/2a4c23295151170c16b9a53887eda09b/63868/loadsuccess.png 250w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/0b533/loadsuccess.png 500w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null}}},{"node":{"id":"6b8e80fe-a035-556b-b871-f4c4ffc7e118","html":"<p>跨端开发中h5加载性能优化是一个老生常谈的问题。h5在开发上有着迭代快、试错成本低的优势，但是h5的性能问题也是一个无法绕过的问题。加载慢、体验差是通常在考虑技术选型时候的一个顾虑点。本系列会以Webview性能优化为切入点尝试了解跨端开发中的技术方案来更好的辅助业务的开发。</p>\n<p>充分利用Webview的缓存(存储)机制能有效的提升h5的加载速度,通常有如下的方案可以实现缓存的过程:</p>\n<ul>\n<li>h5缓存机制</li>\n<li>Application Cache</li>\n<li>浏览器存储</li>\n</ul>\n<h2>h5缓存机制</h2>\n<p>h5缓存是指浏览器根据文件网络传输中的一些字段来确认是否使用已经缓存的文件，具体可以参考<a href=\"https://icantunderstand.cn/web-store\">缓存那些事</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVQoz22SzY6bMBSF8/zddNF1q64rtX2ESO2imheYdFPRhAwJJJAQfgwG+6uOgUwqjSXLNvfy3XOuvfIewGPtjnEscQ68t1h7wLkG5zxlWdL3HSHTt3i/A/Z4H4epPexwLmc1AR1dF2FMxvF4pq5PdN0T45hQ14YoiqjrKgCdE+wzxnwiit7z/PyOOP4AfMT7NSup8xOVYfAcj0eapp3PjtPpxO1243VcgSe8/8XttqYs1zTND+An8HtSOAFluw+ApmlmNY7z+UxVVfR9jzEtbWvIsoKyrJl1zK2Y1pVg3rsZaEmS5K5IMQHrusYYQ57nYf/ysqco8iBgGOyCDPmrBy/BooBStAyBlDgMA1mWhXMcx2GvAloVk5tZ4Y4k+UaSfMeYiDg+UFWvPZNVAbuu43A40LZtgFwul9AeQfVN8QB07i/7/RfS9CvW/iFJ0vuNqvLSAv2w2WyC5fv1XK8hplVFxnH837K1Y6isigswTdOgQla32214k+q1zuqvYppFUUzAx0sZxyEokM3HoRwVkUX1Vz8KqlVz6V+wLNDjW3yELHNRq+ek9a2x5P4Dh85Sl/bdd+YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"h5缓存机制\"\n        title=\"h5缓存机制\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/63868/cache.png 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/0b533/cache.png 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/0f529/cache.png 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Application Cache</h2>\n<p>Application Cache主要是做应用的离线化配置，它跟h5通过缓存头实现的缓存机制相对独立。通过在html中引入manifest属性开启Application Cache.</p>\n<pre><code>&#x3C;html manifest=\"example.appcache\">\n...\n&#x3C;/html>\n\nCACHE MANIFEST\n# Version 1\n// CACHE下声明的文件将在首次加载后进行缓存\nCACHE:\nscript/scriptfilename1.js\ncss/cssfilename.css\nimages/imagename1.png\nimages/imagename2.jpg\nimages/imagename3.png\n// FALLBACK定义离线状态下的规则 \nFALLBACK:\n// images下的资源都将使用images/imagename4.png替代\nimages/ images/imagename4.png\n// 缓存白名单 应用对Network下的请求都会绕过缓存请求服务器\nNETWORK:\nimages/imagename5.png\n\n// 端侧在初始化Webview的时候开启Application Cache \nWebSettings webSettings = webView.getSettings();\n// 允许执行JS\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n</code></pre>\n<p>在使用Application Cache需要注意以下几点:</p>\n<ul>\n<li>有同源限制，缓存大小限制(5MB)</li>\n<li>需要更新缓存文件的时候，需要同步更新manifest文件</li>\n<li>manifest声明中的文件无法下载时会导致无法更新到最新的缓存，浏览器将使用旧的缓存文件(推荐一些几乎不更新的文件使用Application Cache)</li>\n<li>可以在业务代码中通过window.applicationCache相关api实现缓存资源的手动触发更新</li>\n</ul>\n<h2>浏览器存储</h2>\n<p>通过浏览器提供的api实现数据的存储和缓存功能。</p>\n<h3>Dom Storage</h3>\n<p>Dom Storage指的是LocalStorage和SessionStorage。LocalStorage是持久存储，SessionStorage是会话存储。他们都通过key-value的方式来对简单的数据进行存储。Dom Storage存储空间为5MB有同源限制。</p>\n<pre><code>WebSettings webSettings = webView.getSettings();\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n// Webview初始化开启Dom Storage\nwebSettings.setDomStorageEnabled(true);\n\n// javascript\n// 设置键值\nwindow.localStorage.setItem('name', 'haha')\n// 读取键值\nwindow.localStorage.getItem('name')  // 返回\"haha\"\n</code></pre>\n<h3>IndexedDB</h3>\n<p>IndexedDB可以通过数据库的方式对数据进行存储，它的存储空间相对于Dom Storage大很多。通常可以基于封装IndexedDB的库来实现数据的存储。IndexedDB的使用方式可以参考<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<h2>参考</h2>\n<p><a href=\"https://webplatform.github.io/docs/apis/appcache/ApplicationCache/\">ApplicationCache</a><br>\n<a href=\"https://www.html5rocks.com/zh/tutorials/appcache/beginner/\">应用缓存初级使用指南</a><br>\n<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":7,"pageCount":15,"additionalContext":{"pageAllCount":88}}},"staticQueryHashes":[]}