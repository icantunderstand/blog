{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/7",
    "result": {"pageContext":{"pageAllCount":95,"group":[{"node":{"id":"bdbed110-909c-577e-9652-4e22fb148271","html":"<h2><a href=\"https://michel.codes/blogs/ui-as-an-afterthought\">UI AS AN AFTERTHOUGHT</a></h2>\n<p>这篇文章介绍作者对UI框架和状态管理的思考。在React中开发者通常会在组件中处理业务逻辑，这样导致UI和数据无法解耦。文章中的方式是让React做比较纯粹的渲染框架，业务逻辑组织在全局store中.</p>\n<h2><a href=\"https://mmazzarolo.com/blog/2022-02-16-track-down-the-javascript-code-responsible-for-polluting-the-global-scope/\">Track down the JavaScript code responsible for polluting the global scope</a></h2>\n<p>文章提供了基于ES6 proxy查找全局变量污染的方案</p>\n<h2><a href=\"https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md\">useEvent RFC</a></h2>\n<p>相关文章\n<a href=\"https://typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/\">What the useEvent React hook is (and isn't)</a><br>\nreact增加了useEvent提案，使用场景能帮我们缓存一个函数的回调。主要用于解决如下的问题:</p>\n<ol>\n<li>通常的场景在组件中声明中的函数会因为依赖项的问题导致在渲染的时候函数会新生成引用，这样在使用该函数的子组件就会触发重新渲染。</li>\n<li>react hooks的依赖解耦 比如在一个effect hook中有两段业务逻辑，这样就需要把两段业务逻辑的依赖都加入到effect hook的依赖中，导致effect执行不符合预期。</li>\n</ol>\n<p>useEvent简化实现如下:</p>\n<pre><code>    function useEvent(handler) {\n        const handlerRef = useRef(null);\n\n        // In a real implementation, this would run before layout effects\n        useLayoutEffect(() => {\n            handlerRef.current = handler;\n        });\n\n        return useCallback((...args) => {\n            // In a real implementation, this would throw if called during render\n            const fn = handlerRef.current;\n            return fn(...args);\n        }, []);\n    }\n</code></pre>\n<p>useEvent可以看出是官方的解决前面提到问题的方案，在往前走一会，有如下的一些思考:</p>\n<ol>\n<li>是否需要一个不变的callback => 性能 vs 代码复杂度</li>\n<li>组件是否做了组件该做的事 => 渲染和业务逻辑的设计</li>\n</ol>\n<h2><a href=\"https://www.youtube.com/watch?v=NZoRlVi3MjQ\">The Story of Concurrent React </a></h2>\n<p>视频介绍react Concurrent发展的过程</p>\n<h2><a href=\"https://www.developerway.com/posts/react-key-attribute\">React key attribute: best practices for performant lists</a></h2>\n<p>文章介绍React组件中key使用的注意事项</p>\n<h2><a href=\"https://www.robinwieruch.de/react-hook-detect-click-outside-component/\">React Hook: Detect Click outside of Component</a></h2>\n<p>文章介绍如何实现一个自定义的hook来监听组件外的点击</p>\n<h2><a href=\"https://www.robinwieruch.de/web-applications/\">Web Applications 101</a></h2>\n<p>文章介绍web应用前端技术的发展过程，从最开始的web1.0到web2.0娓娓道来。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/timc1/kbar\">kbar</a></h3>\n<p>kbar是一个给站点提供快捷操作的工具</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null}}},{"node":{"id":"b1129eb4-7e02-5c11-a5be-9651c06a747d","html":"<h2><a href=\"https://timothygu.me/es-howto/\">How to Read the ECMAScript Specification</a></h2>\n<p>这篇文章介绍如何阅读ECMAScript规范的一些思路，文章中有对规范章节内容的整体划分和规范写法的例子解读.规范比较难啃，可以通过例子熟悉规范的写法，在自己需要了解相关内容的时候去阅读规范</p>\n<h2><a href=\"https://dev.to/this-is-learning/conquering-javascript-hydration-a9f\">Conquering JavaScript Hydration</a></h2>\n<p>前端框架的服务端渲染可以在服务端输出组件的内容(html, data-fetch)，一定程度上加快FCP(First Contentful Paint).在用户侧浏览器根据服务端提供的内容执行前端脚本完成事件的绑定和组件相关逻辑的执行，这个过程称为Hydration(注水)。在Hydration过程中页面仍然是不可交互的，造成了页面可交互的假象。所以尽量减少在Hydration中执行的逻辑是优化性能的一个方向。这篇文章给出了这个方面的一些思考。</p>\n<h2><a href=\"https://www.chakshunyu.com/blog/a-fundamental-guide-to-react-suspense/\">A Fundamental Guide To React Suspense</a></h2>\n<p>这篇文章详细地介绍的React中使用Suspense解决问题的背景和优点。</p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍列举了React中一些通用的解决方案和工具库，包括状态管理、项目结构、代码规范等。</p>\n<h2><a href=\"https://uniqname.medium.com/why-i-avoid-async-await-7be98014b73e\">Why I avoid async/await</a></h2>\n<p>这篇文章介绍了作者对使用async/await的一些思考，主要的观点心智的转换和写法上的比较。async/await表面上将异步代码转换成同步代码的写法一定程度上改变了代码的运转模式。</p>\n<h2>ECMAScript规范</h2>\n<h3><a href=\"https://2ality.com/2022/03/properties-of-primitives.html\">How do primitive values get their properties?</a></h3>\n<p>这篇文章介绍ECMAScript语法层面上对初值的封装逻辑、属性的获取逻辑、方法的调用逻辑。</p>\n<h3><a href=\"https://github.com/tc39/proposal-type-annotations\">proposal-type-annotations</a></h3>\n<p>tc39新增Type Annotations的proposal,现在处于stage 1阶段。未来有可能javascript直接支持类型定义，可以理解ECMAScript在吸收javascript超集的优点。</p>\n<h3><a href=\"https://2ality.com/2022/04/shadow-realms.html#shadowrealm.evaluate()\">ShadowRealms – an ECMAScript proposal for a better eval()</a></h3>\n<p>这篇文章对ShadowRealms proposal进行了详细的介绍，现在处于stage 3阶段。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/nolimits4web/atropos\">atropos</a></h3>\n<p>atropos是一个做3D触摸特效的动画库</p>\n<h3><a href=\"https://stuk.github.io/jszip/\">JSZip</a></h3>\n<p>JSZip是一个JavaScript操作zip文件的库</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null}}},{"node":{"id":"4c1cd05d-9c62-5dd4-ab31-4f1ca0a7aee3","html":"<h2><a href=\"https://monorepo.tools/\">Understanding Monorepos</a></h2>\n<p>这篇文章通过对Monorepo/Polyrepo(多仓库模式)、实现Monorepo的工具进行对比，对使用Monorepo模式进行开发有参考价值。</p>\n<ol>\n<li>Monorepo是什么: Monorepo在主体仓库中组合了多个子仓库并且这些子仓库的功能是相关联的,对应的例子可以参考<a href=\"https://github.com/facebook/react\">react</a>项目的仓库</li>\n<li>为什么使用Monorepo: Monorepo在组织关联业务代码上有优势，能减少代码复用、技术统一、开发调试中的问题</li>\n</ol>\n<p>关于Monorepos和Polyrepo的思考可以参考这篇文章<a href=\"https://earthly.dev/blog/monorepo-vs-polyrepo/\">Monorepo vs Polyrepo</a></p>\n<h2><a href=\"https://www.modularmanagement.com/blog/what-is-a-good-modular-system\">What is a Good Modular System?</a></h2>\n<p>这篇文章介绍了系统设计的思考点</p>\n<ul>\n<li>模块的功能界定  通过引入模块系统可以降低系统的复杂性，提高系统的灵活性,但是对于引入的模块功能的界定划分需要考量。如果功能没有界限好会导致功能代码从一个位置移动到另一个位置增加了模块维护的复杂度。比如之前的中台概念，需要划分好中台的功能才能更好的实现中台的能力，拆分出模块系统一方面做得更多去帮助系统更好，一方面也要思考如果做得更少去实现最初的目标</li>\n<li>生命周期 功能的稳定和灵活性能提高模块的生命周期</li>\n<li>模块收益的衡量标准</li>\n</ul>\n<p><img src=\"weeklyReport22/modular-value.png\" alt=\"模块收益衡量标准\"></p>\n<p>通过模块衡量的公式，在进行模块系统设计的时候可以有以下的考虑:</p>\n<ol>\n<li>平台的功能边界考量\n<ol>\n<li>不是越少越好，前期的投入能力后期带来收益</li>\n<li>前期的忽视需要后续弥补，要仔细思考</li>\n<li>用小范围的能力边界限制实现整体的灵活扩展</li>\n</ol>\n</li>\n<li>整体和部分的考量\n<ol>\n<li>不用一步到位，部分功能提升到独立的系统也能产生比较大的价值，后期再进行统一</li>\n<li>在资源可能的情况下，相关的依赖系统要统一升级</li>\n</ol>\n</li>\n<li>从长期的视角去看系统的模块设计 从现在的能力出发结合系统未来的发展诉求去做系统设计(能力建设)，这个角度的考虑也是在为未来打地基</li>\n</ol>\n<p>对于模块系统的介绍可以参考这篇文章<a href=\"https://www.modularmanagement.com/blog/all-you-need-to-know-about-modularization\">All You Need to Know About Modularization</a>,模块的实现应该在部分能力抽象的情况下实现系统整体的灵活性</p>\n<p><img src=\"weeklyReport22/modular-define.png\" alt=\"模块化系统的定义\"><br>\n模块化系统能带来效率、灵活度、敏捷的特点。</p>\n<ol>\n<li>效率 模块的复用/功能的组装  这里可以通过比喻装配式建筑来理解,通过对预制模块在工地快速的组装就快速完成了建筑的装配。</li>\n<li>灵活性 基础模块能快速的组装出新的功能模块/通过统一的接口设计能快速的实现模块的功能替换</li>\n<li>敏捷性 由于基础模块的拆分，通过基础模块的改变就可以快速地影响整个系统</li>\n</ol>\n<h2><a href=\"https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd\">Deep dive into React Native’s New Architecture</a></h2>\n<p>这篇文章通过React Native前后架构的对比对新旧架构进行了介绍</p>\n<h2><a href=\"https://kentcdodds.com/blog/javascript-to-know-for-react\">JavaScript to Know for React</a></h2>\n<p>这篇文章介绍了React中JavaScript的一些常用的语法，比如模板字符串、可选链、空值合并预算符等</p>\n<h2><a href=\"https://blog.bitsrc.io/some-reasons-for-disliking-react-hooks-80f1e18eb9b3\">Some reasons for disliking React hooks</a></h2>\n<p>这篇文章作者介绍了使用react hooks的优缺点</p>\n<ul>\n<li>优点 hooks可以更好实现代码的复用组合/逻辑集中</li>\n<li>缺点 hooks的写法上有上手成本和调试成本，容易引发一些bug，还有不要过于过度使用hooks.hooks的调用方式是通过数组的方式调用函数，过多或者依赖关系复杂的hooks会降低页面的性能</li>\n</ul>\n<h2><a href=\"https://blog.bitsrc.io/inversion-of-control-with-react-584533e49245\">Build Decoupled React Components with Inversion of Control</a></h2>\n<p>这篇通过例子的方式介绍通过反转控制的方式解耦组件的实现来应对未来逻辑的变更</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"2022-3-1-前端快报","date":"2022-03-07","tags":"前端快报","path":"/2022-3-7","top":null,"summary":null}}},{"node":{"id":"983124c1-808b-5e13-bea1-17907d6cd08f","html":"<p>这里记录下2022读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2022年已阅读: 40本</p>\n<p>2022读书感悟:\n最开始以为读书能看懂世界，觉得能增加所谓的阅历，其实发现多个看世界的视角就好</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>《半小时漫画历史系列》- 陈磊</h2>\n<h3>推荐指数 5</h3>\n<p>原来发现历史是这么有趣，原来晦涩的朝代故事在笔者轻松的表达下竟然那么引人入胜，非常适合在闲暇的时候当历史简版读物来看。</p>\n<h2>《动物农场》- 乔治·奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>经典之作。这本书描写了动物农场的一场反抗活动，对现实社会有影射意义，思考我们是不是也在一个农场中，只是压迫的程度大小，要跳出来看自己的生活。</p>\n<h2>《1984》- 乔治.奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>是看完动物农场才看的《1984》. 书中塑造了一种恐怖绝望的氛围会跟着主人公体验到从拥有希望到绝望的过程，在小说的故事中文明、历史似乎都可以被改写。读完会有疑惑就是书中描绘的社会是否会在现实中呈现，如果生活在那样的社会应该是十分的压抑的。</p>\n<h2>《为什么是中国》- 金一南</h2>\n<h3>推荐指数 4</h3>\n<p>这本书主要介绍中国近代以来的发展历史，其实作为中国人会感觉到自豪，中国在社会实践上走的是一条充满实践的道路</p>\n<h2>《胜者思维》- 金一南</h2>\n<h3>推荐指数 4.5</h3>\n<p>本书中金一南通过对中国历史发展从军事的角度进行总结，一些思路在其他的领域也很有价值，比如领导者的领导作用、权力的下放与担责</p>\n<h2>《认知觉醒: 开启自我改变的原动力》- 周岭</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中的对思维方式表达改变了我之前对思维方式的思考，思维是可以训练，我们对自己也不应该固步自封，很推荐看这本。</p>\n<h2>《柳林风声》- 肯尼斯·格雷厄姆</h2>\n<h3>推荐指数 4.5</h3>\n<p>这是一本适合大人和孩子一起看的童话书，书中的小动物形象跃然纸上，有的时候你会为书中的蛤蟆扼腕叹息，认为它罪有应得，会喜欢上对人和善的鼹鼠。在阅读的过程中仿佛你就进入了这个童话的世界，跟着动物们一起探索，历险。</p>\n<h2>《时间的形状:相对论史话》- 汪洁</h2>\n<h3>推荐指数 5</h3>\n<p>非常通俗易懂的科普读物 作者通过讲故事的方式把比较硬核的理论通俗易懂地讲出来。了解到相对论等理论的发展过程,发现人类的探索欲也觉得人类很渺小.这是一本充满科学内核的科普“小说”。称它为小说是因为你会被一个个故事所吸引。非常推荐</p>\n<h2>《宇宙的琴弦》- 格林</h2>\n<h3>推荐指数 3.5</h3>\n<p>弦论的科普读物。书中的论证的过程和思考的方式有一定的启发作用</p>\n<h2>《中国新基建：未来布局与行动路线》</h2>\n<h3>推荐指数 3.5</h3>\n<p>这本书比较全面地介绍了新基建的方向、图谱、路径。需要意识到与别人的差距也要切实的看到中国的进度，建立中国自信</p>\n<h2>《花猫三丫上房了》 - 叶广岑</h2>\n<h2>《土狗老哥闯祸了》 - 叶广岑</h2>\n<h2>《耗子大爷起晚了》- 叶广岑</h2>\n<h3>推荐指数 4.5</h3>\n<p>非常生动的童年故事，读起来会有很多温馨的瞬间。不是童话却有童话的感觉</p>\n<h2>《这就是中国: 走向世界的力量》 - 张维为</h2>\n<h3>推荐指数 4.5</h3>\n<p>这本书的内容很多，值得反复阅读。主要包括我们是怎么崛起的、我们为什么会崛起、我们的制度优势、需要建立中国自信(有自己的视角看问题和解读问题，建立自己的话语体系)等。在开始阅读的时候会觉得鸡血貌似多了一点，在逐渐阅读大部分后发现自己之前的一些想法不够成熟。书中的视角是从国家的角度来阐释发展，其实映射到个人也有一定的价值。非常推荐。</p>\n<h2>《超越期待：松浦弥太郎的人生经营原则》- 松浦弥太郎</h2>\n<h3>推荐指数 2</h3>\n<p>书的内容围绕着作者的人生态度和处事原则的细致总结，读起来相对来说缺少面的陈述，不推荐</p>\n<h2>《献给阿尔吉侬的花束》 - 丹尼尔·凯斯</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完有些伤感，小说通过日记的方式叙述查理从不聪明到聪明又回归到愚钝的状态，作者对心理变化的描述入微，读起来感觉在跟查理经历着这一切。这本书有许多的现实反射，比如</p>\n<ul>\n<li>查理的妈妈小时候对查理的不认同，导致查理性格上的讨好和迫切的希望获得别人的认可，可见在孩子幼年的时候塑造一个健全的人格的重要性</li>\n<li>如何接受和认识自身的问题 在没变聪明之前查理过得很开心，在经历了变聪明又变不聪明之后查理的心态无法回到之前的状态，这里也情有可原。文中有两个查理体现在聪明程度的差异，在我们自身上是否在其他方面也有另一个查理呢，在暗处观察着自己。</li>\n</ul>\n<h2>《西方哲学史:从古希腊到当下》- 奎纳尔·希尔贝克 尼尔斯·吉列尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>整本书比较详细的描写了人类历史发展阶段的哲学思考过程.我们现在的社会发展成当前的模式是在前人的思考基础上的,从这个角度去阅读和理解本书是一个不错的角度</p>\n<h2>哪有没时间这回事(白金版) - 纪元</h2>\n<h3>推荐指数 3</h3>\n<p>对时间的管理上有一定的启发</p>\n<h2>聪明的投资者(第四版) - 本杰明·格雷格姆 贾森·兹威格</h2>\n<h3>推荐指数 4.5</h3>\n<p>价值投资的观点并不过时。书中主要介绍格雷厄姆对价值，对投资的一些思考。</p>\n<h2>股票大作手回忆录 埃德温·勒菲弗</h2>\n<h3>推荐指数 3.5</h3>\n<p>作为利弗莫尔一生在”投机“生涯的回忆录，记录视角上会感觉一个经历了大起大落的人在你耳边叙述他的一生。</p>\n<h2>时间尽头的咖啡馆 约翰·史崔勒基</h2>\n<h3>推荐指数 4</h3>\n<p>一本简短的小说，通过故事的方式引领你的思考-关于生命的意义。找到问题的答案仍然需要自己的积极思考</p>\n<h2>斯坦福极简经济学 蒂莫西·泰勒</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中通过简单的例子阐述宏观和微观经济学的基本概念，读起来兴趣盎然。经济学有助于我们改变对世界的认识，推荐这本。</p>\n<h2>养育你内心的小孩 丛非从</h2>\n<h3>推荐指数 4</h3>\n<p>这本书从心理学的角度上介绍了安全、自由、价值、意义、亲密等对行为产生的影响。我们对于外界的行为起因是我们的内心有一定的冲突，要不停的认识自己。</p>\n<h2>火星编年史 雷·布拉德伯里</h2>\n<h3>推荐指数 4.5</h3>\n<p>很喜欢作者对人类文明发展的克制表达，是一本有诗意却有些悲凉色彩的科幻小说</p>\n<h2>邓小平时代 傅高义</h2>\n<h3>推荐指数 4.5</h3>\n<p>对历史的细节有了更多的了解。邓爷爷一辈子起起伏伏，一直在为中国发展贡献着力量，阅读过程中会感觉一个亲切而坚定的人跃然纸上，作者在写作本书的时候对历史的细节有足够的求证力图还原真实的历史。阅读本书了解到了什么是中国特色社会主义制度，为什么会有经济特区，发展才是硬道理等等，祖国的今天得来不易，以史为鉴才能走得更好，感恩前人。</p>\n<h2>法治的细节</h2>\n<h2>圆圈正义: 作为自由前提的信念  罗翔</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完这两边书让我对法治的概念有了基本的思考，也了解到要接受自己的局限性，多思考。</p>\n<h2>李光耀观天下 李光耀</h2>\n<h3>推荐指数 4</h3>\n<p>跟随李光耀先生的视角看了一次世界.在看待中国问题上还是存在一些西方的视角不过也的确看到了发展中出现的问题。在其他区域的发展上从政治经济上看的很广,有全局的视野</p>\n<h2>鼠疫 加缪</h2>\n<h3>推荐指数 4.5</h3>\n<p>在新冠疫情的背景下看这本书更加有感触。书中散发着作者对于生活坚定的力量。</p>\n<h2>用经济思维看懂世界格局·亚欧大陆经济整合--新体系伟大力量的源泉 徐伯赢</h2>\n<h3>推荐指数 5</h3>\n<p>本书从经济学的角度来探讨世界格局，覆盖了美、欧、中东、东南亚、日本、中国在经济领域的历史，读起来兴趣盎然。在探讨的视角是也比较宏观。</p>\n<ul>\n<li>日本和东南亚就像今天中国发展的镜子，如何解决房地产泡沫问题、如何寻找经济发展替换地产经济的问题，发展方式的选择问题(合作共赢还是胜者通吃)、金融领域的开放问题等，有不错的借鉴意义</li>\n<li>欧债危机暴露了很多问题，看似表面团结的欧盟(英国与欧洲大陆国家，欧洲大陆核心国与非核心国)由于国家经济政策不同和整个欧盟产业结问题容易产生一些隐藏的问题。欧盟似乎应该在更加统一的财政政策和独立于美国的政策上发力</li>\n<li>对比其他国家和区域，我们的发展路线是在全球化背景下实践一条合作发展，互利共赢的道路，虽然我们现在也面临很多的问题(法制的建设等)，希望这些问题会越来越好，附上这本书结尾的话: 士不可以不弘毅，任总而道远</li>\n</ul>\n<h2>PDCA循环工作法 冈村拓郎</h2>\n<h3>推荐指数 3.5</h3>\n<p>PDCA循环工作法的实践书籍，对于一些细节和思考上有收获。适合快读</p>\n<h2>纳闷集 匡扶</h2>\n<h3>推荐指数 3</h3>\n<p>漫画集，通过漫画和搞笑的表达方式叙述了温暖的故事</p>\n<h2>战胜华尔街 彼得·林奇 约翰·罗瑟查尔德</h2>\n<h3>推荐指数 4</h3>\n<p>之前读过股票大作手回忆录-利弗莫尔的回忆录，是第三方视角记录的有些内容就会存在失真，收获有限。这本书是彼得·林奇个人写的自传，本书从头到尾都在基于他投资选股的内容进行阐述，在对周期股的概念、长期价值投资的坚定、选股思考的逻辑都有不错的收获</p>\n<h2>自洽: 在不确定的日子里向内看 史欣悦</h2>\n<h3>推荐指数 3.5</h3>\n<p>自洽是一个向内沟通的过程，自己之前有段时间工作相对忙碌，在那段时间里很少的考虑到自己本身的一些想法，被一件一件推着往前走。比较缺少对做的事情的一些思考。最近时常会蹦出来一些想法当时如果这么做会更好。在快的节奏里面如果保持自己的节奏(内心)很重要，需要不断的跟自己沟通，丰富自己的认知。</p>\n<h2>看懂世界格局的第一本书 王伟</h2>\n<h3>推荐指数 4</h3>\n<p>通过本书了解到了很多历史的细节和全面的视角,对了解世界格局和经济很有帮助.比如日本、苏联、东南亚国家的发展都对现在有借鉴价值</p>\n<h2>认知世界的经济学 珍大户</h2>\n<h3>推荐指数 4</h3>\n<p>作为入门读物,在需求供给、弹性、利率等方面通过例子讲解的很清晰.书中有些例子有些刻意为之但是瑕不掩瑜</p>\n<h2>随风去野 白关</h2>\n<h3>推荐指数 4</h3>\n<p>跟随生动的插画与作者一起经历了骑行过程中的人、事、景色，是一次不错的体验</p>\n<h2>海龟交易法则 柯蒂斯·费思</h2>\n<h3>推荐指数 3</h3>\n<p>本书是作者个人的经历介绍.海龟交易法阐述了在市场中交易的基本原则,控制风险、控制仓位、止损、止盈等.从书中的收获是在市场中要掌握自己的优势，发挥自己的优势。 建议关键章节详细看</p>\n<h2>中国近代通史(全10册) - 中国社会科学院近代史研究所</h2>\n<h3>推荐指数 5</h3>\n<p>从鸦片战争到中华人民共和国成立，这本书详细的介绍了中国近代史的细节。在阅读的过程中会有历史在眼前重演的错觉，会有遗憾、不解、叹息等情绪。历史仿佛能启发人的思考，以史为鉴可以正衣冠应该说的就是这个道理，对近代史感兴趣的话推荐这本书</p>\n<h2>荒原狼 赫尔曼·黑塞/涂媛媛译</h2>\n<h3>推荐指数 3.5</h3>\n<p>书中的荒原狼可以理解是黑塞本人或者自我抗争的一种表现，书中有很多光怪陆离的表达手法读起来还不错</p>\n<h2>局外人 加缪</h2>\n<h3>推荐指数 4</h3>\n<p>加缪的小说很像有人在你身边讲故事，通过平淡且扎实的叙事方式推进故事的演进</p>","fields":{"readingTime":{"text":"19 min read"}},"frontmatter":{"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null}}},{"node":{"id":"e88dde7e-fd25-5606-b4a9-8cd74b7e55be","html":"<h2><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/\">JavaScript. The Core: 2nd Edition</a></h2>\n<p>这篇文章介绍JavaScript的一些核心概念，包括对象、原型链、闭包、this、执行上下文等，适合温故知新</p>\n<h2><a href=\"http://www.ayqy.net/blog/%E7%90%86%E8%A7%A3git-submodules/\">理解Git Submodules</a></h2>\n<p>这篇文章介绍了包管理通用的几种方式: npm packages/monorepo/git submodules.\nnpm packages的管理方式基于npm的版本控制方式实现子模块更新，更适合管理底层库、基础依赖。这类代码的变更相对较少，主repo更多使用的是子repo编译后的代码产物<br>\nmonorepo 适用于服务于同一功能的多个模块的组合方式，模块之间功能划分清晰，依赖清晰。解决方案有<a href=\"https://github.com/lerna/lerna\">lerna</a>和yarn的<a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">workspaces</a>.monorepo的优势是可以在一个仓库内完成不同包模块功能的测试，不需要关注子repo的版本问题。劣势是需要解决node_module的依赖问题、编译流程、主repo体积问题等。业务不相关的模块建议直接拆仓维护，自治的成本反而更低。<br>\ngit submodules跟monorepo的理念相近，都直接依赖子repo的源码进行开发。git submodules优势是可以实现子repo的共享源码能力(相对于编译后产物的优势)，可以实现功能的复用(npm packages/微前端)。</p>\n<h2><a href=\"https://blog.plasmic.app/posts/how-react-server-components-work/\">How React server components work: an in-depth guide</a></h2>\n<p>这篇文章详细的介绍了React Server Components的实现机制，通过React Server Components可以更好的实现bundle体积的减少，渲染时间的加快,值得后续的关注</p>\n<h2><a href=\"https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/\">Improving JavaScript Bundle Performance With Code-Splitting</a></h2>\n<p>这篇文章详细的介绍了使用Code Split的细节和关注点</p>\n<h2><a href=\"https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html\">Use Streams to Build High-Performing Node.js Applications</a></h2>\n<p>这篇文章详细的介绍了node中stream流的使用细节，通过例子的方式讲解了流的状态，背压等概念。</p>\n<h2><a href=\"https://www.developerway.com/posts/how-to-write-performant-react-code\">How to write performant React code: rules, patterns, do's and don'ts</a></h2>\n<p>这篇文章通过例子的方式介绍react代码的优化方式，阅读过后能发现出平时一些不注意的点</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null}}},{"node":{"id":"3f01dcef-3d31-579e-9d68-f2ea5cd487a7","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#single-spa\">single-spa简单用法</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#\">子应用配置</a></li>\n<li>1.2. <a href=\"#-1\">主应用配置</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#single-spa-1\">single-spa源码分析</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">启动</a></li>\n<li>2.2. <a href=\"#-1\">子应用挂载/切换</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">关于微前端的一些总结思考</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>微前端是应用组装的一种模式,本文从single-spa的使用方式入手逐步深入到single-spa的源码实现了解微前端的实现方式</p>\n<h2>1. <a name='single-spa'></a>single-spa简单用法</h2>\n<p>single-spa通过子应用与主应用约定交互协议实现微前端应用,在具体的交互中:</p>\n<ul>\n<li>子应用需要暴露应用生命周期方法,例如bootstrap、mount、unmount</li>\n<li>主应用与子应用约定激活规则</li>\n<li>主应用根据挂载规则动态的切换应用状态并且执行对应子应用的生命周期方法</li>\n</ul>\n<p>下面的例子分别从子/主应用的角度梳理下single-spa实现微前端方案的配置方式,在例子中定义了一个主应用(baseapp), 两个子应用(app1, app2).</p>\n<h3>1.1. <a name=''></a>子应用配置</h3>\n<p>single-spa基于js Entry的方式实现微前端方案,在子应用导出的js模块中需要包含子应用的生命周期函数方法，这里的两个子应用都以create-react-app创建的react应用举例,实例代码已上传到<a href=\"https://github.com/icantunderstand/microappdemo\">微前端demo</a></p>\n<ol>\n<li>使用create-react-app创建子应用 npx create-react-app app1</li>\n<li>进入到对应的目录\nnpm run eject // 将创建项目的配置弹出\nnpm install single-spa-react -S</li>\n<li>修改项目的webpack配置,修改输出文件(这里仅为测试使用)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAADCElEQVQ4y32U25KjNhRF/RuTNiAkQCAk7hdjbOxup6YmmYf8/9esFHJ3TzoP87DrSAW1ap+LzqFpGsIwJIpCCtfQrht26LG1QciQSAQIGSDigCAI/L+/06Gua3+I45g4FuTOUdSWsq+p5oGya+iuqz9LlXA8BgTHJ9zr+B8FAYcPh0IIlFK4ccL2zdNlP9AsE+PrDTf06CIlySIym6CyGJnEZEaRForUKGQac6iq6hMoPXCmXVeqaULmOdm4UKwbWT+TTVfK7YF2BhFHCClQWnqQSmN/P7Rt+8WhLg2m3VN2pFaTVgbdOnRjKeeWvLXkTnuHSaHI3NNtWioffcpRFD0dSkk1LozbG918Zr496JcV7WqK+Uo+XsjnjXy6oLuZOAqRMkaIyNd/jwfn3BegjGOyLKNvaoa+p20auqZhmUbGtqZzJWtXsTSOU10yVyWjM6ytozWagzGGMPwAKrSxlOMFd/uJu//ELG/Uj38orz9o2p6hssyu4LpDq5LJGr7PHX1ZcK4tB2vtL4dKUXY93WVluF2opwk39tTzTLOc0EXC0Blql9PanLEraZuCebA4q+lb8xWolESlgtQIilqhnSR3e7EjtJUUTUbeZmSl8k1IzLMpWZX4mLrkKzCWkngfA6NIbELe56RV6iULhW4ysir134qxQGqJdgm5S0ly6fUJjIQgTxS39cJ9u/N6f7BOM9tp4XW7s44Tr7cb1/OZbb3weHvQjyc/e5GIvMIo/NXlUAhOOmGdF+6P7zz++pveGX4sHY+p5trV2DSlVAojJU7GzFlCEEZE7+945xymafLpRiJm1gmZ0ZjR4c4OOxr6a0V9LjH7soglodhfiPIjthvYG5mmqb/vD8M7FO8Op1RStR3tefXdrWzC4gpSKfnj5cU7EVHoo4xCOhlx/P+2+aihB2bquW3GAXeeqK5nYrOXRGDzjGMY8e0l4Nsx4BgENFHIy8tz0xzfo18OvgZCsGSSrau5LQPb1HGbR26nnmur+bMvOFcZo5EMecycx1z8qKQkWn5uoH8BNYv4/t4Q+IAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wepack修改配置\"\n        title=\"wepack修改配置\"\n        src=\"/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png\"\n        srcset=\"/blog/static/0b818be146d1f3df7220cfad8a318320/63868/webpackConfig.png 250w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/0b533/webpackConfig.png 500w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png 1000w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png 1186w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n4. 修改子应用代码</p>\n<pre><code>    import React from 'react';\n    import ReactDOM from 'react-dom';\n    import './index.css';\n    import singleSpaReact from 'single-spa-react'\n    import App from './App'; // App是子应用的入口 \n\n    // 使用single-spa-react产生子应用的生命周期方法\n    const reactLifecycles = singleSpaReact({\n        React,\n        ReactDOM,\n        rootComponent: App,\n        errorBoundary(err, info, props) {\n            // https://reactjs.org/docs/error-boundaries.html\n            return (\n            &#x3C;div>This renders when a catastrophic error occurs&#x3C;/div>\n            );\n        },\n    });\n\n    export const bootstrap = reactLifecycles.bootstrap;\n    export const mount = reactLifecycles.mount;\n    export const unmount = reactLifecycles.unmount;  \n</code></pre>\n<ol start=\"4\">\n<li>\n<p>构建子应用,生成入口文件，这里通过serve提供静态服务的方式提供入口js Entry的访问，在实际中可以使用nginx或者cdn的形式提供访问</p>\n<pre><code> npm run build\n serve -s -l 3001 build // 指定端口 \n</code></pre>\n</li>\n</ol>\n<h3>1.2. <a name='-1'></a>主应用配置</h3>\n<ol>\n<li>\n<p>使用create-react-app创建主应用 npx create-react-app baseapp</p>\n</li>\n<li>\n<p>安装微前端依赖</p>\n<p>npm install single-spa react-router-dom -S</p>\n</li>\n<li>\n<p>主应用增加与子应用配置代码</p>\n<pre><code> import React from 'react';\n import ReactDOM from 'react-dom';\n import { BrowserRouter as Router, Link } from 'react-router-dom'\n import history from 'history/browser';\n import './index.css';\n import { registerApplication, start } from 'single-spa'\n\n async function loadApp(libraryUrl, libraryName) {\n     // 打包的webpack配置是umd模式 直接挂载在window上\n     if(window[libraryName]) {\n         return window[libraryName]\n     }\n     // 加载并且等待js执行\n     await new Promise((resolve, reject) => {\n         const script = document.createElement('script')\n         script.src = libraryUrl\n         script.onload = resolve\n         script.onerror = reject\n         document.body.appendChild(script)\n     })\n     return window[libraryName]\n }\n\n // 子应用可以通过走服务端下发配置 \n const apps = [\n     {\n         name: 'app1',\n         // 子应用加载方法，加载对应的js Entry\n         app: () => loadApp('http://localhost:3001/app1.js', 'app1'),\n         // 子应用激活方法\n         activeWhen: location => location.pathname.startsWith('/app1'),\n         // 共享属性\n         customProps: {}\n     },\n     {\n         name: 'app2',\n         app: () => loadApp('http://localhost:3002/app2.js', 'app2'),\n         activeWhen: location => location.pathname.startsWith('/app2'),\n         customProps: {}\n     }\n ]\n // 注册子应用\n for(let i = 0; i &#x3C; apps.length; i++) {\n     registerApplication(apps[i])\n }\n // 启动single-spa提供微服务能力\n start()\n // 渲染主应用\n ReactDOM.render(\n     &#x3C;div>\n         this is base app\n         &#x3C;Router history={history}>\n         // 子应用入口\n         &#x3C;div>&#x3C;Link to=\"app2\"  >app2&#x3C;/Link>&#x3C;/div>\n         &#x3C;div>&#x3C;Link to=\"app1\" >app1&#x3C;/Link>&#x3C;/div>\n     &#x3C;/Router>\n     &#x3C;/div>,\n     document.getElementById('root')\n );\n</code></pre>\n</li>\n<li>\n<p>启动主应用，就能看到两个子应用聚合成一个应用，点击对应的调整也能正常切换</p>\n</li>\n</ol>\n<p><img src=\"/blog/35257e241336dfb4aa08e94db8b4aec4/run.gif\" alt=\"引用切换\"></p>\n<h2>2. <a name='single-spa-1'></a>single-spa源码分析</h2>\n<p>single-spa的源码可以分成两个阶段来看: 启动阶段和子应用挂载(切换)阶段.下面就分别从这两个阶段看single-spa的执行过程</p>\n<h3>2.1. <a name='-1'></a>启动</h3>\n<p>在启动主应用的时候，通过registerApplication注册子应用和start方法启动微前端\n在registerApplication中主要对子应用的入参进行了格式化处理然后将子应用推入全局的数据保存，然后执行应用切换的主函数reroute做首次应用的加载逻辑</p>\n<pre><code>export function registerApplication(\n    appNameOrConfig,\n    /** 子应用异步加载函数 需要返回带有生命周期的模块导出 */\n    appOrLoadApp,\n    /** 应用激活函数 */\n    activeWhen,\n    /** 共享属性 */\n    customProps\n    ) {\n    // 子应用入参格式化处理\n    const registration = sanitizeArguments(\n        appNameOrConfig,\n        appOrLoadApp,\n        activeWhen,\n        customProps\n    );\n    /** 推入全局的子应用数组 */\n    apps.push(\n        assign(\n        {\n            loadErrorTime: null,\n            /** 应用状态 */\n            status: NOT_LOADED,\n            parcels: {},\n            devtools: {\n            overlays: {\n                options: {},\n                selectors: [],\n            },\n            },\n        },\n        registration\n        )\n    );\n    if (isInBrowser) {\n        ensureJQuerySupport();\n        /** 执行应用切换的主函数 */\n        reroute();\n    }\n}\n</code></pre>\n<p>在reroute中会对子应用加载状态进行分类(appsToUnload\\appsToUnmount\\appsToLoad\\appsToMount)然后根据是否运行过start函数走不同触发逻辑:</p>\n<ol>\n<li>\n<p>未运行过start函数,走app初始化加载逻辑(js Entry下载)</p>\n</li>\n<li>\n<p>运行过start函数,走app挂载/切换逻辑</p>\n<pre><code> export function start(opts) {\n     // start控住通过全局变量控住整个应用挂载状态\n     // 二次调用start 触发对应的子应用挂载\n     started = true;\n     if (opts &#x26;&#x26; opts.urlRerouteOnly) {\n         setUrlRerouteOnly(opts.urlRerouteOnly);\n     }\n     if (isInBrowser) {\n         reroute();\n     }\n }\n /** 执行应用切换的主函数 */\n export function reroute(pendingPromises = [], eventArguments) { \n     /** 应用处于切换状态中,推入到待处理的peopleWaitingOnAppChange 等待后续统一处理 */\n     if (appChangeUnderway) {\n         return new Promise((resolve, reject) => {\n         peopleWaitingOnAppChange.push({\n             resolve,\n             reject,\n             eventArguments,\n         });\n         });\n     }\n     /** 获取当前子应用的状态数组 */\n     /** 在getAppChanges中根据传入的activeWhen进行判断 首次应用应该处于appsToLoad数组中 */\n     const {\n         /** 移除状态 */\n         appsToUnload,\n         /** 卸载状态 */\n         appsToUnmount,\n         /** 加载状态 */\n         appsToLoad,\n         /** 即将挂载状态 */\n         appsToMount,\n     } = getAppChanges();\n     let appsThatChanged,\n         navigationIsCanceled = false,\n         oldUrl = currentUrl,\n         newUrl = (currentUrl = window.location.href);\n     // 是否运行过start函数 走应用切换逻辑\n     if (isStarted()) {\n         appChangeUnderway = true;\n         appsThatChanged = appsToUnload.concat(\n         appsToLoad,\n         appsToUnmount,\n         appsToMount\n         );\n         return performAppChanges();\n     } else {\n         // 未运行过start函数走app初始化加载逻辑\n         appsThatChanged = appsToLoad;\n         return loadApps();\n     }\n     /** 省略若干代码 */\n }\n</code></pre>\n</li>\n</ol>\n<p>loadApps通过微任务的方式加载js Entry然后在对应的app对象设置子应用的生命周期函数</p>\n<pre><code>/** 加载子应用js Entry */\nfunction loadApps() {\n    return Promise.resolve().then(() => {\n        /** 通过微任务的方式加载appsToLoad 在加载完毕后在\n        * 对应的app对象上设置暴露的生命周期方法\n        */\n        const loadPromises = appsToLoad.map(toLoadPromise);\n\n        return (\n        Promise.all(loadPromises)\n        /** 触发路由事件 首次加载可忽略这里 */\n            .then(callAllEventListeners)\n            // there are no mounted apps, before start() is called, so we always return []\n            .then(() => [])\n            .catch((err) => {\n            callAllEventListeners();\n            throw err;\n            })\n        );\n    });\n}\n</code></pre>\n<h3>2.2. <a name='-1'></a>子应用挂载/切换</h3>\n<p>在single-spa启动的时候,会监听路由事件然后再触发路由事件和执行reroute方法</p>\n<pre><code>/** 路由事件监听 */\nwindow.addEventListener(\"hashchange\", urlReroute);\nwindow.addEventListener(\"popstate\", urlReroute);\n/** patchedUpdateState也会触发urlReroute */patchedUpdateState\nwindow.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    \"pushState\"\n);\nwindow.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    \"replaceState\"\n);\n\nfunction urlReroute() {\n    reroute([], arguments);\n}\n</code></pre>\n<p>所以app挂载切换的主逻辑都在reroute的performAppChanges中,主要做了:</p>\n<ul>\n<li>\n<p>派发single-spa自定义事件</p>\n</li>\n<li>\n<p>执行移除/卸载状态应用的生命周期函数</p>\n</li>\n<li>\n<p>执行挂载应用的生命周期函数(依赖卸载/移除的执行tryToBootstrapAndMount)</p>\n<p>function performAppChanges() {</p>\n<pre><code>  return Promise.resolve().then(() => {\n      /** 派发single-spa自定义事件 */\n      /** 省略若干代码 */\n      // 执行需要移除/卸载状态应用的生命周期函数并且删除对应的生命周期函数\n      // 重置应用状态\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      const unmountUnloadPromises = appsToUnmount\n          .map(toUnmountPromise)\n          .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n      unmountAllPromise.then(() => {\n      window.dispatchEvent(\n          new CustomEvent(\n          \"single-spa:before-mount-routing-event\",\n          getCustomEventDetail(true)\n          )\n      );\n      });\n\n      // 子应用的加载和bootstrap生命周期函数执行\n      const loadThenMountPromises = appsToLoad.map((app) => {\n          return toLoadPromise(app).then((app) =>\n              tryToBootstrapAndMount(app, unmountAllPromise)\n          );\n      });\n      // 子应用挂载和mount生命周期函数的执行\n      const mountPromises = appsToMount\n          .filter((appToMount) => appsToLoad.indexOf(appToMount) &#x3C; 0)\n          .map((appToMount) => {\n              return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n      });\n      /** 省略若干代码 */\n  });\n  }\n  // tryToBootstrapAndMount依赖之前需要unLoad和unMount的应用周期函数执行完毕\n  function tryToBootstrapAndMount(app, unmountAllPromise) {\n      if (shouldBeActive(app)) {\n          return toBootstrapPromise(app).then((app) =>\n          unmountAllPromise.then(() =>\n              shouldBeActive(app) ? toMountPromise(app) : app\n          )\n          );\n      } else {\n          return unmountAllPromise.then(() => app);\n      }\n  }\n</code></pre>\n</li>\n</ul>\n<p>以上梳理了single-spa实现微前端的主体流程</p>\n<h2>3. <a name='-1'></a>关于微前端的一些总结思考</h2>\n<p>在讨论使用一个技术方案的时候,主要考虑点这项技术方案是否能解决当前或者未来项目中遇到的问题,微前端的优势在于项目的组合(新老项目平滑过渡\\项目功能共享\\应用拆分\\流程解耦)等但同时也增加了项目维护的一些成本,需要结合项目和业务发展方向进行探索使用</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://juejin.cn/post/6862661545592111111\">微前端框架 之 single-spa 从入门到精通</a><br>\n<a href=\"https://blog.yuanziwen.cn/2019/12/18/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E8%90%BD%E5%9C%B0%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF\">微前端时代思考与实践</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/fy3qri\">你可能并不需要微前端</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/rhduwc\">微前端的核心价值</a></p>","fields":{"readingTime":{"text":"11 min read"}},"frontmatter":{"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":7,"pageCount":16,"additionalContext":{"pageAllCount":95}}},
    "staticQueryHashes": []}