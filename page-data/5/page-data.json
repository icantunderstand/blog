{"componentChunkName":"component---src-templates-index-js","path":"/5","result":{"pageContext":{"pageAllCount":89,"group":[{"node":{"id":"bf1c7d29-cf60-5ac9-b56f-e0daabe2565e","html":"<h2><a href=\"https://h3manth.com/ES2022/\">ES2022 Features!</a></h2>\n<p>这篇文章介绍ES2022的Features。</p>\n<h2><a href=\"https://mikevdv.dev/blog/2022-06-23-stop-the-screen-going-to-sleep-with-javascript\">Stop The Screen Going To Sleep With JavaScript</a></h2>\n<p>这篇文章介绍WakeLock api的使用方法。WakeLock用于防止用户屏幕变暗或者锁屏。<a href=\"https://github.com/richtr/NoSleep.js/\">NoSleep.js</a>就是封装了WakeLock的能力来实现对应的功能.</p>\n<p>NoSleep功能实现:</p>\n<ul>\n<li>在支持wakeLock的设备上使用wakeLock</li>\n<li>在老的ios设备上  通过设置当前href和window.stop的定时器来激活页面</li>\n<li>其他情况通过设置一个循环播放的video标签来实现</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/wbkd/react-flow\">react-flow</a></h3>\n<p>react绘制图表和流程图的工具库</p>\n<h2>想法</h2>\n<h3>关于前端页面设计</h3>\n<ul>\n<li>作为前端开发似乎很容易直接从页面的角度去考虑实现，因为接触的UI就是最直观的图形输入。但是页面不光是简单的UI展示，后面还承载着数据的流动。从数据流去思考业务的逻辑和设计实现页面和业务逻辑的分离。数据承接逻辑，页面承接UI渲染组合能更好的服务于页面的扩展。</li>\n</ul>\n<h3>react hooks的理解</h3>\n<p>hooks是react暴露给外部的接口。这个是react增加hooks提供的一个比较重要的能力。比如react query通过hooks的能力桥接了queryClient.</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/pierpo/react-archer\">react-archer</a>源码分析</h3>\n<p>react-archer通过箭头线绘制React节点之间的关联关系。它的实现主要:</p>\n<ul>\n<li>维护全局的节点关联关系(逻辑抽象 封装)</li>\n<li>解耦节点渲染和箭头线渲染(解耦)</li>\n</ul>\n<h4>节点关系处理逻辑</h4>\n<pre><code>    // 子节点注册逻辑\n    const registerTransitions = (newRelations: Array&#x3C;RelationType>) => {\n        // 格式化节点配置\n        const newSourceToTarget = generateSourceToTarget(id, newRelations);\n        assertContextExists(context);\n        // 更新全局节点配置\n        context.registerTransitions(id, newSourceToTarget);\n    }\n\n    // 根节点更新逻辑\n    const _registerTransitions = useCallback(\n        (elementId: string, newSourceToTargets: SourceToTargetType[]): void => {\n            // 节点关系在根节点中通过useState进行更新维护 触发组件更新\n            setSourceToTargetsMap((previousValue) => ({\n                ...previousValue,\n                [elementId]: newSourceToTargets,\n            }));\n        },\n        [],\n    );\n</code></pre>\n<h4>箭头渲染逻辑</h4>\n<p>在根组件中通过SvgArrows渲染节点连接逻辑</p>\n<pre><code>// 遍历节点关系数据 依次渲染\n{getSourceToTargets(props.sourceToTargetsMap).map((currentRelation) => (\n    &#x3C;AdaptedArrow\n      key={JSON.stringify({\n        source: currentRelation.source,\n        target: currentRelation.target,\n      })}\n      source={currentRelation.source}\n      target={currentRelation.target}\n      label={currentRelation.label}\n      style={currentRelation.style || {}}\n      startMarker={props.startMarker}\n      endMarker={props.endMarker}\n      endShape={props.endShape}\n      strokeColor={props.strokeColor}\n      strokeWidth={props.strokeWidth}\n      strokeDasharray={props.strokeDasharray}\n      noCurves={props.noCurves}\n      lineStyle={props.lineStyle}\n      offset={props.offset}\n      parentCoordinates={parentCoordinates}\n      refs={props.refs}\n      uniqueId={props.uniqueId}\n    />\n))}\n\n// 使用getBoundingClientRect和配置项计算绘制箭头的位置 最后使用svg进行关联线的绘制\nexport const getPointCoordinatesFromAnchorPosition = (\n    position: AnchorPositionType,\n    index: string,\n    parentCoordinates: Vector2,\n    refs: Record&#x3C;string, HTMLElement>,\n): Vector2 => {\n    const rect = getRectFromElement(refs[index]);\n\n    if (!rect) {\n        return new Vector2(0, 0);\n    }\n\n    const absolutePosition = computeCoordinatesFromAnchorPosition(position, rect);\n    return absolutePosition.substract(parentCoordinates);\n};\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null}}},{"node":{"id":"268dcea6-4865-5b5f-a888-e8af729278ed","html":"<p>本文梳理axios中使用CancelToken来实现中断请求的源码实现.\n(CancelToken已经是deprecated, axios已支持AbortController实现相应的功能)</p>\n<h2>简单使用</h2>\n<pre><code>    const CancelToken = axios.CancelToken;\n    // 创建cancelToken\n    const source = CancelToken.source();\n\n    axios.get('/user/12345', {\n        // 请求的时候 传入创建的cancelToken\n        cancelToken: source.token\n    }).catch(function (thrown) {\n        if (axios.isCancel(thrown)) {\n            console.log('Request canceled', thrown.message);\n        } else {\n            // handle error\n        }\n    });\n\n\n    // 调用cancelToken的cancel方法 取消请求\n    source.cancel('Operation canceled by the user.');\n</code></pre>\n<p>上面是axios官网的上使用CancelToken的例子，可以看到通过将创建的cancelToken传入对应的请求对象，就实现了请求控制能力暴露给外部的能力。</p>\n<h2>源码分析</h2>\n<p>XMLHttpRequest支持使用abort方法实现请求的终止，axios底层封装了XMLHttpRequest来实现请求的处理，通过将调用abort方法的能力暴露给外部就实现了请求中断的控制。axios引入了cancelToken来实现这个过程的解耦。下面从具体的源码来看实现的过程</p>\n<h3>创建cancelToken对象</h3>\n<pre><code>// 调用source方法 生成CancelToken 导出token和取消请求的cancel方法\nCancelToken.source = function source() {\n    var cancel;\n    var token = new CancelToken(function executor(c) {\n        cancel = c;\n    });\n    return {\n        token: token,\n        cancel: cancel\n    };\n};\n\nfunction CancelToken(executor) {\n    if (typeof executor !== 'function') {\n        throw new TypeError('executor must be a function.');\n    }\n\n    var resolvePromise;\n    // 设置CancelToken的promise函数\n    this.promise = new Promise(function promiseExecutor(resolve) {\n        resolvePromise = resolve;\n    });\n\n    var token = this;\n    // cancel函数的执行逻辑 在调用cancel接口的时候 执行下面的逻辑\n    executor(function cancel(message) {\n        if (token.reason) {\n            // Cancellation has already been requested\n            return;\n        }\n\n        token.reason = new Cancel(message);\n        resolvePromise(token.reason);\n    });\n}\n</code></pre>\n<h3>cancelToken与XMLHttpRequest绑定</h3>\n<pre><code>    // 代码是axios封装XMLHttpRequest的部分逻辑\n    if (config.cancelToken) {\n        // 如果传入的配置有cancelToken 就调用cancelToken的promise方法 \n        // 通过promise实现控制流的流转 调用cancelToken方法的时候 将resolve时机暴露给cancelToken\n        // 调用cancelToken的cancel方法时,resolve了当前的promise，控制流程回到当前的后续流程，执行request.abort()从而完成请求的终止\n        config.cancelToken.promise.then(function onCanceled(cancel) {\n            if (!request) {\n                return;\n            }\n\n            request.abort();\n            reject(cancel);\n            // Clean up request\n            request = null;\n        });\n    }\n\n    if (!requestData) {\n        requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n</code></pre>\n<p>通过对实现流程的源码梳理，在类似的功能中可以利用promise来完成流程的控制。</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"axios的cancel功能源码解读","date":"2022-06-22","tags":"JavaScript","path":"/axios-cancel","top":null,"summary":null}}},{"node":{"id":"bdbed110-909c-577e-9652-4e22fb148271","html":"<h2><a href=\"https://michel.codes/blogs/ui-as-an-afterthought\">UI AS AN AFTERTHOUGHT</a></h2>\n<p>这篇文章介绍作者对UI框架和状态管理的思考。在React中开发者通常会在组件中处理业务逻辑，这样导致UI和数据无法解耦。文章中的方式是让React做比较纯粹的渲染框架，业务逻辑组织在全局store中.</p>\n<h2><a href=\"https://mmazzarolo.com/blog/2022-02-16-track-down-the-javascript-code-responsible-for-polluting-the-global-scope/\">Track down the JavaScript code responsible for polluting the global scope</a></h2>\n<p>文章提供了基于ES6 proxy查找全局变量污染的方案</p>\n<h2><a href=\"https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md\">useEvent RFC</a></h2>\n<p>相关文章\n<a href=\"https://typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/\">What the useEvent React hook is (and isn't)</a><br>\nreact增加了useEvent提案，使用场景能帮我们缓存一个函数的回调。主要用于解决如下的问题:</p>\n<ol>\n<li>通常的场景在组件中声明中的函数会因为依赖项的问题导致在渲染的时候函数会新生成引用，这样在使用该函数的子组件就会触发重新渲染。</li>\n<li>react hooks的依赖解耦 比如在一个effect hook中有两段业务逻辑，这样就需要把两段业务逻辑的依赖都加入到effect hook的依赖中，导致effect执行不符合预期。</li>\n</ol>\n<p>useEvent简化实现如下:</p>\n<pre><code>    function useEvent(handler) {\n        const handlerRef = useRef(null);\n\n        // In a real implementation, this would run before layout effects\n        useLayoutEffect(() => {\n            handlerRef.current = handler;\n        });\n\n        return useCallback((...args) => {\n            // In a real implementation, this would throw if called during render\n            const fn = handlerRef.current;\n            return fn(...args);\n        }, []);\n    }\n</code></pre>\n<p>useEvent可以看出是官方的解决前面提到问题的方案，在往前走一会，有如下的一些思考:</p>\n<ol>\n<li>是否需要一个不变的callback => 性能 vs 代码复杂度</li>\n<li>组件是否做了组件该做的事 => 渲染和业务逻辑的设计</li>\n</ol>\n<h2><a href=\"https://www.youtube.com/watch?v=NZoRlVi3MjQ\">The Story of Concurrent React </a></h2>\n<p>视频介绍react Concurrent发展的过程</p>\n<h2><a href=\"https://www.developerway.com/posts/react-key-attribute\">React key attribute: best practices for performant lists</a></h2>\n<p>文章介绍React组件中key使用的注意事项</p>\n<h2><a href=\"https://www.robinwieruch.de/react-hook-detect-click-outside-component/\">React Hook: Detect Click outside of Component</a></h2>\n<p>文章介绍如何实现一个自定义的hook来监听组件外的点击</p>\n<h2><a href=\"https://www.robinwieruch.de/web-applications/\">Web Applications 101</a></h2>\n<p>文章介绍web应用前端技术的发展过程，从最开始的web1.0到web2.0娓娓道来。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/timc1/kbar\">kbar</a></h3>\n<p>kbar是一个给站点提供快捷操作的工具</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null}}},{"node":{"id":"b1129eb4-7e02-5c11-a5be-9651c06a747d","html":"<h2><a href=\"https://timothygu.me/es-howto/\">How to Read the ECMAScript Specification</a></h2>\n<p>这篇文章介绍如何阅读ECMAScript规范的一些思路，文章中有对规范章节内容的整体划分和规范写法的例子解读.规范比较难啃，可以通过例子熟悉规范的写法，在自己需要了解相关内容的时候去阅读规范</p>\n<h2><a href=\"https://dev.to/this-is-learning/conquering-javascript-hydration-a9f\">Conquering JavaScript Hydration</a></h2>\n<p>前端框架的服务端渲染可以在服务端输出组件的内容(html, data-fetch)，一定程度上加快FCP(First Contentful Paint).在用户侧浏览器根据服务端提供的内容执行前端脚本完成事件的绑定和组件相关逻辑的执行，这个过程称为Hydration(注水)。在Hydration过程中页面仍然是不可交互的，造成了页面可交互的假象。所以尽量减少在Hydration中执行的逻辑是优化性能的一个方向。这篇文章给出了这个方面的一些思考。</p>\n<h2><a href=\"https://www.chakshunyu.com/blog/a-fundamental-guide-to-react-suspense/\">A Fundamental Guide To React Suspense</a></h2>\n<p>这篇文章详细地介绍的React中使用Suspense解决问题的背景和优点。</p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍列举了React中一些通用的解决方案和工具库，包括状态管理、项目结构、代码规范等。</p>\n<h2><a href=\"https://uniqname.medium.com/why-i-avoid-async-await-7be98014b73e\">Why I avoid async/await</a></h2>\n<p>这篇文章介绍了作者对使用async/await的一些思考，主要的观点心智的转换和写法上的比较。async/await表面上将异步代码转换成同步代码的写法一定程度上改变了代码的运转模式。</p>\n<h2>ECMAScript规范</h2>\n<h3><a href=\"https://2ality.com/2022/03/properties-of-primitives.html\">How do primitive values get their properties?</a></h3>\n<p>这篇文章介绍ECMAScript语法层面上对初值的封装逻辑、属性的获取逻辑、方法的调用逻辑。</p>\n<h3><a href=\"https://github.com/tc39/proposal-type-annotations\">proposal-type-annotations</a></h3>\n<p>tc39新增Type Annotations的proposal,现在处于stage 1阶段。未来有可能javascript直接支持类型定义，可以理解ECMAScript在吸收javascript超集的优点。</p>\n<h3><a href=\"https://2ality.com/2022/04/shadow-realms.html#shadowrealm.evaluate()\">ShadowRealms – an ECMAScript proposal for a better eval()</a></h3>\n<p>这篇文章对ShadowRealms proposal进行了详细的介绍，现在处于stage 3阶段。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/nolimits4web/atropos\">atropos</a></h3>\n<p>atropos是一个做3D触摸特效的动画库</p>\n<h3><a href=\"https://stuk.github.io/jszip/\">JSZip</a></h3>\n<p>JSZip是一个JavaScript操作zip文件的库</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null}}},{"node":{"id":"4c1cd05d-9c62-5dd4-ab31-4f1ca0a7aee3","html":"<h2><a href=\"https://monorepo.tools/\">Understanding Monorepos</a></h2>\n<p>这篇文章通过对Monorepo/Polyrepo(多仓库模式)、实现Monorepo的工具进行对比，对使用Monorepo模式进行开发有参考价值。</p>\n<ol>\n<li>Monorepo是什么: Monorepo在主体仓库中组合了多个子仓库并且这些子仓库的功能是相关联的,对应的例子可以参考<a href=\"https://github.com/facebook/react\">react</a>项目的仓库</li>\n<li>为什么使用Monorepo: Monorepo在组织关联业务代码上有优势，能减少代码复用、技术统一、开发调试中的问题</li>\n</ol>\n<p>关于Monorepos和Polyrepo的思考可以参考这篇文章<a href=\"https://earthly.dev/blog/monorepo-vs-polyrepo/\">Monorepo vs Polyrepo</a></p>\n<h2><a href=\"https://www.modularmanagement.com/blog/what-is-a-good-modular-system\">What is a Good Modular System?</a></h2>\n<p>这篇文章介绍了系统设计的思考点</p>\n<ul>\n<li>模块的功能界定  通过引入模块系统可以降低系统的复杂性，提高系统的灵活性,但是对于引入的模块功能的界定划分需要考量。如果功能没有界限好会导致功能代码从一个位置移动到另一个位置增加了模块维护的复杂度。比如之前的中台概念，需要划分好中台的功能才能更好的实现中台的能力，拆分出模块系统一方面做得更多去帮助系统更好，一方面也要思考如果做得更少去实现最初的目标</li>\n<li>生命周期 功能的稳定和灵活性能提高模块的生命周期</li>\n<li>模块收益的衡量标准</li>\n</ul>\n<p><img src=\"weeklyReport22/modular-value.png\" alt=\"模块收益衡量标准\"></p>\n<p>通过模块衡量的公式，在进行模块系统设计的时候可以有以下的考虑:</p>\n<ol>\n<li>平台的功能边界考量\n<ol>\n<li>不是越少越好，前期的投入能力后期带来收益</li>\n<li>前期的忽视需要后续弥补，要仔细思考</li>\n<li>用小范围的能力边界限制实现整体的灵活扩展</li>\n</ol>\n</li>\n<li>整体和部分的考量\n<ol>\n<li>不用一步到位，部分功能提升到独立的系统也能产生比较大的价值，后期再进行统一</li>\n<li>在资源可能的情况下，相关的依赖系统要统一升级</li>\n</ol>\n</li>\n<li>从长期的视角去看系统的模块设计 从现在的能力出发结合系统未来的发展诉求去做系统设计(能力建设)，这个角度的考虑也是在为未来打地基</li>\n</ol>\n<p>对于模块系统的介绍可以参考这篇文章<a href=\"https://www.modularmanagement.com/blog/all-you-need-to-know-about-modularization\">All You Need to Know About Modularization</a>,模块的实现应该在部分能力抽象的情况下实现系统整体的灵活性</p>\n<p><img src=\"weeklyReport22/modular-define.png\" alt=\"模块化系统的定义\"><br>\n模块化系统能带来效率、灵活度、敏捷的特点。</p>\n<ol>\n<li>效率 模块的复用/功能的组装  这里可以通过比喻装配式建筑来理解,通过对预制模块在工地快速的组装就快速完成了建筑的装配。</li>\n<li>灵活性 基础模块能快速的组装出新的功能模块/通过统一的接口设计能快速的实现模块的功能替换</li>\n<li>敏捷性 由于基础模块的拆分，通过基础模块的改变就可以快速地影响整个系统</li>\n</ol>\n<h2><a href=\"https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd\">Deep dive into React Native’s New Architecture</a></h2>\n<p>这篇文章通过React Native前后架构的对比对新旧架构进行了介绍</p>\n<h2><a href=\"https://kentcdodds.com/blog/javascript-to-know-for-react\">JavaScript to Know for React</a></h2>\n<p>这篇文章介绍了React中JavaScript的一些常用的语法，比如模板字符串、可选链、空值合并预算符等</p>\n<h2><a href=\"https://blog.bitsrc.io/some-reasons-for-disliking-react-hooks-80f1e18eb9b3\">Some reasons for disliking React hooks</a></h2>\n<p>这篇文章作者介绍了使用react hooks的优缺点</p>\n<ul>\n<li>优点 hooks可以更好实现代码的复用组合/逻辑集中</li>\n<li>缺点 hooks的写法上有上手成本和调试成本，容易引发一些bug，还有不要过于过度使用hooks.hooks的调用方式是通过数组的方式调用函数，过多或者依赖关系复杂的hooks会降低页面的性能</li>\n</ul>\n<h2><a href=\"https://blog.bitsrc.io/inversion-of-control-with-react-584533e49245\">Build Decoupled React Components with Inversion of Control</a></h2>\n<p>这篇通过例子的方式介绍通过反转控制的方式解耦组件的实现来应对未来逻辑的变更</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"2022-3-1-前端快报","date":"2022-03-07","tags":"前端快报","path":"/2022-3-7","top":null,"summary":null}}},{"node":{"id":"983124c1-808b-5e13-bea1-17907d6cd08f","html":"<p>这里记录下2022读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2022年已阅读: 40本</p>\n<p>2022读书感悟:\n最开始以为读书能看懂世界，觉得能增加所谓的阅历，其实发现多个看世界的视角就好</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>《半小时漫画历史系列》- 陈磊</h2>\n<h3>推荐指数 5</h3>\n<p>原来发现历史是这么有趣，原来晦涩的朝代故事在笔者轻松的表达下竟然那么引人入胜，非常适合在闲暇的时候当历史简版读物来看。</p>\n<h2>《动物农场》- 乔治·奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>经典之作。这本书描写了动物农场的一场反抗活动，对现实社会有影射意义，思考我们是不是也在一个农场中，只是压迫的程度大小，要跳出来看自己的生活。</p>\n<h2>《1984》- 乔治.奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>是看完动物农场才看的《1984》. 书中塑造了一种恐怖绝望的氛围会跟着主人公体验到从拥有希望到绝望的过程，在小说的故事中文明、历史似乎都可以被改写。读完会有疑惑就是书中描绘的社会是否会在现实中呈现，如果生活在那样的社会应该是十分的压抑的。</p>\n<h2>《为什么是中国》- 金一南</h2>\n<h3>推荐指数 4</h3>\n<p>这本书主要介绍中国近代以来的发展历史，其实作为中国人会感觉到自豪，中国在社会实践上走的是一条充满实践的道路</p>\n<h2>《胜者思维》- 金一南</h2>\n<h3>推荐指数 4.5</h3>\n<p>本书中金一南通过对中国历史发展从军事的角度进行总结，一些思路在其他的领域也很有价值，比如领导者的领导作用、权力的下放与担责</p>\n<h2>《认知觉醒: 开启自我改变的原动力》- 周岭</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中的对思维方式表达改变了我之前对思维方式的思考，思维是可以训练，我们对自己也不应该固步自封，很推荐看这本。</p>\n<h2>《柳林风声》- 肯尼斯·格雷厄姆</h2>\n<h3>推荐指数 4.5</h3>\n<p>这是一本适合大人和孩子一起看的童话书，书中的小动物形象跃然纸上，有的时候你会为书中的蛤蟆扼腕叹息，认为它罪有应得，会喜欢上对人和善的鼹鼠。在阅读的过程中仿佛你就进入了这个童话的世界，跟着动物们一起探索，历险。</p>\n<h2>《时间的形状:相对论史话》- 汪洁</h2>\n<h3>推荐指数 5</h3>\n<p>非常通俗易懂的科普读物 作者通过讲故事的方式把比较硬核的理论通俗易懂地讲出来。了解到相对论等理论的发展过程,发现人类的探索欲也觉得人类很渺小.这是一本充满科学内核的科普“小说”。称它为小说是因为你会被一个个故事所吸引。非常推荐</p>\n<h2>《宇宙的琴弦》- 格林</h2>\n<h3>推荐指数 3.5</h3>\n<p>弦论的科普读物。书中的论证的过程和思考的方式有一定的启发作用</p>\n<h2>《中国新基建：未来布局与行动路线》</h2>\n<h3>推荐指数 3.5</h3>\n<p>这本书比较全面地介绍了新基建的方向、图谱、路径。需要意识到与别人的差距也要切实的看到中国的进度，建立中国自信</p>\n<h2>《花猫三丫上房了》 - 叶广岑</h2>\n<h2>《土狗老哥闯祸了》 - 叶广岑</h2>\n<h2>《耗子大爷起晚了》- 叶广岑</h2>\n<h3>推荐指数 4.5</h3>\n<p>非常生动的童年故事，读起来会有很多温馨的瞬间。不是童话却有童话的感觉</p>\n<h2>《这就是中国: 走向世界的力量》 - 张维为</h2>\n<h3>推荐指数 4.5</h3>\n<p>这本书的内容很多，值得反复阅读。主要包括我们是怎么崛起的、我们为什么会崛起、我们的制度优势、需要建立中国自信(有自己的视角看问题和解读问题，建立自己的话语体系)等。在开始阅读的时候会觉得鸡血貌似多了一点，在逐渐阅读大部分后发现自己之前的一些想法不够成熟。书中的视角是从国家的角度来阐释发展，其实映射到个人也有一定的价值。非常推荐。</p>\n<h2>《超越期待：松浦弥太郎的人生经营原则》- 松浦弥太郎</h2>\n<h3>推荐指数 2</h3>\n<p>书的内容围绕着作者的人生态度和处事原则的细致总结，读起来相对来说缺少面的陈述，不推荐</p>\n<h2>《献给阿尔吉侬的花束》 - 丹尼尔·凯斯</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完有些伤感，小说通过日记的方式叙述查理从不聪明到聪明又回归到愚钝的状态，作者对心理变化的描述入微，读起来感觉在跟查理经历着这一切。这本书有许多的现实反射，比如</p>\n<ul>\n<li>查理的妈妈小时候对查理的不认同，导致查理性格上的讨好和迫切的希望获得别人的认可，可见在孩子幼年的时候塑造一个健全的人格的重要性</li>\n<li>如何接受和认识自身的问题 在没变聪明之前查理过得很开心，在经历了变聪明又变不聪明之后查理的心态无法回到之前的状态，这里也情有可原。文中有两个查理体现在聪明程度的差异，在我们自身上是否在其他方面也有另一个查理呢，在暗处观察着自己。</li>\n</ul>\n<h2>《西方哲学史:从古希腊到当下》- 奎纳尔·希尔贝克 尼尔斯·吉列尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>整本书比较详细的描写了人类历史发展阶段的哲学思考过程.我们现在的社会发展成当前的模式是在前人的思考基础上的,从这个角度去阅读和理解本书是一个不错的角度</p>\n<h2>哪有没时间这回事(白金版) - 纪元</h2>\n<h3>推荐指数 3</h3>\n<p>对时间的管理上有一定的启发</p>\n<h2>聪明的投资者(第四版) - 本杰明·格雷格姆 贾森·兹威格</h2>\n<h3>推荐指数 4.5</h3>\n<p>价值投资的观点并不过时。书中主要介绍格雷厄姆对价值，对投资的一些思考。</p>\n<h2>股票大作手回忆录 埃德温·勒菲弗</h2>\n<h3>推荐指数 3.5</h3>\n<p>作为利弗莫尔一生在”投机“生涯的回忆录，记录视角上会感觉一个经历了大起大落的人在你耳边叙述他的一生。</p>\n<h2>时间尽头的咖啡馆 约翰·史崔勒基</h2>\n<h3>推荐指数 4</h3>\n<p>一本简短的小说，通过故事的方式引领你的思考-关于生命的意义。找到问题的答案仍然需要自己的积极思考</p>\n<h2>斯坦福极简经济学 蒂莫西·泰勒</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中通过简单的例子阐述宏观和微观经济学的基本概念，读起来兴趣盎然。经济学有助于我们改变对世界的认识，推荐这本。</p>\n<h2>养育你内心的小孩 丛非从</h2>\n<h3>推荐指数 4</h3>\n<p>这本书从心理学的角度上介绍了安全、自由、价值、意义、亲密等对行为产生的影响。我们对于外界的行为起因是我们的内心有一定的冲突，要不停的认识自己。</p>\n<h2>火星编年史 雷·布拉德伯里</h2>\n<h3>推荐指数 4.5</h3>\n<p>很喜欢作者对人类文明发展的克制表达，是一本有诗意却有些悲凉色彩的科幻小说</p>\n<h2>邓小平时代 傅高义</h2>\n<h3>推荐指数 4.5</h3>\n<p>对历史的细节有了更多的了解。邓爷爷一辈子起起伏伏，一直在为中国发展贡献着力量，阅读过程中会感觉一个亲切而坚定的人跃然纸上，作者在写作本书的时候对历史的细节有足够的求证力图还原真实的历史。阅读本书了解到了什么是中国特色社会主义制度，为什么会有经济特区，发展才是硬道理等等，祖国的今天得来不易，以史为鉴才能走得更好，感恩前人。</p>\n<h2>法治的细节</h2>\n<h2>圆圈正义: 作为自由前提的信念  罗翔</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完这两边书让我对法治的概念有了基本的思考，也了解到要接受自己的局限性，多思考。</p>\n<h2>李光耀观天下 李光耀</h2>\n<h3>推荐指数 4</h3>\n<p>跟随李光耀先生的视角看了一次世界.在看待中国问题上还是存在一些西方的视角不过也的确看到了发展中出现的问题。在其他区域的发展上从政治经济上看的很广,有全局的视野</p>\n<h2>鼠疫 加缪</h2>\n<h3>推荐指数 4.5</h3>\n<p>在新冠疫情的背景下看这本书更加有感触。书中散发着作者对于生活坚定的力量。</p>\n<h2>用经济思维看懂世界格局·亚欧大陆经济整合--新体系伟大力量的源泉 徐伯赢</h2>\n<h3>推荐指数 5</h3>\n<p>本书从经济学的角度来探讨世界格局，覆盖了美、欧、中东、东南亚、日本、中国在经济领域的历史，读起来兴趣盎然。在探讨的视角是也比较宏观。</p>\n<ul>\n<li>日本和东南亚就像今天中国发展的镜子，如何解决房地产泡沫问题、如何寻找经济发展替换地产经济的问题，发展方式的选择问题(合作共赢还是胜者通吃)、金融领域的开放问题等，有不错的借鉴意义</li>\n<li>欧债危机暴露了很多问题，看似表面团结的欧盟(英国与欧洲大陆国家，欧洲大陆核心国与非核心国)由于国家经济政策不同和整个欧盟产业结问题容易产生一些隐藏的问题。欧盟似乎应该在更加统一的财政政策和独立于美国的政策上发力</li>\n<li>对比其他国家和区域，我们的发展路线是在全球化背景下实践一条合作发展，互利共赢的道路，虽然我们现在也面临很多的问题(法制的建设等)，希望这些问题会越来越好，附上这本书结尾的话: 士不可以不弘毅，任总而道远</li>\n</ul>\n<h2>PDCA循环工作法 冈村拓郎</h2>\n<h3>推荐指数 3.5</h3>\n<p>PDCA循环工作法的实践书籍，对于一些细节和思考上有收获。适合快读</p>\n<h2>纳闷集 匡扶</h2>\n<h3>推荐指数 3</h3>\n<p>漫画集，通过漫画和搞笑的表达方式叙述了温暖的故事</p>\n<h2>战胜华尔街 彼得·林奇 约翰·罗瑟查尔德</h2>\n<h3>推荐指数 4</h3>\n<p>之前读过股票大作手回忆录-利弗莫尔的回忆录，是第三方视角记录的有些内容就会存在失真，收获有限。这本书是彼得·林奇个人写的自传，本书从头到尾都在基于他投资选股的内容进行阐述，在对周期股的概念、长期价值投资的坚定、选股思考的逻辑都有不错的收获</p>\n<h2>自洽: 在不确定的日子里向内看 史欣悦</h2>\n<h3>推荐指数 3.5</h3>\n<p>自洽是一个向内沟通的过程，自己之前有段时间工作相对忙碌，在那段时间里很少的考虑到自己本身的一些想法，被一件一件推着往前走。比较缺少对做的事情的一些思考。最近时常会蹦出来一些想法当时如果这么做会更好。在快的节奏里面如果保持自己的节奏(内心)很重要，需要不断的跟自己沟通，丰富自己的认知。</p>\n<h2>看懂世界格局的第一本书 王伟</h2>\n<h3>推荐指数 4</h3>\n<p>通过本书了解到了很多历史的细节和全面的视角,对了解世界格局和经济很有帮助.比如日本、苏联、东南亚国家的发展都对现在有借鉴价值</p>\n<h2>认知世界的经济学 珍大户</h2>\n<h3>推荐指数 4</h3>\n<p>作为入门读物,在需求供给、弹性、利率等方面通过例子讲解的很清晰.书中有些例子有些刻意为之但是瑕不掩瑜</p>\n<h2>随风去野 白关</h2>\n<h3>推荐指数 4</h3>\n<p>跟随生动的插画与作者一起经历了骑行过程中的人、事、景色，是一次不错的体验</p>\n<h2>海龟交易法则 柯蒂斯·费思</h2>\n<h3>推荐指数 3</h3>\n<p>本书是作者个人的经历介绍.海龟交易法阐述了在市场中交易的基本原则,控制风险、控制仓位、止损、止盈等.从书中的收获是在市场中要掌握自己的优势，发挥自己的优势。 建议关键章节详细看</p>\n<h2>中国近代通史(全10册) - 中国社会科学院近代史研究所</h2>\n<h3>推荐指数 5</h3>\n<p>从鸦片战争到中华人民共和国成立，这本书详细的介绍了中国近代史的细节。在阅读的过程中会有历史在眼前重演的错觉，会有遗憾、不解、叹息等情绪。历史仿佛能启发人的思考，以史为鉴可以正衣冠应该说的就是这个道理，对近代史感兴趣的话推荐这本书</p>\n<h2>荒原狼 赫尔曼·黑塞/涂媛媛译</h2>\n<h3>推荐指数 3.5</h3>\n<p>书中的荒原狼可以理解是黑塞本人或者自我抗争的一种表现，书中有很多光怪陆离的表达手法读起来还不错</p>\n<h2>局外人 加缪</h2>\n<h3>推荐指数 4</h3>\n<p>加缪的小说很像有人在你身边讲故事，通过平淡且扎实的叙事方式推进故事的演进</p>","fields":{"readingTime":{"text":"19 min read"}},"frontmatter":{"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":5,"pageCount":15,"additionalContext":{"pageAllCount":89}}},"staticQueryHashes":[]}