{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/5",
    "result": {"pageContext":{"pageAllCount":90,"group":[{"node":{"id":"8418a542-013e-52de-bd15-8927e0017b7f","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>单例模式</h2>\n<p>单例模式通过全局维护一个实例的方式来达到全局属性的共享和减少内存的占用。单例的简单实现如下:</p>\n<pre><code>    let instance;\n    let counter = 0;\n    class Counter {\n        constructor() {\n            if (instance) {\n                throw new Error(\"You can only create one instance!\");\n            }\n            instance = this;\n        }\n        getInstance() {\n            return this;\n        }\n        getCount() {\n            return counter;\n        }\n        increment() {\n            return ++counter;\n        }\n        decrement() {\n            return --counter;\n        }\n    }\n    const singletonCounter = Object.freeze(new Counter());\n    // 暴露给外部的单一实例\n    export default singletonCounter;\n</code></pre>\n<p>单例模式的优点也恰恰是他的缺点，由于全局属性的共享导致改动的全局污染问题、测试用例写法问题等。在react中全局的redux\\context store就是应用中的单例，store通过单向的数据流来规避单例的一些问题。</p>\n<h2>Proxy(代理)模式</h2>\n<p>代理模式通过为对象提供占位符来控制对象的访问。代理对象相当于中间人角色，可以在不改变被代理对象的接口的情况下扩展功能。在JavaScript中可以使用Proxy来实现代理的功能。</p>\n<pre><code>    const person = {\n        name: \"John Doe\",\n        age: 42,\n        nationality: \"American\"\n    };\n    const personProxy = new Proxy(person, {\n        // handler的get/set方法代理了被代理对象属性的访问方法\n        get: (obj, prop) => {\n            console.log(`The value of ${prop} is ${obj[prop]}`);\n            // 可以用Reflect修改代理对象的属性\n            Reflect.set(obj, prop);\n        },\n        set: (obj, prop, value) => {\n            console.log(`Changed ${prop} from ${obj[prop]} to ${value}`);\n            obj[prop] = value;\n            return true;\n        }\n    });\n    personProxy.name;\n    personProxy.age = 43;\n</code></pre>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"5分钟速读系列-单例模式/代理模式","date":"2022-11-01","tags":"设计模式","path":"/2022-11-singleton","top":null,"summary":null}}},{"node":{"id":"4cf57e5c-235a-5434-99e0-3ff79238a9aa","html":"<p>偶然间想起2021竟然没有过来总结，恍然间发现时间过的好快。这次提前来总结下，希望年终总结能成为每年的一个思考和沉淀的习惯。</p>\n<h2>工作</h2>\n<p>近两年经历了两次工作的变动，从字节离开 => 短暂的教育行业经历(3个月) => 现在的公司(也经历过一次内部的部门调整)。仔细回想自己应该有半年多的迷茫期或者比较空闲的状态，那段时间感觉十分地缺少自信，也是循环播放Unstoppable的一段时间。</p>\n<ul>\n<li>从字节离开的时候，leader有对工作去向和内心的想法疏解，记忆最深的一句话就是不要跟系统内改变不了的东西对抗，比如架构调整之类. 现在再回头看当时自己的确没有想明白当时的问题或者自己想要什么。在离开字节之前没有好好跟合作的伙伴都打个招呼，现在想起来很不成熟。总是觉得要走就要一个人偷摸的走。如果有机会可以改之前飞书的签名，我会写: 有缘再见，不如加个V 哈哈。</li>\n<li>短暂的教育行业经历略过</li>\n<li>在当前的公司经历过一次内部的调整，有过一小段时间的“空闲”。这段时间想明白了一件事就是要让自己的状态跟环境匹配，从小事中逐步的找到做事的状态，甚至整理xlsx表格这种小事也相当认真。自己在这段\"空闲\"的时候做了一个组内前端报警的工具，自己从想法到功能设计完善了整个工具的功能，是这段时间比较有意思的事情。</li>\n</ul>\n<h3>技术能力</h3>\n<ol>\n<li>回归到B端业务的开发 自己从B端到C端又回到了B端感觉经历了一个圈。想起之前面试字节面试官问我B端业务和C端业务的区别是啥。我当时很懵(没有准备/思考过这个问题)，现在在重新尝试回答下这个问题，有可能还是比较浅显的认知，后续有新的认知在回来check</li>\n</ol>\n<ul>\n<li>面向的用户不同， 决定着同一个业务形式的在B端和C端是两套不同的技术架构和业务发展模式。在进行技术储备和规划上就需要做更多的考虑。比如广告业务，在C端侧业务是如何将广告与人结合，转化。从产品上会考虑如何原生化、样式多样性、结合转化流程的简单性、趣味性、品牌价值(平台如何给广告主带来价值)、平台价值等，业务形态上流程短、迭代节奏快。在B端上就需要为C端的业务提供完成的配套流程，业务形态上要简单好用（减轻用户的理解成本/操作成本）、功能完善等。</li>\n<li>业务形态决定技术方案的选择思考点不同。C端薄的业务可以快速的试错。新技术方案的尝试(跨端)或者欠考虑的技术实现后期都有比较大的空间可以进行业务迭代。B端由于系统是一以贯之的，需要前期相对于C端业务要更加充分的进行技术方案的对比，当然在B端和C端都会产生技术债问题。</li>\n<li>B端和C端是可以进行良性互补。比如广告中的建站平台，就是客户侧对快，开发对效率有要求才产生的平台。</li>\n</ul>\n<ol start=\"2\">\n<li><a href=\"https://icantunderstand.github.io/blog/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\">前端快报</a> 月维度收录一些阅读的比较好的前端文章，算是对自己的一个督促。仔细考虑这一年对技术方面的学习是落后的。</li>\n</ol>\n<h3>工作心态</h3>\n<p>工作上慢慢的变的不那么急躁。从最开始的被UI支配的控制到现在改UI的时候心态很相对平静(改UI真的容易心态炸裂)。学会注意到工作中双方的认知差异。比如在UI实现上设计师是领域专家，那在实现上基于成本的考虑就可以以设计师的想法为主。</p>\n<h2>生活</h2>\n<h3>读书</h3>\n<p>在2020的年终总结上说要多读书，今年才开始系统的读书了<a href=\"https://icantunderstand.github.io/blog/book-list-2022\">读书目录2022</a>。有一次突然觉得好多事好像还看不懂，不明白，就不管三七二十一的读起来了。希望能一直读下去。</p>\n<h3>投资</h3>\n<p>尝试进行投资理财。发现只有上交到家庭的固定工资部分是真的“理财”，其他都是负理财。后续规划上会进行一些系统知识的学习。</p>\n<h3>家庭</h3>\n<p>貌似懂得了陪伴，但是这些方面做的还远不够。国庆老妈来北京逛了一圈。我作为一个在北京10多年的老北漂家人第一次来北京溜达实属惭愧。</p>\n<h2>思考</h2>\n<p>转眼已经30出了个小头了。距离不惑虽然还有些年龄的距离，但是距离不惑的状态还是有些差距。有好多事还没想明白，有好多事甚至都没曾想过。不过一个简单的想法就是要注重自己的价值和心理状态。持续的读书是想保证内心的富足。这个博客也希望能坚持下去，后续会做其他别的分享带来其他的价值</p>\n<h2>番外</h2>\n<p>写到中间的时候，发现<a href=\"https://mp.weixin.qq.com/s?__biz=MzUwOTk5NDI3OA==&#x26;mid=2247484174&#x26;idx=1&#x26;sn=123f7a9b633c3c786519e24f3f4b0072&#x26;chksm=f908f747ce7f7e51785450e91d9aa8c68f411f63935b162d9f19b4fea1cb9184ef10b30f3e7f#rd\">2021的流水账</a>记录在微信的公众号上了，这个博客没有同步。看了下比上次或许有一点进步就算是安慰了。</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"2022年终总结","date":"2022-10-20","tags":"年度总结","path":"/2022-summary","top":null,"summary":"2022年总结-回顾了工作、生活和自身的一些思考"}}},{"node":{"id":"9867eee0-87d3-5eb8-901e-4886bc0cd7cd","html":"<h2><a href=\"https://legendapp.com/open-source/legend-state/\">Making React fast by default and truly reactive</a></h2>\n<p>这篇文章通过介绍React中组件渲染优化的问题引出类mobx的状态库方案<a href=\"https://github.com/LegendApp/legend-state\">legend-state</a>,在底层的技术方案上跟mobx是相似的，通过监听observable值的变化来运行渲染函数。</p>\n<h2><a href=\"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/\">A (Mostly) Complete Guide to React Rendering Behavior</a></h2>\n<p>这篇文章比较详细的介绍了React组件渲染的细节，包括渲染的阶段、Fiber、渲染优化等。</p>\n<h2><a href=\"https://prateeksurana.me/blog/future-of-rendering-in-react/\">The future of rendering in React</a></h2>\n<p>这篇文章主要介绍基于react的页面渲染流程和渲染方式的优缺点。</p>\n<ol>\n<li>CSR(Client-side rendering)- 客户端渲染。这种渲染方式通过在客户侧的浏览器执行脚本来完成整个页面内容的生成和数据的加载。 这种方式可以通过CDN去优化JS脚本的加载，能有效的提交TTFB(Time To First Byte),但是由于页面和数据都是在客户端组装和渲染会影响用户的首次可交互时间和不方便做SEO优化。</li>\n<li>SSR(Server-side rendering)- 服务端渲染。这种渲染方式通过react提供的api在服务端组装数据和渲染页面内容。服务端渲染的优势在于有利于SEO优化，能有效的提供FCP(First Contentful Paint)和LCP(Largest Contentful Paint),劣势是服务端渲染会降低TTFB,但是可以通过一些手段去优化，比如\n<ul>\n<li>SSG(Static site generation)- 静态页面生成  将不依赖数据的页面提前进行预编译，在访问的时候直接将已编译好的页面内容返回</li>\n<li>ISR (Incremental static site generation)- 增量式页面生层 ISR为了解决SSG的对动态数据依赖和构建规模问题，可以在运行时动态的生成页面内容并存储</li>\n<li>Streaming SSR- 流式服务端渲染 主要使用node中的stream实现流式的返回服务端渲染的内容，能有效的提高TTFB</li>\n</ul>\n</li>\n</ol>\n<h2><a href=\"https://alexkondov.com/half-hour-to-learn-js/\">A Half-Hour to Learn JavaScript</a></h2>\n<p>这篇文章介绍JavaScript中的基础知识点，包括变量声明、闭包、this、new关键字、原型链、继承、异步调用(async await,Promise)、事件循环等，适合复习基础的时候浏览查缺补漏。</p>\n<h2><a href=\"https://2ality.com/2022/10/javascript-decorators.html\">JavaScript metaprogramming with the 2022-03 decorators API</a></h2>\n<p>这篇文章详细的介绍了JavaScript中装饰器的细节</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/google/zx\">zx</a></h3>\n<p>google的一个脚本工具，可以在脚本中写javascript，值得一试</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/SortableJS/Sortable\">Sortable</a>源码解读</h3>\n<p>Sortable是一个实现可拖拽列表的库，它提供了丰富的功能比如共享列表的拖拽、多条目的拖拽等。以下主要从两方面对Sortable的源码进行简单的分析，希望对功能库的设计有所思考</p>\n<ol>\n<li>插件机制</li>\n<li>拖拽功能实现</li>\n</ol>\n<h4>插件机制</h4>\n<ul>\n<li>插件能很好的实现功能的隔离。插件内功能逻辑自治，</li>\n<li>通过统一的接口提供接入和调用能力。便于后续功能的扩展</li>\n<li>通过组合插件，可以提供多版本的库</li>\n</ul>\n<h5>插件注册</h5>\n<pre><code>    //  通过mount方法调用PluginManager的mount来注册插件\n    Sortable.mount = function(...plugins) {\n        if (plugins[0].constructor === Array) plugins = plugins[0];\n\n        plugins.forEach((plugin) => {\n            if (!plugin.prototype || !plugin.prototype.constructor) {\n                throw `Sortable: Mounted plugin must be a constructor function, not ${ {}.toString.call(plugin) }`;\n            }\n            if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n            PluginManager.mount(plugin);\n        });\n    };\n</code></pre>\n<h5>触发插件</h5>\n<p>通过调用pluginEvent来触发插件执行的逻辑</p>\n<pre><code>    pluginEvent(eventName, sortable, evt) {\n        this.eventCanceled = false;\n        evt.cancel = () => {\n            this.eventCanceled = true;\n        };\n        const eventNameGlobal = eventName + 'Global';\n        plugins.forEach(plugin => {\n            if (!sortable[plugin.pluginName]) return;\n            // Fire global events if it exists in this sortable\n            if (\n                sortable[plugin.pluginName][eventNameGlobal]\n            ) {\n                sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n            }\n\n            // 触发对应插件上对应eventName的处理函数\n            // 比如MultiDrag plugin的drop方法就是通过pluginEvent('drop', this, { evt })触发\n            if (\n                sortable.options[plugin.pluginName] &#x26;&#x26;\n                sortable[plugin.pluginName][eventName]\n            ) {\n                sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n            }\n        });\n    },\n</code></pre>\n<h4>拖拽能力实现</h4>\n<p>拖拽能力主要实现是:</p>\n<ul>\n<li>初始化绑定根元素拖拽的dom事件监听函数</li>\n<li>根据事件触发顺序添加动画处理逻辑、插件调用逻辑、元素替换逻辑、配置的回调函数触发逻辑等</li>\n</ul>\n<h4>绑定事件监听函数</h4>\n<p>在<a href=\"https://lotabout.me/2018/HTML-5-Drag-and-Drop/\">HTML 5 Drag and Drop 入门教程</a>中有对html5中拖拽函数介绍。</p>\n<pre><code>    // 事件监听\n    if (!this.nativeDraggable || touch) {\n\t\tif (this.options.supportPointer) {\n\t\t\ton(document, 'pointermove', this._onTouchMove);\n\t\t} else if (touch) {\n\t\t\ton(document, 'touchmove', this._onTouchMove);\n\t\t} else {\n\t\t\ton(document, 'mousemove', this._onTouchMove);\n\t\t}\n\t} else {\n        // 注意这里传入的是this\n\t\ton(dragEl, 'dragend', this);\n\t\ton(rootEl, 'dragstart', this._onDragStart);\n\t}\n</code></pre>\n<h4>事件触发</h4>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\">addEventListener</a>的第二个参数listener可以是一个函数或者是一个带handleEvent函数的对象。在绑定监听函数的时候listener传入的是this,在触发回调的时候就会走入到handleEvent处理拖拽结束的函数逻辑</p>\n<pre><code>    handleEvent: function (/**Event*/evt) {\n        switch (evt.type) {\n            case 'drop':\n            case 'dragend':\n                // 拖拽结束的时候 执行逻辑\n                this._onDrop(evt);\n                break;\n\n            case 'dragenter':\n            case 'dragover':\n                if (dragEl) {\n                    this._onDragOver(evt);\n                    _globalDragOver(evt);\n                }\n                break;\n\n            case 'selectstart':\n                evt.preventDefault();\n                break;\n        }\n    },\n</code></pre>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"2022-10-1-前端快报","date":"2022-10-08","tags":"前端快报","path":"/2022-10-1","top":null,"summary":null}}},{"node":{"id":"5138f9c7-1e45-5332-b7f5-477d54a56248","html":"<h2><a href=\"https://www.joshwcomeau.com/react/usememo-and-usecallback/\">Understanding useMemo and useCallback</a></h2>\n<p>这篇文章介绍useMemo和useCallback</p>\n<ul>\n<li>useMemo可以实现组件内计算逻辑的拆分缓存能力，减少页面渲染时的计算和子组件重复渲染.需要考虑的是是否可以通过组件拆分或者计算逻辑的拆分来实现计算逻辑的优化.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/eef642c6e58030017ad568bf488a4430/d14c1/useMemo.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAARD/2gAIAQEAAT8hHP/aAAwDAQACAAMAAAAQAA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAADAQEAAAAAAAAAAAAAAAAAAREhcf/aAAgBAQABPxDKJZrOH//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"useMemo\"\n        title=\"useMemo\"\n        src=\"/blog/static/eef642c6e58030017ad568bf488a4430/a2510/useMemo.jpg\"\n        srcset=\"/blog/static/eef642c6e58030017ad568bf488a4430/0479a/useMemo.jpg 250w,\n/blog/static/eef642c6e58030017ad568bf488a4430/41099/useMemo.jpg 500w,\n/blog/static/eef642c6e58030017ad568bf488a4430/a2510/useMemo.jpg 1000w,\n/blog/static/eef642c6e58030017ad568bf488a4430/d14c1/useMemo.jpg 1234w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>useCallback用于保存函数的引用，保证在依赖不变的情况下复用之前的函数</li>\n</ul>\n<p>需要注意的是在开发中不要对hook过度使用，在关键的位置做好优化比如:</p>\n<ol>\n<li>使用useState定制的hook，返回的setter函数通过useCallback缓存</li>\n<li>全局context使用useMemo缓存减少渲染</li>\n</ol>\n<h2><a href=\"https://thisweekinreact.com/articles/useSyncExternalStore-the-underrated-react-api\">useSyncExternalStore - The underrated React API</a></h2>\n<p>这篇文章介绍react useSyncExternalStore的使用场景</p>\n<h2><a href=\"https://github.com/pubkey/broadcast-channel\">broadcast-channel</a></h2>\n<p>在<a href=\"https://www.smashingmagazine.com/2022/09/javascript-api-guide/\">JavaScript APIs You Don’t Know About</a>中提及到BroadcastChannel来实现跨页面间的通信。<a href=\"https://github.com/pubkey/broadcast-channel\">broadcast-channel</a>这个库通过封装BroadcastChannel、localStorage、indexedDB、node的socket来实现跨运行时的通信。</p>\n<h2><a href=\"https://2ality.com/2022/09/nodejs-overview.html\">An overview of Node.js: architecture, APIs, event loop, concurrency</a></h2>\n<p>这篇文章介绍node的架构、同步异步的api风格、通过例子介绍node中事件循环的模型。</p>\n<h2><a href=\"https://marmelab.com/blog/2022/09/20/react-i-love-you.html\">React I Love You, But You're Bringing Me Down</a></h2>\n<p>这篇文章介绍作者长期使用react的一些感受和痛点，有点观点很有共鸣。比如：</p>\n<ul>\n<li>context的渲染问题 是否能像redux的useSelector一样来优化渲染</li>\n<li>react引入的一些规则倒是代码写起来比较‘别扭’，不支持条件effect、forwardRef、hook的依赖等</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/AykutSarac/jsoncrack.com\">JSON Crack</a></h3>\n<p>JSON校验和结构可视化工具</p>\n<h3><a href=\"https://pemistahl.github.io/grex-js/\">grex-js</a></h3>\n<p>在线生成正则表达式的工具</p>\n<h2><a href=\"https://engineering.fb.com/2022/09/12/open-source/memlab/\">MemLab: An open source framework for finding JavaScript memory leaks</a></h2>\n<p><a href=\"https://github.com/facebookincubator/memlab\">MemLab</a>是一个分析前端脚本内存泄露的工具，使用puppeteer来执行页面操作进而分析页面的内存状态。</p>\n<h2><a href=\"https://github.com/naptha/tesseract.js#tesseractjs\">tesseract.js</a></h2>\n<p>tesseracts是一个视频图片中文字的前端库，可以支持node和浏览器场景</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-9-1-前端快报","date":"2022-09-21","tags":"前端快报","path":"/2022-9-1","top":null,"summary":null}}},{"node":{"id":"fd92a9b2-6634-513c-b581-0c6d7a60cd38","html":"<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-0-61fea500b180\">Frontend Web Performance: The Essentials [0]</a></h2>\n<p>这篇文章介绍前端页面渲染的过程，包括渲染的流程，优化的手段等。通过例子结合chrome的开发者工具给出优化的过程。</p>\n<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-1-cb6513e1c3a1\">Frontend Web Performance: The Essentials [1]</a></h2>\n<p>这篇文章介绍浏览器的事件循环，包括宏任务，微任务等，通过将微任务与宏任务结合的方式可以实现宏任务的拆分。</p>\n<h2><a href=\"https://www.toptal.com/javascript/10-most-common-javascript-mistakes\">The 10 Most Common JavaScript Issues Developers Face</a></h2>\n<p>这篇文章介绍了javascript中几个常见的问题点。比如this的确定、内存泄露、原型链等.</p>\n<h2><a href=\"https://www.robinwieruch.de/typescript-react-useref/\">TypeScript: React useRef Hook</a></h2>\n<p>介绍React useRef Hook的文章.\nReact提供了useCallback, useMemo来实现memoization能力，减少重复的计算。应该避免对应hook的滥用，在缓存大量计算逻辑的时候使用<br>\nuseImperativeHandle可以实现父组件对子组件的方法调用。在使用useImperativeHandle的时候思考是否可以将逻辑抽离到store层处理<br>\nuseRef可以用于存储值，改变useRef的值不需要重新渲染组件</p>\n<h2>工具</h2>\n<h3><a href=\"https://react-svgr.com/docs/what-is-svgr/\">SVGR</a></h3>\n<p>SVGR通过svgo优化，svg内容解析将svg转化成React组件使用</p>\n<h3><a href=\"https://github.com/thebuilder/react-intersection-observer\">react-intersection-observer</a></h3>\n<p>react-intersection-observer通过对IntersectionObserver的封装提供了react hook的方式来监听元素在视口中的位置</p>\n<h3><a href=\"https://github.com/pmndrs/react-spring\">react-spring</a></h3>\n<p>react实现spring动画的库</p>\n<h2>想法</h2>\n<h3>关于前端store设计</h3>\n<p>在<a href=\"https://icantunderstand.github.io/blog/2022-7-1\">上期前端快报</a>中聊到了前端的页面设计，要从数据逻辑去思考页面，实现数据逻辑和渲染逻辑的分离。\n在对前端store(View-Model)的设计上，可以从页面的角度，去拆分通用模块，页面级别模块实现更好的数据逻辑与渲染逻辑的隔离.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpElEQVQ4y51Ty07DMBDM/wvxAUj8CwckxBmpouJE2zRJ82iSPvxMB80GN6EBVDiMvLuxx7MTb2StxRjGGAHj4/GIpmkEVVWdY6XUZG9ANCYab3LO4XA4YLfbCUmSJBITrPP7QEhoiaNLdVy5WWstB7fbrWC9Xp9j1vszTsiM8TDmJPlEIdsk4jhGURSiLqhs21bWzWaDPM+htYIxDl2XoeveoPUe0bhVrnVdiwoeoFfMWffeS04v+Y1o2wZFUaNpHpCmt1Bq3isMZDxEFSQJnjEPXVA5VQeFVVUiz2nBE5S6h3PzQSE94+3L5VIU8iBJCRKNvabHQYhzHt638D6DtZ8tcwO9IVFZlqKMJLyAOTF+AQNCjX+8kzUKN7JNqsqyDPv9/qw44HvCnrR/Nj0iGp2mqYBKQkzSy/Yuh+A7RGx1sViId1TJdTabYbVaTabhGtKIftG7uu7fW1FUSJJMaj+N16+EXwsOzvERrybTczXhYK6GtYDWz8jzOyj1DmtPUv+HwjHhI8ryBs69whjI0Pd/8I+EYci9jwG8wNpC8uFJXEf4ASte1qZJXzjwAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"store设计\"\n        title=\"store设计\"\n        src=\"/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png\"\n        srcset=\"/blog/static/e6385772916f35fe16003bf9eb93be77/63868/storeDesign.png 250w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/0b533/storeDesign.png 500w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png 1000w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/187fa/storeDesign.png 1194w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-8-1-前端快报","date":"2022-08-05","tags":"前端快报","path":"/2022-8-1","top":null,"summary":null}}},{"node":{"id":"bf1c7d29-cf60-5ac9-b56f-e0daabe2565e","html":"<h2><a href=\"https://h3manth.com/ES2022/\">ES2022 Features!</a></h2>\n<p>这篇文章介绍ES2022的Features。</p>\n<h2><a href=\"https://mikevdv.dev/blog/2022-06-23-stop-the-screen-going-to-sleep-with-javascript\">Stop The Screen Going To Sleep With JavaScript</a></h2>\n<p>这篇文章介绍WakeLock api的使用方法。WakeLock用于防止用户屏幕变暗或者锁屏。<a href=\"https://github.com/richtr/NoSleep.js/\">NoSleep.js</a>就是封装了WakeLock的能力来实现对应的功能.</p>\n<p>NoSleep功能实现:</p>\n<ul>\n<li>在支持wakeLock的设备上使用wakeLock</li>\n<li>在老的ios设备上  通过设置当前href和window.stop的定时器来激活页面</li>\n<li>其他情况通过设置一个循环播放的video标签来实现</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/wbkd/react-flow\">react-flow</a></h3>\n<p>react绘制图表和流程图的工具库</p>\n<h2>想法</h2>\n<h3>关于前端页面设计</h3>\n<ul>\n<li>作为前端开发似乎很容易直接从页面的角度去考虑实现，因为接触的UI就是最直观的图形输入。但是页面不光是简单的UI展示，后面还承载着数据的流动。从数据流去思考业务的逻辑和设计实现页面和业务逻辑的分离。数据承接逻辑，页面承接UI渲染组合能更好的服务于页面的扩展。</li>\n</ul>\n<h3>react hooks的理解</h3>\n<p>hooks是react暴露给外部的接口。这个是react增加hooks提供的一个比较重要的能力。比如react query通过hooks的能力桥接了queryClient.</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/pierpo/react-archer\">react-archer</a>源码分析</h3>\n<p>react-archer通过箭头线绘制React节点之间的关联关系。它的实现主要:</p>\n<ul>\n<li>维护全局的节点关联关系(逻辑抽象 封装)</li>\n<li>解耦节点渲染和箭头线渲染(解耦)</li>\n</ul>\n<h4>节点关系处理逻辑</h4>\n<pre><code>    // 子节点注册逻辑\n    const registerTransitions = (newRelations: Array&#x3C;RelationType>) => {\n        // 格式化节点配置\n        const newSourceToTarget = generateSourceToTarget(id, newRelations);\n        assertContextExists(context);\n        // 更新全局节点配置\n        context.registerTransitions(id, newSourceToTarget);\n    }\n\n    // 根节点更新逻辑\n    const _registerTransitions = useCallback(\n        (elementId: string, newSourceToTargets: SourceToTargetType[]): void => {\n            // 节点关系在根节点中通过useState进行更新维护 触发组件更新\n            setSourceToTargetsMap((previousValue) => ({\n                ...previousValue,\n                [elementId]: newSourceToTargets,\n            }));\n        },\n        [],\n    );\n</code></pre>\n<h4>箭头渲染逻辑</h4>\n<p>在根组件中通过SvgArrows渲染节点连接逻辑</p>\n<pre><code>// 遍历节点关系数据 依次渲染\n{getSourceToTargets(props.sourceToTargetsMap).map((currentRelation) => (\n    &#x3C;AdaptedArrow\n      key={JSON.stringify({\n        source: currentRelation.source,\n        target: currentRelation.target,\n      })}\n      source={currentRelation.source}\n      target={currentRelation.target}\n      label={currentRelation.label}\n      style={currentRelation.style || {}}\n      startMarker={props.startMarker}\n      endMarker={props.endMarker}\n      endShape={props.endShape}\n      strokeColor={props.strokeColor}\n      strokeWidth={props.strokeWidth}\n      strokeDasharray={props.strokeDasharray}\n      noCurves={props.noCurves}\n      lineStyle={props.lineStyle}\n      offset={props.offset}\n      parentCoordinates={parentCoordinates}\n      refs={props.refs}\n      uniqueId={props.uniqueId}\n    />\n))}\n\n// 使用getBoundingClientRect和配置项计算绘制箭头的位置 最后使用svg进行关联线的绘制\nexport const getPointCoordinatesFromAnchorPosition = (\n    position: AnchorPositionType,\n    index: string,\n    parentCoordinates: Vector2,\n    refs: Record&#x3C;string, HTMLElement>,\n): Vector2 => {\n    const rect = getRectFromElement(refs[index]);\n\n    if (!rect) {\n        return new Vector2(0, 0);\n    }\n\n    const absolutePosition = computeCoordinatesFromAnchorPosition(position, rect);\n    return absolutePosition.substract(parentCoordinates);\n};\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":5,"pageCount":15,"additionalContext":{"pageAllCount":90}}},
    "staticQueryHashes": []}