{"componentChunkName":"component---src-templates-index-js","path":"/8","result":{"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"10f3ddbf-187f-554e-88b0-cfec4ae36045","html":"<p>写这个主题是比较忐忑的，自己有一段时间会规划小组内下个阶段的工作目标，现在看当时做的阶段目标其实谈不上技术规划，本文主要结合自身的一些案例总结做技术规划上的一些思考。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQoz2VSQW6DMBD0/w+9VVXUa/qQ9AFRq36ghyRSMZhgSIzXJlONiYlpkUbgnfXsLLtKRBBCwDAM6LoOfd/De79gHMf0Zl4Z5zmj5NXlcsH1eoXWGlVVoWmaVTILlZdKYRb7yyu6MsbgdDolMZ6ZZK1Nbgl+szDjLE4451KMHOMZigQTKEpQMItmMX5P04QYA+pao+vOS1GC9/mwgKLNGGMi6rpeBCnetu0dBt4LnAvQ+gxjLIyZOXbFu9ShAZV7Z5Akk+h6DQ/nWoi8A9ghhF06Mz6Oc07+DctQOBAOhoLlUERYMCLGM/p+i8PhGU2zgUgFkdudf+Sr3OLxeExidFqux4yQBLV+w37/hO/vlyTo/fQvV+W22G6ecrkadOB9RAgthmELrTew9hUiP4vgymFebDorF/uxW7NDEU76C8AnbrcPiNh7fC34C+UwAiFBmhIuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png\"\n        srcset=\"/blog/static/19e59b526f6f15361b687635a5717660/63868/plan.png 250w,\n/blog/static/19e59b526f6f15361b687635a5717660/0b533/plan.png 500w,\n/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png 1000w,\n/blog/static/19e59b526f6f15361b687635a5717660/aa440/plan.png 1500w,\n/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png 1747w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>自身案例分析</h2>\n<p>在做下个阶段目标的时候经常会有如下的一些疑问:</p>\n<ol>\n<li>下个阶段做什么(来源)</li>\n<li>怎么做(过程)</li>\n<li>完成的总结</li>\n</ol>\n<p>在反思自己之前的制定目标的时候有以下的问题:</p>\n<ol>\n<li>多数在关注1阶段而弱化了2，3阶段的思考，这样会导致在下一次做规划的时候还是很挣扎跳不出这个圈。</li>\n<li>没有一个完整的全局视角 这个导致我的一个疑问是业务侧做这个为啥，看着很分散</li>\n<li>没有一个长期的视角，导致阶段性目标不明确</li>\n</ol>\n<h3>下个阶段做什么(来源)</h3>\n<p>在这个阶段我的思路是关注业务侧的规划文档，但是在看业务侧的文档会存在以下的\"问题\":</p>\n<ul>\n<li>某些目标比较泛并不能准确的落实到技术目标上 比如收入增加XXX</li>\n<li>可以收集到下个阶段的业务目标比如需求A，需求B，需求C，但是A，B，C有可能之间关联性不大，当然这可能跟当前的业务现状有关</li>\n</ul>\n<p>虽然通过看业务侧文档可以整理出下个阶段的业务目标，但是每次都感觉没有所谓的抓手，有种隔靴搔痒的感觉，其实从现在来看之前的我，可以看出很多思考上不足的点，才导致每次都很痛苦的想下个阶段要做啥。\n在思考上可以有两个思路:</p>\n<ol>\n<li>从上往下视角 从全局视角看不同模块的关系，建立联系和目标</li>\n<li>从下往上视角 为什么会有这样的关系，基于已有的关系是否会衍生出新的关系，在新的模块上能做什么</li>\n</ol>\n<h4>下个阶段业务目标</h4>\n<p>在梳理业务目标的时候可以从以下几点考虑:</p>\n<ol>\n<li>熟悉业务的现状  熟悉业务现状才能有目的性的查看业务侧的规划来反推出更多的思路来推动业务目标，比如\n<ul>\n<li>后续会发力营销但是现有的营销页面并不支持配置化那是否可以尝试推动业务侧一起建立配置平台</li>\n<li>业务侧要对存量的业务有一系列的优化，存量的业务还是老旧的技术栈，那么提前对技术栈进行迁移和统一</li>\n</ul>\n</li>\n<li>多与业务侧沟通，建立正向的连接  可以跟业务侧一起建立双向的规划分享，这样互相都比较了解对方做事的思路，团队每人也更有全局的意识</li>\n<li>数据思维 关注产品数据，业务数据促进对业务的反思，可以养成一个思维习惯就是产品的数据怎么能映射到我当前开发的具体业务上</li>\n</ol>\n<h4>下个阶段技术目标</h4>\n<p>在梳理技术目标可以从以下几点考虑:</p>\n<ol>\n<li>流程优化 梳理业务开发的流程针对性解决，比如:\n<ul>\n<li>规范 技术栈统一，代码规范，开发上线流程，Code Review(思考中，如何建立有效的Code Review)</li>\n<li>质量 性能，监控</li>\n<li>效率 通过工具、库来实现提效，已有业务的抽象组合</li>\n</ul>\n</li>\n<li>了解团队成员能力和诉求 可以针对不同阶段的团队成员制定不同的规划，比如工作年限相对短的可以多从一些复杂的业务中成长，年限久的赋予更多的自由度，实现自治</li>\n<li>技术储备(分享输出等) 技术储备可以为团队输入新的血液，分享和输出可以建立团队的整体意识和对外的口碑</li>\n</ol>\n<h3>怎么做(过程)</h3>\n<ul>\n<li>里程碑 每个目标阶段要有里程碑，比如做页面性能监控:\n<ol>\n<li>已有业务接入性能监控</li>\n<li>主要业务首屏优化达到XXX</li>\n<li>性能优化总结，推动上下游进行优化，新技术探索</li>\n</ol>\n</li>\n<li>可调整 在具体实现上因为优先级或者当前目标实现的结果不理想及时调整当前或者下个阶段目标</li>\n<li>多阶段完成 一个大的目标可以拆分成多个子目标在规划的多个阶段落实，需要建立多个目标之间的关系，保证规划的整体性</li>\n</ul>\n<h3>完成的总结</h3>\n<p>这个阶段可以结合上面的两个阶段来看:</p>\n<ul>\n<li>完成了哪些业务目标，技术目标，产生了哪些收益</li>\n<li>过程中产生了哪些问题，是否在下个阶段可以进行优化和避免(下个阶段目标)</li>\n<li>下个阶段目标调整</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844904201160491016\">技术管理- 怎样做好技术规划</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null}}},{"node":{"id":"2aa1bc1b-e5e4-51e4-950f-0ffc8b5a36cd","html":"<p>使用<a href=\"https://icantunderstand.github.io/blog/webview-store\">缓存</a>和<a href=\"https://icantunderstand.github.io/blog/cross-platform-offline\">离线包</a>可以一定程度上提前页面展示的时间，但是页面的展示依赖具体的数据加载，Webview在加载h5的时间线可以做如下简化:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAa0lEQVQY05WPSwrAIAxEvf9RjSL4w7hJmcAUkW66eEw+JhmDqtrJ3tvGGJZztlqr03u3UoqTUvKaiFhrzXXO6XOYDwhu1lq+FA9O5bG7TiMgfDnEQrhCDmWOHlyhTmX/dUjb+OJJjPGXMn4AApw0UHe2ZIsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png\"\n        srcset=\"/blog/static/0ce30849a4870d72a825560fed237688/63868/timeLine.png 250w,\n/blog/static/0ce30849a4870d72a825560fed237688/0b533/timeLine.png 500w,\n/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png 1000w,\n/blog/static/0ce30849a4870d72a825560fed237688/aa440/timeLine.png 1500w,\n/blog/static/0ce30849a4870d72a825560fed237688/fd8a5/timeLine.png 1659w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Webview初始化 Webview在首次初始化会占用相对长的时间进行初始化(可以通过Webview池的方式来优化)</li>\n<li>DNS TCP TLS 建立与服务器的连接，可以通过html的预加载标签来优化(dns-prefetch, preconnect)</li>\n<li>数据请求响应阶段 在解析响应的html的时候会解析到js代码下载并执行发起数据请求(可以通过服务端渲染方案优化但是也增加了服务端成本需要考量)</li>\n</ul>\n<p>从上面的分析可以看出在发起数据请求之前通过Native并行提前完成数据的读取就能换取页面提前展示给用户的时间，下面介绍一种可能的预取方案。</p>\n<h2>实现方案</h2>\n<p>本方案通过配置维护了对应url下需要预取的配置，在初始Webview的时候客户端并行完成数据获取，最后通过jsbridge获取数据。</p>\n<h3>预取配置</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 775px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA60lEQVQoz3WRx6rFMAxE8/8/l1VIyCINQnrvVZcjMOQt3mKwNZJmBts6jkPAdV1ynqfeOQ1M/4v/eGAhtO+7FEUh8zzLfd9/lujDGXxNvzxzKrhtm4zjKHVdyzAMKvpNOE2TdF0nfd8rMIdnz3AADXiL4SiKJMsyieNYkiSRdV3VETGMlmVRIwzLstRE8OzCA3jmLNR93xfXdcXzPHEcR+8MB0Ggok3TSBiG8jyP2LYtaZqqMTV30hGCWattW8nzXIVIiBNNUuBcVZUKmkTU7/tq/eX5A01o3hARBHD5/qbhOJlj3rwhtembvR/OZxjL3yVM2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n        srcset=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/63868/config.png 250w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0b533/config.png 500w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png 775w\"\n        sizes=\"(max-width: 775px) 100vw, 775px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>配置侧 提供配置能力，需要对配置有准入审核，管理(下线，上线)</li>\n<li>服务侧 根据配置提供获取配置服务</li>\n<li>Native 动态拉取配置更新本地数据</li>\n</ul>\n<h3>加载流程</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 923px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 115.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y42VV47DMAxEff/T5Su9996c3hg8AmPIJWUBQo5EDodDShvdbjcL7Xq9Jutms7HdbudrHMd2v9+T808WZcEUcDqdbL1e236/dwM0m7AIPCpi9ng87HK5OBAMD4eDf79er5xvDrAoIyCLxcKGw6F1Oh3r9Xo2m81sPp/b+Xz+WnqUzcQfAJSr0o/Hoy2XS2s2mw4M20+gCUNK3G63zqrRaHgwbCifFQ1hiA/2E5AgAgaDgYPV63X/DSAsp9OpJ+r3+w7+FZBDhF+tVg4MS8oMk6EpySaTyW+GHNIIldRutxOtxJBvZhHD9y8NYQi7VqvloLASIAnYH41Gv0sOy6KbdBlgAkNAtO12uynArEXhzZCGBAHMHoHscYaGJPu7y4AgOkwomd9iCEi5XLbxeOw6sq84WYqhACm7Vqu5Xgy3mLAPczRkItQcpIC9GporGSfAYMI3TFgrlYpVq1VnSdn44ocMpVLJ9/BLdZnssIQZAWKoc5Jwzh6JYIoP7NhntCJ1Byc9Agx1eMWQg2B0pft86w0gEYBIkHscyBo+qhpggjSf2bEhBpYkLXy+cAxNDdPQMwXhTWEFkB7kGBYNavgSUTKPBJJobMQwBfjJwpECCK0wWOqd1A1LSv4HUBrSZZrGM4YEaAk7JCj8J/UNkJLpLivsns9nTmtuyhvVnukgKd1z8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载流程\"\n        title=\"加载流程\"\n        src=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n        srcset=\"/blog/static/b70892349e045d91bae6d4a918265e42/63868/prefetch.png 250w,\n/blog/static/b70892349e045d91bae6d4a918265e42/0b533/prefetch.png 500w,\n/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png 923w\"\n        sizes=\"(max-width: 923px) 100vw, 923px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在加载h5的时候</p>\n<ul>\n<li>Native会在初始化Webview的时候并行的根据配置加载数据(动态参数根据页面url和配置完成映射)</li>\n<li>Webview展示的时候触发jsbridge请求，普通请求jsb与prefetch jsb的区别在于prefetch有一层从本地获取数据的步骤和数据的重置操作。</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null}}},{"node":{"id":"b01b3c20-e1da-5302-8c89-7076361a2c51","html":"<p>在<a href=\"https://icantunderstand.github.io/blog/webview-store\">一起学跨端技术-Webview缓存</a>中介绍了几种常用的缓存实现方案，几种方案都各有优缺点。其实h5页面加载过程可以类比成CPU在运行时动态获取数据，从寄存器中读取数据对比从磁盘中读取数据的时间是相差极大的。那h5页面加载的时候有没有一种方案可以绕过耗时较大的网络获取数据阶段直接加载内容展示呢？离线化就是这种解决方案。通过离线包的动态下发可以让用户在打开页面的时候直接加载已经在app中存储的离线化资源从而加速页面的展示。本文从以下两个方面介绍离线包的实现过程:</p>\n<ul>\n<li>离线包分发过程</li>\n<li>端内加载离线包过程</li>\n</ul>\n<h2>离线包分发过程</h2>\n<p>离线包的分发流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 907px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnElEQVQ4y4WS167CQAxE8/8/h0QEQfReQk0oSSjy1RnJuStA4sFa72Z9PONNVFWV3e93ez6fCvLj8Whpmtput7PtdluH71n3+319Tr7ZbOx8PlsEoCgKW6/XOjydTrqwWq2053w+n6sB++l0aqPRyLrdro3HY+v3+4rZbGaLxeIfyGWKALJOJhMVAGClgBUYZwBpxNlwOJQAzqNvlh36btWDbx4uBCey7MDH46Eoy1JFXAzDQRR6E/YoY0ScHw4Hi4DwCFhEMuoAYKXVaqmAvNPpyCb3yOM4ltVer2fNZlPfGEs9wzzPJfl6varbcrnUBeAMm2IaMjdyoP4YQJktdR+WyS+Xi2VZpias3ogcheS32033uOMrwqQQaBgOJl6vl2aGdVQnSSLV5ED8Ib0m8kKHkaMACwyZi1hpNBqyyYzb7bZs8yh8D8XUwBAc7ilA0WAwUBNy/xe9YVgTfYOFagms8Sfwe2CZWQJjZu8iPoAhlMGzAvJHAETOWH4qDLtRhD1UUMjwUQocGHvyn8AQ6i8HkOBBPIDxO71b/gMnvXNQcp6IjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"分发\"\n        title=\"分发\"\n        src=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n        srcset=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/63868/broadcast.png 250w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/0b533/broadcast.png 500w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png 907w\"\n        sizes=\"(max-width: 907px) 100vw, 907px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n分发流程中主要涉及4种角色:</p>\n<ul>\n<li>离线配置平台 配置平台可以提供离线配置能力、离线包管理(上传、禁用、清空)、离线包使用统计、离线包准入审核(自动(包大小限制)+人工(解决特殊case))</li>\n<li>离线配置服务 配置服务主要提供服务层能力，实现离线配置服务，离线包更新服务，离线资源上传下载服务、离线资源使用统计服务</li>\n<li>离线SDK 端内接入离线SDK，SDK主要与离线配置服务进行交互，完成离线资源的管理和接入配置能力</li>\n<li>Native侧  实现拦截请求在特定的协议下接入离线资源</li>\n</ul>\n<h2>离线包加载过程</h2>\n<p>离线包的加载流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQ4y32UWa+CQAyF5///Mx95IMYouKOouOKGS83XpDfDON6HpjDLOaenBdc0jRD3+/0vn89n8df9PTL7l8ultWbhwksc3G63crvdvojIrC+XS6mq6ouwBWiHZ7OZ5Hku4/G4BUY8Hg85HA6yXq8V1Fdp4XwGAKfTqSRJoqAxwLquZT6fa3CeNc5YdiaVBfOvKAo5Ho8S8/f1eklZlrLb7RQQxfv9Xm2CzAHACwAc4BJlxzyElPP9fl+yLFPi4XAok8lEA3AHOhssrFYr6fV6qgDQ0B/zEDsABJx3BKGYd3e9XlUdGZM3m40SLBYLXQtVvt9vbQpdhoA7NIjQks0/gjJRl6apmh5TCDkKKRWQ0WgknU5HgwpbXUYRyiiHHHaZZ5QNBgMFPJ1O2hDsYTrUQ78kACmZC7CHgDYFANgcovr5fGpEBxvmbrf7s9MoZA+facTXYIcKMZwL5BggJeIVwDarPz89AGFlhCg95iEkNhHhd94CtKFFgeXwjxL+Wf792xg7CukWOabQ9yum8AMub8+9QkzZbwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载\"\n        title=\"加载\"\n        src=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png\"\n        srcset=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/63868/load.png 250w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/0b533/load.png 500w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png 1000w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png 1113w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在端加载离线资源的过程中可以分为两个方面:</p>\n<ul>\n<li>离线SDK更新离线配置和离线资源 离线SDK通过与离线配置服务交互完成离线配置和离线包资源更新</li>\n<li>Web容器加载离线资源</li>\n</ul>\n<p>下面从代码层面简单介绍下加载离线资源的实现</p>\n<h3>离线配置</h3>\n<p>离线需要有一定的配置能力，比如禁用、特定的前缀支持离线化等。通过对离线配置的解析，Web容器就知道在打开对应页面是否的具体行为。这个过程是约定协议的过程。</p>\n<h3>加载离线资源</h3>\n<p>在<a href=\"https://icantunderstand.github.io/blog/jsbridge\">Hybrid开发-JSBridge原理</a>中通过拦截请求在特定的协议下可以实现javascript和Native的通信，那么在特定的协议下其实也可以实现离线包的加载能力。</p>\n<pre><code>// 定义请求资源类型映射\nprivate HashMap&#x3C;String, String > resourceMimeTypeMap  = new HashMap&#x3C;String, String>();\npublic CustomWebViewClient() {\n    super();\n    resourceMimeTypeMap.put(\"html\", \"text/html\");\n    resourceMimeTypeMap.put(\"js\", \"application/javascript\");\n}\n@Override\npublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n    Uri uri = request.getUrl();\n    String scheme = uri.getScheme();\n    String host = uri.getHost();\n    String path = uri.getPath();\n    // 处理资源加载离线包场景\n    // 协定 域名为www.test.com 且 path是local的走加载离线包逻辑\n    if(host.equals(new String(\"www.test.com\")) &#x26;&#x26; path.startsWith(\"/local\")) {\n        InputStream in = null;\n        String pageNamePath = path.split(\"/\")[2];\n        String type = pageNamePath.split(\"\\\\.\")[1];\n        String mimeType = \"text/plain\";\n        if(resourceMimeTypeMap.containsKey(type)) {\n            mimeType = resourceMimeTypeMap.get(type);\n        }\n        try {\n            // 加载本地离线资源\n            in = view.getContext().getAssets().open(pageNamePath);\n        } catch(IOException e) {\n          // 处理处理本地无离线资源 请求网络\n          return super.shouldInterceptRequest(view, request);\n        }\n        // 将本地读取的的内容进行类型映射后通过WebResourceResponse返回\n        WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", in);\n        return response;\n    }\n    return super.shouldInterceptRequest(view, request);\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADg0lEQVRIx+WWXUybZRTHn5WvQaFv2/ft2kIFRqgbHWbqHGGBTnEujdNIBpRBgjcmBo0yJ4lZskggfBhCsuxiiUYIXHJrwsW80HhhHBfTzGnQaLYJLZJsYx/EOIW29Geep5Z0fExJXhONJ/nl/J9zzvPvafopXnz5JH7/XoqLSzAMVwo9I+sGum6ovNbP6LndHnwlj1Bbe4ipqSmEXSvAphXgLXbj9rhw6DZ0w47T0NANDaeuUbbbh6c43fuzLrPLjlO3Y+xyICyCUCiE8Bi78Tqq8BkBfK4AXseeDfiMfRTrVZv2Sj1VlBgBnNZSGhqOIJ4ofIeOskuEfZ/S+eRFXj84zWFxgWd3fEyDSPGMuLCm08i+nOs88AVdh76iY/9HPBc8jjiaf54uEeNVscgbOXfp2nmPTnGH13b8TSy3ObXzPh1ihiO1xxEhyyhn98C5g79z7qkY5+tivC1W6BIrvKWIZeSNnBTLnBJJXhFRHq88jHjJMcpIBQwHYgxVxnjPn+BdI64441jhtO03TmsP4z5ntDhvFs2xr7wWcXbwfeau/MqXn8zy/fRNLn8WYWZ6gSufR7j+9V3u/JTk1rU4i9cTm3LrapylKHx7MUro6POID0c/4ObtBS5/c4kbiz/z47Xv+OGqZIZ7vyySiiRbR6q3cCNKuDWMmJiY4GGxmkiSXE2yugWJ+Kqam5uN0NbWhhgfH1eFeDxOMimHVlVOo3ZIbr2hnJcRiawzTCQSDxiZZrjd+EcNT5wwe0MzDaPRKOFw2FzDlpYWsw1N3rCpqen/Zmj6q9zc3PwvNzT9KZtqKD/LphrOz8/T2Nj4X3wfbpcN3zZjY2OqsLy8rH6otkssFlP3Z2dnU4aTk5OYEUtLS7S2tiLk8x4ZGaG/v5+hoSH6+vro7e1VenBwUNHT06P66bPUsib1wMAAw8PDdHd3p/4fCiHIpLCwkIqKigdqdXV1ZGdnr52lbm9vZ/3dmpoahNVqVQO5ublYLBYcDgcej0dpWcvKyqK8vJyioiKlJVJXV1erezk5OeTl5SnD+vp6hK7rOJ1OhdSapmGz2UjXZZZb2+12pSVSFxQUrN0zDIP8/HyCwSBCNwxcLpcqpvmr8/qa2+3Gai1MGe4ydOyatrZNJnJ4K515luTl5vLCsWOIygNPszdQTVlpqXqkzbZZb5S5pdfrxe9/FH9gPyWPBfkD9GZ9jWzUPEsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"成功加载离线资源\"\n        title=\"成功加载离线资源\"\n        src=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n        srcset=\"/blog/static/2a4c23295151170c16b9a53887eda09b/63868/loadsuccess.png 250w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/0b533/loadsuccess.png 500w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null}}},{"node":{"id":"6b8e80fe-a035-556b-b871-f4c4ffc7e118","html":"<p>跨端开发中h5加载性能优化是一个老生常谈的问题。h5在开发上有着迭代快、试错成本低的优势，但是h5的性能问题也是一个无法绕过的问题。加载慢、体验差是通常在考虑技术选型时候的一个顾虑点。本系列会以Webview性能优化为切入点尝试了解跨端开发中的技术方案来更好的辅助业务的开发。</p>\n<p>充分利用Webview的缓存(存储)机制能有效的提升h5的加载速度,通常有如下的方案可以实现缓存的过程:</p>\n<ul>\n<li>h5缓存机制</li>\n<li>Application Cache</li>\n<li>浏览器存储</li>\n</ul>\n<h2>h5缓存机制</h2>\n<p>h5缓存是指浏览器根据文件网络传输中的一些字段来确认是否使用已经缓存的文件，具体可以参考<a href=\"https://icantunderstand.github.io/blog/web-store\">缓存那些事</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVQoz22SzY6bMBSF8/zddNF1q64rtX2ESO2imheYdFPRhAwJJJAQfgwG+6uOgUwqjSXLNvfy3XOuvfIewGPtjnEscQ68t1h7wLkG5zxlWdL3HSHTt3i/A/Z4H4epPexwLmc1AR1dF2FMxvF4pq5PdN0T45hQ14YoiqjrKgCdE+wzxnwiit7z/PyOOP4AfMT7NSup8xOVYfAcj0eapp3PjtPpxO1243VcgSe8/8XttqYs1zTND+An8HtSOAFluw+ApmlmNY7z+UxVVfR9jzEtbWvIsoKyrJl1zK2Y1pVg3rsZaEmS5K5IMQHrusYYQ57nYf/ysqco8iBgGOyCDPmrBy/BooBStAyBlDgMA1mWhXMcx2GvAloVk5tZ4Y4k+UaSfMeYiDg+UFWvPZNVAbuu43A40LZtgFwul9AeQfVN8QB07i/7/RfS9CvW/iFJ0vuNqvLSAv2w2WyC5fv1XK8hplVFxnH837K1Y6isigswTdOgQla32214k+q1zuqvYppFUUzAx0sZxyEokM3HoRwVkUX1Vz8KqlVz6V+wLNDjW3yELHNRq+ek9a2x5P4Dh85Sl/bdd+YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"h5缓存机制\"\n        title=\"h5缓存机制\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/63868/cache.png 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/0b533/cache.png 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/0f529/cache.png 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Application Cache</h2>\n<p>Application Cache主要是做应用的离线化配置，它跟h5通过缓存头实现的缓存机制相对独立。通过在html中引入manifest属性开启Application Cache.</p>\n<pre><code>&#x3C;html manifest=\"example.appcache\">\n...\n&#x3C;/html>\n\nCACHE MANIFEST\n# Version 1\n// CACHE下声明的文件将在首次加载后进行缓存\nCACHE:\nscript/scriptfilename1.js\ncss/cssfilename.css\nimages/imagename1.png\nimages/imagename2.jpg\nimages/imagename3.png\n// FALLBACK定义离线状态下的规则 \nFALLBACK:\n// images下的资源都将使用images/imagename4.png替代\nimages/ images/imagename4.png\n// 缓存白名单 应用对Network下的请求都会绕过缓存请求服务器\nNETWORK:\nimages/imagename5.png\n\n// 端侧在初始化Webview的时候开启Application Cache \nWebSettings webSettings = webView.getSettings();\n// 允许执行JS\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n</code></pre>\n<p>在使用Application Cache需要注意以下几点:</p>\n<ul>\n<li>有同源限制，缓存大小限制(5MB)</li>\n<li>需要更新缓存文件的时候，需要同步更新manifest文件</li>\n<li>manifest声明中的文件无法下载时会导致无法更新到最新的缓存，浏览器将使用旧的缓存文件(推荐一些几乎不更新的文件使用Application Cache)</li>\n<li>可以在业务代码中通过window.applicationCache相关api实现缓存资源的手动触发更新</li>\n</ul>\n<h2>浏览器存储</h2>\n<p>通过浏览器提供的api实现数据的存储和缓存功能。</p>\n<h3>Dom Storage</h3>\n<p>Dom Storage指的是LocalStorage和SessionStorage。LocalStorage是持久存储，SessionStorage是会话存储。他们都通过key-value的方式来对简单的数据进行存储。Dom Storage存储空间为5MB有同源限制。</p>\n<pre><code>WebSettings webSettings = webView.getSettings();\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n// Webview初始化开启Dom Storage\nwebSettings.setDomStorageEnabled(true);\n\n// javascript\n// 设置键值\nwindow.localStorage.setItem('name', 'haha')\n// 读取键值\nwindow.localStorage.getItem('name')  // 返回\"haha\"\n</code></pre>\n<h3>IndexedDB</h3>\n<p>IndexedDB可以通过数据库的方式对数据进行存储，它的存储空间相对于Dom Storage大很多。通常可以基于封装IndexedDB的库来实现数据的存储。IndexedDB的使用方式可以参考<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<h2>参考</h2>\n<p><a href=\"https://webplatform.github.io/docs/apis/appcache/ApplicationCache/\">ApplicationCache</a><br>\n<a href=\"https://www.html5rocks.com/zh/tutorials/appcache/beginner/\">应用缓存初级使用指南</a><br>\n<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null}}},{"node":{"id":"743bd4e6-3437-513e-a516-b525ec1dee0c","html":"<p>Android中可以使用异步消息处理机制来完成主线程和子线程任务调度，本文主要介绍使用Handler实现消息通信的过程。</p>\n<h2>Handler</h2>\n<h3>基本概念</h3>\n<p>使用Handler实现异步消息需要以下的组件:</p>\n<ul>\n<li>Message\n发送消息传递的数据对象</li>\n<li>Handler\n负责消息的传递和处理</li>\n<li>MessageQueue\n负责保存当前线程中的发送的Message，每个线程只能有一个MessageQueue</li>\n<li>Looper\n负责管理线程中的MessageQueue，将MessageQueue中的Message不停的取出给Handler处理。每个线程只有一个Looper</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 814px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxzQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAQABBQJp/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQESExQf/aAAgBAQABPyG2301CwGUf/9oADAMBAAIAAwAAABAjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExcYGRsf/aAAgBAQABPxAoWhxEaUveYagcl+RXQfIANVP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Handler实现结构\"\n        title=\"Handler实现结构\"\n        src=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n        srcset=\"/blog/static/86b2a15f43db42534948074b87746b3e/0479a/Handler.jpg 250w,\n/blog/static/86b2a15f43db42534948074b87746b3e/41099/Handler.jpg 500w,\n/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg 814w\"\n        sizes=\"(max-width: 814px) 100vw, 814px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>例子实现</h3>\n<p>下面的例子中布局文件中定义了一个TextView和Button，在Button点击的时候通过发送Message来实现TextView内容的更新。 使用Handler处理异步消息主要有如下的步骤:</p>\n<ul>\n<li>\n<p>初始化Looper(Looper.prepare)和MessageQueue(Looper.loop)</p>\n</li>\n<li>\n<p>根据当前的Looper创建Handler并重写handleMessage方法</p>\n</li>\n<li>\n<p>在子线程中通过Handler发送Message传递数据</p>\n</li>\n<li>\n<p>主线程处理数据(UI显示)</p>\n</li>\n<li>\n<p>主线程退出后清除Handler的任务/关闭Looper</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n  // 定义更新按钮文旦的标识\n  public static  final  int UPDATE_TEXT = 1;\n  private TextView textView;\n  private Handler handler;\n  private Runnable runnable;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    textView = (TextView) findViewById(R.id.textView);\n    Button button = (Button) findViewById(R.id.button);\n    if(Looper.myLooper() == null) {\n      // 初始化当前线程的Looper 通过判断保证当前线程只有一个Looper\n      Looper.prepare();\n      // 开始线程中的MessageQueue\n      Looper.loop();\n    }\n    // 创建Handler  创建Handler必须执行Looper\n    handler = new Handler(Looper.myLooper()) {\n      @Override\n      public void handleMessage(@NonNull Message msg) {\n        // 重写消息处理方法\n        switch (msg.what) {\n          case UPDATE_TEXT:\n            // 获取传递的数据\n            String content = msg.getData().getString(\"content\");\n            textView.setText(content);\n            break;\n        }\n        super.handleMessage(msg);\n      }\n    };\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n          // 在子线程中通过Handler发送Message\n          runnable = new Runnable() {\n            @Override\n            public void run() {\n              // 这里可以做一些耗时操作\n              Message message = new Message();\n              Bundle bundle = new Bundle();\n              bundle.putString(\"content\", \"you click me!!!\");\n              message.setData(bundle);\n              message.what = UPDATE_TEXT;\n              handler.sendMessage(message);\n            }\n          };\n          runnable.run();\n        }\n    });\n  }\n  @Override\n  protected void onDestroy() {\n    // 可以在这里清除runnable/终止消息的处理\n    handler.removeCallbacks(runnable);\n    Looper.myLooper().quit();\n    super.onDestroy();\n  }\n}\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/blog/54c35e9eba49d7862bdca4f06c052160/showHandler.gif\" alt=\"使用Handler\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null}}},{"node":{"id":"d49efd27-23e6-5f40-ba34-533df32251e2","html":"<p>Hybrid混合开发相对于单一的客户端开发有着开发周期短，迭代快的优势，但是Hybrid模式开发的页面存在着一定的缺陷，比如性能问题、缺乏客户端能力等。通过JSBridge这个桥梁可以实现客户端能力的打通，赋予了Hybrid应用更强的端能力。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 838px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcElEQVQ4y42U2Y7CMAxF+/8/SJ8qSksXukJXKNSjY8lVBmZEI0W249wb23HiDcMgZVlKVVVSFIX0fS+Px0Pn7XbT9bqudaKz3/xd121Y5DiO4qHgZCABLssi9/tdzuezbmY2TbPZz+dT/WDXdVUsNj7PNjAgAggxG06nk8zzLFEUSdu2moFLiG7DglFCiN4JIcqyTNI0VcnkAPxuhLsJAcRxLFZj6nm5XD5S/kpIagDQIbTakS4S+/V6bQT/ElJcZJ7neltERJqskT4AOgD/NE2qUw4G2A9CUiMy3/cVFIahBEGgAFKjRYjscDhs0aIzOByOj5St9wBatNfrVcuANNuyIf2vNWTRLuV4PCoZkZI+NSVaMqEMu2/Z6kZE2OyB2Ozdt8yi2zbUyYjQqes7ob2UX4TUjIF0Ce2FJEmipDQ2oL9eCmsbIRdBqwC2t2wp2+fAQdguoX0mdIhhPYAQ2qTH7DfhENoFEBP93e9i4foBsVCB7aDDCl4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"JS\"\n        title=\"JS\"\n        src=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n        srcset=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/63868/JSBridge.png 250w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/0b533/JSBridge.png 500w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png 838w\"\n        sizes=\"(max-width: 838px) 100vw, 838px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nJSBridge作为客户端和H5的通信的桥梁，可以承接如下的能力:</p>\n<ul>\n<li>鉴权能力 JSBridge调用能力鉴权，白名单，黑名单等</li>\n<li>胶水能力 JSBridge兼容代码，做版本控制等调用透明</li>\n<li>测试能力 提供测试方法，方便测试</li>\n<li>Scope(配置)能力 能基于配置产出精简版、目标版本JSBridge</li>\n</ul>\n<p>下面以Android代码为例，介绍JSBridge的实现方式。</p>\n<h2>Js调用Native</h2>\n<p>Js调用Native通常有如下的方案:</p>\n<ul>\n<li>拦截请求(shouldOverrideUrlLoading/shouldInterceptRequest)</li>\n<li>拦截特定方法(prompt/alert/confirm)</li>\n<li>客户端注入JSBridge(addJavascriptInterface)</li>\n</ul>\n<h3>拦截请求</h3>\n<p>在安卓初始化Wevview的时候可以设定WebViewClient，WebViewClient主要功能是处理Webview加载时的通知和请求事件等。通过重写WebViewClient的shouldOverrideUrlLoading/shouldInterceptRequest就可以实现拦截h5的请求从而实现端能力调用。\n实现思路如下:</p>\n<ul>\n<li>定义JSBridge实现Jsb方法</li>\n<li>定义JSBManager管理Jsb的调用</li>\n<li>实现拦截方法的重写</li>\n<li>H5侧调用</li>\n</ul>\n<h4>定义JSBridge方法类</h4>\n<pre><code>// 以下例子均省略import语句 \npublic class JSBridge {\n  // 需要考虑callback和入参一致性问题\n  public void showToast(JSONObject jsonObject) {\n      try {\n          Toast.makeText(MainActivity.context, jsonObject.getString(\"content\"), Toast.LENGTH_LONG).show();\n      } catch(Exception e) {\n      }\n  }\n}\n</code></pre>\n<h4>定义JSBManager管理Jsb的调用</h4>\n<pre><code>public class JsbManager {\n  // 通过HashMap获取JSBridge定义的所有方法\n  public static Map&#x3C;String, Method> methodMap = new HashMap&#x3C;>();\n  public void init() {\n      Method[] methods = JSBridge.class.getDeclaredMethods();\n      for(Method method : methods) {\n          methodMap.put(method.getName(), method);\n      }\n  }\n}\n</code></pre>\n<h4>实现拦截方法的重写</h4>\n<p>以下以shouldOverrideUrlLoading方法的重写为例子。在例子中定义的通信协议是myjsb://method?params。通过在拦截方法中对请求进行解析就可以实现调用对应客户端method的逻辑。</p>\n<pre><code>public class CustomWebViewClient extends WebViewClient {\n    private JsbManager jsbManager = new JsbManager();\n    private JSBridge jsBridge = new JSBridge();\n    public void initJsb() {\n        // 初始jsbManager和jsBridge实例\n        jsbManager.init();\n        jsBridge = new JSBridge();\n    }\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n        Uri uri = request.getUrl();\n        String scheme = uri.getScheme();\n        if(scheme.equals(new String(\"myjsb\"))) {\n            // 获取方法名 入参\n            String methodName = uri.getAuthority();\n            String query = uri.getQuery();\n            try {\n                JSONObject jsonObject = new JSONObject(query);\n                Method method = jsbManager.methodMap.get(methodName);\n                // 调用对应的客户端逻辑\n                method.invoke(jsBridge,jsonObject);\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n}\n// 主活动代码逻辑\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建WebViewClient\n        CustomWebViewClient webViewClient = new CustomWebViewClient();\n        // 调用JSBridge初始逻辑\n        webViewClient.initJsb();\n        WebView webView = (WebView) findViewById(R.id.webView);\n        // 设置WebViewClient处理webviewt通知，请求等\n        webView.setWebViewClient(webViewClient);\n        // 开启调试功能\n        webView.setWebContentsDebuggingEnabled(true);\n        WebSettings webSettings = webView.getSettings();\n        // 允许执行JS\n        webSettings.setJavaScriptEnabled(true);\n        // 这里加载项目本地的html文件方便调试\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n}\n</code></pre>\n<h4>H5侧调用</h4>\n<pre><code>    &#x3C;body>\n        &#x3C;div>this page test JSB&#x3C;/div>\n        &#x3C;script>\n          // 通过创建iframe发起JSBridge调用\n          function iframeCall(url) {\n            let iframe = document.createElement('iframe')\n            iframe.src = url\n            iframe.style.display = 'none'\n            document.documentElement.appendChild(iframe)\n            setTimeout(() => { document.documentElement.removeChild(iframe) })\n          }\n          function callJsb(method, params) {\n            let url = `myjsb://`\n            if(!method) {\n              return\n            }\n            url += `${method}`\n            if(!!params) {\n              url += `?${encodeURIComponent(JSON.stringify(params))}`\n            }\n            iframeCall(url)\n          }\n          callJsb('showToast', { content: 'xiaohong' })\n        &#x3C;/script>\n    &#x3C;/body>\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 196.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAnCAYAAAAPZ2gOAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+1US09TQRQeGwh90Pb29kFppQ9BVAghGjfqQorFaNyZCCt3CBSoMa6IhkRiDCYmBqMxRU34ObSEFlalYCIkbuTRCra29N62n5nR2/SF1IorPMmXc+Y7c89jZs4lOl4DTq+AoUmL5pNGaHRyaHkldAYleKOS+ZpbeLQ4TeAMCuiMyiLwRhXbr9UrwPFqEDN/Gm36PrTqXWhvuoZzVjfOWtxw6lywq3tg1/TAoXHBoXUxuxA2dQ/aDL3otLlxpqkPdlM3SLuqH/dsn3DXGoK3O8zwuPcj7nBB9BE/bpIAblQA5am/nwth4moEE5c+w+2YArmoHsQDkoOH7GCUfIW3fpfpMbKLcdkuxk/8QqFdwNF9w2QH94kIt3wG5Hz9MJ5bgVeXU3h5QcSHWxk84gSMkTS8VWKcJPGQANfr34JcMQ/hRTvwrCOO6c4UpjtSeNqaxJQjiSlndXjijGP6FHDb+gZkaNADiMDulzTi21nEd7JIRLP4Hqse37YFQABez/hARsdGQSVLo9YoOWSYfvd+FsTj8bCFIIjIZXM1QRR+FjPrKwgoiiJyuVxNFdJvWcDZ/wGPacBS5B/vb5JVDJjJZA6ehEMqrxgwlUpBEASk02kGuml/fz8frOoKR0ZGsLm5iXA4jOXlZaytrWF1dRXr6+uMq7llqSrp7LLZ7N+1LJGlZ/fHLf+zWz7mo1eoDzrXwuSHXkrpDR80OZKuusJq7aqejfTYY7EYtra2GKLRKJLJZFkHZaNHhc4t/UEUIpFIYGNjA0tLSwyRSAR7e3tl+2hiKj6fD8Tr9eKoZG5uDmRgYID9DBYWFhAMBrG4uAi/389silAoxHyBQIDZEjc/P5//huqVlRVMTk6CKJVKEEKKwHFc0Voul0Or1RZxFosFKpWqiKurqwNpbGwsIx0ORxFnMplgs9mYLZPJmO7q6oLZbC5LTHQ6HdRqdR40AXVIa41GA4VCwThqS1xDQwNodxJHwTozGAwwGo1FoBUdxlXaQ2MRvV6PowSx2+3geZ5Fp5Ac0rqUK/UX8rTKH4LefgGruMzUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"拦截请求实现调用\"\n        title=\"拦截请求实现调用\"\n        src=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n        srcset=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/63868/overrideUrlCall.png 250w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/0b533/overrideUrlCall.png 500w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>使用iframe发送消息的方式会存在消息丢失，参数限制等问题，可以通过消息队列和拦截shouldInterceptRequest方法来实现。</p>\n<h3>拦截特定方法</h3>\n<p>在初始化WebView的时候可以同步设置WebChromeClient，WebChromeClient主要是辅助WebView处理Js对话框，标题等操作，通过拦截WebChromeClient相应的方法同样可以实现调用端能力。</p>\n<h4>实现WebChromeClient</h4>\n<pre><code>public class CustomWebChromeClient extends WebChromeClient {\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 此处举例为主 直接弹端toast\n        // 实现上跟拦截url一致\n        Log.d(\"mesage\", message.startsWith(\"myjsb\")+ \"\");\n        if(message.startsWith(\"myjsb\")) {\n            Toast.makeText(MainActivity.context, \"PropmtCall\", Toast.LENGTH_LONG).show();\n            // 此时js调起了 需要JsPromptResult.confirm(result)\n            return true;\n        } else {\n            return super.onJsPrompt(view, url, message, defaultValue, result);\n        }\n    }\n}\n// 在初始化WebView的时候设置WebChromeClient\nCustomWebChromeClient webChromeClient = new CustomWebChromeClient();\nwebView.setWebChromeClient(webChromeClient);\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.prompt('myjsb://')\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 199.60000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+2U309bVRzAD9BCgdv23tt7ewsKq6nIBnWLcWYJ0RfjlLin6UzmHjQLyWYcbcfMKsZkPvrj0YRAoegMITz45xAShiYGWGIMIUQEWlrbjzmnu3jpHIPFx57kk/P9fs/3+znn9qGipydOxLSJOd040S5sK4ptOVgRBzviYJlRumLPKWSsah5kb9SOKceLiT6EbnYSMv3YsTCmrdEZ8qOFW9GtNoxogLDVSnevTlePrmLDDih0+9F5JIAWaqUz7Cesa4g+4xIX7HFes8d486XPuTj4BW+dGedccIyBtgzJ9tsMtKUVycBtBgMZhayf8acZev4ub788zjsDX5FwhhCva99yvf0PPgr+Sjr+kNHeh2STv3PV9wvviQdcESsHvO9B5pfFA64bv3E3uc6XyR1etUYQ77ZPcS8E48ZfZLVd7nXvkRK7jDXtcaelcDS+Ahmxx6fiT+4IuKDdQlwUOb4+Bd+d3eOb0/t8P7RPShS5KQp8cmx2yAg43zaKuPFGjoVrMPvBLvevFvnhSpGfrp2MHz/c4eeP4dK5UcT9uVlqqwxUH8XVE1JWU2OfZRD5fE1YKpWpVDg5f1cp7deE6XQGMTtbE5bLZarV6jMhZ+XKZOqEz7IawoawIWwIG8JjCt1/YW9cT/3ZU4Xe/Umv8kqf+snuQKVSOUDW3Lhe+kSh95Pk4NbWFqurq6ytral9fX2d7e3to184MzOjkmKxqA5KpZLaZb6xscHKygqLi4ssLS2xvLzM5ubmQY9LoVBQjlQqhVhYWOD/WtlsFjEyMsLc3BzT09Pk83lyuRyTk5MqlsifROZTU1MqdusTExOHZubn5xkeHkYIIahH07RDeTAYxOfzHaolEonH5lRPR0cHLS0tKmlublYyx3FoamrC7/erPRaLYZqmimWfpL+/X/XKGZlLh7xYyEZd1xWGYRAOh9WBjN2aHAyFQgc1iXyI7PXWpEtYto1t21iWpbDr8uPW3FiYeu2WSCRyJLL5v2IX5TANxOmz54mf6sWy/r3NHfLiFdWfSV6Ix+kbfIV/AHs5ocTNraY7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"重写Prompt方法调用\"\n        title=\"重写Prompt方法调用\"\n        src=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n        srcset=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/63868/overridePrompt.png 250w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/0b533/overridePrompt.png 500w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>客户端注入JSBridge</h3>\n<p>通过<a href=\"https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String)\">addJavascriptInterface</a>可以在初始化WebView的时候将客户端的调用逻辑暴露给H5。</p>\n<h4>实现JSInterface</h4>\n<pre><code>    public class JsInterface {\n        private Context context;\n        public JsInterface(Context context) {\n            this.context = context;\n        }\n        // JsInterface需要用@JavascriptInterface注解才可以被调用\n        @JavascriptInterface\n        public void showToast(String content) {\n            Toast.makeText(this.context, content, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    // 在初始WebView的时候注入interface\n    webView.addJavascriptInterface(new JsInterface(context), \"myjsb\");\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.myjsb.showToast(\"Interface\")  \n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 200.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADaklEQVRIx+2Vy09TQRTGB+jDK9D29j76UEyJIo9gfGCqJmowrtwQaMHIxoWJ8rJaCUaif4EL3oSFqAs3rliZCBFiXLKHiCECoRASiLzEtpT29jMz9dbyqoXgSif5Zc75euabczt3cslZ52UIvABZssJqOQJJlCGJFoYoUGTIkg1221EWx7Tf0DpZis1Wiw3EaMqEwawDL3Gw2HlkGjXIMupgEHTgZT2Mog6SPQs5uQJMkp7Bb5oPsfoskxYGEwdi54vhtD1AidyAi8fuo7TAi2uFXpRIDcjX16DocC0KuRoUHKpBIVcbp4irRYG+Bqf5elwv9uLq8Uacc1SBnDDcwF3Rh9vZX1F/bBqeXB+enJnDHWECZeQzXOTLrpSTMdzSj6Pp1AyeFH9DleMtyCmDC03aEJpNfjRxP/BM8sOr+YEHxI9GTQCPMnanMSMAb1oA9eQ7HpII3BnvQAp0LjRnRtB+IYTnRSF0X9nAUz6EeySIOhJEbQrUkQA8BKgg70Eu5bnwuiKMF2VBvCwPorcsiN7yIF651vGqIpgSvRUBvKkEHpe+B6m6WYnYUABE90mEOXz8NAhS6Y4ZKpEoFCWKqII9EwkrzOPDB2pY+cuQmkX3RyQS63BwMMFQ/XE/47/hP2uoKApjp/dM3XBPhsnGnzrfZri6uspYXFzE0tISVlZWWL6wsMC6TrXDvr4+ELfbjdnZWUxPT2NkZASTk5Ms9/l8GB8fjxenYtjf33+wjzw0NPQXD+X/TTlYw8Q52SGpcVLDVE51a82eOqTF6uukxls3/GOHanEoFML8/DympqbYDZqbm8Pa2lryjxS9elTc2NjYRDgcht/vx8zMDMbGxjA6OoqJiQksLy9vq11fX2eGAwMDINXV1TioMTw8DOJ0OtHd3Y2Ojg50dnayuaWlJZ53dXWhra2NaTSmGoXmra2tLG5vb0dPTw88Hg8Ix3EghGyC5/ltmiAIm3Kr1QqDwbCtjhiNRmg0mjharRYWiwV6vZ7l6enpbKHNZmOxTqdDWloacnJyWB2N6Rpay5qjO9OOEsnOzo7HZrMZdFOq0VjVaE43UjVVJ4IgQpIkiKIYZ2u+k0bzRI3FkgRilUWYTEaYzQL7n3aDLkqWsw55E0je+VLknczHEbt9x85UEo22IssyHA4HjucX4yfjfpxnxqZHBAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"interface调用\"\n        title=\"interface调用\"\n        src=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n        srcset=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/63868/callInterface.png 250w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/0b533/callInterface.png 500w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>Native调用Js</h2>\n<p>Nativa调用Js通常有如下的方案:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></li>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></li>\n</ul>\n<p>以下例子在H5中都定义了全局函数供Native调用</p>\n<pre><code>    function testNativeCall() {\n      console.log(\"nativeCallJs\")\n      return 'nativeCallJs'\n    }\n</code></pre>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></h3>\n<p>可以通过webView.loadUrl(\"javascript: testNativeCall()\")发起调用(需要等待Js执行完成)。loadUrl的方式会刷新页面且无法获取js的回调。</p>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></h3>\n<pre><code>webView.evaluateJavascript(\"javascript: testNativeCall()\", new ValueCallback&#x3C;String>() {\n    @Override\n    public void onReceiveValue(String value) {\n        return;\n    }\n});\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADPUlEQVRIx+1US08TURi9hSK0DG3n1SkEgRYlKAoGVoqPhZqwAF0pJi6MC9EIGoGFBlpRsRF5FAqJEH6AUXGlfwVIWFgKBASBYELaTqFwzL3N1PIqj7AwkZucfI97vnPPdOaW5OblQ+BF2JQs2GxZkCQrZFmBJFoZREFGVmY2A821vgbKtcoKREGC3e4AsQgcMiypkBQzRNkMznQMnCkNFskAQTayaMvmkXmcZzkvG2Ng+6KR8TlzGkxmDqSAv4GrOe9RrrSg4pQbVefaUFXchjLuJYpTnChJdbGo5fEoSmrGlew3uFn6DpVFnTiTUwFSzr1GLf8b9wx+1Np+4rF1Bs8Lf+Gu3o/bxIfqBLhFfuA+N4mG/Bm8OLmMi0oDyHWDBy1mwKkE4FJCeJsfwjNdEPW6EBr1KhqTE0Cvop6EUEeW0UCAS8YmkMvEg1YFaC8Jwn0ijPbiMJ6SEGpICA/3jADqCHBe3wRSc82Db0+Ajw8C+PxIxacaFUO1Kr7WqRiqi8ZEoJwvtUF8rwfulDeDfBjoRXRFcPAVnX3V6gLxeqOCK+EI1iLrB8JqOCrocrpAenujgpFIBOvr6wcCnWWCrm0E97uOBP9rwdXV1W2/MW1op8O2CPb19e3qYF8OOzs7EQwGsbi4iLm5ORaXlpawsLDAsG+HHR0dbHB8fBzDw8OYmprC9PQ0/H4/Jicn/4FHPvSXcnRTDl9w84vYCfGcXR3uxWk8d88ON39Ka2trsd6eHWrkcDiM+fl5+Hy+GCYmJtjVXFlZ2Vmwp6eHFaqqstMpKCEQCGB2dhajo6MMIyMjGBsbY/ed3n3K0fj0cLqcTifI4OAgDmu53W6Q6upqDAwMoLu7G16vl8Wuri7Qn4LWNNLa4/HEehT0T0WboU/Z39+PyspKEEIINsNisWyozWYzDAbDhl5hYeGWueTkZJD09HSW6PV6JCUlwWg0wmq1spz2dDodZFmGIAgsT0lJYXsOhwMZGRkxHtXgOA6EEnmej4G6o0Stpvu0NplMiOdSI9R5/CzdJ5IkMweSJMWwXb1bT8uJKFBXPERRTAhKTrRHn4xqkdOlF2DPy91wmkaKx3a9v3sSHHY7Cs6W4Q880qCTlgwo4gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"evaluate调用js\"\n        title=\"evaluate调用js\"\n        src=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n        srcset=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/63868/evaluateJS.png 250w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/0b533/evaluateJS.png 500w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a>\n<a href=\"https://juejin.cn/post/6844903840588759048\">跨端技能必备之JSBridge</a>\n<a href=\"https://juejin.cn/post/6844903856418062350\">从零开始写一个 JSBridge</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":8,"pageCount":15,"additionalContext":{"pageAllCount":87}}},"staticQueryHashes":[]}