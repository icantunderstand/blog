{"componentChunkName":"component---src-templates-index-js","path":"/8","result":{"pageContext":{"pageAllCount":88,"group":[{"node":{"id":"743bd4e6-3437-513e-a516-b525ec1dee0c","html":"<p>Android中可以使用异步消息处理机制来完成主线程和子线程任务调度，本文主要介绍使用Handler实现消息通信的过程。</p>\n<h2>Handler</h2>\n<h3>基本概念</h3>\n<p>使用Handler实现异步消息需要以下的组件:</p>\n<ul>\n<li>Message\n发送消息传递的数据对象</li>\n<li>Handler\n负责消息的传递和处理</li>\n<li>MessageQueue\n负责保存当前线程中的发送的Message，每个线程只能有一个MessageQueue</li>\n<li>Looper\n负责管理线程中的MessageQueue，将MessageQueue中的Message不停的取出给Handler处理。每个线程只有一个Looper</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 814px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxzQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAQABBQJp/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQESExQf/aAAgBAQABPyG2301CwGUf/9oADAMBAAIAAwAAABAjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExcYGRsf/aAAgBAQABPxAoWhxEaUveYagcl+RXQfIANVP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Handler实现结构\"\n        title=\"Handler实现结构\"\n        src=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n        srcset=\"/blog/static/86b2a15f43db42534948074b87746b3e/0479a/Handler.jpg 250w,\n/blog/static/86b2a15f43db42534948074b87746b3e/41099/Handler.jpg 500w,\n/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg 814w\"\n        sizes=\"(max-width: 814px) 100vw, 814px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>例子实现</h3>\n<p>下面的例子中布局文件中定义了一个TextView和Button，在Button点击的时候通过发送Message来实现TextView内容的更新。 使用Handler处理异步消息主要有如下的步骤:</p>\n<ul>\n<li>\n<p>初始化Looper(Looper.prepare)和MessageQueue(Looper.loop)</p>\n</li>\n<li>\n<p>根据当前的Looper创建Handler并重写handleMessage方法</p>\n</li>\n<li>\n<p>在子线程中通过Handler发送Message传递数据</p>\n</li>\n<li>\n<p>主线程处理数据(UI显示)</p>\n</li>\n<li>\n<p>主线程退出后清除Handler的任务/关闭Looper</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n  // 定义更新按钮文旦的标识\n  public static  final  int UPDATE_TEXT = 1;\n  private TextView textView;\n  private Handler handler;\n  private Runnable runnable;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    textView = (TextView) findViewById(R.id.textView);\n    Button button = (Button) findViewById(R.id.button);\n    if(Looper.myLooper() == null) {\n      // 初始化当前线程的Looper 通过判断保证当前线程只有一个Looper\n      Looper.prepare();\n      // 开始线程中的MessageQueue\n      Looper.loop();\n    }\n    // 创建Handler  创建Handler必须执行Looper\n    handler = new Handler(Looper.myLooper()) {\n      @Override\n      public void handleMessage(@NonNull Message msg) {\n        // 重写消息处理方法\n        switch (msg.what) {\n          case UPDATE_TEXT:\n            // 获取传递的数据\n            String content = msg.getData().getString(\"content\");\n            textView.setText(content);\n            break;\n        }\n        super.handleMessage(msg);\n      }\n    };\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n          // 在子线程中通过Handler发送Message\n          runnable = new Runnable() {\n            @Override\n            public void run() {\n              // 这里可以做一些耗时操作\n              Message message = new Message();\n              Bundle bundle = new Bundle();\n              bundle.putString(\"content\", \"you click me!!!\");\n              message.setData(bundle);\n              message.what = UPDATE_TEXT;\n              handler.sendMessage(message);\n            }\n          };\n          runnable.run();\n        }\n    });\n  }\n  @Override\n  protected void onDestroy() {\n    // 可以在这里清除runnable/终止消息的处理\n    handler.removeCallbacks(runnable);\n    Looper.myLooper().quit();\n    super.onDestroy();\n  }\n}\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/blog/54c35e9eba49d7862bdca4f06c052160/showHandler.gif\" alt=\"使用Handler\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null}}},{"node":{"id":"d49efd27-23e6-5f40-ba34-533df32251e2","html":"<p>Hybrid混合开发相对于单一的客户端开发有着开发周期短，迭代快的优势，但是Hybrid模式开发的页面存在着一定的缺陷，比如性能问题、缺乏客户端能力等。通过JSBridge这个桥梁可以实现客户端能力的打通，赋予了Hybrid应用更强的端能力。\n<img src=\"./crossPlatformStatic/jsBridge/JSBridge.png\" alt=\"JS\"><br>\nJSBridge作为客户端和H5的通信的桥梁，可以承接如下的能力:</p>\n<ul>\n<li>鉴权能力 JSBridge调用能力鉴权，白名单，黑名单等</li>\n<li>胶水能力 JSBridge兼容代码，做版本控制等调用透明</li>\n<li>测试能力 提供测试方法，方便测试</li>\n<li>Scope(配置)能力 能基于配置产出精简版、目标版本JSBridge</li>\n</ul>\n<p>下面以Android代码为例，介绍JSBridge的实现方式。</p>\n<h2>Js调用Native</h2>\n<p>Js调用Native通常有如下的方案:</p>\n<ul>\n<li>拦截请求(shouldOverrideUrlLoading/shouldInterceptRequest)</li>\n<li>拦截特定方法(prompt/alert/confirm)</li>\n<li>客户端注入JSBridge(addJavascriptInterface)</li>\n</ul>\n<h3>拦截请求</h3>\n<p>在安卓初始化Wevview的时候可以设定WebViewClient，WebViewClient主要功能是处理Webview加载时的通知和请求事件等。通过重写WebViewClient的shouldOverrideUrlLoading/shouldInterceptRequest就可以实现拦截h5的请求从而实现端能力调用。\n实现思路如下:</p>\n<ul>\n<li>定义JSBridge实现Jsb方法</li>\n<li>定义JSBManager管理Jsb的调用</li>\n<li>实现拦截方法的重写</li>\n<li>H5侧调用</li>\n</ul>\n<h4>定义JSBridge方法类</h4>\n<pre><code>// 以下例子均省略import语句 \npublic class JSBridge {\n  // 需要考虑callback和入参一致性问题\n  public void showToast(JSONObject jsonObject) {\n      try {\n          Toast.makeText(MainActivity.context, jsonObject.getString(\"content\"), Toast.LENGTH_LONG).show();\n      } catch(Exception e) {\n      }\n  }\n}\n</code></pre>\n<h4>定义JSBManager管理Jsb的调用</h4>\n<pre><code>public class JsbManager {\n  // 通过HashMap获取JSBridge定义的所有方法\n  public static Map&#x3C;String, Method> methodMap = new HashMap&#x3C;>();\n  public void init() {\n      Method[] methods = JSBridge.class.getDeclaredMethods();\n      for(Method method : methods) {\n          methodMap.put(method.getName(), method);\n      }\n  }\n}\n</code></pre>\n<h4>实现拦截方法的重写</h4>\n<p>以下以shouldOverrideUrlLoading方法的重写为例子。在例子中定义的通信协议是myjsb://method?params。通过在拦截方法中对请求进行解析就可以实现调用对应客户端method的逻辑。</p>\n<pre><code>public class CustomWebViewClient extends WebViewClient {\n    private JsbManager jsbManager = new JsbManager();\n    private JSBridge jsBridge = new JSBridge();\n    public void initJsb() {\n        // 初始jsbManager和jsBridge实例\n        jsbManager.init();\n        jsBridge = new JSBridge();\n    }\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n        Uri uri = request.getUrl();\n        String scheme = uri.getScheme();\n        if(scheme.equals(new String(\"myjsb\"))) {\n            // 获取方法名 入参\n            String methodName = uri.getAuthority();\n            String query = uri.getQuery();\n            try {\n                JSONObject jsonObject = new JSONObject(query);\n                Method method = jsbManager.methodMap.get(methodName);\n                // 调用对应的客户端逻辑\n                method.invoke(jsBridge,jsonObject);\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n}\n// 主活动代码逻辑\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建WebViewClient\n        CustomWebViewClient webViewClient = new CustomWebViewClient();\n        // 调用JSBridge初始逻辑\n        webViewClient.initJsb();\n        WebView webView = (WebView) findViewById(R.id.webView);\n        // 设置WebViewClient处理webviewt通知，请求等\n        webView.setWebViewClient(webViewClient);\n        // 开启调试功能\n        webView.setWebContentsDebuggingEnabled(true);\n        WebSettings webSettings = webView.getSettings();\n        // 允许执行JS\n        webSettings.setJavaScriptEnabled(true);\n        // 这里加载项目本地的html文件方便调试\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n}\n</code></pre>\n<h4>H5侧调用</h4>\n<pre><code>    &#x3C;body>\n        &#x3C;div>this page test JSB&#x3C;/div>\n        &#x3C;script>\n          // 通过创建iframe发起JSBridge调用\n          function iframeCall(url) {\n            let iframe = document.createElement('iframe')\n            iframe.src = url\n            iframe.style.display = 'none'\n            document.documentElement.appendChild(iframe)\n            setTimeout(() => { document.documentElement.removeChild(iframe) })\n          }\n          function callJsb(method, params) {\n            let url = `myjsb://`\n            if(!method) {\n              return\n            }\n            url += `${method}`\n            if(!!params) {\n              url += `?${encodeURIComponent(JSON.stringify(params))}`\n            }\n            iframeCall(url)\n          }\n          callJsb('showToast', { content: 'xiaohong' })\n        &#x3C;/script>\n    &#x3C;/body>\n</code></pre>\n<p><img src=\"./crossPlatformStatic/jsBridge/overrideUrlCall.png\" alt=\"拦截请求实现调用\"></p>\n<p>使用iframe发送消息的方式会存在消息丢失，参数限制等问题，可以通过消息队列和拦截shouldInterceptRequest方法来实现。</p>\n<h3>拦截特定方法</h3>\n<p>在初始化WebView的时候可以同步设置WebChromeClient，WebChromeClient主要是辅助WebView处理Js对话框，标题等操作，通过拦截WebChromeClient相应的方法同样可以实现调用端能力。</p>\n<h4>实现WebChromeClient</h4>\n<pre><code>public class CustomWebChromeClient extends WebChromeClient {\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 此处举例为主 直接弹端toast\n        // 实现上跟拦截url一致\n        Log.d(\"mesage\", message.startsWith(\"myjsb\")+ \"\");\n        if(message.startsWith(\"myjsb\")) {\n            Toast.makeText(MainActivity.context, \"PropmtCall\", Toast.LENGTH_LONG).show();\n            // 此时js调起了 需要JsPromptResult.confirm(result)\n            return true;\n        } else {\n            return super.onJsPrompt(view, url, message, defaultValue, result);\n        }\n    }\n}\n// 在初始化WebView的时候设置WebChromeClient\nCustomWebChromeClient webChromeClient = new CustomWebChromeClient();\nwebView.setWebChromeClient(webChromeClient);\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.prompt('myjsb://')\n</code></pre>\n<p><img src=\"./crossPlatformStatic/jsBridge/overridePrompt.png\" alt=\"重写Prompt方法调用\"></p>\n<h3>客户端注入JSBridge</h3>\n<p>通过<a href=\"https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String)\">addJavascriptInterface</a>可以在初始化WebView的时候将客户端的调用逻辑暴露给H5。</p>\n<h4>实现JSInterface</h4>\n<pre><code>    public class JsInterface {\n        private Context context;\n        public JsInterface(Context context) {\n            this.context = context;\n        }\n        // JsInterface需要用@JavascriptInterface注解才可以被调用\n        @JavascriptInterface\n        public void showToast(String content) {\n            Toast.makeText(this.context, content, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    // 在初始WebView的时候注入interface\n    webView.addJavascriptInterface(new JsInterface(context), \"myjsb\");\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.myjsb.showToast(\"Interface\")  \n</code></pre>\n<p><img src=\"./crossPlatformStatic/jsBridge/callInterface.png\" alt=\"interface调用\"></p>\n<h2>Native调用Js</h2>\n<p>Nativa调用Js通常有如下的方案:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></li>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></li>\n</ul>\n<p>以下例子在H5中都定义了全局函数供Native调用</p>\n<pre><code>    function testNativeCall() {\n      console.log(\"nativeCallJs\")\n      return 'nativeCallJs'\n    }\n</code></pre>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></h3>\n<p>可以通过webView.loadUrl(\"javascript: testNativeCall()\")发起调用(需要等待Js执行完成)。loadUrl的方式会刷新页面且无法获取js的回调。</p>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></h3>\n<pre><code>webView.evaluateJavascript(\"javascript: testNativeCall()\", new ValueCallback&#x3C;String>() {\n    @Override\n    public void onReceiveValue(String value) {\n        return;\n    }\n});\n</code></pre>\n<p><img src=\"./crossPlatformStatic/jsBridge/evaluateJS.png\" alt=\"evaluate调用js\"></p>\n<h2>参考</h2>\n<p><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a>\n<a href=\"https://juejin.cn/post/6844903840588759048\">跨端技能必备之JSBridge</a>\n<a href=\"https://juejin.cn/post/6844903856418062350\">从零开始写一个 JSBridge</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null}}},{"node":{"id":"09619f27-782b-59fc-93f7-749e19e44ed8","html":"<p>在前端页面开发中，通常会将数据层和UI层进行隔离，这样能更好的做到职责的分离。在安卓开发中ViewModel可以实现UI的数据管理能力，结合LiveData的观察通知能力可以做到页面与数据视图的更新绑定，更有效的组织页面逻辑。</p>\n<h2>ViewModel</h2>\n<p>View能有效的做到视图和数据的分离，数据共享能力。\n<img src=\"./androidStatic/androidViewModel/viewmodel.png\" alt=\"ViewModel作用\"></p>\n<h3>ViewModel生命周期</h3>\n<p>ViewModel对象存在的时间范围是获取ViewModel时传递给ViewModelProvider的生命周期。ViewModel将一直留在内存中，直到限定其存在时间范围的Lifecycle永久消失：对于Activity，是在Activity完成时；而对于 Fragment，是在 Fragment 分离时。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkklEQVQ4y6WU208TQRTG+a99Uh/UGH3VaIgvPvkEGMGAPICXekVDsS3UloJZe9n7dtu9X2Z+ZhdbDdZC4yYnZ2Zy5ttz+b5ZklLmUkpx3sTECymyXIg8F6UXM2J/WREcLxUL/vObYEgpkylglmXSNE05GAxK3x8M5Nh1ZK3ry+WXinz86kQ+evVDtvVIQi6jNJJxFslc5MX9EkMI8RuwKGY8HmPbNqPRCMuyiUOfphpy53mH26tVbm8c0xhEuJHGoXZAU//KKBpOk5wCTjKeVY6XCHYbGk8rh2wf9NDHOXagcjQPsDhJ01SqqoqiKPT7/dLrukaYZHTtgO+qg2J6xBmY/iUAix5aloWmaZimia7r2I6DzGIyt8ew3yZ1FMhjDF+jeRHgv0qWgU3QfEF/b41RbQM8DSMwOFKrNLU5gJNeTk2Isz+MFKLXdxls3sTfuQFGHSOyaZk12lZjAUApygx9R+Pd+iN2Vh7yZu0BTu8Yw9fZa1f4cvIeN3QuByjEWQdOrIRr6wpXV5pcWTlhv5cyDAZsfVjn5f4249hdjDa2n/HsS48nO3VWP/2g56Q4oUbLrM8vuZhyEAQU5HZdF8/ziMKAIBE0ui4fDxWqpxZeDNaENvOGkiSJHA6HdLtd2u12SZ+h65LGIalnEboGiWeCyDB89WLa/Hot/hQ85S4ZE3QqnH7awP22C6GN7uscadVFpXe2laMe4cdltN37jCv3QKtjRQ4tvUbbaODFo9kZFo9DlmVF6aWlSUImQA4VzO1bKBs3MDavk7W2UH2davc9tf4eTmD+W8vFIIredTqdUnq+75PneRFeBE+5+fn0LVv7a2ztr9LS6otJ7y8pznlgL1DKbGP2+WKAk6mfX88C/AlUyUhxrEpdmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ViewModel生命周期\"\n        title=\"ViewModel生命周期\"\n        src=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n        srcset=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/63868/cycle.png 250w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/0b533/cycle.png 500w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>LiveData</h2>\n<p>LiveData是一种可观察的数据存储类，它具有生命周期感知能力，可以遵循其他应用组件(如Activity、Fragment、Service)的生命周期进行数据的更新通知。使用LiveData有通常有以下的三个步骤:</p>\n<ul>\n<li>在ViewModel中创建LiveData实例保存数据</li>\n<li>创建可以定义OnChange()方法的<a href=\"https://developer.android.com/reference/androidx/lifecycle/Observer?hl=zh-cn\">Observer</a>对象</li>\n<li>在界面控制器中使用<a href=\"https://developer.android.com/reference/androidx/lifecycle/LiveData?hl=zh-cn#observe(android.arch.lifecycle.LifecycleOwner,%0Aandroid.arch.lifecycle.Observer%3CT%3E)\">observe()</a>方法将创建的Observer对象附加到LiveData对象</li>\n</ul>\n<h3>添加依赖</h3>\n<p>使用LiveData需要引入ViewModel</p>\n<pre><code>dependencies {\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.lifecycle:lifecycle-viewmodel:2.3.1\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>在ViewModel中创建LiveData对象</h3>\n<pre><code>public class MyViewModel extends ViewModel {\n    private MutableLiveData&#x3C;String> title;\n    public MutableLiveData&#x3C;String> getTitle() {\n        if (title == null) {\n            // 网络请求、读取文件etc\n            title = new MutableLiveData&#x3C;String>(\"哈哈\");\n        }\n        return title;\n    }\n} \n</code></pre>\n<h3>在界面中使用LiveData数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyViewModel myViewModel;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        TextView textView = (TextView) findViewById(R.id.textView);\n        // 获取ViewModel\n        myViewModel = new ViewModelProvider(this).get(MyViewModel.class);\n        // 创建Observer\n        final Observer&#x3C;String> titleObserver = new Observer&#x3C;String>() {\n            @Override\n            public void onChanged(String s) {\n                textView.setText(s);\n            }\n        };\n        myViewModel.getTitle().observe(this, titleObserver);\n        Button button = (Button) findViewById(R.id.button);\n        // 定义button的点击事件 更改ViewModel的数据\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                myViewModel.getTitle().setValue(\"我变了\");\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/d9632f4d22fc8dd9b600386ab2ade7dc/showLiveData.gif\" alt=\"使用LiveData\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-页面数据管理(ViewModel&LiveData)","date":"2021-07-02","tags":"跨端技术","path":"/android-view-model","top":null,"summary":null}}},{"node":{"id":"18f81a43-93e0-5cd2-aa8e-b21265c68aec","html":"<p>应用程序在运行时需要占用系统的存储空间来实现加载代码运行、存储运行时数据等功能。理解内存空间的管理策略能让我们更好的理解代码在系统中运行的机制。本文从代码运行时存储开始逐步介绍V8的垃圾回收机制。</p>\n<h2>运行时存储</h2>\n<h3>堆存储</h3>\n<ul>\n<li>主要存储全局变量,引用类型</li>\n<li>动态分配，可分配动态空间，有垃圾回收机制参与空间管理</li>\n<li>总存储空间大(通常分配给应用的空间有限制)，查找效率低</li>\n<li>堆空间被应用的线程间共享</li>\n</ul>\n<h3>栈存储</h3>\n<ul>\n<li>主要存储局部变量(基础数据类型)、指针、函数执行片段(function frames)</li>\n<li>由系统分配，通常存储限定大小的数据，栈片段弹出后空间释放</li>\n<li>栈结构后进先出(LIFO),访问效率高</li>\n<li>多线程应用每个线程都有一个栈存储空间</li>\n</ul>\n<h2>内存管理</h2>\n<p>通常说的内存管理都是指对堆内存空间的管理，以下介绍V8中的内存管理方式。<br>\n在V8中运行的程序会被分配如下的内存空间(Resident Set)\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACd0lEQVQoz23LX0wSARwH8HvoqYde22o91kubbj20zH8Tpw+ZpjMn1ioLzywljAORSRqKcIIgJ3hcd7RQ1OafkNWdoilq2siMXeLBwTEOway57EXsvaHV1tb22Xe/73f7AYEoH5lf5qa93ExaxLN4dHAzXnbOS8+s0qSPpj7Q076N2VXm0KZnNbiwshmNAdEQS7UZJI80cjncItV2NmpkkE4mg6HmLnejqRPSK4wPlYYmlRYSVdvzq7ECoS2rHBuV2mMhBoiHwg51X5bGXGLGi7qRcjks6LGUIHie1mhvtLZo2qQLZTJPlWysJrccO37DdlJEHKtEUYkjHg4CXDgyK9XratRIQw8CwqgINoM6MwjrhWoX2Ce+7RTVD4gluESMP7jzWnhrqvrmq+KrEy+kozzLACE2wnYY/A3tAah747EmAHUzrYZgh4GGoI12pVuud0mNnnaUUo0Mgl3D9RonqEUqlHNyPceyQJDldp6oEuC9xKOmhLhpq+7udotyF1d8s2bsolk/iJzvaMYemr2D6KyZpy0Xztjzz/eeO/G2tjLK8ennpLqLF0u2FMotRSvf3JxQdX61Pd02F3+xlG2j15PIlR1rVbyv11F02XmtcKSiiBBcnL9fy0ViQIhh9wkshVn3bWkpzJrC0RSOHjxHDwafHTiwFDHw047u9RuHLp0dFWROlmbjmafe1wljXAxYD/PU1DLpWiJdR/kb5V6hKB9F+kj3O9K19GbSO0yMO/ExJzE+hL2cGCY/hXnAE4gLetfzej7m6/+RA6+VWfyl/f5ceC29GNYFJvpIgYkuNPmpzzzg55OLTPz/gof+VO9m7K9FhvfzyV+uIZYSosOVRgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"V8内存结构\"\n        title=\"V8内存结构\"\n        src=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n        srcset=\"/blog/static/51d594675e95270d44f2ba31e0459f30/63868/V8.png 250w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/0b533/V8.png 500w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png 960w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>V8堆内存结构</h3>\n<ul>\n<li>(New Space)新生区</li>\n</ul>\n<p>新分配对象或者存活期较短的对象都会存储到新生区</p>\n<ul>\n<li>(Old Space)老生区</li>\n</ul>\n<p>新生区经过垃圾回收会晋升到老生区</p>\n<ul>\n<li>Old pointer space 保存有指向其他对象的对象</li>\n<li>Old data space 存放只包含原始数据对象(无指向其他对象指针)、字符串、封箱的数字以及未封箱的双精度数字数组</li>\n<li>(Large object space)大对象区</li>\n</ul>\n<p>存储超过超过1MB大小的对象，垃圾回收不会处理大对象区。</p>\n<ul>\n<li>(Code-space)代码区</li>\n</ul>\n<p>存储代码，唯一有运行权限的存储空间</p>\n<ul>\n<li>Cell space, property cell space, and map space</li>\n</ul>\n<p>这些空间保存大小一致的对象</p>\n<h3>V8垃圾回收</h3>\n<p>V8的垃圾回收机制只作用于内存空间的新生区和老生区，由于在新生区和老生区存储数据的类型(大小，存活时间)等不同，垃圾回收在新生区和老生区使用不同的策略实现。</p>\n<h3>新生区垃圾回收</h3>\n<p>新生使用Scavenger算法</p>\n<ul>\n<li>新生区内存一分为二,每部分空间称为semispace. 在运行时只有一个semispace处于使用中,使用状态的semispace称为From空间,空闲状态的semispace称为To空间</li>\n<li>在分配对象的时候会先从From空间分配对象，当From空间无法存储没有足够的空间存储新对象的时候触发垃圾回收</li>\n<li>在进行垃圾回收的时候会检查From空间的存活对象将存活对象复制到To空间,完成复制后From空间和To空间会进行角色互换</li>\n</ul>\n<h4>新生区晋升到老生区</h4>\n<p>在新生区的垃圾回收中满足以下两个条件，可以移动到老生区存储。</p>\n<ul>\n<li>当对象从From空间复制到To空间的时候,如果它经历过一次Scavenge回收会把该对象从From空间复制到老生区</li>\n<li>当对象从From空间复制到To空间的时候如果To空间使用超过25%则这个对象直接复制到老生区</li>\n</ul>\n<h3>老生区垃圾回收</h3>\n<p>老生区由于存活占比较大,使用Scavenge算法并不科学。在老生区使用Mark-Sweep-Compact来实现垃圾回收。</p>\n<ul>\n<li>Mark</li>\n</ul>\n<p>只标记存活的对象，如果循环引用但是无法被标也会被清除(解决循环引用问题)</p>\n<ul>\n<li>垃圾回收器会在内部创建一个根列表(全局对象,本地函数的局部变量和参数,当前嵌套调用链上的其他函数的变量和参数),用于从根节点出发去寻找可以被访问的变量</li>\n<li>垃圾回收器从所有根节点出发遍历其可以访问到的子节点标记为活动节点,不能到达的节点为非活动节点</li>\n<li>Sweep 释放非活动节点空间</li>\n<li>Compact 整理内存空间，将存活对象占用的空间移动到一起，减少内存间隙</li>\n</ul>\n<p>由于垃圾回收会暂停应用的执行，V8的垃圾回收机制又通过增量回收(incremental GC)、并行标记(Concurrent marking)、并行清除整理(Concurrent sweeping/compacting)、(懒整理)Lazy sweeping等手段结合优化回收效率。</p>\n<h2>参考</h2>\n<p><a href=\"https://deepu.tech/memory-management-in-programming/\">Demystifying memory management in modern programming languages</a><br>\n<a href=\"https://deepu.tech/memory-management-in-v8/\">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a><br>\n<a href=\"https://juejin.cn/post/6844904016325902344\">一文搞懂V8引擎的垃圾回收</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"聊聊Node的内存管理","date":"2021-07-01","tags":"Node","path":"/node-memory","top":null,"summary":null}}},{"node":{"id":"a799c79e-7dd9-5e63-ad1c-467f0ec79fdf","html":"<p>Android使用的文件系统提供了以下几种保存应用数据的选项:</p>\n<ul>\n<li>应用专属存储空间 存储仅供应用使用的文件 存储在/data/data/package_name目录</li>\n<li>共享存储 存储应用打算与其他应用共享的文件</li>\n<li>偏好设置 以键值对的形式存储私有原始数据</li>\n<li>数据库 将结构化数据存储到专用数据库中</li>\n</ul>\n<p>下面介绍几种常用的存储方式:</p>\n<ol>\n<li>文件存储</li>\n<li>键值存储(SharedPreferences)</li>\n<li>数据库存储(ROOM)</li>\n</ol>\n<h2>文件存储</h2>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileOutput(java.lang.String,%20int)\">openFileOutput(String name, int mode)</a></td>\n<td>用于文件写入，返回FileOutputStream。mode有MODE_PRIVATE/MODE_APPEND,MODE_APPEND模式会在已有文件的尾部追加内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileInput(java.lang.String)\">openFileInput(String name)</a></td>\n<td>用于文件的读取，返回FileInputStream</td>\n</tr>\n</tbody>\n</table>\n<p>以下通过一个输入框存储和读取输入内容的例子来梳理文件存储的实现方式。</p>\n<h3>存储文件</h3>\n<pre><code>// 布局文件 定义一个居中显示的EditText \n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n    &#x3C;EditText\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:width=\"200dp\"\n        android:id=\"@+id/editText\"\n        android:lines=\"2\"\n    />\n&#x3C;/androidx.constraintlayout.widget.ConstraintLayout>\n// 活动文件\npublic class MainActivity extends AppCompatActivity {\n    private EditText editText;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 读取对应id EditText中的输入\n        editText = (EditText) findViewById(R.id.editText);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        String  inputText = editText.getText().toString();\n        // 在活动destroy时候 获取editText的内容写入文件\n        save(inputText);\n    }\n    public void save(String inputText) {\n        FileOutputStream out = null;\n        BufferedWriter writer = null;\n        try {\n          // 写入data文件 返回FileOutputStream\n          out = openFileOutput(\"data\", Context.MODE_PRIVATE);\n          // 转换成字符输入流\n          writer = new BufferedWriter(new OutputStreamWriter(out));\n          // 写入文件\n          writer.write(inputText);\n        } catch(IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if(writer != null) {\n                  // 关闭写入流 \n                  writer.close();\n                }\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}  \n</code></pre>\n<p>在模拟器中启动程序，在输入框中输入内容test save file然后退出应用。通过Android Studio提供的Device File Explorer查下对应app下的目录文件内容已经正常写入。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/acd79/saveData.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAu0lEQVQY032OSU7DQBBFfRx6gDhBgILBdnf1YHcmR8n9r/KQexGJBSyeVE/6VfWbNBdciMRproQ8V69IxIf08JAnfM6MEhgk0Ivw7T3Orx6ZT2ea17d32naLtRZjDMbaOv/mGW00gxPK8UIuB3zMOEmENCFpYpTI6APNy6ZFKYXW+k/WR0o90fUDy+3O9Xav7ddj5XjivFxre4mZZtNuH0v/sWZ2Hx1SFvZDYLfv+XSJPs7Ew4Uvn+lc5Ae/ZIZnhB7+6gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"保存数据\"\n        title=\"保存数据\"\n        src=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/00d43/saveData.png\"\n        srcset=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/63868/saveData.png 250w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/0b533/saveData.png 500w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/00d43/saveData.png 1000w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/aa440/saveData.png 1500w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/acd79/saveData.png 1543w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>读取文件</h3>\n<p>在存储文件的基础上，在Activiy创建的时候读取存储文件，实现填写恢复功能。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText editText;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        editText = (EditText) findViewById(R.id.editText);\n        // 读取文件内容 在存在内容的情况下直接设置内容\n        String existText = load();\n        editText.setText(existText);\n        if(!TextUtils.isEmpty(existText)) {\n            editText.setText(existText);\n            editText.setSelection(existText.length());\n        }\n    }\n    public String load() {\n        FileInputStream in = null;\n        BufferedReader reader = null;\n        StringBuilder content = new StringBuilder();\n        try {\n            // 获取FileInputStream\n            in = openFileInput(\"data\");\n            // 转换成读取流\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            // 分行读取文件内容写入\n            while((line = reader.readLine()) != null) {\n                content.append(line);\n            }\n        } catch(IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if(reader != null) {\n                try {\n                  reader.close();\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        // 返回读取内容\n        return content.toString();\n    }\n}\n</code></pre>\n<p>再次重启应用，输入框内已经默认填写的内容。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 670px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 170.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAABYlAAAWJQFJUiTwAAACD0lEQVRIx+2Vy2sTURSHL4rNo5ImJn1IrUWFKjYp6kKxgWzFRbsVFzWNBNGosU0ibUwQhEB01YX9s1zYgiQQyCoLIQkkwcwk6WQ+mcmjtdg0DnXVHvg4c8699zdnLvfcEXanGZtjhOmrE9hdFhzjJuzjZhxd7C4TM9dcTF6xMeYy7ef7cyyMOc1ctI/gcNoQbucKdyeD3JsKcGfiOXNmP7dGV7lp9feZszzrPq8e8n48jgALrgDeGyGuTz1APHV+I3g5x4vZHCuXsjwW31kWuyyLHZbEju478a4eL/XznfjJ6A+CM1k+LpZ4OP0G8fr8T6ImmajlFxu2Ou+tEpELEmvnJNYH0Bt/J+q8FTXWBXitG4iQKLLtVfjqbbHta7F1v8kHe4OXQiY0FA1eiTprAhZNm4hP80W+eFqk52XSt2U+e7q4hyftrrO1AI9mNxGVSgXN2opCu902RKvV0jUSiQSiVqvpgYqKUVMURffJZBJRrVY7gm0VVTXG3p6yX2FfUDVWobauV+GZ4KkVPOqsHRQ4EcGD40MLHvfZR71oYIXFYpFsNkuhUCCXy5HP58lkMvolYGgPJUmiVCqh3UKauObL5TKyLNNsNnUajYbuj63wb5vf89qiw/yT4H8/NoM4a71TLWiUPwS1ttIS2s/aKFpbahaPxxGcoKVSKUQ4HCYWixGNRg0TiUT06nw+H78BU6xYVu/6WoMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"保存数据\"\n        title=\"保存数据\"\n        src=\"/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png\"\n        srcset=\"/blog/static/1380de4785f0d92cefda9699479135b6/63868/readData.png 250w,\n/blog/static/1380de4785f0d92cefda9699479135b6/0b533/readData.png 500w,\n/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png 670w\"\n        sizes=\"(max-width: 670px) 100vw, 670px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>键值存储</h2>\n<h3>SharedPreferences</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context#getSharedPreferences(java.lang.String,%20int)\">getSharedPreferences(String name, int mode)</a>)</td>\n<td>获取共享偏好设置文件 mode默认为MODE_PRIVATE</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/app/Activity#getPreferences(int)\">getPreferences()</a></td>\n<td>获取活动的偏好设置文件</td>\n</tr>\n</tbody>\n</table>\n<p>以下通过一个按钮触发存储和读取偏好设置文件来梳理键值存储的实现方式。</p>\n<h4>存储键值</h4>\n<p>通过获取到的SharedPreferences的edit方法获取到SharedPreferences.Editor，主要通过调用SharedPreferences.Editor相关方法完成</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#putInt(java.lang.String,%20int)\">Editor.putInt</a></td>\n<td>指定key写入数字内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#putString(java.lang.String,%20java.lang.String)\">Editor.putString</a></td>\n<td>指定key写入字符内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#apply()\">Editor.apply</a></td>\n<td>立即更改内存中的SharedPreferences对象，异步写入磁盘</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#commit()\">Editor.commit</a></td>\n<td>更改SharedPreferences对象同步写入磁盘</td>\n</tr>\n</tbody>\n</table>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.buttonTest);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n              // 获取SharedPreferences\n              SharedPreferences.Editor editor = getSharedPreferences(\"test\", MODE_PRIVATE).edit();\n              editor.putString(\"toastStr\", \"hello you click me\");\n              // apply完成写入\n              editor.apply();\n            }\n        });\n    } \n}  \n</code></pre>\n<p>通过查看对用应用的shared_prefs目录已经完成了写入\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/6569d/writeSharedPerference.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA20lEQVQY00WNWW6DQBAFOU7osWMFLwHGbD3AMCy2SZT7H6Uim0j5KJX0PupF6kd6H1jmkW4YsGVNXlbYYiMvKopKcd7jwkClLXXbUTqlUOXaKLUqTdtTd54ozT45p2cym5HmGbm9kmcnko8D+/07ZmfIrGW6rQzjTDeMuH4LP+26gab125F2REYEMYI8LQZjDDsjvHYR4jgmSY6EaWH9/mGaF3wINOqYlxthmljudx7rF7U6olfkDxH5x2xxIzFyOHKwLTo+SMqet1OBXCouTeBYevJ2pgor+7ThF5+Wh7cLoqijAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"写入SharedPreferences\"\n        title=\"写入SharedPreferences\"\n        src=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/00d43/writeSharedPerference.png\"\n        srcset=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/63868/writeSharedPerference.png 250w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/0b533/writeSharedPerference.png 500w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/00d43/writeSharedPerference.png 1000w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/6569d/writeSharedPerference.png 1328w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>读取键值</h4>\n<p>在上面的基础上按钮点击立即读取内容完成Toast提示。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.buttonTest);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                SharedPreferences.Editor editor = getSharedPreferences(\"test\", MODE_PRIVATE).edit();\n                editor.putString(\"toastStr\", \"hello you click me\");\n                editor.apply();\n                showSaveSharedPreference();\n            }\n        });\n    }\n    public void showSaveSharedPreference() {\n        // 指定名称获取SharedPreferences\n        SharedPreferences pref = getSharedPreferences(\"test\", MODE_PRIVATE);\n        // 通过getString/getInt读取存储内容\n        String toastStr = pref.getString(\"toastStr\", \"\");\n        Toast.makeText(this, toastStr, Toast.LENGTH_LONG).show();\n    }\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 682px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADd0lEQVRIx+2U7WtbdRTHf05mkramSe69ydIHDekDzeoiU6qIQ/piIG7q3OpbH5CsD5MJ7SKj0zrBgbKC+G5ziiC+UNgLGfrSf0Ba2VpJW1vUYhF8I31McpObm4/87u3N0rR1TRio4IUP93fO75zvOed3H4SmBpEcCDUR1EKoSnALSkCjpfkBDoTCKIq2bV9TQ1aeElB5MBJF+JR6vH43obCCX23Ar3nwa3UWAa0On+qhNaIRbGq01s5eCbUOr99Dg9eNP+BFHNYGONI0xlORUZ5sHuXg/nMc8iRt3Pa92zXCQ+5ztl1G931JHlPOc6RllOPxS7SFnkD0NX5HwvsHCWWRV+9f5IT4iVNigRfEPCfFAifFvGVL+sQCL5bRJ+Z5qe4XzrQscqF7jcPqy4jX3DcZ88MFJc3FcJaxoM47IZ1LUZ2LYZ13m3XGNJvRxiwj+7KM3Hub4XsynBXrDAvoaTiNeGXfLca7YDye5aPHc1yO5xh/OMeHj+Z4P2bbHxzMcflQjreDOqdFloFtpDkr4BFXP+K9o7f47Dm4cizD1Wd0Pj5uc+VpnavHbBzftWd1Pj2h80kF155P88UpOBrrR/z82wz2VQCKNWJYCq+/MYhI/WgLGjkT06Am8rmCpTE4MIiYmbEFTdOkWCzWRKGwKThYIVjL9b/gf1FQBjj33aiM27OgaRQxC2UYRYrm9oJ3HNkR3XVMs1j9yJmVIjfezPP1sMGNpME35w2un8mT+tZOlh3vqUOn+p+/mgyIDMn9WZKuLG8FdMv+qj9n/0ryexXc7DCfKXLzep7JL/P8sMn3n+f5fbpQKvzPnqEVaGzHrPYp3/X38N/96e1l3MqxqxKs7KR8XfW3/HedVu7fsUMZsL6+bpFOpy2c9cbGBtlsdnfBVCpVEnFEZcLS0hITExNMT08jY6ampqz17Owsq6urVrz1RzJNDMO4LTg3N7fj03O6Wltbs+6yM6drR6DyfIeGhhCTk5NWgKzqCEikgEQKl4s6wsvLy6UCKysrlmAikUBEIhHa29tpa2sjGo3S1dVFLBaz1o4vHo/T2dlZ8sn4np4eOjo6LNvxhcNhhBCCclRVJRAIbPHJAm63e4uvt7eXylyPx4Oor6+3gqUhcblcW+zdfDvZPp8PoWkadws5nVAUhVqQyTv5hdwopzyhmj157q2trfwFQwS6D7Ui69MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"读取SharedPreferences\"\n        title=\"读取SharedPreferences\"\n        src=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png\"\n        srcset=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/63868/readSharedPerference.png 250w,\n/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/0b533/readSharedPerference.png 500w,\n/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png 682w\"\n        sizes=\"(max-width: 682px) 100vw, 682px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>数据库存储</h2>\n<p>ROOM是SQLite上的抽象层，通过ROOM可以完成对数据库的存储。<br>\n应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8d3f78a5cef5b83fc0d933cdfc4dae96/0a47e/roomStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 90.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEbklEQVQ4y4WSX0xTZxTAD7Atm6AuMzgTtmXTbAvxwWRvy2KWLDEZJntZsuxhy4aCy8iEAlUD0pZCW1ooguWCtB1WnUbsxibQIhcs0HK5/9p7W8DgHC1UCtd/hcwBwpZIznLvQCU+7Ca/nPOd75xfvpscYH6/e5qPLYzwsfnrfGzex8fmB2QiiSWF8MyiEkdnHw1EZpcVhPjDAT76X9/6TD8fm+fom1IBhKYWYqOzyxhJLG2ih5nAa+xN7A9NIsnfwm5q7EktcGMWx+ZWNvXLjmAs2S4L45HE88KB8DReYyawX4gq0qtDInpGbmBnIIJDYzM4Jq1geGbxmZllDEaTbmBuSieCsYWLfDTZxkeTrg0iM4uu0dllVySxqDAurbjG5pZd43OPXOHbD13c5APXM/3y7BV6Yu4LEKb/BERUmFpC+Gs9/z8S/yDcWUOQHiNIawhzjxHGpBVQvsoqwy6DuX4rIqZ8ogEwkflgHjgCRjIPaq7nK9HsOwKWwe/A2JsHn1W/CuHk/bQlxNT7iKkPEFPvIaaO3/k7BYoKC6G0tDSz5HhxhuH8cWjwat+2+bV5zSO6XJtfk0tQ2lxbQI663OYR3be2IU1+vbdiT533BBCkJcXjF8ETEMHjF6DLRwOUlJQowuNVqm21XWVwqq+8wNRVgvpfjqKpuwSrfy1C+VzVUYiV7qNY4ynFBl+5qs5fBk6P5sU4QcAGtwjiqfBYpWpbXVc5NPSd/MbsVaPhqmrJ0qNeMnYWPzJ71KvGzuLVqo6iZUvPMTzlKz/s9GoBEECy2yHe0gKjViuMWCxPhYVFhenlNWowXzr5SuM17R5iqHK3rat6L9Ff/V4TU5F1JqjLcoqGNxsHK95qPqfbeqvm1Ja7bT9mrLndGQ/Pn88Qamu3XjcYXngiLCosSs9KfR9aeT00DJRBW38D9F+mtqu/L8sqL9buqa4w7a0q1u6G13JenmoiDs+2tKxMNzVJk42N96ZsNkk6c2Z1urW1DlQqFajV6sxDhw69pNPp4OuPC8DWbk7zO8fhys+Xd+kNlVlGs2GnxWp+47TZ+A52kHCbICrv2+04brEgrdejaDJh0uHAOYejU1kbjUbzusFgeNdqtWZbrVZlfeQ6SZI79Xr9h0aj8SuTyfTp6fr6D8IaDfzR2vpR3G5vSzgcRMLpbJ1xOJrjdrsrard/DjzPK4uanZ2dnpOTs13Oo9EoSJIkO9NkNpaZY1lIJJOACwvy3RbYt28bHDiQCfv374CDB3cskCQARVEnWJa9xHGcg+M4J8uyZxmGOScIwjlRFM8KgqAgiqIrGAxeEATBxXPcTwxFtbM0fXGdCyxN/0YFAl8Cx3FxQRAwFAqhHDfo6+tDkiTR5/MpeW9vLw4ODiq14eFhDIfDm/plWJZ1y8KoKIrPXXq9XnS73djT06MIu7u70ePxKDVZHolENj1CdnAc1y7/MsEwTIim6QBN09QGoVCIEkWRCgaDCvJZRhAEiud5pYdhmI1+P8MwkeHh4R/+BZT5oarFBcAMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ROOM结构\"\n        title=\"ROOM结构\"\n        src=\"/blog/static/8d3f78a5cef5b83fc0d933cdfc4dae96/0a47e/roomStruct.png\"\n        srcset=\"/blog/static/8d3f78a5cef5b83fc0d933cdfc4dae96/63868/roomStruct.png 250w,\n/blog/static/8d3f78a5cef5b83fc0d933cdfc4dae96/0b533/roomStruct.png 500w,\n/blog/static/8d3f78a5cef5b83fc0d933cdfc4dae96/0a47e/roomStruct.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在build.gradle中引入room依赖</p>\n<pre><code>dependencies {\n    def room_version = \"2.3.0\"\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.room:room-runtime:$room_version\"\n    annotationProcessor \"androidx.room:room-compiler:$room_version\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>定义实体</h3>\n<pre><code>// 实体会在数据库中创建对应的表\n@Entity()\npublic class User {\n    // 主键id自增\n    @PrimaryKey(autoGenerate = true)\n    public int id;\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    // 定义列\n    @ColumnInfo()\n    public String name;\n    @ColumnInfo()\n    public int age;\n}\n</code></pre>\n<h3>定义Dao</h3>\n<pre><code>// Dao封装数据查询操作\n@Dao\npublic interface UserDao {\n    @Insert\n    void insertUser(User user);\n\n    @Query(\"SELECT * FROM User\")\n    List&#x3C;User> getAll();\n};\n</code></pre>\n<h3>定义数据库文件</h3>\n<pre><code>// 指定实体 版本\n@Database(entities = { User.class }, version = 2)\npublic abstract class AppDataBase extends RoomDatabase {\n    // 指定Dao\n    public abstract UserDao userDao();\n}\n</code></pre>\n<h3>访问数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建db\n        AppDataBase db = Room.databaseBuilder(getApplicationContext(), AppDataBase.class, \"dbTest\").allowMainThreadQueries().build();\n        // 插入数据\n        db.userDao().insertUser(new User(\"xiaohong\", 19));\n        db.userDao().insertUser(new User(\"dawang\", 19));\n    }\n}  \n</code></pre>\n<p>通过Android Studio的Database Inspector查看已经在数据表中插入了对应的数据<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/f69df/showDataBase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAASUlEQVQI142JQQ6AIAwEeZUmRovtFgvE/39njd7g5GEyO9lk0SnmfO315onCPetvjqnThsZFnKuAiMZsPiAKWgki6rfnX/0a+gEPIUZXbc7pYgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"显示DataBase\"\n        title=\"显示DataBase\"\n        src=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/00d43/showDataBase.png\"\n        srcset=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/63868/showDataBase.png 250w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/0b533/showDataBase.png 500w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/00d43/showDataBase.png 1000w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/aa440/showDataBase.png 1500w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/f69df/showDataBase.png 1762w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"一起学Android-数据存储","date":"2021-06-29","tags":"跨端技术","path":"/android-store","top":null,"summary":null}}},{"node":{"id":"4e73be01-4c68-5088-b080-f4fc9002ae45","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1e207791889ca13b322aad1f9814efd4/8ae78/viewGroup.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVQoz4WQvUsDQRDF76+0stBSsLWQYLDwC7Qyoo0oabRIoXVIEbExJjGXBAnhcpjI5cD7MruX283t3s5IchjhRHzFwDzmN/MYDf+QUgoR66/9tZ3jzcOz9fxJrnCdmdEyPQAoAABMFCBi13jLFa4OLm93L4qFm/t/4MzxOI7DiHnB54SGEeNSyiRJpJRprixsvI+fu/1ap1fr9NxggghCxEKIBSLSdYwxIYSU8geGRc2fF1e3jzb2T1e29ipPL4j44TiNRsM0TUopAFBKDcNoNpue52nLhPMkANW6XipX7yqPpfKDadkIihDqeR4hhHOOiLPZjBDi+/50OtVSUn5r/itEUMnST5IkNX9Li6LItm3XdTnnAMA493zfsixCqViQYRiOx2Pf9xljWTgIgna7PRgMCCFKqTAMR6NRq9VyHCeO569yXVfX9eFwSCnNwF/EHvWL4zIuSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"布局\"\n        title=\"布局\"\n        src=\"/blog/static/1e207791889ca13b322aad1f9814efd4/00d43/viewGroup.png\"\n        srcset=\"/blog/static/1e207791889ca13b322aad1f9814efd4/63868/viewGroup.png 250w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/0b533/viewGroup.png 500w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/00d43/viewGroup.png 1000w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/8ae78/viewGroup.png 1096w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n安卓的页面是通过ViewGroup + View的组合来实现。</p>\n<ul>\n<li>ViewGroup是布局容器，它定义内部视图的展示方式。</li>\n<li>View是视图组件，例如Button、TextView等。</li>\n</ul>\n<h2>LinearLayout(线性布局)</h2>\n<p>LinearLayout会将它包含的元素按照水平或者垂直方向线性排布。</p>\n<h3>LinearLayout布局属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout#attr_android:orientation\">android:orientation</a></td>\n<td>horizontal/vertical</td>\n<td>水平/垂直布局</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout#attr_android:gravity\">android:gravity</a></td>\n<td>left、right、top等</td>\n<td>定义内部元素的对齐方式,默认left</td>\n</tr>\n</tbody>\n</table>\n<h3>LinearLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams#attr_android:layout_weight\">android:layout_weight</a></td>\n<td>数字</td>\n<td>布局权重，结合layout_width可以实现均等分布</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams#attr_android:layout_gravity\">android:layout_gravity</a></td>\n<td>left、right、top等</td>\n<td>定义组件在非主轴上的对齐方式，会影响父布局gravity的作用</td>\n</tr>\n</tbody>\n</table>\n<h2>RelativeLayout(相对布局)</h2>\n<p>RelativeLayout是以相对位置显示子视图的视图组，每个视图的位置可以指定为相对于同级元素的位置或者相对于父级的位置。</p>\n<h3>RelativeLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_alignParentTop\">android:layout_alignParentXXX</a></td>\n<td>相对于父元素的位置对齐</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_below\">android:layout_below/above</a></td>\n<td>定位在指定视图的上面或下面</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_toRightOf\">android:layout_toXXXOf</a></td>\n<td>定位到指定视图的左右边缘</td>\n</tr>\n</tbody>\n</table>\n<h2>ConstraintLayout</h2>\n<p>ConstraintLayout与RelativeLayout相似，视图均根据同级视图与父布局之间的关系进行布局。在ConstraintLayout中定义的视图必须至少添加一个水平约束条件和一个垂直约束条件。ConstraintLayout的布局方式能有效的解决嵌套问题，优化页面性能。</p>\n<h3>ConstraintLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_toXXXOf=\"id/parent\"</a></td>\n<td>相对于另一个元素或者容器布局</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_marginXXX</a></td>\n<td>定义外边距</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_bias</a></td>\n<td>通常用与调整视图水平/垂直位置</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_goneMarginXXX</a></td>\n<td>定义当相对视图不可见时候的边距</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_minXXX / maxXXX</a></td>\n<td>定义组件的宽度限制条件</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_percent</a></td>\n<td>百分比布局</td>\n</tr>\n</tbody>\n</table>\n<h2>自定义视图</h2>\n<p>在业务开发中，不同页面的组件能力共享能有效减少业务逻辑的重复。下面以一个按钮为例子了解创建自定义视图的流程。</p>\n<h3>创建组件</h3>\n<p>新建一个类继承LinearLayout并且在构造函数中引用按钮的布局。</p>\n<pre><code>// 类文件\npublic class button extends LinearLayout {\n    public button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // 指定按钮的布局\n        LayoutInflater.from(getContext()).inflate(R.layout.button, this);\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Toast.makeText(getContext(),\"toast\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n}\n// 按钮的布局文件\n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    &#x3C;Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/button1\"\n        android:text=\"button\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>\n<h3>使用组件</h3>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n    // 通过类名使用组件\n    &#x3C;com.example.learnlayout.button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        title=\"clickMe\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学Android-布局","date":"2021-06-25","tags":"跨端技术","path":"/android-layout","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":8,"pageCount":15,"additionalContext":{"pageAllCount":88}}},"staticQueryHashes":[]}