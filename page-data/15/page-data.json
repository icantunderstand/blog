{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/15",
    "result": {"pageContext":{"pageAllCount":91,"group":[{"node":{"id":"99c9b30a-e728-507a-9299-d6242ca4ad7f","html":"<h2>简介</h2>\n<p>网络套接字是应用层和传输层的桥梁。套接字提供了应用层与系统内核的交互的能力来完成数据的发送和接收.下面主要从套接字的几个基础api来介绍套接字并且结合tcp来理解网络应用对外提供服务的整体过程.</p>\n<h2>基础api</h2>\n<ol>\n<li>在使用套接字发送数据时将数据从应用进程的缓冲区写入到套接字的发送缓冲区，来完成数据的发送.</li>\n<li>通过对套接字函数的调用可以获取套接口的一个描述(一个套接口可以对应多个套接字描述),当内核中不存在套接字的描述符的引用的时候,内核会触发该套接字的close.</li>\n<li>基本TCP客户/服务器程序的套接字函数调用过程</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB6klEQVQ4y5VT25KiMBD1/z/MB6t884qgYhEFBJKQK52kmdJMMe7s1K5zHqhKyOk+fbp7Nr6Nvu/X6/Vut9Nax5vZm0xEFEKkaVqWpbX2/2REHMeRMZYkyel0EkJcLpeyLIdheDczPhFCkFKmaZrn+VuZXxFCMMYQQuq6BoBf18w53+/3RVF8NwwRlVKTnm9lRwDA4XAghEz3syipbdvdbne73SZJPzq3WCyWy6X3/iuz955SmiRJVVVCiBCC9x4RrbX3+905h4j+CSGE1nqSM4uBGWNpmrZtG9tojPHeE0Lm8/l2u7XWaq1jrCjtUzYitm3bNE2apk3TaK3DE7GllNJhGKZUxpjJrQfZOSelVEp1XSeltNYCgDGGMdZ1HWMMAIZh6Lquqqrz+VxVVV3XUsoHGQCcc+M4/m31q2HOOa11lmWEkBgdER/kWMY/yNOcZFlWVVV8HEL4JMduvZbHGMvz/HK5aK2998YYSunxeLxer5xzKeUjs3Ouf2K/30e3o7HGGCllLCp+h2EQQiil/hjPEELf95vN5n6/x3+ICACU0q7rXntjnvhyO5KVUnVdc86NMQBgreWcE0Ji8wGg73tKaVEUcWx+txha67Zt42JzzgHAez/7cQemNY6Ix7IsV6tVkiRFUcQR+AAp44e3Q8OxXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"套接字基础api\"\n        title=\"套接字基础api\"\n        src=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n        srcset=\"/blog/static/488016f75fa3e6b554b97157803a13e8/63868/api.png 250w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/0b533/api.png 500w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>socket(int family, int type, int protocal) 默认产生一个主动的套接字 其中family字段指明协议族如Ipv4,Ipv6等, type为套接字类型如SOCK_STREAM(字节流套接字), SOCK_DGRAM(数据报套接字) protocal指的是由前两个参数决定的协议说明 例如tcp传输协议  UDP传输协议</li>\n<li>connect(int socket, const strcut *servaddr, socklen_t addrlen) 在TCP套接字状态下调用此方法会激发TCP的三次握手.几种常见的网络错误也是在这个阶段出现了\n<ul>\n<li>如果发送了SYN,在经过TCP的超时重试之后仍然没有收到对应的ACK,此时显示ETIMEOUT超时</li>\n<li>收到RST(复位) 通常对应的对方没有正在监听的服务器、TCP想断开一个已有的连接、TCP收到一个不存在连接上的分节</li>\n</ul>\n</li>\n<li>bind(int sockfd, const struct *myaddr, socklen_t addrlen)  将一个本地协议地址绑定到一个套接字\n<ul>\n<li>在绑定地址上,在服务端上的一般都绑定到特定的端口 对IP地址进行0.0.0.0(INADDR_ANY)绑定(为了处理服务器有多个网络接口), 最后由系统内核指定IP地址  在客户端一般有内核指定IP地址和端口</li>\n</ul>\n</li>\n<li>listen(int sockfd, int backlog) 将一个从主动状态转为被动状态,指示内核接受指向该套接字的请求\n<ul>\n<li>backlog参数代表着未完成连接队列和已完成连接队列之和.在正常的三次握手的过程中,一个未完成连接的条目存活的时间是最后一次客户端对服务端ACK的确定(RTT)</li>\n<li>设置成较大的backlog是为了扩大为完成连接数目的队列.当为队列数目是满的时候,TCP会忽略该分组,这样TCP将重发SYN而不是显示连接错误等</li>\n</ul>\n</li>\n<li>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) 从已完成队列中返回一个已完成的连接\n<ul>\n<li>区分监听套接字和已连接套接字  监听套接字在服务器的整个生命周期只存在一个,连接套接字是为每个接受的请求都会创建的</li>\n</ul>\n</li>\n<li>fork 创建自身进程的一个副本\n<ul>\n<li>fork的调用会在父进程和子进程中进行返回,通过区分返回值来区分父进程和子进程</li>\n<li>子进程共享共享父进程fork之前的所有描述符(注意在fork的时候关闭对应的描述符)</li>\n</ul>\n</li>\n<li>int shutdown(int sockfd, int howto) howto指明如何关闭改套接字是关闭读的部分还是写的部分,这样能防止关闭套接字时候无法处理到达的网路请求返回数据</li>\n</ol>\n<h2>相关参考链接</h2>\n<p><a href=\"http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html\">tcp backlog</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null}}},{"node":{"id":"b3d4eea3-bcd1-54be-82e3-ecc3aca713b9","html":"<h2>简介</h2>\n<p>通过对运输层和网络层的基础知识的学习,了解到他们分别提供了基于主机进程间的通信和主机间的通信,这都基于数据链路层实现的上述功能,下面通过对数据链路层的学习来了解数据是如何通过相应的数据链路来实现传输和交付的</p>\n<h2>基础</h2>\n<p>1 在通信路径上连接相邻通信节点的通信信道称为链路。链路层协议将网络层的数据报封装成链路层帧来实现数据在链路节点间的移动。\n2 链路层主要提供的服务有数据报的成帧,链路的接入(无线链路,有线链路),可靠交付,差错检测和纠正.链路层的功能主要在网络适配器(NIC)上来实现相应的功能\n3 链路层通信通过MAC地址(LAN地址或者物理地址)来实现,所以一个通信的具体过程会涉及到三种地址:</p>\n<ol>\n<li>主机名</li>\n<li>IP地址</li>\n<li>MAC地址</li>\n</ol>\n<h2>地址解析协议(ARP)</h2>\n<h3>ARP的作用和寻址过程</h3>\n<p>ARP提供的是同一个子网和路由器的网络层地址到MAC地址的转换.主机会在内存中维护一个ARP表,这个表保存着一定时间内该子网内主机IP地址和MAC地址的映射.当目的主机的IP地址在ARP表中时,发送主机通过封装链路层帧目的MAC地址为保存的目的MAC地址将数据推送进数据链路层.当ARP表中没有响应的条目的时候,发送主机通过MAC广播地址发送APR广播分组,这样子网内所有的主机都会处理该分组,符合该IP地址的主机会发送ARP响应分组,将自己的MAC地址通知给请求发并且更新请求方的ARP表</p>\n<h2>以太网</h2>\n<h3>以太网基础</h3>\n<p>以太网是基于之前的各种协议实现的一种局域网技术,它提供给网络层无连接服务.</p>\n<h3>以太网帧结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 884px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVQY0z2LTUvbYACA80PEHzC9CLrLKlLGDuJgpTI3vzpE2EUZyHbRIt5kh6FsggeL2po0PSiryeL7NhVddVK1TWcjJbXWFisxpB9C0tqlJjbv0E0fntvDg5mmiRBSlUr27DyTzpbVa4RQWa2kkplqtYYQusv3mA8+gkmiVJALSkkVc2IumytIRVmSxXMpk8rqNf3fdFUsyZeyWf8/GrqRlwpaVcMOufhxIq1UtJKqXpXL+aKyuxdJZy5EOV+rm9c3xs2tKSTP4ryg6beabvwx6mpVi0bixZKCPaUTnZunjgDXQfNW6miQjVlgygZiL9bCr8FRZzBlBUL7hmBhEh0waYVCFys4AlzbOj8Vu8AmmajNz7W6wccNboyJWtxwiuXH/L/mNw+ee7efeMPTW8euHd61f7IQijsB1+zbf0kEvgR/fw6fYv1L4JkLNs3gvR7Y6wYts95hcntg0T9OMq1zqw1fqdHVkPP7Tye9N7G2NYSzjd+o9jlv9yL4BCNY1zLT5wuOkvQbAr4l4AhJ2wh2iPjhwKn3JDPgC3bj0L4C7B7GvgJ6cPiOhB981KtlaiYU/Qscvja2c8oD8QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"以太网帧结构\"\n        title=\"以太网帧结构\"\n        src=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n        srcset=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/63868/dataLink.png 250w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/0b533/dataLink.png 500w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png 884w\"\n        sizes=\"(max-width: 884px) 100vw, 884px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>前同步码 主要用于在发送方和接收方进行时钟的同步</li>\n<li>目的MAC地址 当接受方收到对应的链路层帧的时候,当该帧的目的MAC地址是本机的MAC或者是广播地址的时候,数据字段的内容就是向上传递给网络层进行处理</li>\n<li>源地址 发送方的MAC地址</li>\n<li>类型字段 用于与上一层的某协议相结合</li>\n<li>数据 网络层数据报</li>\n<li>CRC 循环冗余检测用于接受方检测是否存在差错</li>\n</ul>\n<h2>交换机</h2>\n<p>链路层交换机主要提供转发和过滤的功能.过滤是指决定一个帧是否被转发到某个接口还是将其废弃的功能.转发指一个帧具体应该被转向那个接口.</p>\n<h3>交换机的转发过程</h3>\n<p>交换机通过自学习的特性定期的维护自身的交换机表.表的条目分别是MAC地址,接口,时间.当交换机收到一个帧的时候,会根据该帧的目的地址做出不同的行为</p>\n<ol>\n<li>如果交换表中没有该MAC地址的时候,交换机就会向它所有的端口转发该帧</li>\n<li>当交换机接受到该帧的端口MAC地址和目的地址相同的时候,丢弃该帧.</li>\n<li>当交换机表中存在相应的条目的时候,将该帧转发到相应的端口</li>\n</ol>\n<h2>web页面请求的详细过程</h2>\n<p>可以结合前两篇来理解这个过程(DHCP HTTP  UDP CIDR IP MAC(ARP))  里面涉及的编制 寻址 传输等相关协议</p>\n<h2>思考</h2>\n<ol>\n<li>网络协议虽然是分层的，但实际的实现上层与层之前的界限并没有那么清晰,不能割裂的去学习网络协议模型,要从整体上理解网络协议的整体过程</li>\n<li>在具体功能的实现上,例如数据链路层通过MAC地址进行通信而不是依赖网络层的IP地址,这样就能使数据链路层与其他种数据格式对接,增加独立性</li>\n<li>层与层之前的功能不具有强依赖关系,例如数据链路层是能够通过CRC循环冗余检测来实现差错检测和恢复的,网络层自己实现了本身的差错检测,在实现一个大型的系统的时候,功能到底是依赖于上层还是自己去维护(稳定性)都是值得考虑的点</li>\n</ol>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null}}},{"node":{"id":"4a2c57bb-e06c-5beb-a596-a9352d6e71d9","html":"<h2>简介</h2>\n<p>在初学node的时候,都会在学习到下面的这个例子:</p>\n<pre><code>const http = require('http');\nconst server = http.createServer(function(req,res) {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('okay');\n});\nserver.listen(8080,function() {\n  console.log('server is on');\n});  \n</code></pre>\n<p>上面的例子就创建了一个最简单的web服务,当通过浏览器访问本地的8080端口的时候页面就会输出okay。下面主要从两个方面来理解node如何加载和运行这段代码来提供服务的。</p>\n<h2>node代码结构(基于node V6.11.0)</h2>\n<p>下面就是node的代码结构,在lib中主要是node提供的标准库(例如http等模块),在src模块主要是node的入口文件和node提供给lib的C++接口.在deps中主要包含了DNS解析,http解析,事件循环和跨平台的异步IO的实现等.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 932px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABB0lEQVQ4y62STU+EMBRFWasLE93KAKV8tDhAS9FAYTIMBtf+Aifj3v+/uqadxGh04XRcnDT9yMm779XLshxaa/S9RpKkoDRxgpAYnBfwzKaqakzTDmmaIQwj+yCOqcVJ2DQK2+0EISTW6/Ik0Q+hiVnXAsMwYlmeoVRrL8+KLIRA1/Uoy+oz7tfVKfI8P1mhi+yXCiXa9sH271+mrJSyMt9ffZuuc2QpGzsUrQfbS/N9zoicQsgGfT+AscJizmJT4R85CulRyLMMQ9fhnjOQIACNIiSEnEZMQKMQBcvh0eoRzWZBwCV8JrBy5C6vYVzezfyG9OUd19MBl+MrrjZ7Jy7GPW53B3wAKwuBpW1A2esAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node代码结构\"\n        title=\"node代码结构\"\n        src=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n        srcset=\"/blog/static/38795164842a3beb02db9ed01e44311f/63868/nodeSrc.png 250w,\n/blog/static/38795164842a3beb02db9ed01e44311f/0b533/nodeSrc.png 500w,\n/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png 932w\"\n        sizes=\"(max-width: 932px) 100vw, 932px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>node如何加载我们的代码</h2>\n<p>通过都是通过命令行 node server.js来启动一个简单的服务,下面来简单的看node如何加载和执行这个server.js文件<br>\n在node的启动文件src/node_main.cc中有如下这段代码,它调用了node.cc的node的Start方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABG0lEQVQY032QW27CMBBFs44SE+dhk4Q4YAenBIIoffFH1Q10/7s4VRxRqf3ox9Gdq5k7I00k1ZrWd4wnh2oc286z6yxp7ShbyzDs8d5TVRWJTEiSJctkOetyroOXs48SKZGFpNwW6HYip+4UK5MFKqso6hTVZKGnTY5a55RbxWpTUFqFbvKQV+uMSEqJdTV+aHF+y+PBU7Y1WbNBGYuqNafLkd3eYeyaXKXILCFTkrxMA2khg58IC5/OPa8vA+N45Pr2zqGzbPoL2p3RuuLjdmMcT3TeMc3HsUDEIui9vhPJVGK0waiWbmfoe8PX1fL53OH7R5qmYT/s0VoTx/H8t3+ITGlwtSVN0hAQQvCwECymi+I3U+Cv/iDmhd//Pa9jeahOZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"main\"\n        title=\"main\"\n        src=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n        srcset=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/63868/nodeMain.png 250w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/0b533/nodeMain.png 500w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在Start方法先对平台进行了初始化操作 主要关注下面的代码<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVQ4y5VUbY6bMBTMLbbi0wYCBtuYGBuyCWxIVlWlXqA/ev9zTGWTRNlmW2l/PD3LFuOZeYM3QgjM84TpeMDr64j9fodx7GCMhLUGfW8wDAP2+z2UUhisBWMMURQhSZKn2nBewfQSvS8BY1owVoGQFJTSe2VZBkKIX6dp+gEkjmNfHjDNKmRlg6auIYT0t2d5hjiKEIUBojBEGAYIgwBhGCKK1orjyLN0e4/Am4o1aLhE27a+hOCoawZabJGVa89LhrKskOcFsiz3ndIM2+0WVVVdGV4lZ5Si19p71XUdrLW+s1ZDmAMaPUDYA6Z5wvvlDafTEfN8wPnyhmEYvafOgrtk58ttw3W/ThIQv06QXqUYs8PhYNDUBRjL0ba19zMIgrvcO6A7cACPphNCr+v1Qr57RdPPyLlFKQxS1oFUClKPsMZgHEfkeX5lSCiSK6ADSh/AbwpcdKZpwnlZ/P4/Y0MoQUkT5CS+Azn6N6BVTgJrB5zeTricz56N1hrO/5vUW3Q2NKP4dZH4/dPi+48T5sni/f2I83LCspyxLG4QM5ZlRte1Po9uuq4/DuPO0B1yLiDlGp2iKPyU21aiU2uXkkGpGkoJb4nL3mOYH0E3Utbouhq7XQO949gWW7y8fPPTC32o1wCvIY6eGD0xdIykFF6OY8M5gxAMVVUiSdJPjf8b5EmyUh3cI+H+krZlnq37W1xk/vfxp4BN2WDgFoop/5qoTkP3wwewr4BuHLNxGH25x6HgGkwfkRelfwC+ws4B/gFXCsyHoBFOiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"init\"\n        title=\"init\"\n        src=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n        srcset=\"/blog/static/8b7bf7989faf13dade451e000d201e37/63868/init.png 250w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/0b533/init.png 500w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这创建了一个node的实例并且传递了一系列的参数(v8_thread_pool_size uv_default_loop 后续会对这些参数进行讲解) 最后调用StartNodeInstance开启了node的实例,然后顺着这个方法往下走发现node继续这行了LoadEnvironment()和下面这段代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmElEQVQoz22R227iMBRF+YtpCSQhsZ2LE99iQoBQOmj6/5+0RrhSpen0YWmf87C395E3tajx0RHPgbh4/GwJJ8dpPWKmnuXmmM+GMGviMnL7PRFPPs3LanFRU6kyIfuKTVVVtG1H23RIoRC1RIqGRikaJRh0g7WaQXeM4yezM1y8YXEj12Dxg0ZJRbbN2MhacD1feH9/436/8XisfHy8sa5HrutMCCPGarR+8gx/hvZpb5oGY0aC97Rty36/Z1MWJZdz4PHnwvV65BgNMfpkMMYyDCN5XqTXs2xHtt2RZVlit/t3zvP88+TyUFDJA/t8z6+XF16320S227LbZxRlTl7kSYuyoCjLZP5OaqiUYL1HjufAss4s68Tl7jldHPEUUJ1E9QLRVMiuTnslqmT+KXQjhCBOE8F/Yo2jazumEPAuMA6Wvu2wpqfvNc46pJDJXBTFf2zKQ4nqJY1WNMNTJbITiUYLulHSGYVsBVJUHA6HH5t9NazrCucdU5ywzuK8ZTQjve4xbiRMOv2yMZppGlBKfZ371O/8BY6zCINLY+oYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"exec\"\n        title=\"exec\"\n        src=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png\"\n        srcset=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/63868/execNode.png 250w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/0b533/execNode.png 500w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png 1000w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这段代码拿到lib/internal/bootstrap_node.js文件,将它编译解析并且转换成C++的函数最后执行。在lib/internal/bootstrap_node.js中其实就是一个匿名函数<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADBElEQVQ4y52U247bNhRF/RuJdaMkSryKulu+jO2ZuE3TvhT9/39ZhRV7ggkCFOjD1qEAYktrn0NuqlLSeY91Gjf1+MOC2020y4hpFKLMEGVCLhMKmRJtt0RRRBzHJEnyXp/aZGVFNR5pTm8080J/ONKeLoy3v+iWmet15HDes5vHVbVxlEXxS7PVUBQlOoyopke3A9Y5pDLodsR7RRsMJvSoZqD2HaZp0br+bpj8MHyab1JRkEqHChO6nZDKYoY9bn5B9Qest4yDwSrJqEqsLEjT7B07juIP+Js0u2ckyCvxyCtdVdSCLE/fJWRGIcWqUufr+33/fd+HPywyQRM62ssXmt2B7uVCd/nC8HYjHK+E3R7fNmscrg2r4d3s+aFcZj8hJzG5GZDtCeVa+tON/vqN+es/hN2Jy3ngeBgYrKaxlih6YiarogfyB8PCT9TDET8vDK9f2f3xN/3lhh8Xltcby+0bflgYx0DXGZwq6VVBWxfMtqbVFZWUjwzTlLyqkc6g+4Cd7h3XqNCRS0VdlTinMKYmBI31nsoFKutRLmCMJkvTH2OTpglCd6jhSDhcafdnwjhx/e3C8brnfB6YDgfm6xvLaWFsG8ZxRvmOQjtqVT/QoydygrQGN/fooLBjS7MfCYcdzRLwTU3fe3TTkusGpSTBVxhZUGcJeZqsgy6EeCCvhhbdt1RWrcMrTUCFkbI2aFXRd47aWIraonS9RqBKiSpyylxQ/GyoQqBZJtzQEE5nXOdY9h437fDzRCYSkmxLJrZE8ZY4jUjyiG30/VxHa92u6GuGubJUQ4scHfUc8NOE7nu0t/hlwc076qYhHF/QbYcd75Gc1uNZGY+oHMY1a3M294fpF9zhjWbsmI8TTdeTiZIsu5+eilzWJGm2dj0vK0Qu17UoJFlekGY5eVE+LgchEGlCsv1EGkfE289sP396INyHePu+jh6I8QMzfqzj+FljNmUpWE49tz9vvFwXTq9XjA/co/jV9fRf2lhl+P10w40H8tpQNQPKtwiR/S/DfwGj6A9fBUsu3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runCode\"\n        title=\"runCode\"\n        src=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png\"\n        srcset=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/63868/runOurJs.png 250w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/0b533/runOurJs.png 500w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png 1000w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png 1058w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里面先做一些挂载的操作(例如给js调用C++代码的挂载), 然后从命令行中获取到文件的名字并且读取文件进行warp,这个函数会被上面提到的位置去执行,这样node就加载并且执行了传入的server.js文件。</p>\n<h2>http.createServer()如何对网络请求提供服务</h2>\n<p>通过对上面代码的理解,node对网络请求提供服务其实是通过lib下的基础模块调用C++模块的代码来实现的,下面跟着http.createServer()来梳理下这个流程\nhttp.createServer(requestListener),它通过调用_http_server.js下的Server(requestListener)方法创建了一个net.Server(继承EventEmitter)并且将传入的构造函数绑定到request事件同时绑定了connection事件<br>\n上面的代码部分主要完成了一个server的创建.最后调用listen()方法的时候才能监听器对应的端口来对外提供服务.server.listen([port],[host],[backlog],[callback])其实调用的是net.Server的listen方法.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 895px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVQoz12Ry27bMAAE/R2NKPH9EEVKtBXbcdQmaeuc+/8/M0WMoKhzWOxtMNjdDcOAdZrDmpn3jTgf8ClRz9+Zt9+4OOK8xTtNLDPT44WyXrDWIISg7/t//ZGdUorRjyST8NphfELFivQTMUVicBjrkL6g4ox0GWstD113A32F7qSSjGGkhILXhtA20vYHt38hn35Sjm8sx43ltFHXjWU58LQUWnQEa2/wO0MpJZ3oEFLQdd/Q0x6/vqFiIZ7fcY9XyvHCus7MS+UwOq7HyuOcyVNGyuEeOAwSFwxln6gtUFogtcq0JlyWSPWAsgPK92gn6GWH8hIdFL4YpPkCFKKntcz79YkfrxdOL6/Mz7/I7YxPE6G02wEhV1I7MS4rxhhE97Fff0vfi8/+NNRakbMnpISJmUEZBu2xccTnijEalzKh7om1obW+s/rf8C9CdsvY254TIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen\"\n        title=\"listen\"\n        src=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n        srcset=\"/blog/static/ed775f0f74eb21887b354475a2e11427/63868/listen.png 250w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/0b533/listen.png 500w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png 895w\"\n        sizes=\"(max-width: 895px) 100vw, 895px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在net.Server的方法中主要对参数进行了判断,例如是否存在IP,port以及是否传出handle,通常的调用方法都是server.listen(port,callback) 这样会在特定的端口监听来自IPV4或者\u001cIPV6的网络请求,在listening事件触发的时候响应callback.下面在继续跟进listen方法.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVQoz5WS246bMBRF8xmTcLExBgMGnAAhhHQ6N0XtSJXax/7/j6wKMmmbTKRpH7bOkeWztbyPF3GSUjQDtukpMoN1DbYbKVyLlPIkIRAiJAxDhBBzDeeztz4815BFJCPSWJNaR5xXxIkhLdfEccy6NlQ2odAKZzQm0YRhQBD4BEFwU4tYKkxmyZseWzvc7oBtBxKTka9binYgL2uUUicqGSGEfJOYTc50M+H0nLo9MI4jPx8zjk8D7v5I2Wwpmh1lt8ftH7DdnqzaUEzRbHpM6UhNhu/7l4YqVmQqxeqMwFuxvLtjtVzOF33fI/C9uT+TXBBd0Z0MVYzUCVJF1HWJcyW5tajEEEXyYvhWZufzP0tRiu7lG/3LK8+vXzl+/0G3P6B0Om/3muBa7zKcgq36T1S7zxT9PTqv0HmJzibK9N3AR5oN3eGZ9uELxbohyS2m3mCqDUlWzF/kvwynnKrtSL0dkMLH91Z/yfv9rH8lXURSopOUKcvrL3Aro48MfwFwaTboCCOYlAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen2\"\n        title=\"listen2\"\n        src=\"/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png\"\n        srcset=\"/blog/static/5940d58735192e92131a71aab4c797d5/63868/listen2.png 250w,\n/blog/static/5940d58735192e92131a71aab4c797d5/0b533/listen2.png 500w,\n/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png 1000w,\n/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png 1116w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n继续跟进_listen2方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.39999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVRIx41VSXLjRhDkMzwigN53NDYCILhqGStCHvsL/v8z0tHNkUYaUbIOFQAOncjKyspe2bFFt5vxcNjix3nG7ejx748Ju7GB6g6w/R6buyf0pz9RjzvE+YTu8ID++B2+m2CbAX7YwtQtlDFYacURG4uNrXAKBYxREHUL6Tx0cFDWwsSYSzl/eXoPaRQYJyjLNYr1GmVR5FoRTkAVAXUca8NBDINwBMJTiMDALYVwFNwSSEehArtUzWEaCek4yrJCVV1qpbjEME2Iw4iH8w63uxHBaSjJ4LWElhxWCzgtwThDRSoQSnI9vyegsiwvgFpp3B8OmIceT02Fp44iaAmvBHqnEY1CNBLBKFBK88Fr9Qy6Yoxh6CNisLgPJe5qAiP5C2jnNIQQWCeNfh68Vi8MCWUgykO5GkwaEBVQlQWK9Q2KoshAN+sCxRtGFapXzF7XKrWhhYJretimRwgB0jUQNsKkSUuBxipYnabKfzH6gOmKEgLjasT5gGEecTxOmHdbLIctlv2UWx/6DZphA+M9XN1c2H0ESCiFoAxCaFTSg+oArgwEo2i1yAwrQrFOXntuufqflhnjGB/+Rnt8ROxnTG1EbTUUZ0gdEELeHvyMYQLkXKCdT2i2R7h2QPQ2MyuK97b4aMqvAAmkVNifntAvZ0idTC1RVeQNwFfAXgC5EKi3J8TlDN9P8N4h+fMrIOVv7a845xfjfvsD65tvKIp19t9X2Fxjv2KUIe2z8jWUNmDSgnKZQfPfiyL/5DlNytfvV/TNPtSuzq12bcB22WAzthiGGt0QEcZ9zjxTd9ChydnnhyUPz4aYXVCWxatdTpsiDYTrIHwLG9us4RA0pmhgnYWQAnlFqwpJomQzJiQoY0g+Jj9D44WhtBFh94A47THNHU63W5zujjjfHbA7LuiGHmGz5C0ZnIaRAi6ldLysq3EhS3DZFELgXcQy3SF4B+8EfLDQsYcKLZSPIMJCGA/t66vTfxNfydRcubxuyjcgLH3bLP4lcdY5fZ6/Xx++lomrZBnCVQbJEZZspA2qqrzE181Nrgz8icl/aSgMuPYwSYvYIQxb1Jsl69P0G5wff+D8+BeGeXnR6dNNYTpANzPa4wO6/T26w32+Hk07QxubB5EqefSjzXljbMIlmHb5vrCGo20sqPSQrobtRgjtYLsJ2vk3Zr52n1w0ZBI2tDA+QAqWbzbKOLiU4FLkPU+eS9omH1YpzijL4UEIfc+QMwHTLQj9iH7TY7ttcdx3mOcWm01A0zUQ2sJJhsZIaJ+2ZwcdInw3vrPRijAGUU+ol1uM3/9BN24wzNuckcVvN135TrP3OfkfVOAewXaWNUwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"handle\"\n        title=\"handle\"\n        src=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png\"\n        srcset=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/63868/handle.png 250w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/0b533/handle.png 500w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png 1000w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png 1171w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在这个方法中主要创建了一个server的handle并且绑定在之前传入的port并且在这个handle上添加onconnection的监听函数并且在nextTick的时候触发listening事件.createServerHandle其实做的是调用的C++层的接口,创建了一个TCP实例,并且将它监听到IPV4或者IPV6端口。node处理网络请求实际是通过触发这个handle的connection事件实现的\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 944px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVQ4y4WUWXMaRxSF+RMJzAKzz3TPwizAsAmQwUJCyJJdseUtdvkhVXlO5Q/kn3+paWwsx0J5uNXT25nb59x7Wp7M8fM5opxyv+nz+SLm41rychkjspJAxKT1GcXZhny+Js1LbMui2+3S6/V+ipbt+vj5jHJ1yWDxjHxYUy4uyQZjoqzAdhx10LJsepb19WKXbrf3OKBlOziBJIhT/CAgSjLivERkBSKvsG1bZfPfaEC/gTzMtuU4NotlxbCQ3BVdPtY93g90bssevueqw5b1eDYP4xtoy7EdfMcnjBNCz8XtGThNWCam2UXXDTTNUGMTpqFjdrvoholhNmfMI1gzthzbJkkrqsWaejIgTSRJ6BN4LkKGlGXCYJhRlTF5kREmfbVXyIC+CIki8WOGPauHlBnTasGwLAhDHxl4+K6jvpMkIs2EGmUs8EWM6zjqp8L38Hwf6yiW4tBRB0xNw9B0tE4brdNB1zronQ7tdodOu1nT0Npt9Pavak/TNDRdV9+GutvB0DVaruMSeRGiUTavSAZT4mqMKGpEPiQvCpJyRJhkiHxAOpohqxrRzJMMWQxJBmOS0Yy4rGnZlo2Ufepn14zW1ww3N1TTGfPVjEE9URx5YROReq4vErwoxvUDvCYieViXqVpvWbaFCGPG/Slp3MdyXVV7nmth25ZS0TQMTNM4jI3Kam5+31Nrh1B16Ng9Ou1f0LX2YUM/8Glq+skWOxUt23FxZIG7eYN79QlPpATZCHdQENQVURQdfmIadE3zWCIne7npAlGMGN68J13tyGdrytWO6vme/OwcP4xw/BA3iHA8/wHQCcBe1yRIcsbbOxWT3W/k0xX9yYrybM3g2U6tTa5fUy0vVM09RUOrqcGqnij5D2oluI2qkUCkfcK0IEgygjhTih6ebP5kCkfARvr9/SdW272qv3K5JZAJ9WzB/v4zxWiKrCaq/oJQ4MYVfiiOfD7CoaV8zrLt76NyGBvb9bBth8biLMf56omHc6cN1nGUkfqRVJ3QdEfzfCljGn4f88KH7vIToB+E3P/5F7e//0F1fqVE6A/H1OsdIklVuXx7xY+XT2Toeh7bV+9Ybm8IkgJRjnE9n7A/xAslhq5jGIYyCl3Xnszu6NhVFVMWUnlfWcTUoz5lGTOblQwGKePJiMXFnsniHOsJsCPg9W7O7e2SzWbMze2KF7cr9i+WvH235XI74uWbO778/Q83r99jW/8D2IiyuTxne7Xg8nLOcl6xez5lvRxxdTHh+e6CVx/ecffhC9uX98g4VryeBGxEabhLs4Q0FUjfpR/5ZKGPb/eo5muW+zcImXzlsPckh/8C/oPY8Ao+dPAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"connection\"\n        title=\"connection\"\n        src=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n        srcset=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/63868/connection.png 250w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/0b533/connection.png 500w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png 944w\"\n        sizes=\"(max-width: 944px) 100vw, 944px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上面的代码中,底层的C++代码会在connetion的时候传入clientHandle,然后node会创建一个Socket实例并且在通过connection事件将这个Socket实例传入对应的回调函数。这样就用回到了lib/_http_server.js中对connection的监听函数中<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fed65a33502990495432004fc0039796/d0143/request.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB70lEQVQ4y32S2XLjIBRE5zOSCIRYBUKLLTlWvMUz8///dKakJK5yypmHBl5oDt33l1KKqqqwlaHdvDIc35nngctx5Hrccn7bMvcNb0NmHrfM24GubYlNpI41QgjKsrzp183QWjbDzOu0p8mB2lpab+mCo/UaYwyu6fBNR4gJURRIKVeTZf863wwX9bsTp8uZy2XkvBCeJoa+RbmAdh7rHLIoEKK4o/oyuzM0RuNyT+47NkOirQO7XBOMJuQel1rq3FGWCik/qYS8o7wZaq0Z8sAubdDG8VIIlFYIpVC6opQCXUq0FJhSrqqUWmNYYB4SLqX004Hp8ofjYcv7aeLvaeT3ceS4aXnfZg7jwDxNzLuJ9rMYt8Tw0NBatv3MbtyTkiM6y5ACXe3J3hKtRluPjRmXMsa6teGHX/4qpR0PnK8nrtdXDseRfuqxwfNcFBRLXkKs7Yri5W5cfiQ0dSJ3DW1OVOo+m0f6TrcaLsuSQwo1pZA8PT3z/FKsxQgpP2hWFcj1kvzvA6uh955pujDv9/RdJHvHNgWcNR+D3HTUKVN+DvBPuhF65/ExE2JcmwvWkGuLXWYzRlwd8XWNUiXlN6nqQzfCJcMUEmPosa5BNxPaGnSsMKHCpWVXuEZjo8bWGpfMeja+wrcWnw2VUavhP+s9cWr9hXq5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"request\"\n        title=\"request\"\n        src=\"/blog/static/fed65a33502990495432004fc0039796/00d43/request.png\"\n        srcset=\"/blog/static/fed65a33502990495432004fc0039796/63868/request.png 250w,\n/blog/static/fed65a33502990495432004fc0039796/0b533/request.png 500w,\n/blog/static/fed65a33502990495432004fc0039796/00d43/request.png 1000w,\n/blog/static/fed65a33502990495432004fc0039796/d0143/request.png 1025w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个方法主要对之前创建的Socket进行一些解析处理和方法绑定最后将生成的req,res通过request事件传入到回调函数中.这样就回到了http.createServer(requsestListener)中来完成特定业务的处理</p>\n<h2>总结</h2>\n<p>从以上的两部分，主要从两方面来整理了下node启动和执行服务代码,node如何处理网络请求，但是node中还有很多有意思的东西还没有说清和弄明白.例如backlog 事件循环 v8_thread_pool_size(node的线程池)等等.</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null}}},{"node":{"id":"18374d92-6b8b-544b-b3eb-b649443d935f","html":"<h2>简介</h2>\n<p>运输层提供了运行在不同主机上的应用进程之间的逻辑通信，应用程序通过逻辑通信，运行在不同进程的主机好像直连一样(例如输出一个URI 就能找到对应主机的资源)。 运输层是直接与应用层打交道的网络层级。通过对运输层协议(TCP/UDP)的了解和传输机制的学习，能更好的帮助我们理解应用程序的行为。在阅读计算机网络自顶向下方法的运输层时整理了如下的笔记。</p>\n<h2>运输层基础</h2>\n<p>运输层通过多路复用与多路分解来实现将主机间的数据交付服务扩展成主机的进程间的交付服务。它对应用层提供了两种服务类型:</p>\n<ul>\n<li>基于连接的，可靠地服务(TCP)</li>\n<li>不基于连接的，不可靠的服务(UDP)</li>\n</ul>\n<h2>TCP</h2>\n<h3>TCP报文段结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 454px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABu0lEQVQoz22R646rIBRGff9XapM2fYEaTZpevBQUBKEgKBdltCdTck4mJ7N+7nxkf6ydVFU1jqMxZpqm8S9KqWEYmqa53+9SSmttnP/LTNNEKU0opeu6lmUJIeSc0w9a623blFKc82EYiqKglBJCMMaEEEqpEMJam3DOvfcIoThijAkh2rYFAFBKMcaU0izLuq4TQvR9zxjjnAshnHPfm733zjlrrfswjiMAoKoqAEBZlk3T1HVNCNFaG2NizHxI5AdrbQghtoAQXq9XQkhd1xDC2LmqKozxsixxk/d+nufkcrns9/s8zzHGp9Ppdrulabrb7Y7H4+FwiL2893VdAwAej0fbttZapZTWOun7PoTgnBNCZFn2fD4BAEVRCCGmadJaT9N0Pp/zPG+a5vF4RBfbti3LkjDGrLXxVIQQKeXr9YraIIRRct/3SikpZfxRNMIY+348z3PUMM9zLBlCkFKmaRqdjeMYM8MwMMaklAghKWUSpdsfGGO898aYuq4551LKZVmi5+jJex/NJV+/Mc8zQghCiBACAGit13UNP1iWJYSQvH9jXVfOedd1fd9jjJ1z7/d727b/Yn8AH0+bq1J7Cv0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP\"\n        title=\"TCP\"\n        src=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n        srcset=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/63868/fragment.png 250w,\n/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png 454w\"\n        sizes=\"(max-width: 454px) 100vw, 454px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>端口和目的端口用于TCP数据的多路复用和多路分解</li>\n<li>序号和确认号用于实现可靠数据传输</li>\n<li>TCP的连接状态保存在端系统中，这种链接的状态对网络层是不可见的。网络层只看到的数据报</li>\n<li>确认号可以理解成发送方期待接受方发送的下一段序列的初始字节编号。例如当A收到B发送的数据是500-600（不包括600）并且在累计确认下(前500的数据都得到确认) B在发送的报文中确认号就是600,A接收到报文后就会发送600之后的数据给B</li>\n<li>接收窗口用于实现拥塞控制(TCP慢启动)</li>\n<li>在6个标志字段中 ACK用于确认上一个已成功报文的确认 RST，SYN,FIN 用于连接的建立和拆除 PSH被设置的时候标志接受方应立即将数据交付给上层</li>\n</ul>\n<h3>流量控制</h3>\n<p>流量控制是发送方与接收方的一种速度匹配服务。在发送方与接收方都维持一个接收窗口的变量。假设该变量的值为rwnd，发送方必须保证LastByteSent - LastByteAcked &#x3C;= rwnd.假设接收方的缓存空间是RcvBuffer,必须保证 rwnd = RcvBuffer - [LastByteRcvd - LastByteRead].该窗口字段在接收端发送报文的时候会写到TCP报文的窗口字段。当接收端的窗口是0的时候，发送方接收到对应的报文将发送只有一个字节的数据报文段，此时接收端将接收这个报文并且清空自己的缓存空间(数据传送给上层)并且回复一个rwnd大于0的报文段</p>\n<h3>TCP连接的建立与中断</h3>\n<h4>TCP连接的建立</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPElEQVQ4y21Ty07jMBSN+CF2iK/gQ/gdliyQumEkxKpUHakwmpRFxDNNUlJFQigPMrRJWgfHaRLH8R3BRaYwc1b29X2dc681AJBSAsBqtTo8PDw4OCCEKOMmbm9vj46OTNNUFk1KKYRo2xYAtre3d3Z2AKBtW7mBrusAIMuy3d3d8XisHDSsgM/7+/t7e3tFUaBFAVPbtr21taXrOgAIId4qA0BZloQQzvl8PnccJ89zQsi/bQshxuPx6+urIvUW7Pu+bduEEMbYYrFwHKff75v397913TTNNE2rqsLWOOcq11vbm7mbpqmqCs+r5fLx8XHqur90fTgcep6XJEkcx0j4g7MiJqWs67osSyVBJ2WZ56HjZL4/dd2zfv/6+poxZlnWdDrlnGuoR9u2Xdet12tKaVVVrCiuLi6GvV6/17MNw314iOM/nHNKKYqPxTQhBM4DJUmSZDQaDQeDn6enV4bhh2FZfxJWan0EA0CapsvlkjFGKR2NRufn51EUBVGE/HERmqbhnOd5jhaEhrtFCFmv13meB0Hw9PQ0dZwfx8eXl5e2bSdJ0jQNeuMKqCl+UZtzXtc1Tn4+nxuGMRgMTk5OdF2PojBN06Kgm/6a4oCjQrVV7rqugyC4ubmxLOvu7g5H9SnYt8rYIb5hRrUCcRy/vLxg8AfnzTUsy5JS+u1LoSsesiz7D2e8h2HoeR7OTH4FAFBKXddtmka843vbQghK6Ww2WywWz8/Pvu9PJpM4jr13WJbFGNv8sH8BdCuyVQ0e+JcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"三次握手\"\n        title=\"三次握手\"\n        src=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n        srcset=\"/blog/static/450ef929b273efe5395a856db3581d99/63868/connect.png 250w,\n/blog/static/450ef929b273efe5395a856db3581d99/0b533/connect.png 500w,\n/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>客户端在向服务端请求连接的时候，会向服务端发送一个SYN报文段。会随机选取一个client_isn作为序号字段放置在该SYN报文中。</li>\n<li>服务端在收到该报文后，会发送给客户端一个报文并且设置TCP的缓存和变量。该报文的ack字段是client_isn + 1,序号字段为server_isn,SYN比特为设置成1.代表当前服务器已经准备接收数据</li>\n<li>客户端在接收服务端的确认报文后会创建TCP的缓存和变量并且向服务端继续发送报文(此时的报文可以携带上上层的数据),其中ack字段是server_isn + 1,序号字段是client_isn + 1,SYN字段为0(此后的报文中SYN字段都为0).至此TCP连接建立成功。(三次握手是为了确定双方的序号)</li>\n</ol>\n<h4>TCP连接的中断</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACnUlEQVRIx4WVS2pyQRCF7+qyCFcgCK7AUYYhOnfgyEAgDl2BRIMKOjAPiCGaGI3vtyY+ovXzNZS0915/G5qr3V2nTlWdrnZERLbbrfz+/pr59/cn+/2e5cPXHqzp+m63k9lsJtPpVJbLpVl32Oj1elKr1eTj4+PI0A/M/gL49PQkLy8v0m63zZoDO4Cen5+lXC7L29ubrFYrDxs/wE6nI4+Pj5LP58232+2Ks9lsjIdMJiORSEQuLy8PTGHgN3Qd57lcTq6uriQcDsvd3Z04xWJREomExGIxSaVSZhK+bahMbcbNZlOSyaREo1G5vr6Wm5sbSafT4tze3kogEJBgMCj39/fy8PAgk8nEF4ipTkqlkoRCIbm4uJB4PC7ZbNakzcG4UCiYSg2HQ5nP53JquEFRRaVSOVpzKMB6vTZ/+v2+DAYDc3CxWJgvB1utlkm4eyAVdzSOfWA0GhkQNigWzgCGPY5+fn7MRBmcYQ/JHQHaiQYQA/cAkCIgYvYBYb6+vkqj0TgU0AM4Ho8PtwV2ypCQv7+/TX4JU3WKA1+GmlDU/vn5aUAxVPBTgzPk3Rb7EUPyBKNzVdbzhI8y7H0PIF7d1w4VEK4NCHNyXq/XTTo0DY5NlxyqhDQVGCIZDCkOwOSOdCCZ9/d3c1W1mI6CIRM2McQIcK2qtifN59mQVRp0DMIGiAkI4NxtioX+7IYBS9+iaCtCa3ZVMYY5QBQLcDtknGPnkQ2Di03IAJxqsLqOA5XZ19eXPyC5Y9pF8Zv2oLKaQw8gOaT8hOLuzu6urf/dwj4ChBkh24CnGJ4FBIRK8jb87z1xA9qyOWpfhFqtVs0L5s4hldZO4n6sqLz2SU/IDLqvPlCnQraZclP0/fF0G76wRMDnAN2ysn//Aw2QzK7dGbfNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP close\"\n        title=\"TCP close\"\n        src=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n        srcset=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/63868/close.png 250w,\n/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n(发送方和接受方都可以中断TCP连接)</p>\n<ol>\n<li>终止方向另一端发送一个TCP报文，其FIN比特位被设置成1</li>\n<li>接收方回复一个ACK报文并且发送一个FIN报文</li>\n<li>终止端回复一个ACK报文，至此两方为了维持TCP连接的缓存和变量都将清除(接受FIN端需要把自己剩余的信息发送完 才能发送FIN报文)</li>\n</ol>\n<h4>TCP客户端和服务端的状态转变</h4>\n<h5>TCP客户端客户端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB4klEQVQ4y42U144CMQxF5/8/CF54gDckiui9I3rvHa+OV4YwO0hrKcokE19fXzvxxLF2uy2ZTEaWy6Wuj8ejbDYbGQ6HMhgMZLfbyfV61X/M8XhcstmspNNpCYfD0mq1xHs+n2IDu1wuslqtFIQDs9lMarWaNBoNmU6nMh6PNeBisdAAj8dDwff7vc6eC3Y4HGS9Xr/WFoBxPp91NmMNaLValXq9rmvMc1OGmZkbyDV/Ntvt9uOfd7vdpNvtqhZEIiIsXWe/LMxkMxqNJJlMynw+V71fgFCnIKVSScVHK7QxZ5cBhg/aQoKRSqVU8/v9/k4ZkHK5/Ce9oDWAFIQBEPqx99KQqoVCIcnlcnI6nT6cgxhyHlaJREJisZj0+/23hnYYPYz2N0D/PkDNZvPDR9uGDRoY/aD+DcxfZc7Sn65pUahsPp+XSqWiTQywn6n7TcHoDDSnysw0PPvKEN0AAYy+oh/dKge1DekCVCwWtTsmk8kb0OgT9VuFg1K2m0UL0XofRbHOp4IuE+6nXb2gs0gDkV6v98sQ3SKRiD4EnU5HtSAag6qjbaFQUAfWFIF/3A4YIhfgprnHK8GTRQ8CaMyIxnWyFwbNACI9cwY8Go3q04WOfx6H/7SKewaGsCaYPRI/rcIZxDx6n2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"客户端状态变化\"\n        title=\"客户端状态变化\"\n        src=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n        srcset=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/63868/client-status.png 250w,\n/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>连接的建立 初始的时候TCP客户端处于CLOSED，当它需要与服务端建立TCP连接的时候，发送SYN字段，进入SYN_SENT状态. 当收到服务端对SYN报文的确认后，就进入ESTABLISHED状态，此刻TCP客户已经能发送和接收数据了</li>\n<li>连接的中断 客户端发送TCP报文(FIN字段被设置为1),进入FIN_WAIT_1,等待服务端的确认报文然后进入FIN_WAIT_2.等到服务端的FIN报文并且发送确认报文后，进入TIME_WAIT.最后进入CLOSED状态</li>\n</ol>\n<h5>TCP服务端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABxklEQVQ4y42Ux47DMAxE9f+flFOQ5JKDL+k9SO+9Vy4eASqCsIssAcGWRI9myLHc7XYTxuVykdPpJMfjUZ/MebdxOBzkfr9Lu92WdDotmUxGUqmUZLNZGQwGmk+Oq1ar0u12ZTabyfV6FeL5fHrw4XAo4/HYgz4eD1kul9JqtaRYLMp0OpUwXKPRkHK5LJVKRdbrtWe2WCxkv98r4Gg0UpDVaqV7rIfxfr/9cOEGySxavF4vncOYdwvmHGj7BqoMLdHkhCfGEa7vdjsvNwR1sEJ2s9nUuiCb4sdS7CMO3W63UqvVJEkS2Ww2OocYQxkCSqcmk4k2w1iHLO0dubCjppaPS3xT6C5dZJAcA8SSLVABMERo6Hw+FxzjWIQ2nUNOKO83hvYEEGXIxT44pd/vf7psgP9liBrA4j2HmZENdWTjtbDb8QfUF69SPxoJkfP5/Kkhk06no/rr9bomxvYJy2AeRGapVNJuw9QzNGRY2h8QA/1lH5jGJXFhovnpW5CDbcyvgFM6BaR2uVxOXW+mpXt0nxLQvUKhIL1eT+uL8dnHJvl8XnPssqAcDgD+FC4BYwcwtQWAmnI5kEdJ7EbCzBwCofDX+wGhXtIqR2SqKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"服务端变化\"\n        title=\"服务端变化\"\n        src=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n        srcset=\"/blog/static/884026a29f246f33aa0a88780176d2d5/63868/server-status.png 250w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/0b533/server-status.png 500w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>理解TIME_WAIT状态</h5>\n<ol>\n<li>可靠的实现TCP全双工连接的终止 主要close的一端 需要维持状态以防止最后一次的ACK对方收不到来进行网络重传</li>\n<li>TIME_WAIT阶段设置的超时时间会导致网络中迷失的分组丢失,这样在同样的端口创建新的TCP连接时候,不需要判断之前的数据.</li>\n</ol>\n<h3>拥塞控制</h3>\n<p>TCP使用的是端到端的拥塞控制，来防止网络拥塞时发生的各种问题(多余的分组,丢包等)。相比流量控制，拥塞控制是对网络拥塞的一种感知来控制发送的速度。流量控制是对接受方处理速度的一种速度调整。\n在TCP发送方维护一个拥塞窗口的变量来实现拥塞控制<br>\nLastByteSent - LastByteAcked &#x3C;= min { cwnd(接收窗口) , rwnd(拥塞窗口)}</p>\n<ul>\n<li>当发送方正确的收到确认报文的时候，他认为网络中无拥塞，不断的调整 cwnd</li>\n<li>当发送方超时未收到ack或者收到接收方三次冗余,需要降低发送速度</li>\n</ul>\n<h2>基础词汇解释</h2>\n<p>MSS 最大报文段长度<br>\n在不同的链路层协议上，其最大的传输单元(最大链路层帧长度)不同，这就导致了在封装到IP数据报的时候，需要适应底层的链路层长度。</p>\n<h2>TCP UDP 区别</h2>\n<ol>\n<li>TCP提供差错校验,重传等功能 UDP不提供对应的功能,UDP需要在应用程序中添加对应的逻辑来完成相应的功能</li>\n<li>UDP的数据报长度字段会随着数据发送给接收端,TCP是一种字节流协议,没有记录标记的长度(content-length) 主要是两者实现方式上的不同UDP是不面向连接的 也就是可以从一个套接字接受多个数据源 如果没有长度加以区分数据就会混乱.一个TCP套接字只对应着一个数据源,可以由应用层来决定数据的读取.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null}}},{"node":{"id":"ec68373d-8e97-584b-87f0-0a3da8f93d38","html":"<h2>简介</h2>\n<p>在实际的工作中，发现自己对网络这方面的知识有些欠缺并且作为一个web开发者有必要了解网络中数据传输的基本过程，在阅读计算机网络自顶向下方法中把网络层的基础知识整理如下。主要分为三个方面网络层的基础，IP(网际协议)，相关协议简介来简单的学习下网络层。</p>\n<h2>基础</h2>\n<ul>\n<li>网络层提供的通信机制是多个协议族共同运行的结果。主要有以下三个组件：IP协议,路由选择协议,ICMP协议</li>\n<li>网络层提供的主要功能是提供分组的转发并且结合路由算法实现路由功能，也就是最终实现主机间的通信。运输层提供了主机上进程之间的通信。</li>\n<li>因特网的网络层提供的服务是一种尽力而为的服务，这样做能简化网络层的行为.当上层的服务需要对应的功能(例如运输层需要保证数据的按序接收等)时候，通过它自己去实现.</li>\n<li>网络层的有连接服务和无连接服务\n提供有连接服务和无连接服务的网络层形成了不同的网络体系。仅提供有连接服务计算机网络称为虚电路网络(ATM,帧中继)。仅提供无连接服务的网络称为数据报网络。</li>\n</ul>\n<h2>虚电路网络和数据报网络</h2>\n<h3>虚电路网络</h3>\n<ul>\n<li>连接建立 虚电路网络需要在路由器上维持连接信息，在虚电路建立阶段,需要在建立的路径上的路由器之间维持连接状态信息(对应连接的路径)，当连接建立后，这些路径信息存储在路由器的转发表中</li>\n<li>数据发送  发送对应的数据</li>\n<li>虚电路拆除 发送方通知网路层终止虚电路,在网络的路由器上就删除对应的路径信息</li>\n</ul>\n<h3>数据报网络</h3>\n<p>因特网是一种数据报网络，这种网络体系结构在发送数据的时候需要将目的端系统地址推进到网络中,通过逐个路由器的转发最终到达目的主机</p>\n<h2>网际协议</h2>\n<p>网际协议(IP)现在主要有两个版本：IPv4和IPv6<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 573px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABE0lEQVQY021Q2Y6DMAzk/39tW4ntwQIthENFCkkDCWlwnYNVG/Vpd2SNLM9Ylicp8nKa5uF2I6QxxsC6pml6znK0VmuN+HwXPh76cDiKafbeAwAizvOcMMalVFLKcRwpHZ1znHEhhPdeKTWOLFqfAH3XE9JM02StRUQpZbJtm3Nu28KyLPlPDgAhBO/8e1kWRTnNs7U2HjydzpSOIQRrrVIqqaqqKMq6rhm/L1pzxi7Xqm07pRSlVEoJAMMw7Hb78nKta8L4HQDWdRVCJMaYxwda68gAKyHN7mvftB0AxPlL+niMMZzzxDlnP0CMjN77vu2+0wNpWu89RuEtxdY59/r5FcYfAKxd12dZVtUEnv8gpv0LtNCK129tzhMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"数据报格式\"\n        title=\"数据报格式\"\n        src=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n        srcset=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/63868/IPv4.png 250w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/0b533/IPv4.png 500w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png 573w\"\n        sizes=\"(max-width: 573px) 100vw, 573px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>字段解释</h3>\n<ul>\n<li>版本号 指示当前数据报使用的IP协议版本</li>\n<li>首部长度  数据报长度  IP数据报可以提供可变数量的选项，可以通过这两个字段来确定数据报的首部和数据的长度</li>\n<li>标识、标志、片偏移  在数据报传输给链路层的时候，由于不同链路层协议的产生的链路层帧不同，通过这三个字段来完成数据报的分片与重组</li>\n<li>生存时间(TTL) 保证一个分组不会在网络之前循环的转发，数据报信息每通过一次路由TTL字段减1.为0的时候必须丢弃改该数据报。</li>\n<li>协议  与运输层的那种协议传输数据(TCP/UDP)</li>\n<li>首部校验和  每次到达路由器的时候，路由器都会对数据报的IP首部进行校验，丢弃出错的分组信息</li>\n<li>源IP地址和目的IP地址  实现主机间的通信</li>\n<li>数据  承载上层协议的数据(TCP/UDP(应用层 HTTP SMTP) ICMP )</li>\n</ul>\n<h2>网络编址</h2>\n<h3>IP地址</h3>\n<p>IP地址可以对应理解成主机与物理链路的接口，在每个子网中，子网中的主机的网络前缀相同为X,后面的32-X位决定该子网具体能容纳下多少台主机</p>\n<h4>地址获取(DHCP)</h4>\n<p>在一个子网中，需要为每个主机分配IP地址来实现通信，这个的通常实现是通过DHCP协议(也可以通过静态的配置)，通过DHCP获取IP地址主要有以下四个阶段</p>\n<ol>\n<li>新连接的主机广播DHCP发现报文</li>\n<li>DHCP 服务器收到发现报文，广播DHCP提供报文(在子网中存在多个DHCP服务器)</li>\n<li>主机根据DHCP提供报文发送对应的DHCP响应报文，将之前DHCP的提供报文的数据回显</li>\n<li>DHCP ACk DHCP服务器确定请求，主机可以进行通信.</li>\n</ol>\n<h4>地址转换(NAT)</h4>\n<p>NAT是一种地址管理策略的实现。他通过在NAT路由器中维护NAT转换表来实现对外界统一请求的转发和请求到外界的转发。\n实现 子网中的主机通过端口A连接NAT路由器，NAT在收到数据包的时候创建一个新的端口B并将数据的源端口改为B，IP地址改为改子网对外的统一IP地址,外部服务收到对应的报文，响应报文到NAT路由器，NAT路由器查找NAT转换表找到刚才转换的端口A和初始的请求主机IP地址将响应报文发送对请求的主机</p>\n<h2>相关协议简介</h2>\n<h3>因特网控制报文协议(ICMP)</h3>\n<p>ICMP用于主机与路由器之间沟通网络层信息，ICMP是运行在IP协议层之上的，也就是IP数据报的数据部分是包括ICMP的数据报文的内容的(跟IP承载TCP/UDP报文一样)</p>\n<h2>理解路由</h2>\n<ol>\n<li>当主机想发送一个IP数据报的时候,它会查看自己的路由表。如果目的IP地址就是在本地网络，就直接将数据进行封装发送给目的主机.如果目的IP地址不在本局域网中,数据被封装然后发送给路由器(此时在数据链路层的帧的目的地址是路由器的物理地址,IP报头的目的IP仍然为原来的目的IP地址).</li>\n<li>路由器接收到对应的数据传递给网络层,如果目的IP是自身则自己处理这个数据(用于更新路由表等)否则查询路由表将数据进行转发。</li>\n</ol>\n<h2>基础词汇解释</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>丢包</td>\n<td>在路由器中存在着缓存结构来缓存需要发送或者接受待转发的分组.<br>当这个缓存过大超出其内存空间的时候，路由器就会丢弃该分组，造成丢包</td>\n</tr>\n<tr>\n<td>IP数据报分片</td>\n<td>由于不同数据链路层所能承载的最大传输数据单元(MTU)不同.IP数据报在数据链路层会被进行分片和重组</td>\n</tr>\n<tr>\n<td>CIDR 无类别域间路由</td>\n<td>它通过扩展IP的网络位数来实现将一个IP地址对应成多个IP地址的行为</td>\n</tr>\n<tr>\n<td>ARP 地址解析协议</td>\n<td>在数据链路层提供将网络层的IP地址转换为物理地址</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null}}},{"node":{"id":"963e265f-8eb5-570f-8504-c716bb34314d","html":"<h2>简介</h2>\n<p>node中的Stream模块在很多基础的模块都有使用下面就从官网的文档和源码上学习下Steam模块的基础知识</p>\n<h2>基础</h2>\n<ol>\n<li>node.js 中有四种形式的流 可读(Readable)  可写(Writable)  可读可写(Duplex)   转换流(Transform)</li>\n<li>流在内部维护了一个链表来完成缓存数据的读取,流继承了EventEmitter,通过事件的监听来完成数据的获取</li>\n<li>在进行流的初始化的时候通过设置highWaterMark来控制缓存区的大小 当读写速度出现差异，存储的数据到达highWaterMark的时候，就会出现背压。这样读写流就会停止读或者写入</li>\n</ol>\n<h2>可写流</h2>\n<p>可写流是可以写入数据的目的地的抽象</p>\n<h3>事件</h3>\n<p>drain  stream.write(chunk) 会返回true false来通知当前流是否可写。当它返回false的时候  当前流再次可用的时候 会触发drain事件<br>\nerror  读写数据出现error的时候会触发这个事件 但是不会关掉流<br>\nfinish  在stream.end(chunk,encoding,callback)的时候在数据发送完毕后会触发finish事件，传入的callback作为监听函数</p>\n<h3>方法</h3>\n<p>writable.cork()/writable.uncork()\nbuffer缓存和清除缓存 调用的次数必须一致,在使用writable.uncork()的时候 推荐使用process.nextTick()<br>\nwritable.write(chunk,encoding,callback)  返回的true /false 通知当前是否可写\n结合drain事件来完成持续的写入(即使return false 仍然能完成数据的写入造成内存的占用 给垃圾回收造成压力)<br>\nwritable.destory(error) 关掉这个流<br>\nwritable.end(chunk,encoding,callback) 通知不会在有其他的写入,callback会变成finish事件的回调函数</p>\n<h2>可读流</h2>\n<p>可读流是可以被消耗的数据源的抽象\n可读流有两种状态: flowing paused</p>\n<ol>\n<li>在flowing状态下通过对data事件的监听获取数据。</li>\n<li>在paused状态下通过对_read(size)方法的调用来完成数据的读取.</li>\n</ol>\n<p>在node的lib/_stream_readable.js中,在构造函数中会通过传入的options来初始化流的状态</p>\n<pre><code>  this.buffer = new BufferList(); //  链表 \n  this.length = 0;  // 存储的长度\n  this.pipes = null;  //  pipe 数组 目的地 (初始的时候是null) \n  this.pipesCount = 0; // pipe 长度\n  this.flowing = null;  //  state  null true false (flowing paused) \n  this.ended = false;   \n  this.endEmitted = false; // 是否发送end事件\n  this.reading = false;   // 是否正在读取  \n</code></pre>\n<p>在上面的代码中this.flowing就是控制stream的状态是否是flowing或者paused 通过pipe unpipe 或者data事件的监听能切换状态 (当this.flowing为false的时候通过data事件的监听不会造成this.flowing变成true 必须调用stream.resume())\n在实现可读流的时候,需要实现_read(size)方法触发底层数据的读取.可以使用size(size会根据背压动态变化)来完成读取的流量控制</p>\n<h3>事件</h3>\n<p>data  当流准备发送数据的时候会触发data事件( 切换成flowing 或者read() 方法的调用)\nend 当可读流的数据都被消费后会触发end事件 通知无数据可读取\nreadable  通知当前有数据可以读取或者流数据的结尾会触发 通过监听readable然后通过read事件来完成数据的读取</p>\n<h3>方法</h3>\n<p>readable.isPaused() 返回流当前的状态(对应上面的this.flowing)<br>\nreadable.pause() 切换this.flowing = false<br>\nreadable.pipe(dest)<br>\n(1)可以一个src多个dest(对应上面代码的this.pipes)<br>\n(2)返回dest支持链式调用  a.pipe(a).pipe(b)<br>\n(3)背压的控制 通过在src上注册drain事件并且在write的时候根据dest的状态来写入完成背压的控制</p>\n<pre><code>    src.on('data', ondata);\n    function ondata(chunk) {\n      increasedAwaitDrain = false;\n      var ret = dest.write(chunk);\n        if (false === ret &#x26;&#x26; !increasedAwaitDrain) {\n          // If the user unpiped during `dest.write()`, it is possible\n          // to get stuck in a permanently paused state if that write\n          // also returned false.\n          // => Check whether `dest` is still a piping destination.\n          if (((state.pipesCount === 1 &#x26;&#x26; state.pipes === dest) ||\n               (state.pipesCount > 1 &#x26;&#x26; state.pipes.indexOf(dest) !== -1)) &#x26;&#x26;\n              !cleanedUp) {\n            debug('false write response, pause', src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n          }\n          src.pause();\n      }\n    }\n</code></pre>\n<p>当src接受到drain事件后会触发drain事件的监听函数重新完成数据的写入</p>\n<pre><code>//  pipe  end flag\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 &#x26;&#x26; EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n</code></pre>\n<h3>实现一个可读流</h3>\n<pre><code>const { Readable } = require('stream');\n// Stream 实现\nclass MyReadable extends Readable {\n  constructor(dataSource, options) {\n    super(options);\n    this.dataSource = dataSource;\n  }\n  // 继承了 Readable 的类必须实现这个函数\n  // 触发系统底层对流的读取\n  _read() {\n    const data = this.dataSource.makeData();\n    this.push(data);\n  }\n}\n// 模拟资源池\nconst dataSource = {\n  data: ['1','2','3','4','5','6','7','8'],\n  // 每次读取时 pop 一个数据\n  makeData() {\n    if (!dataSource.data.length) return null;\n    return dataSource.data.pop();\n  }\n};\nconst myReadable = new MyReadable(dataSource);\nmyReadable.setEncoding('utf8');\nmyReadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n</code></pre>\n<h4>从源码上理解上面的例子</h4>\n<p>通过data事件的监听</p>\n<pre><code>    Readable.prototype.on = function(ev, fn) {\n        const res = Stream.prototype.on.call(this, ev, fn);\n\n        if (ev === 'data') {\n        if (this._readableState.flowing !== false)\n          this.resume();\n        } else if (ev === 'readable') {\n        const state = this._readableState;\n        if (!state.endEmitted &#x26;&#x26; !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.emittedReadable = false;\n          if (!state.reading) {\n            process.nextTick(nReadingNextTick, this);\n          } else if (state.length) {\n            emitReadable(this, state);\n          }\n        }\n      }\n      return res;\n    };\n</code></pre>\n<p>当注册data事件的时候,会调用this.resume() 最后调用flow(stream) 来完成数据的持续读取</p>\n<pre><code>    function flow(stream) {\n      const state = stream._readableState;\n      debug('flow', state.flowing);\n      while (state.flowing &#x26;&#x26; stream.read() !== null);\n    }  \n    \n</code></pre>\n<h2>总结</h2>\n<p>上面就简单的介绍了下node中stream模块的基础知识,通过对流模块的学习能更好的帮助我们理解node中数据的发送处理过程,也可以尝试着去阅读一些简单的模块(send)来加深对Stream的理解.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903588649500679\">Node.js可读流和可写流</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":15,"pageCount":16,"additionalContext":{"pageAllCount":91}}},
    "staticQueryHashes": []}