{"componentChunkName":"component---src-templates-index-js","path":"/15","result":{"pageContext":{"pageAllCount":86,"group":[{"node":{"id":"963e265f-8eb5-570f-8504-c716bb34314d","html":"<h2>简介</h2>\n<p>node中的Stream模块在很多基础的模块都有使用下面就从官网的文档和源码上学习下Steam模块的基础知识</p>\n<h2>基础</h2>\n<ol>\n<li>node.js 中有四种形式的流 可读(Readable)  可写(Writable)  可读可写(Duplex)   转换流(Transform)</li>\n<li>流在内部维护了一个链表来完成缓存数据的读取,流继承了EventEmitter,通过事件的监听来完成数据的获取</li>\n<li>在进行流的初始化的时候通过设置highWaterMark来控制缓存区的大小 当读写速度出现差异，存储的数据到达highWaterMark的时候，就会出现背压。这样读写流就会停止读或者写入</li>\n</ol>\n<h2>可写流</h2>\n<p>可写流是可以写入数据的目的地的抽象</p>\n<h3>事件</h3>\n<p>drain  stream.write(chunk) 会返回true false来通知当前流是否可写。当它返回false的时候  当前流再次可用的时候 会触发drain事件<br>\nerror  读写数据出现error的时候会触发这个事件 但是不会关掉流<br>\nfinish  在stream.end(chunk,encoding,callback)的时候在数据发送完毕后会触发finish事件，传入的callback作为监听函数</p>\n<h3>方法</h3>\n<p>writable.cork()/writable.uncork()\nbuffer缓存和清除缓存 调用的次数必须一致,在使用writable.uncork()的时候 推荐使用process.nextTick()<br>\nwritable.write(chunk,encoding,callback)  返回的true /false 通知当前是否可写\n结合drain事件来完成持续的写入(即使return false 仍然能完成数据的写入造成内存的占用 给垃圾回收造成压力)<br>\nwritable.destory(error) 关掉这个流<br>\nwritable.end(chunk,encoding,callback) 通知不会在有其他的写入,callback会变成finish事件的回调函数</p>\n<h2>可读流</h2>\n<p>可读流是可以被消耗的数据源的抽象\n可读流有两种状态: flowing paused</p>\n<ol>\n<li>在flowing状态下通过对data事件的监听获取数据。</li>\n<li>在paused状态下通过对_read(size)方法的调用来完成数据的读取.</li>\n</ol>\n<p>在node的lib/_stream_readable.js中,在构造函数中会通过传入的options来初始化流的状态</p>\n<pre><code>  this.buffer = new BufferList(); //  链表 \n  this.length = 0;  // 存储的长度\n  this.pipes = null;  //  pipe 数组 目的地 (初始的时候是null) \n  this.pipesCount = 0; // pipe 长度\n  this.flowing = null;  //  state  null true false (flowing paused) \n  this.ended = false;   \n  this.endEmitted = false; // 是否发送end事件\n  this.reading = false;   // 是否正在读取  \n</code></pre>\n<p>在上面的代码中this.flowing就是控制stream的状态是否是flowing或者paused 通过pipe unpipe 或者data事件的监听能切换状态 (当this.flowing为false的时候通过data事件的监听不会造成this.flowing变成true 必须调用stream.resume())\n在实现可读流的时候,需要实现_read(size)方法触发底层数据的读取.可以使用size(size会根据背压动态变化)来完成读取的流量控制</p>\n<h3>事件</h3>\n<p>data  当流准备发送数据的时候会触发data事件( 切换成flowing 或者read() 方法的调用)\nend 当可读流的数据都被消费后会触发end事件 通知无数据可读取\nreadable  通知当前有数据可以读取或者流数据的结尾会触发 通过监听readable然后通过read事件来完成数据的读取</p>\n<h3>方法</h3>\n<p>readable.isPaused() 返回流当前的状态(对应上面的this.flowing)<br>\nreadable.pause() 切换this.flowing = false<br>\nreadable.pipe(dest)<br>\n(1)可以一个src多个dest(对应上面代码的this.pipes)<br>\n(2)返回dest支持链式调用  a.pipe(a).pipe(b)<br>\n(3)背压的控制 通过在src上注册drain事件并且在write的时候根据dest的状态来写入完成背压的控制</p>\n<pre><code>    src.on('data', ondata);\n    function ondata(chunk) {\n      increasedAwaitDrain = false;\n      var ret = dest.write(chunk);\n        if (false === ret &#x26;&#x26; !increasedAwaitDrain) {\n          // If the user unpiped during `dest.write()`, it is possible\n          // to get stuck in a permanently paused state if that write\n          // also returned false.\n          // => Check whether `dest` is still a piping destination.\n          if (((state.pipesCount === 1 &#x26;&#x26; state.pipes === dest) ||\n               (state.pipesCount > 1 &#x26;&#x26; state.pipes.indexOf(dest) !== -1)) &#x26;&#x26;\n              !cleanedUp) {\n            debug('false write response, pause', src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n          }\n          src.pause();\n      }\n    }\n</code></pre>\n<p>当src接受到drain事件后会触发drain事件的监听函数重新完成数据的写入</p>\n<pre><code>//  pipe  end flag\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 &#x26;&#x26; EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n</code></pre>\n<h3>实现一个可读流</h3>\n<pre><code>const { Readable } = require('stream');\n// Stream 实现\nclass MyReadable extends Readable {\n  constructor(dataSource, options) {\n    super(options);\n    this.dataSource = dataSource;\n  }\n  // 继承了 Readable 的类必须实现这个函数\n  // 触发系统底层对流的读取\n  _read() {\n    const data = this.dataSource.makeData();\n    this.push(data);\n  }\n}\n// 模拟资源池\nconst dataSource = {\n  data: ['1','2','3','4','5','6','7','8'],\n  // 每次读取时 pop 一个数据\n  makeData() {\n    if (!dataSource.data.length) return null;\n    return dataSource.data.pop();\n  }\n};\nconst myReadable = new MyReadable(dataSource);\nmyReadable.setEncoding('utf8');\nmyReadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n</code></pre>\n<h4>从源码上理解上面的例子</h4>\n<p>通过data事件的监听</p>\n<pre><code>    Readable.prototype.on = function(ev, fn) {\n        const res = Stream.prototype.on.call(this, ev, fn);\n\n        if (ev === 'data') {\n        if (this._readableState.flowing !== false)\n          this.resume();\n        } else if (ev === 'readable') {\n        const state = this._readableState;\n        if (!state.endEmitted &#x26;&#x26; !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.emittedReadable = false;\n          if (!state.reading) {\n            process.nextTick(nReadingNextTick, this);\n          } else if (state.length) {\n            emitReadable(this, state);\n          }\n        }\n      }\n      return res;\n    };\n</code></pre>\n<p>当注册data事件的时候,会调用this.resume() 最后调用flow(stream) 来完成数据的持续读取</p>\n<pre><code>    function flow(stream) {\n      const state = stream._readableState;\n      debug('flow', state.flowing);\n      while (state.flowing &#x26;&#x26; stream.read() !== null);\n    }  \n    \n</code></pre>\n<h2>总结</h2>\n<p>上面就简单的介绍了下node中stream模块的基础知识,通过对流模块的学习能更好的帮助我们理解node中数据的发送处理过程,也可以尝试着去阅读一些简单的模块(send)来加深对Stream的理解.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903588649500679\">Node.js可读流和可写流</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null}}},{"node":{"id":"cfb62610-6cf5-58f8-94ad-207f2e5dfb04","html":"<h2>简介</h2>\n<p>koa利用生成器来解决回调函数的嵌套问题，实现的十分巧妙，下面跟着官网的例子逐步学习下koa的实现原理<br>\n官网 <a href=\"http://koa.bootcss.com/\">koa</a></p>\n<h2>使用</h2>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n});\r\napp.listen(8080);  \n</code></pre>\n<p>这个例子很像在Node中构建HTTP服务器的例子</p>\n<pre><code>var http = require('http');\r\nhttp.createServer(function(req,res){\r\n    res.writeHead(200,{'Content-Type':'text/plain'});\r\n    res.end('hello world');  \r\n}).listen(8080);  \n</code></pre>\n<p>通过app.use()设定中间件 app.listen()监听特定的端口这样整个web服务器就启动了 那我们的关注点就到了这句话 var app = koa();<br>\nkoa的源码lib下有四个文件 application.js context.js request.js response.js  在koa的package.json中main属性的值指向的是lib/application.js 也就是整个web服务器的生成过程都在这个js中 下面我们逐步的解读下application.js的部分源码</p>\n<pre><code>module.exports = Application;\r\nfunction Application() {\r\n    if (!(this instanceof Application)) return new Application;//确保不通过new调用构造函数的时候返回正确的值\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.subdomainOffset = 2;\r\n    this.middleware = [];//保存中间件的数组\r\n    this.proxy = false;\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);//通过指定的原型创建对象\r\n }  \n</code></pre>\n<p>通过上面这段代码，也就是在调用这句话的时候 var app = koa()实际上就是生成了一个Application实例 在实例上有一个数组用于保存中间件 三个属性 context request response</p>\n<pre><code>var app = Application.prototype;\r\napp.listen = function(){\r\n    debug('listen');\r\n    var server = http.createServer(this.callback());//this.callback()就是请求来的处理函数\r\n    return server.listen.apply(server, arguments);  \r\n    //这里上文中Node构建HTTP服务的例子 似曾相识 \r\n};  \n</code></pre>\n<p>在http.createServer(this.callback())中this.callback()就是请求来的处理函数也就是app.callback()这个函数 正是这个函数实现了koa的中间件机制</p>\n<h2>中间件</h2>\n<p>在介绍中间件的原理之前 先上一个例子</p>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(next){\r\n    console.log(1);\r\n    yield next;\r\n    console.log(2);\r\n});\r\napp.use(function *(next){\r\n    console.log(3);\r\n    yield next;\r\n    console.log(4);\r\n});\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n})；\r\napp.listen(3000);  \n</code></pre>\n<p>当对服务器发送一个请求的时候  会发现服务器的控制台log出的顺序是 1 3 4 2 下面我们来看一下这个神秘的app.callback()函数到底做了什么</p>\n<pre><code>app.use = function(fn){\r\n    if (!this.experimental) {\r\n      // es7 async functions are not allowed,\r\n      // so we have to make sure that `fn` is a generator function\r\n      assert(fn &#x26;&#x26; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);//将每次调用的生成器函数push到中间件数组\r\n    return this;//可以实现链式调用\r\n}; \n</code></pre>\n<p>app.use()就是收集所有设定的中间件，然后存储到数组中</p>\n<pre><code>app.callback = function(){\r\n  var fn = this.experimental\r\n    ? compose_es7(this.middleware)\r\n    : co.wrap(compose(this.middleware));\r\n  var self = this;  \r\n  return function handleRequest(req, res){\r\n    res.statusCode = 404;\r\n    var ctx = self.createContext(req, res);\r\n    onFinished(res, ctx.onerror);\r\n    fn.call(ctx).then(function handleResponse() {\r\n      respond.call(ctx);\r\n    }).catch(ctx.onerror);\r\n  }\r\n};  \n</code></pre>\n<p>app.callback()中的返回值 function handleRequest(req,res){}就是请求来的时候的处理函数 在这个处理函数中调用fn进行事件的处理 fn是什么呢？  我们只需要搞明白这句话 co.wrap(compose(this.middleware))</p>\n<p>第一步 compose对生成器函数数组进行了处理</p>\n<pre><code>function compose(middleware){\r\n  return function *(next){\r\n    if (!next) next = noop();\r\n    var i = middleware.length;\r\n    while (i--) {\r\n      next = middleware[i].call(this, next);//不断的获取后一个生成器对象 作为参数传入当前的生成器函数并且执行获得生成器对象\r\n    }\r\n    return yield *next;\r\n  }\r\n}\r\nfunction *noop(){}  \n</code></pre>\n<p>其实理解compose的作用要理解好通过app.use(function *(next) {}) 传递的生成器函数传递的next  整个compose的作用就是生成器函数的执行后进行从头到尾的串联 然后返回一个生成器<br>\n接下来就需要理解co的执行流程了</p>\n<h2>co源码解读</h2>\n<p>co是通过生成器避免了多个异步操作的回调嵌套</p>\n<pre><code>function *test() {\r\n  var a = yield readFile1();\r\n  var b = yield readFile2();\r\n}\n</code></pre>\n<p>简单理解co的作用就是首先获取之前执行的结果 保存下来当下次调用generator.next()的时候作为参数传入，这样就实现了异步操作的同步执行</p>\n<pre><code>function co(gen) {\r\n  var ctx = this;\r\n  var args = slice.call(arguments, 1)\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\r\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\r\n    onFulfilled();\r\n\r\n    function onFulfilled(res) {\r\n      var ret;\r\n      try {\r\n        ret = gen.next(res);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n\t}\r\n    function onRejected(err) {\r\n      var ret;\r\n      try {\r\n        ret = gen.throw(err);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n    }\r\n    function next(ret) {  //这里使用promise进行了封装 当之前的异步调用完成后 就会在调用onFullfilled将这次执行结果的返回值传入\r\n      if (ret.done) return resolve(ret.value);\r\n      var value = toPromise.call(ctx, ret.value);\r\n      if (value &#x26;&#x26; isPromise(value)) return value.then(onFulfilled, onRejected);\r\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\r\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\r\n    }\r\n  });\r\n}\n</code></pre>\n<p>通过上面的代码阶段我们就学习了koa的中间件机制 其实ES7的异步函数就是实现的co所做的事</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":true,"index":15,"pageCount":15,"additionalContext":{"pageAllCount":86}}},"staticQueryHashes":[]}