{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/15",
    "result": {"pageContext":{"pageAllCount":88,"group":[{"node":{"id":"18374d92-6b8b-544b-b3eb-b649443d935f","html":"<h2>简介</h2>\n<p>运输层提供了运行在不同主机上的应用进程之间的逻辑通信，应用程序通过逻辑通信，运行在不同进程的主机好像直连一样(例如输出一个URI 就能找到对应主机的资源)。 运输层是直接与应用层打交道的网络层级。通过对运输层协议(TCP/UDP)的了解和传输机制的学习，能更好的帮助我们理解应用程序的行为。在阅读计算机网络自顶向下方法的运输层时整理了如下的笔记。</p>\n<h2>运输层基础</h2>\n<p>运输层通过多路复用与多路分解来实现将主机间的数据交付服务扩展成主机的进程间的交付服务。它对应用层提供了两种服务类型:</p>\n<ul>\n<li>基于连接的，可靠地服务(TCP)</li>\n<li>不基于连接的，不可靠的服务(UDP)</li>\n</ul>\n<h2>TCP</h2>\n<h3>TCP报文段结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 454px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABu0lEQVQoz22R646rIBRGff9XapM2fYEaTZpevBQUBKEgKBdltCdTck4mJ7N+7nxkf6ydVFU1jqMxZpqm8S9KqWEYmqa53+9SSmttnP/LTNNEKU0opeu6lmUJIeSc0w9a623blFKc82EYiqKglBJCMMaEEEqpEMJam3DOvfcIoThijAkh2rYFAFBKMcaU0izLuq4TQvR9zxjjnAshnHPfm733zjlrrfswjiMAoKoqAEBZlk3T1HVNCNFaG2NizHxI5AdrbQghtoAQXq9XQkhd1xDC2LmqKozxsixxk/d+nufkcrns9/s8zzHGp9Ppdrulabrb7Y7H4+FwiL2893VdAwAej0fbttZapZTWOun7PoTgnBNCZFn2fD4BAEVRCCGmadJaT9N0Pp/zPG+a5vF4RBfbti3LkjDGrLXxVIQQKeXr9YraIIRRct/3SikpZfxRNMIY+348z3PUMM9zLBlCkFKmaRqdjeMYM8MwMMaklAghKWUSpdsfGGO898aYuq4551LKZVmi5+jJex/NJV+/Mc8zQghCiBACAGit13UNP1iWJYSQvH9jXVfOedd1fd9jjJ1z7/d727b/Yn8AH0+bq1J7Cv0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP\"\n        title=\"TCP\"\n        src=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n        srcset=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/63868/fragment.png 250w,\n/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png 454w\"\n        sizes=\"(max-width: 454px) 100vw, 454px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>端口和目的端口用于TCP数据的多路复用和多路分解</li>\n<li>序号和确认号用于实现可靠数据传输</li>\n<li>TCP的连接状态保存在端系统中，这种链接的状态对网络层是不可见的。网络层只看到的数据报</li>\n<li>确认号可以理解成发送方期待接受方发送的下一段序列的初始字节编号。例如当A收到B发送的数据是500-600（不包括600）并且在累计确认下(前500的数据都得到确认) B在发送的报文中确认号就是600,A接收到报文后就会发送600之后的数据给B</li>\n<li>接收窗口用于实现拥塞控制(TCP慢启动)</li>\n<li>在6个标志字段中 ACK用于确认上一个已成功报文的确认 RST，SYN,FIN 用于连接的建立和拆除 PSH被设置的时候标志接受方应立即将数据交付给上层</li>\n</ul>\n<h3>流量控制</h3>\n<p>流量控制是发送方与接收方的一种速度匹配服务。在发送方与接收方都维持一个接收窗口的变量。假设该变量的值为rwnd，发送方必须保证LastByteSent - LastByteAcked &#x3C;= rwnd.假设接收方的缓存空间是RcvBuffer,必须保证 rwnd = RcvBuffer - [LastByteRcvd - LastByteRead].该窗口字段在接收端发送报文的时候会写到TCP报文的窗口字段。当接收端的窗口是0的时候，发送方接收到对应的报文将发送只有一个字节的数据报文段，此时接收端将接收这个报文并且清空自己的缓存空间(数据传送给上层)并且回复一个rwnd大于0的报文段</p>\n<h3>TCP连接的建立与中断</h3>\n<h4>TCP连接的建立</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPElEQVQ4y21Ty07jMBSN+CF2iK/gQ/gdliyQumEkxKpUHakwmpRFxDNNUlJFQigPMrRJWgfHaRLH8R3BRaYwc1b29X2dc681AJBSAsBqtTo8PDw4OCCEKOMmbm9vj46OTNNUFk1KKYRo2xYAtre3d3Z2AKBtW7mBrusAIMuy3d3d8XisHDSsgM/7+/t7e3tFUaBFAVPbtr21taXrOgAIId4qA0BZloQQzvl8PnccJ89zQsi/bQshxuPx6+urIvUW7Pu+bduEEMbYYrFwHKff75v397913TTNNE2rqsLWOOcq11vbm7mbpqmqCs+r5fLx8XHqur90fTgcep6XJEkcx0j4g7MiJqWs67osSyVBJ2WZ56HjZL4/dd2zfv/6+poxZlnWdDrlnGuoR9u2Xdet12tKaVVVrCiuLi6GvV6/17MNw314iOM/nHNKKYqPxTQhBM4DJUmSZDQaDQeDn6enV4bhh2FZfxJWan0EA0CapsvlkjFGKR2NRufn51EUBVGE/HERmqbhnOd5jhaEhrtFCFmv13meB0Hw9PQ0dZwfx8eXl5e2bSdJ0jQNeuMKqCl+UZtzXtc1Tn4+nxuGMRgMTk5OdF2PojBN06Kgm/6a4oCjQrVV7rqugyC4ubmxLOvu7g5H9SnYt8rYIb5hRrUCcRy/vLxg8AfnzTUsy5JS+u1LoSsesiz7D2e8h2HoeR7OTH4FAFBKXddtmka843vbQghK6Ww2WywWz8/Pvu9PJpM4jr13WJbFGNv8sH8BdCuyVQ0e+JcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"三次握手\"\n        title=\"三次握手\"\n        src=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n        srcset=\"/blog/static/450ef929b273efe5395a856db3581d99/63868/connect.png 250w,\n/blog/static/450ef929b273efe5395a856db3581d99/0b533/connect.png 500w,\n/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>客户端在向服务端请求连接的时候，会向服务端发送一个SYN报文段。会随机选取一个client_isn作为序号字段放置在该SYN报文中。</li>\n<li>服务端在收到该报文后，会发送给客户端一个报文并且设置TCP的缓存和变量。该报文的ack字段是client_isn + 1,序号字段为server_isn,SYN比特为设置成1.代表当前服务器已经准备接收数据</li>\n<li>客户端在接收服务端的确认报文后会创建TCP的缓存和变量并且向服务端继续发送报文(此时的报文可以携带上上层的数据),其中ack字段是server_isn + 1,序号字段是client_isn + 1,SYN字段为0(此后的报文中SYN字段都为0).至此TCP连接建立成功。(三次握手是为了确定双方的序号)</li>\n</ol>\n<h4>TCP连接的中断</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACnUlEQVRIx4WVS2pyQRCF7+qyCFcgCK7AUYYhOnfgyEAgDl2BRIMKOjAPiCGaGI3vtyY+ovXzNZS0915/G5qr3V2nTlWdrnZERLbbrfz+/pr59/cn+/2e5cPXHqzp+m63k9lsJtPpVJbLpVl32Oj1elKr1eTj4+PI0A/M/gL49PQkLy8v0m63zZoDO4Cen5+lXC7L29ubrFYrDxs/wE6nI4+Pj5LP58232+2Ks9lsjIdMJiORSEQuLy8PTGHgN3Qd57lcTq6uriQcDsvd3Z04xWJREomExGIxSaVSZhK+bahMbcbNZlOSyaREo1G5vr6Wm5sbSafT4tze3kogEJBgMCj39/fy8PAgk8nEF4ipTkqlkoRCIbm4uJB4PC7ZbNakzcG4UCiYSg2HQ5nP53JquEFRRaVSOVpzKMB6vTZ/+v2+DAYDc3CxWJgvB1utlkm4eyAVdzSOfWA0GhkQNigWzgCGPY5+fn7MRBmcYQ/JHQHaiQYQA/cAkCIgYvYBYb6+vkqj0TgU0AM4Ho8PtwV2ypCQv7+/TX4JU3WKA1+GmlDU/vn5aUAxVPBTgzPk3Rb7EUPyBKNzVdbzhI8y7H0PIF7d1w4VEK4NCHNyXq/XTTo0DY5NlxyqhDQVGCIZDCkOwOSOdCCZ9/d3c1W1mI6CIRM2McQIcK2qtifN59mQVRp0DMIGiAkI4NxtioX+7IYBS9+iaCtCa3ZVMYY5QBQLcDtknGPnkQ2Di03IAJxqsLqOA5XZ19eXPyC5Y9pF8Zv2oLKaQw8gOaT8hOLuzu6urf/dwj4ChBkh24CnGJ4FBIRK8jb87z1xA9qyOWpfhFqtVs0L5s4hldZO4n6sqLz2SU/IDLqvPlCnQraZclP0/fF0G76wRMDnAN2ysn//Aw2QzK7dGbfNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP close\"\n        title=\"TCP close\"\n        src=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n        srcset=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/63868/close.png 250w,\n/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n(发送方和接受方都可以中断TCP连接)</p>\n<ol>\n<li>终止方向另一端发送一个TCP报文，其FIN比特位被设置成1</li>\n<li>接收方回复一个ACK报文并且发送一个FIN报文</li>\n<li>终止端回复一个ACK报文，至此两方为了维持TCP连接的缓存和变量都将清除(接受FIN端需要把自己剩余的信息发送完 才能发送FIN报文)</li>\n</ol>\n<h4>TCP客户端和服务端的状态转变</h4>\n<h5>TCP客户端客户端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB4klEQVQ4y42U144CMQxF5/8/CF54gDckiui9I3rvHa+OV4YwO0hrKcokE19fXzvxxLF2uy2ZTEaWy6Wuj8ejbDYbGQ6HMhgMZLfbyfV61X/M8XhcstmspNNpCYfD0mq1xHs+n2IDu1wuslqtFIQDs9lMarWaNBoNmU6nMh6PNeBisdAAj8dDwff7vc6eC3Y4HGS9Xr/WFoBxPp91NmMNaLValXq9rmvMc1OGmZkbyDV/Ntvt9uOfd7vdpNvtqhZEIiIsXWe/LMxkMxqNJJlMynw+V71fgFCnIKVSScVHK7QxZ5cBhg/aQoKRSqVU8/v9/k4ZkHK5/Ce9oDWAFIQBEPqx99KQqoVCIcnlcnI6nT6cgxhyHlaJREJisZj0+/23hnYYPYz2N0D/PkDNZvPDR9uGDRoY/aD+DcxfZc7Sn65pUahsPp+XSqWiTQywn6n7TcHoDDSnysw0PPvKEN0AAYy+oh/dKge1DekCVCwWtTsmk8kb0OgT9VuFg1K2m0UL0XofRbHOp4IuE+6nXb2gs0gDkV6v98sQ3SKRiD4EnU5HtSAag6qjbaFQUAfWFIF/3A4YIhfgprnHK8GTRQ8CaMyIxnWyFwbNACI9cwY8Go3q04WOfx6H/7SKewaGsCaYPRI/rcIZxDx6n2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"客户端状态变化\"\n        title=\"客户端状态变化\"\n        src=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n        srcset=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/63868/client-status.png 250w,\n/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>连接的建立 初始的时候TCP客户端处于CLOSED，当它需要与服务端建立TCP连接的时候，发送SYN字段，进入SYN_SENT状态. 当收到服务端对SYN报文的确认后，就进入ESTABLISHED状态，此刻TCP客户已经能发送和接收数据了</li>\n<li>连接的中断 客户端发送TCP报文(FIN字段被设置为1),进入FIN_WAIT_1,等待服务端的确认报文然后进入FIN_WAIT_2.等到服务端的FIN报文并且发送确认报文后，进入TIME_WAIT.最后进入CLOSED状态</li>\n</ol>\n<h5>TCP服务端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABxklEQVQ4y42Ux47DMAxE9f+flFOQ5JKDL+k9SO+9Vy4eASqCsIssAcGWRI9myLHc7XYTxuVykdPpJMfjUZ/MebdxOBzkfr9Lu92WdDotmUxGUqmUZLNZGQwGmk+Oq1ar0u12ZTabyfV6FeL5fHrw4XAo4/HYgz4eD1kul9JqtaRYLMp0OpUwXKPRkHK5LJVKRdbrtWe2WCxkv98r4Gg0UpDVaqV7rIfxfr/9cOEGySxavF4vncOYdwvmHGj7BqoMLdHkhCfGEa7vdjsvNwR1sEJ2s9nUuiCb4sdS7CMO3W63UqvVJEkS2Ww2OocYQxkCSqcmk4k2w1iHLO0dubCjppaPS3xT6C5dZJAcA8SSLVABMERo6Hw+FxzjWIQ2nUNOKO83hvYEEGXIxT44pd/vf7psgP9liBrA4j2HmZENdWTjtbDb8QfUF69SPxoJkfP5/Kkhk06no/rr9bomxvYJy2AeRGapVNJuw9QzNGRY2h8QA/1lH5jGJXFhovnpW5CDbcyvgFM6BaR2uVxOXW+mpXt0nxLQvUKhIL1eT+uL8dnHJvl8XnPssqAcDgD+FC4BYwcwtQWAmnI5kEdJ7EbCzBwCofDX+wGhXtIqR2SqKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"服务端变化\"\n        title=\"服务端变化\"\n        src=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n        srcset=\"/blog/static/884026a29f246f33aa0a88780176d2d5/63868/server-status.png 250w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/0b533/server-status.png 500w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>理解TIME_WAIT状态</h5>\n<ol>\n<li>可靠的实现TCP全双工连接的终止 主要close的一端 需要维持状态以防止最后一次的ACK对方收不到来进行网络重传</li>\n<li>TIME_WAIT阶段设置的超时时间会导致网络中迷失的分组丢失,这样在同样的端口创建新的TCP连接时候,不需要判断之前的数据.</li>\n</ol>\n<h3>拥塞控制</h3>\n<p>TCP使用的是端到端的拥塞控制，来防止网络拥塞时发生的各种问题(多余的分组,丢包等)。相比流量控制，拥塞控制是对网络拥塞的一种感知来控制发送的速度。流量控制是对接受方处理速度的一种速度调整。\n在TCP发送方维护一个拥塞窗口的变量来实现拥塞控制<br>\nLastByteSent - LastByteAcked &#x3C;= min { cwnd(接收窗口) , rwnd(拥塞窗口)}</p>\n<ul>\n<li>当发送方正确的收到确认报文的时候，他认为网络中无拥塞，不断的调整 cwnd</li>\n<li>当发送方超时未收到ack或者收到接收方三次冗余,需要降低发送速度</li>\n</ul>\n<h2>基础词汇解释</h2>\n<p>MSS 最大报文段长度<br>\n在不同的链路层协议上，其最大的传输单元(最大链路层帧长度)不同，这就导致了在封装到IP数据报的时候，需要适应底层的链路层长度。</p>\n<h2>TCP UDP 区别</h2>\n<ol>\n<li>TCP提供差错校验,重传等功能 UDP不提供对应的功能,UDP需要在应用程序中添加对应的逻辑来完成相应的功能</li>\n<li>UDP的数据报长度字段会随着数据发送给接收端,TCP是一种字节流协议,没有记录标记的长度(content-length) 主要是两者实现方式上的不同UDP是不面向连接的 也就是可以从一个套接字接受多个数据源 如果没有长度加以区分数据就会混乱.一个TCP套接字只对应着一个数据源,可以由应用层来决定数据的读取.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null}}},{"node":{"id":"ec68373d-8e97-584b-87f0-0a3da8f93d38","html":"<h2>简介</h2>\n<p>在实际的工作中，发现自己对网络这方面的知识有些欠缺并且作为一个web开发者有必要了解网络中数据传输的基本过程，在阅读计算机网络自顶向下方法中把网络层的基础知识整理如下。主要分为三个方面网络层的基础，IP(网际协议)，相关协议简介来简单的学习下网络层。</p>\n<h2>基础</h2>\n<ul>\n<li>网络层提供的通信机制是多个协议族共同运行的结果。主要有以下三个组件：IP协议,路由选择协议,ICMP协议</li>\n<li>网络层提供的主要功能是提供分组的转发并且结合路由算法实现路由功能，也就是最终实现主机间的通信。运输层提供了主机上进程之间的通信。</li>\n<li>因特网的网络层提供的服务是一种尽力而为的服务，这样做能简化网络层的行为.当上层的服务需要对应的功能(例如运输层需要保证数据的按序接收等)时候，通过它自己去实现.</li>\n<li>网络层的有连接服务和无连接服务\n提供有连接服务和无连接服务的网络层形成了不同的网络体系。仅提供有连接服务计算机网络称为虚电路网络(ATM,帧中继)。仅提供无连接服务的网络称为数据报网络。</li>\n</ul>\n<h2>虚电路网络和数据报网络</h2>\n<h3>虚电路网络</h3>\n<ul>\n<li>连接建立 虚电路网络需要在路由器上维持连接信息，在虚电路建立阶段,需要在建立的路径上的路由器之间维持连接状态信息(对应连接的路径)，当连接建立后，这些路径信息存储在路由器的转发表中</li>\n<li>数据发送  发送对应的数据</li>\n<li>虚电路拆除 发送方通知网路层终止虚电路,在网络的路由器上就删除对应的路径信息</li>\n</ul>\n<h3>数据报网络</h3>\n<p>因特网是一种数据报网络，这种网络体系结构在发送数据的时候需要将目的端系统地址推进到网络中,通过逐个路由器的转发最终到达目的主机</p>\n<h2>网际协议</h2>\n<p>网际协议(IP)现在主要有两个版本：IPv4和IPv6<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 573px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABE0lEQVQY021Q2Y6DMAzk/39tW4ntwQIthENFCkkDCWlwnYNVG/Vpd2SNLM9Ylicp8nKa5uF2I6QxxsC6pml6znK0VmuN+HwXPh76cDiKafbeAwAizvOcMMalVFLKcRwpHZ1znHEhhPdeKTWOLFqfAH3XE9JM02StRUQpZbJtm3Nu28KyLPlPDgAhBO/8e1kWRTnNs7U2HjydzpSOIQRrrVIqqaqqKMq6rhm/L1pzxi7Xqm07pRSlVEoJAMMw7Hb78nKta8L4HQDWdRVCJMaYxwda68gAKyHN7mvftB0AxPlL+niMMZzzxDlnP0CMjN77vu2+0wNpWu89RuEtxdY59/r5FcYfAKxd12dZVtUEnv8gpv0LtNCK129tzhMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"数据报格式\"\n        title=\"数据报格式\"\n        src=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n        srcset=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/63868/IPv4.png 250w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/0b533/IPv4.png 500w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png 573w\"\n        sizes=\"(max-width: 573px) 100vw, 573px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>字段解释</h3>\n<ul>\n<li>版本号 \b指示当前数据报使用的\bIP协议版本</li>\n<li>首部长度  数据报长度  IP数据报可以提供可变数量的选项，可以通过这两个字段来确定数据报的首部和数据的长度</li>\n<li>标识、标志、片偏移  在\b数据报传输给链路层的时候，由于不同链路层协议的\b产生的链路层帧不同，通过这三个字段来完成数据报的分片与重组</li>\n<li>生存时间(TTL) 保证一个分组不会在网络之前循环的转发，数据报信息每通过一次路由TTL字段减1.为0的时候必须丢弃改该数据报。</li>\n<li>协议  与运输层的那种协议传输数据(TCP/UDP)</li>\n<li>首部校验和  每次到达路由器的时候，路由器都会对数据报的IP首部进行校验，丢弃出错的分组信息</li>\n<li>源IP地址和目的IP地址  实现主机间的通信</li>\n<li>数据  承载上层协议的数据(TCP/UDP(应用层 HTTP SMTP) ICMP )</li>\n</ul>\n<h2>网络编址</h2>\n<h3>IP地址</h3>\n<p>IP地址可以对应理解成主机与物理链路的接口，在每个子网中，子网中的主机的网络前缀相同为X,后面的32-X位决定该子网具体\b能容纳下多少台主机</p>\n<h4>地址获取(DHCP)</h4>\n<p>在一个子网中，需要为每个主机分配IP地址来实现通信，这个的通常实现是通过DHCP\b协议(也可以通过\b静态的配置)，通过DHCP获取IP地址主要有以下四个阶段</p>\n<ol>\n<li>新连接的主机广播DHCP发现报文</li>\n<li>DHCP 服务器收到发现报文，广播DHCP提供报文(在\b子网中存在多个DHCP服务器)</li>\n<li>\b主机根据DHCP提供报文发送对应的DHCP响应报文，将之前DHCP的\b提供报文的数据回显</li>\n<li>DHCP ACk DHCP服务器确定\b请求，主机可以进行通信.</li>\n</ol>\n<h4>地址转换(NAT)</h4>\n<p>NAT是一种地址管理策略的实现。他通过在NAT路由器中维护NAT转换表来实现对外界统一请求的转发和请求到外界的转发。\n实现 子网中的主机通过端口A连接NAT路由器，NAT在收到数据包的时候\b创建一个新的端口B并将数据的源端口改为B，IP地址改为改子网对外的统一IP地址,外部服务收到对应的报文，\b响应报文到NAT路由器，NAT路由器查找NAT\b转换表找到刚才转换的端口A和初始的请求主机IP地址将响应报文发送对请求的主机</p>\n<h2>相关协议简介</h2>\n<h3>因特网控制报文协议(ICMP)</h3>\n<p>ICMP用于主机与路由器之间沟通网络层信息，ICMP是运行在IP协议层之上的，也就是IP数据报的数据部分是包括ICMP的数据报文的内容的(跟IP承载TCP/UDP报文一样)</p>\n<h2>理解路由</h2>\n<ol>\n<li>当主机想发送一个IP数据报的时候,它会查看自己的路由表。如果目的IP地址就是在本地网络，就直接将数据进行封装发送给目的主机.如果目的IP地址\b不在本局域网中,数据被封装然后发送给路由器(此时\b在数据链路层的帧的目的地址是路由器的物理地址,IP报头的目的IP仍然为原来的目的IP地址).</li>\n<li>路由器接收到对应的数据\b传递给网络层,如果目的IP是自身则自己处理这个数据\b(用于更新路由表等)否则查询路由表将数据进行转发。</li>\n</ol>\n<h2>基础词汇解释</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>丢包</td>\n<td>在路由器中存在着缓存结构来缓存需要发送或者接受待转发的分组.<br>当这个缓存过大超出其内存空间的时候，路由器就会丢弃该分组，造成丢包</td>\n</tr>\n<tr>\n<td>IP数据报分片</td>\n<td>由于不同数据链路层所能承载的最大传输数据单元(MTU)不同.IP数据报在数据链路层会被进行分片和重组</td>\n</tr>\n<tr>\n<td>CIDR 无类别域间路由</td>\n<td>它通过扩展IP的网络位数来实现将一个IP\b地址对应成多个IP地址的行为</td>\n</tr>\n<tr>\n<td>ARP 地址解析协议</td>\n<td>在数据链路层提供将网络层的IP地址转换为物理地址</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null}}},{"node":{"id":"963e265f-8eb5-570f-8504-c716bb34314d","html":"<h2>简介</h2>\n<p>node中的Stream模块在很多基础的模块都有使用下面就从官网的文档和源码上学习下Steam模块的基础知识</p>\n<h2>基础</h2>\n<ol>\n<li>node.js 中有四种形式的流 可读(Readable)  可写(Writable)  可读可写(Duplex)   转换流(Transform)</li>\n<li>流在内部维护了一个链表来完成缓存数据的读取,流继承了EventEmitter,通过事件的监听来完成数据的获取</li>\n<li>在进行流的初始化的时候通过设置highWaterMark来控制缓存区的大小 当读写速度出现差异，存储的数据到达highWaterMark的时候，就会出现背压。这样读写流就会停止读或者写入</li>\n</ol>\n<h2>可写流</h2>\n<p>可写流是可以写入数据的目的地的抽象</p>\n<h3>事件</h3>\n<p>drain  stream.write(chunk) 会返回true false来通知当前流是否可写。当它返回false的时候  当前流再次可用的时候 会触发drain事件<br>\nerror  读写数据出现error的时候会触发这个事件 但是不会关掉流<br>\nfinish  在stream.end(chunk,encoding,callback)的时候在数据发送完毕后会触发finish事件，传入的callback作为监听函数</p>\n<h3>方法</h3>\n<p>writable.cork()/writable.uncork()\nbuffer缓存和清除缓存 调用的次数必须一致,在使用writable.uncork()的时候 推荐使用process.nextTick()<br>\nwritable.write(chunk,encoding,callback)  返回的true /false 通知当前是否可写\n结合drain事件来完成持续的写入(即使return false 仍然能完成数据的写入造成内存的占用 给垃圾回收造成压力)<br>\nwritable.destory(error) 关掉这个流<br>\nwritable.end(chunk,encoding,callback) 通知不会在有其他的写入,callback会变成finish事件的回调函数</p>\n<h2>可读流</h2>\n<p>可读流是可以被消耗的数据源的抽象\n可读流有两种状态: flowing paused</p>\n<ol>\n<li>在flowing状态下通过对data事件的监听获取数据。</li>\n<li>在paused状态下通过对_read(size)方法的调用来完成数据的读取.</li>\n</ol>\n<p>在node的lib/_stream_readable.js中,在构造函数中会通过传入的options来初始化流的状态</p>\n<pre><code>  this.buffer = new BufferList(); //  链表 \n  this.length = 0;  // 存储的长度\n  this.pipes = null;  //  pipe 数组 目的地 (初始的时候是null) \n  this.pipesCount = 0; // pipe 长度\n  this.flowing = null;  //  state  null true false (flowing paused) \n  this.ended = false;   \n  this.endEmitted = false; // 是否发送end事件\n  this.reading = false;   // 是否正在读取  \n</code></pre>\n<p>在上面的代码中this.flowing就是控制stream的状态是否是flowing或者paused 通过pipe unpipe 或者data事件的监听能切换状态 (当this.flowing为false的时候通过data事件的监听不会造成this.flowing变成true 必须调用stream.resume())\n在实现可读流的时候,需要实现_read(size)方法触发底层数据的读取.可以使用size(size会根据背压动态变化)来完成读取的流量控制</p>\n<h3>事件</h3>\n<p>data  当流准备发送数据的时候会触发data事件( 切换成flowing 或者read() 方法的调用)\nend 当可读流的数据都被消费后会触发end事件 通知无数据可读取\nreadable  通知当前有数据可以读取或者流数据的结尾会触发 通过监听readable然后通过read事件来完成数据的读取</p>\n<h3>方法</h3>\n<p>readable.isPaused() 返回流当前的状态(对应上面的this.flowing)<br>\nreadable.pause() 切换this.flowing = false<br>\nreadable.pipe(dest)<br>\n(1)可以一个src多个dest(对应上面代码的this.pipes)<br>\n(2)返回dest支持链式调用  a.pipe(a).pipe(b)<br>\n(3)背压的控制 通过在src上注册drain事件并且在write的时候根据dest的状态来写入完成背压的控制</p>\n<pre><code>    src.on('data', ondata);\n    function ondata(chunk) {\n      increasedAwaitDrain = false;\n      var ret = dest.write(chunk);\n        if (false === ret &#x26;&#x26; !increasedAwaitDrain) {\n          // If the user unpiped during `dest.write()`, it is possible\n          // to get stuck in a permanently paused state if that write\n          // also returned false.\n          // => Check whether `dest` is still a piping destination.\n          if (((state.pipesCount === 1 &#x26;&#x26; state.pipes === dest) ||\n               (state.pipesCount > 1 &#x26;&#x26; state.pipes.indexOf(dest) !== -1)) &#x26;&#x26;\n              !cleanedUp) {\n            debug('false write response, pause', src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n          }\n          src.pause();\n      }\n    }\n</code></pre>\n<p>当src接受到drain事件后会触发drain事件的监听函数重新完成数据的写入</p>\n<pre><code>//  pipe  end flag\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 &#x26;&#x26; EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n</code></pre>\n<h3>实现一个可读流</h3>\n<pre><code>const { Readable } = require('stream');\n// Stream 实现\nclass MyReadable extends Readable {\n  constructor(dataSource, options) {\n    super(options);\n    this.dataSource = dataSource;\n  }\n  // 继承了 Readable 的类必须实现这个函数\n  // 触发系统底层对流的读取\n  _read() {\n    const data = this.dataSource.makeData();\n    this.push(data);\n  }\n}\n// 模拟资源池\nconst dataSource = {\n  data: ['1','2','3','4','5','6','7','8'],\n  // 每次读取时 pop 一个数据\n  makeData() {\n    if (!dataSource.data.length) return null;\n    return dataSource.data.pop();\n  }\n};\nconst myReadable = new MyReadable(dataSource);\nmyReadable.setEncoding('utf8');\nmyReadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n</code></pre>\n<h4>从源码上理解上面的例子</h4>\n<p>通过data事件的监听</p>\n<pre><code>    Readable.prototype.on = function(ev, fn) {\n        const res = Stream.prototype.on.call(this, ev, fn);\n\n        if (ev === 'data') {\n        if (this._readableState.flowing !== false)\n          this.resume();\n        } else if (ev === 'readable') {\n        const state = this._readableState;\n        if (!state.endEmitted &#x26;&#x26; !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.emittedReadable = false;\n          if (!state.reading) {\n            process.nextTick(nReadingNextTick, this);\n          } else if (state.length) {\n            emitReadable(this, state);\n          }\n        }\n      }\n      return res;\n    };\n</code></pre>\n<p>当注册data事件的时候,会调用this.resume() 最后调用flow(stream) 来完成数据的持续读取</p>\n<pre><code>    function flow(stream) {\n      const state = stream._readableState;\n      debug('flow', state.flowing);\n      while (state.flowing &#x26;&#x26; stream.read() !== null);\n    }  \n    \n</code></pre>\n<h2>总结</h2>\n<p>上面就简单的介绍了下node中stream模块的基础知识,通过对流模块的学习能更好的帮助我们理解node中数据的发送处理过程,也可以尝试着去阅读一些简单的模块(send)来加深对Stream的理解.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903588649500679\">Node.js可读流和可写流</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null}}},{"node":{"id":"cfb62610-6cf5-58f8-94ad-207f2e5dfb04","html":"<h2>简介</h2>\n<p>koa利用生成器来解决回调函数的嵌套问题，实现的十分巧妙，下面跟着官网的例子逐步学习下koa的实现原理<br>\n官网 <a href=\"http://koa.bootcss.com/\">koa</a></p>\n<h2>使用</h2>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n});\r\napp.listen(8080);  \n</code></pre>\n<p>这个例子很像在Node中构建HTTP服务器的例子</p>\n<pre><code>var http = require('http');\r\nhttp.createServer(function(req,res){\r\n    res.writeHead(200,{'Content-Type':'text/plain'});\r\n    res.end('hello world');  \r\n}).listen(8080);  \n</code></pre>\n<p>通过app.use()设定中间件 app.listen()监听特定的端口这样整个web服务器就启动了 那我们的关注点就到了这句话 var app = koa();<br>\nkoa的源码lib下有四个文件 application.js context.js request.js response.js  在koa的package.json中main属性的值指向的是lib/application.js 也就是整个web服务器的生成过程都在这个js中 下面我们逐步的解读下application.js的部分源码</p>\n<pre><code>module.exports = Application;\r\nfunction Application() {\r\n    if (!(this instanceof Application)) return new Application;//确保不通过new调用构造函数的时候返回正确的值\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.subdomainOffset = 2;\r\n    this.middleware = [];//保存中间件的数组\r\n    this.proxy = false;\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);//通过指定的原型创建对象\r\n }  \n</code></pre>\n<p>通过上面这段代码，也就是在调用这句话的时候 var app = koa()实际上就是生成了一个Application实例 在实例上有一个数组用于保存中间件 三个属性 context request response</p>\n<pre><code>var app = Application.prototype;\r\napp.listen = function(){\r\n    debug('listen');\r\n    var server = http.createServer(this.callback());//this.callback()就是请求来的处理函数\r\n    return server.listen.apply(server, arguments);  \r\n    //这里上文中Node构建HTTP服务的例子 似曾相识 \r\n};  \n</code></pre>\n<p>在http.createServer(this.callback())中this.callback()就是请求来的处理函数也就是app.callback()这个函数 正是这个函数实现了koa的中间件机制</p>\n<h2>中间件</h2>\n<p>在介绍中间件的原理之前 先上一个例子</p>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(next){\r\n    console.log(1);\r\n    yield next;\r\n    console.log(2);\r\n});\r\napp.use(function *(next){\r\n    console.log(3);\r\n    yield next;\r\n    console.log(4);\r\n});\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n})；\r\napp.listen(3000);  \n</code></pre>\n<p>当对服务器发送一个请求的时候  会发现服务器的控制台log出的顺序是 1 3 4 2 下面我们来看一下这个神秘的app.callback()函数到底做了什么</p>\n<pre><code>app.use = function(fn){\r\n    if (!this.experimental) {\r\n      // es7 async functions are not allowed,\r\n      // so we have to make sure that `fn` is a generator function\r\n      assert(fn &#x26;&#x26; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);//将每次调用的生成器函数push到中间件数组\r\n    return this;//可以实现链式调用\r\n}; \n</code></pre>\n<p>app.use()就是收集所有设定的中间件，然后存储到数组中</p>\n<pre><code>app.callback = function(){\r\n  var fn = this.experimental\r\n    ? compose_es7(this.middleware)\r\n    : co.wrap(compose(this.middleware));\r\n  var self = this;  \r\n  return function handleRequest(req, res){\r\n    res.statusCode = 404;\r\n    var ctx = self.createContext(req, res);\r\n    onFinished(res, ctx.onerror);\r\n    fn.call(ctx).then(function handleResponse() {\r\n      respond.call(ctx);\r\n    }).catch(ctx.onerror);\r\n  }\r\n};  \n</code></pre>\n<p>app.callback()中的返回值 function handleRequest(req,res){}就是请求来的时候的处理函数 在这个处理函数中调用fn进行事件的处理 fn是什么呢？  我们只需要搞明白这句话 co.wrap(compose(this.middleware))</p>\n<p>第一步 compose对生成器函数数组进行了处理</p>\n<pre><code>function compose(middleware){\r\n  return function *(next){\r\n    if (!next) next = noop();\r\n    var i = middleware.length;\r\n    while (i--) {\r\n      next = middleware[i].call(this, next);//不断的获取后一个生成器对象 作为参数传入当前的生成器函数并且执行获得生成器对象\r\n    }\r\n    return yield *next;\r\n  }\r\n}\r\nfunction *noop(){}  \n</code></pre>\n<p>其实理解compose的作用要理解好通过app.use(function *(next) {}) 传递的生成器函数传递的next  整个compose的作用就是生成器函数的执行后进行从头到尾的串联 然后返回一个生成器<br>\n接下来就需要理解co的执行流程了</p>\n<h2>co源码解读</h2>\n<p>co是通过生成器避免了多个异步操作的回调嵌套</p>\n<pre><code>function *test() {\r\n  var a = yield readFile1();\r\n  var b = yield readFile2();\r\n}\n</code></pre>\n<p>简单理解co的作用就是首先获取之前执行的结果 保存下来当下次调用generator.next()的时候作为参数传入，这样就实现了异步操作的同步执行</p>\n<pre><code>function co(gen) {\r\n  var ctx = this;\r\n  var args = slice.call(arguments, 1)\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\r\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\r\n    onFulfilled();\r\n\r\n    function onFulfilled(res) {\r\n      var ret;\r\n      try {\r\n        ret = gen.next(res);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n\t}\r\n    function onRejected(err) {\r\n      var ret;\r\n      try {\r\n        ret = gen.throw(err);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n    }\r\n    function next(ret) {  //这里使用promise进行了封装 当之前的异步调用完成后 就会在调用onFullfilled将这次执行结果的返回值传入\r\n      if (ret.done) return resolve(ret.value);\r\n      var value = toPromise.call(ctx, ret.value);\r\n      if (value &#x26;&#x26; isPromise(value)) return value.then(onFulfilled, onRejected);\r\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\r\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\r\n    }\r\n  });\r\n}\n</code></pre>\n<p>通过上面的代码阶段我们就学习了koa的中间件机制 其实ES7的异步函数就是实现的co所做的事</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":true,"index":15,"pageCount":15,"additionalContext":{"pageAllCount":88}}},
    "staticQueryHashes": []}