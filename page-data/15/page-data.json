{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/15",
    "result": {"pageContext":{"pageAllCount":94,"group":[{"node":{"id":"cd56cd7c-4adc-5c34-be0f-983b3549de82","html":"<h2>简介</h2>\n<p>事件循环是不同的宿主环境(浏览器或node)对javascript任务进行调度的一种机制,在讨论事件循环的时候首先应该区分node和浏览器(不同宿主环境实现的事件循环机制不同).下面通过介绍一些javascript的基础知识,进而简单的介绍浏览器中的事件循环和node中事件循环.</p>\n<h2>基本概念</h2>\n<ol>\n<li>javascript程序的执行机制是通过栈来管理的.当进入一个函数,就创建了这个函数的执行环境并将这个执行环境推入栈顶,执行完当前的函数后,从栈顶移除对应的执行环境,进入到外层的执行环境.</li>\n</ol>\n<p><img src=\"/blog/ee34151d44d3f796b1f1436e0926a2a7/stack.gif\" alt=\"stack\">\n2. javascript的执行是单线程的.但是由于整个事件循环的调度,赋予了javascript对异步任务的强大处理能力.对于异步任务(网络请求,按钮点击)javascript代码调用宿主环境提供的api,将异步任务交给其他的线程去完成.当对应的异步任务完成的时候,将回调函数添加到\n回调函数的队列中,由事件循环来实现会回调函数的调用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>marcotasks microtasks</h2>\n<p>将macrotasks和micortasks单拉出来讲解,是因为理解好这点能更好的理解浏览器或node的任务队列.在实际的实现环境中不同的任务可以放置在不同的任务队列中,然后通过对多个任务队列的调用来完成整个事件循环.</p>\n<ol>\n<li>macrotasks:</li>\n</ol>\n<ul>\n<li>定时器(timer) setTimeout setInterval setImmediate</li>\n<li>message channel  (message channel执行的优先级高于timer)</li>\n<li>I/O</li>\n<li>UI rendering</li>\n</ul>\n<ol start=\"2\">\n<li>microtasks:</li>\n</ol>\n<ul>\n<li>Promises</li>\n<li>MutationObserver(监听DOM)</li>\n</ul>\n<ol start=\"3\">\n<li>其他api</li>\n</ol>\n<ul>\n<li>\n<p>queueMicrotask(fn)\n将Fn推入微任务执行队列</p>\n</li>\n<li>\n<p>requestAnimationFrame<br>\n通知浏览器在下次重绘之前调用传入的回调函数，回调函数默认传入函数执行的时间戳.requestAnimationFrame不属于宏任务和微任务，在微任务执行之后执行</p>\n</li>\n<li>\n<p>process.nextTick\nprocess.nextTick是node上的api，具体的执行时机是在微任务之前执行。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVQ4y42T227aQBRF+QwItudqjw12bGyMuQQCCRENtE9VK7X//x+r8uSiRkmkPGwdzRnN1lkzewbKWHTeYos5dTujW9V0q4Z6XhPHCWEYEkXRO33WHyilUPGUpKjJ2xVuWpBVDWlRkkxywiB4o6Cvz2YfmQ6klBTJFCcNURgiTYxU2ktEEUJIdOzQxqJih4kdSsp3Zi9rP6GWirbdUa9vqfcn2rszy8svuvtHqs2B+eEbi/szy4fv1G1Hf+YjXG+otSYMxuTdlmb/SN4sqW6OlMs9Rbcju679lFJZpFSeIhj3+CFBEPrqFT5poLTyaPEkIy0zXJkxbUuS3CFtgHEC4xQ2lWgnsZnGpMrXF/X7QkZE4hlZCIGOIyYzTT43ZJUiKxVZZUgrS1Zb3LV+rUlumC4crrToRL2aSiN6ZEUQRtzXhr+nip93Bb+PBX+OBZdDQ96tmcwaqps7quWaOE3xVEr4Owv+R++Re8MoEuTOcbqcOP04s9jsKNuOax+jkrSYkbcbf7/5fIW1sY/PpznUShEnFmsVUghGwxHD4ZDRaMT46upJoyHjq5FX+GoWvovPoH+5fsrH84bLZcf2Zk5TF1jT9yVKPSkS4ms/pX+Q1CXcrjs22479w579ccf2sGW9W7FoSxZd47P3mcnbHBqNS1KcchibYLMCk05J8hk2nWKtJUliH62vGP4DF253f3L9M/QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nextTick\"\n        title=\"nextTick\"\n        src=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png\"\n        srcset=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/63868/nextTick.png 250w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/0b533/nextTick.png 500w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png 1000w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png 1150w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>setTimeout(function(){\n  console.log(1);\n});\nnew Promise(function(resolve){\n  console.log(2)\n  for( var i=100000 ; i>0 ; i-- ){\n      i==1 &#x26;&#x26; resolve()\n  }\n  console.log(3)\n}).then(function(){\n  console.log(4)\n});  \n\nconsole.log(5);\nprocess.nextTick(() => { console.log('nextTick'); })\n输出的顺序依次是 2 3 5 nextTick 4 1 \n</code></pre>\n</li>\n<li>\n<p>requestIdleCallback\nwindow.requestIdleCallback(callback[, options])</p>\n<ol>\n<li>callback是一个在事件循环空闲时即将被调用的函数的引用，接收一个IdleDeadline参数，通过该参数可以获取当前空闲时间(timeRemaining())以及回调是否在超时时间前已执行的状态(didTimeout)</li>\n<li>options 可选参数 可以配置timeout  表示超时毫秒数未调用回调函数，回调函数将在下一次空闲期间被强制执行。</li>\n</ol>\n</li>\n</ul>\n<p>在具体的实现中只会有一个microTasks队列,简单的理解事件循:</p>\n<ol>\n<li>浏览器或者node会按照顺序执行自己环境的多个macrotasks队列</li>\n<li>每执行完一个macrotask队列就会拿出micortasks队列的任务全部执行，然后继续执行下一个macrotask队列</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1CLID/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRR5Ef/aAAwDAQACAAMAAAAQ48//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAAAATFBEVEhcfD/2gAIAQEAAT8Qy3TXN2M1O2ZJuxz7aIH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runTask\"\n        title=\"runTask\"\n        src=\"/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg\"\n        srcset=\"/blog/static/9a253bb0db2af3498f93ce723c928568/0479a/runTask.jpg 250w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/41099/runTask.jpg 500w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg 1000w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg 1098w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in browser</h2>\n<p>其实通过对上面相关的知识的介绍,已经可以大致的了解浏览器中事件循环的任务队列 主要有以下几种macrotasks队列</p>\n<ol>\n<li>事件callback</li>\n<li>I/O(xhr)</li>\n<li>timers</li>\n<li>UI渲染</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in node</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAACzklEQVRIx5WVC0/qQBCF/f//RQMKUfAJCpIoAYxBBBGjEfABgkApbWFuviHbFCwpt8lkutvu2TMzZ2d3ZO1ZLBbqHceRwWAg39/fav1+X/3Pz498fX2ptyxL7NlM/505jsznc9kBYN14AMtmsxKLxdQODw/l4OBAfTKZlKOjI3l5eZHp1JbZbKbg0+l0CRjG0LZt+fz89BliMMN4//j4kNFo5K+DnQUgA8/zlLbruiugwYdv/LMpRa7rLQH56f39XVqtlry9vfm7MgcLE/7d3Z1cX18rw263K8/PzysbQ0oBf39/5fb2Vs7Pz6VQKMjr66tY1lR6vZ70en2ZTCZSq9UknU5r/vgX0E6nqyB/AAnl/v5erq6u5ObmRobD4Z+wmON7JpNR5ibHoYBGIhQANptyOB6P/RQsx5NwwE1VZhPySehojjySnuAYmYQyDNMhi4rFomru5ORE9vf3VXtYIpGQXC6nRQwFXAflQaxGc0Ed4mFJikjDRsD1cBuNhhYL//j4KA8PD9JsNrXiSIi5arXqy4zibgTkGCEhQj07O1N/enoqx8fH+h70aDISkI+Eg1F5NsB4pxDG+E5qVk5KGCALn56eVMQwoQCpVEouLy+VMYXh1BA2+YxkyO4AYuTM5NB4rF6v65i2FglIxdAZlUQ+sGBh0PONE2QaRmTI+Xze73tokJ5o+iHjvb09LRTAWxUFJrCEISckaMxjMKVYkYAc/E6no5Jot9tSKpWkUqlozsrlsrYuzjXfttIhIQOAAUB1MaqNUX3EzdE0DSOyKGiMpOON7sy9wYbMw24rHbKQ8Eg6zLis0OHFxYU2YpotY1j+tw7RmznPeIw5o0OKtlWVCcd0F3P7UXkKZW4/UrJVyOSHxKNDY/F4XEPd3d3VdzTJlWCagxPF0HTooPZgSUFgjzFnGIb2w033iXlY4HlzcT1PAXh3HFdBl0qw5R8VVUHLG1SyuAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node\"\n        title=\"node\"\n        src=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n        srcset=\"/blog/static/624c9768d8888b109a4649298c0cb091/63868/node.png 250w,\n/blog/static/624c9768d8888b109a4649298c0cb091/0b533/node.png 500w,\n/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>注意点</h2>\n<ol>\n<li>在浏览器或者node中某些代码的执行会导致event loop失效(停留在处理一个事件队列导致无法进入其他的事件队列的处理).比如浏览器中javascript的长时间执行会导致UI无法交互,node中process.nextTick的递归调用</li>\n</ol>\n<h2>相关资料</h2>\n<p><a href=\"https://tuobaye.com/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/\">通过microtasks和macrotasks看JavaScript异步任务执行顺序</a><br>\n<a href=\"http://docs.libuv.org/en/v1.x/design.html\">libuv Design overview</a>\n<a href=\"https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f\">How JavaScript works in browser and node?</a>\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&#x26;utm_medium=email\">Tasks, microtasks, queues and schedules</a><br>\n<a href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\">Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018</a>\n<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;t=55s\">菲利普·罗伯茨：到底什么是Event Loop呢？ | 欧洲 JSConf 2014</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null}}},{"node":{"id":"d9a2727c-f773-51a0-ae91-74deed50be73","html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.下面从几个方面来拆分这个小例子来重新学习下XMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,顺序对应着请求的方法、地址、是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中增加query的方法进行数据的发送并且在调用send方法时必须send(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, 注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error 请求发生错误的时候的监听函数</li>\n<li>loadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>xhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载并且可以通过download进行文件名的设置.这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件名,这个时候可以通过设置responseType为blob,生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的时数据上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么上传阶段完成是mock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的切分上传阶段和数据接收阶段的比例来完成对用户接受更合理的进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>作为一个web前端开发者离不开XMLHttpRequest的使用,以上通过对xhr基础的介绍和自己在项目中遇到的问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null}}},{"node":{"id":"627714b4-755f-5558-b731-9a17d8bbe360","html":"<h2>简介</h2>\n<p>在看深入浅出node.js这本书的过程中,遇到了几个容易迷糊的概念,例如阻塞I/O、非阻塞I/O、同步、异步。下面主要从I/O模型上对上面的概念进行理解.</p>\n<h2>基本概念</h2>\n<p>I/O复用指的是内核具有当进程指定的I/O条件就位的时候通知进程的能力.</p>\n<h2>I/O模型</h2>\n<ol>\n<li>阻塞式I/O 在发生系统调用(I/O)的时候,对应的系统调用直到相应的操作完成或者错误时才返回.(例如在进行网络IO时,需要等待网络数据的就绪完成读取才会完成系统调用的返回)</li>\n<li>非阻塞式I/O 进程可以把一个套接字设置成非阻塞模式.这样当通过该套接字进行相关I/O操作并且需要进程进行等待的时候(例如通过网络读取数据,但是数据并没有就绪的时候), 内核不能将该进程投入睡眠而是返回一个错误标识(轮询)</li>\n<li>I/O复用模型 通过select或者poll来对多个相关的描述符进行监听(此时进程阻塞在select和 poll的调用上)),当描述符状态就绪的时候,返回可读条件然后在通过系统调用来完成对应的I/O操作</li>\n<li>信号驱动式I/O模型 通过开启套接字的信号驱动式I/O的功能并且添加相应的信号处理函数,当套接字准备好读取的时候,通过信号通知进程来完成响应的I/O操作.这种模式进程是不被阻塞的</li>\n<li>异步I/O模型  通告系统调用告知内核相应的操作,然后内核在完成相应的操作后会通知进程.这个过程中进程是不被阻塞的.</li>\n</ol>\n<h2>同步VS异步</h2>\n<p>同步,异步的概念区分上在于实际上发生系统I/O的时候,是否会阻塞进程.因此上面的前四种模式都是同步I/O,只有最后一种是异步I/O</p>\n<h2>select</h2>\n<p>int select(int maxfdpl, fd_set *readset, fd_set *writeset,fd_set *exceptset, const struct timeeval *timeout) 该函数允许进程指示内核等待多个事件中的任何一个发生,在其实一个或者多个事件发生后或者经历了一定时间后唤起进程.该函数的当有描述符就位的时候返回描述符的数目,超时返回0,若出错返回-1,下面对主要的参数进行分析</p>\n<ul>\n<li>timeout 告知内核等待所指定的描述符中任何一个就绪所花的时间.\n<ol>\n<li>当该timeout结构的代表的值均为0的时候,表示无需等待直接返回</li>\n<li>当设定一定时间的时候,表示当select返回的时候,不能超过该时间</li>\n<li>当设置为空指针的时候,表示select会一直等待直至有响应的描述符就绪</li>\n</ol>\n</li>\n<li>readset writeset  exceptset  表示让内核检测响应的读,写,异常描述符,当有响应的描述符就位时返回.</li>\n<li>maxfdpl 指定待测试的描述符的个数</li>\n</ul>\n<h2>node如何实现高性能的异步I/O</h2>\n<p>参考自己之前整理的一篇blog<a href=\"https://www.cnblogs.com/tiantianwaigong/p/6234961.html\">node的异步I/O</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null}}},{"node":{"id":"99c9b30a-e728-507a-9299-d6242ca4ad7f","html":"<h2>简介</h2>\n<p>网络套接字是应用层和传输层的桥梁。套接字提供了应用层与系统内核的交互的能力来完成数据的发送和接收.下面主要从套接字的几个基础api来介绍套接字并且结合tcp来理解网络应用对外提供服务的整体过程.</p>\n<h2>基础api</h2>\n<ol>\n<li>在使用套接字发送数据时将数据从应用进程的缓冲区写入到套接字的发送缓冲区，来完成数据的发送.</li>\n<li>通过对套接字函数的调用可以获取套接口的一个描述(一个套接口可以对应多个套接字描述),当内核中不存在套接字的描述符的引用的时候,内核会触发该套接字的close.</li>\n<li>基本TCP客户/服务器程序的套接字函数调用过程</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB6klEQVQ4y5VT25KiMBD1/z/MB6t884qgYhEFBJKQK52kmdJMMe7s1K5zHqhKyOk+fbp7Nr6Nvu/X6/Vut9Nax5vZm0xEFEKkaVqWpbX2/2REHMeRMZYkyel0EkJcLpeyLIdheDczPhFCkFKmaZrn+VuZXxFCMMYQQuq6BoBf18w53+/3RVF8NwwRlVKTnm9lRwDA4XAghEz3syipbdvdbne73SZJPzq3WCyWy6X3/iuz955SmiRJVVVCiBCC9x4RrbX3+905h4j+CSGE1nqSM4uBGWNpmrZtG9tojPHeE0Lm8/l2u7XWaq1jrCjtUzYitm3bNE2apk3TaK3DE7GllNJhGKZUxpjJrQfZOSelVEp1XSeltNYCgDGGMdZ1HWMMAIZh6Lquqqrz+VxVVV3XUsoHGQCcc+M4/m31q2HOOa11lmWEkBgdER/kWMY/yNOcZFlWVVV8HEL4JMduvZbHGMvz/HK5aK2998YYSunxeLxer5xzKeUjs3Ouf2K/30e3o7HGGCllLCp+h2EQQiil/hjPEELf95vN5n6/x3+ICACU0q7rXntjnvhyO5KVUnVdc86NMQBgreWcE0Ji8wGg73tKaVEUcWx+txha67Zt42JzzgHAez/7cQemNY6Ix7IsV6tVkiRFUcQR+AAp44e3Q8OxXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"套接字基础api\"\n        title=\"套接字基础api\"\n        src=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n        srcset=\"/blog/static/488016f75fa3e6b554b97157803a13e8/63868/api.png 250w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/0b533/api.png 500w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>socket(int family, int type, int protocal) 默认产生一个主动的套接字 其中family字段指明协议族如Ipv4,Ipv6等, type为套接字类型如SOCK_STREAM(字节流套接字), SOCK_DGRAM(数据报套接字) protocal指的是由前两个参数决定的协议说明 例如tcp传输协议  UDP传输协议</li>\n<li>connect(int socket, const strcut *servaddr, socklen_t addrlen) 在TCP套接字状态下调用此方法会激发TCP的三次握手.几种常见的网络错误也是在这个阶段出现了\n<ul>\n<li>如果发送了SYN,在经过TCP的超时重试之后仍然没有收到对应的ACK,此时显示ETIMEOUT超时</li>\n<li>收到RST(复位) 通常对应的对方没有正在监听的服务器、TCP想断开一个已有的连接、TCP收到一个不存在连接上的分节</li>\n</ul>\n</li>\n<li>bind(int sockfd, const struct *myaddr, socklen_t addrlen)  将一个本地协议地址绑定到一个套接字\n<ul>\n<li>在绑定地址上,在服务端上的一般都绑定到特定的端口 对IP地址进行0.0.0.0(INADDR_ANY)绑定(为了处理服务器有多个网络接口), 最后由系统内核指定IP地址  在客户端一般有内核指定IP地址和端口</li>\n</ul>\n</li>\n<li>listen(int sockfd, int backlog) 将一个从主动状态转为被动状态,指示内核接受指向该套接字的请求\n<ul>\n<li>backlog参数代表着未完成连接队列和已完成连接队列之和.在正常的三次握手的过程中,一个未完成连接的条目存活的时间是最后一次客户端对服务端ACK的确定(RTT)</li>\n<li>设置成较大的backlog是为了扩大为完成连接数目的队列.当为队列数目是满的时候,TCP会忽略该分组,这样TCP将重发SYN而不是显示连接错误等</li>\n</ul>\n</li>\n<li>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) 从已完成队列中返回一个已完成的连接\n<ul>\n<li>区分监听套接字和已连接套接字  监听套接字在服务器的整个生命周期只存在一个,连接套接字是为每个接受的请求都会创建的</li>\n</ul>\n</li>\n<li>fork 创建自身进程的一个副本\n<ul>\n<li>fork的调用会在父进程和子进程中进行返回,通过区分返回值来区分父进程和子进程</li>\n<li>子进程共享共享父进程fork之前的所有描述符(注意在fork的时候关闭对应的描述符)</li>\n</ul>\n</li>\n<li>int shutdown(int sockfd, int howto) howto指明如何关闭改套接字是关闭读的部分还是写的部分,这样能防止关闭套接字时候无法处理到达的网路请求返回数据</li>\n</ol>\n<h2>相关参考链接</h2>\n<p><a href=\"http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html\">tcp backlog</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null}}},{"node":{"id":"b3d4eea3-bcd1-54be-82e3-ecc3aca713b9","html":"<h2>简介</h2>\n<p>通过对运输层和网络层的基础知识的学习,了解到他们分别提供了基于主机进程间的通信和主机间的通信,这都基于数据链路层实现的上述功能,下面通过对数据链路层的学习来了解数据是如何通过相应的数据链路来实现传输和交付的</p>\n<h2>基础</h2>\n<p>1 在通信路径上连接相邻通信节点的通信信道称为链路。链路层协议将网络层的数据报封装成链路层帧来实现数据在链路节点间的移动。\n2 链路层主要提供的服务有数据报的成帧,链路的接入(无线链路,有线链路),可靠交付,差错检测和纠正.链路层的功能主要在网络适配器(NIC)上来实现相应的功能\n3 链路层通信通过MAC地址(LAN地址或者物理地址)来实现,所以一个通信的具体过程会涉及到三种地址:</p>\n<ol>\n<li>主机名</li>\n<li>IP地址</li>\n<li>MAC地址</li>\n</ol>\n<h2>地址解析协议(ARP)</h2>\n<h3>ARP的作用和寻址过程</h3>\n<p>ARP提供的是同一个子网和路由器的网络层地址到MAC地址的转换.主机会在内存中维护一个ARP表,这个表保存着一定时间内该子网内主机IP地址和MAC地址的映射.当目的主机的IP地址在ARP表中时,发送主机通过封装链路层帧目的MAC地址为保存的目的MAC地址将数据推送进数据链路层.当ARP表中没有响应的条目的时候,发送主机通过MAC广播地址发送APR广播分组,这样子网内所有的主机都会处理该分组,符合该IP地址的主机会发送ARP响应分组,将自己的MAC地址通知给请求发并且更新请求方的ARP表</p>\n<h2>以太网</h2>\n<h3>以太网基础</h3>\n<p>以太网是基于之前的各种协议实现的一种局域网技术,它提供给网络层无连接服务.</p>\n<h3>以太网帧结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 884px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVQY0z2LTUvbYACA80PEHzC9CLrLKlLGDuJgpTI3vzpE2EUZyHbRIt5kh6FsggeL2po0PSiryeL7NhVddVK1TWcjJbXWFisxpB9C0tqlJjbv0E0fntvDg5mmiRBSlUr27DyTzpbVa4RQWa2kkplqtYYQusv3mA8+gkmiVJALSkkVc2IumytIRVmSxXMpk8rqNf3fdFUsyZeyWf8/GrqRlwpaVcMOufhxIq1UtJKqXpXL+aKyuxdJZy5EOV+rm9c3xs2tKSTP4ryg6beabvwx6mpVi0bixZKCPaUTnZunjgDXQfNW6miQjVlgygZiL9bCr8FRZzBlBUL7hmBhEh0waYVCFys4AlzbOj8Vu8AmmajNz7W6wccNboyJWtxwiuXH/L/mNw+ee7efeMPTW8euHd61f7IQijsB1+zbf0kEvgR/fw6fYv1L4JkLNs3gvR7Y6wYts95hcntg0T9OMq1zqw1fqdHVkPP7Tye9N7G2NYSzjd+o9jlv9yL4BCNY1zLT5wuOkvQbAr4l4AhJ2wh2iPjhwKn3JDPgC3bj0L4C7B7GvgJ6cPiOhB981KtlaiYU/Qscvja2c8oD8QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"以太网帧结构\"\n        title=\"以太网帧结构\"\n        src=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n        srcset=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/63868/dataLink.png 250w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/0b533/dataLink.png 500w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png 884w\"\n        sizes=\"(max-width: 884px) 100vw, 884px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>前同步码 主要用于在发送方和接收方进行时钟的同步</li>\n<li>目的MAC地址 当接受方收到对应的链路层帧的时候,当该帧的目的MAC地址是本机的MAC或者是广播地址的时候,数据字段的内容就是向上传递给网络层进行处理</li>\n<li>源地址 发送方的MAC地址</li>\n<li>类型字段 用于与上一层的某协议相结合</li>\n<li>数据 网络层数据报</li>\n<li>CRC 循环冗余检测用于接受方检测是否存在差错</li>\n</ul>\n<h2>交换机</h2>\n<p>链路层交换机主要提供转发和过滤的功能.过滤是指决定一个帧是否被转发到某个接口还是将其废弃的功能.转发指一个帧具体应该被转向那个接口.</p>\n<h3>交换机的转发过程</h3>\n<p>交换机通过自学习的特性定期的维护自身的交换机表.表的条目分别是MAC地址,接口,时间.当交换机收到一个帧的时候,会根据该帧的目的地址做出不同的行为</p>\n<ol>\n<li>如果交换表中没有该MAC地址的时候,交换机就会向它所有的端口转发该帧</li>\n<li>当交换机接受到该帧的端口MAC地址和目的地址相同的时候,丢弃该帧.</li>\n<li>当交换机表中存在相应的条目的时候,将该帧转发到相应的端口</li>\n</ol>\n<h2>web页面请求的详细过程</h2>\n<p>可以结合前两篇来理解这个过程(DHCP HTTP  UDP CIDR IP MAC(ARP))  里面涉及的编制 寻址 传输等相关协议</p>\n<h2>思考</h2>\n<ol>\n<li>网络协议虽然是分层的，但实际的实现上层与层之前的界限并没有那么清晰,不能割裂的去学习网络协议模型,要从整体上理解网络协议的整体过程</li>\n<li>在具体功能的实现上,例如数据链路层通过MAC地址进行通信而不是依赖网络层的IP地址,这样就能使数据链路层与其他种数据格式对接,增加独立性</li>\n<li>层与层之前的功能不具有强依赖关系,例如数据链路层是能够通过CRC循环冗余检测来实现差错检测和恢复的,网络层自己实现了本身的差错检测,在实现一个大型的系统的时候,功能到底是依赖于上层还是自己去维护(稳定性)都是值得考虑的点</li>\n</ol>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null}}},{"node":{"id":"4a2c57bb-e06c-5beb-a596-a9352d6e71d9","html":"<h2>简介</h2>\n<p>在初学node的时候,都会在学习到下面的这个例子:</p>\n<pre><code>const http = require('http');\nconst server = http.createServer(function(req,res) {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('okay');\n});\nserver.listen(8080,function() {\n  console.log('server is on');\n});  \n</code></pre>\n<p>上面的例子就创建了一个最简单的web服务,当通过浏览器访问本地的8080端口的时候页面就会输出okay。下面主要从两个方面来理解node如何加载和运行这段代码来提供服务的。</p>\n<h2>node代码结构(基于node V6.11.0)</h2>\n<p>下面就是node的代码结构,在lib中主要是node提供的标准库(例如http等模块),在src模块主要是node的入口文件和node提供给lib的C++接口.在deps中主要包含了DNS解析,http解析,事件循环和跨平台的异步IO的实现等.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 932px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABB0lEQVQ4y62STU+EMBRFWasLE93KAKV8tDhAS9FAYTIMBtf+Aifj3v+/uqadxGh04XRcnDT9yMm779XLshxaa/S9RpKkoDRxgpAYnBfwzKaqakzTDmmaIQwj+yCOqcVJ2DQK2+0EISTW6/Ik0Q+hiVnXAsMwYlmeoVRrL8+KLIRA1/Uoy+oz7tfVKfI8P1mhi+yXCiXa9sH271+mrJSyMt9ffZuuc2QpGzsUrQfbS/N9zoicQsgGfT+AscJizmJT4R85CulRyLMMQ9fhnjOQIACNIiSEnEZMQKMQBcvh0eoRzWZBwCV8JrBy5C6vYVzezfyG9OUd19MBl+MrrjZ7Jy7GPW53B3wAKwuBpW1A2esAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node代码结构\"\n        title=\"node代码结构\"\n        src=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n        srcset=\"/blog/static/38795164842a3beb02db9ed01e44311f/63868/nodeSrc.png 250w,\n/blog/static/38795164842a3beb02db9ed01e44311f/0b533/nodeSrc.png 500w,\n/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png 932w\"\n        sizes=\"(max-width: 932px) 100vw, 932px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>node如何加载我们的代码</h2>\n<p>通过都是通过命令行 node server.js来启动一个简单的服务,下面来简单的看node如何加载和执行这个server.js文件<br>\n在node的启动文件src/node_main.cc中有如下这段代码,它调用了node.cc的node的Start方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABG0lEQVQY032QW27CMBBFs44SE+dhk4Q4YAenBIIoffFH1Q10/7s4VRxRqf3ox9Gdq5k7I00k1ZrWd4wnh2oc286z6yxp7ShbyzDs8d5TVRWJTEiSJctkOetyroOXs48SKZGFpNwW6HYip+4UK5MFKqso6hTVZKGnTY5a55RbxWpTUFqFbvKQV+uMSEqJdTV+aHF+y+PBU7Y1WbNBGYuqNafLkd3eYeyaXKXILCFTkrxMA2khg58IC5/OPa8vA+N45Pr2zqGzbPoL2p3RuuLjdmMcT3TeMc3HsUDEIui9vhPJVGK0waiWbmfoe8PX1fL53OH7R5qmYT/s0VoTx/H8t3+ITGlwtSVN0hAQQvCwECymi+I3U+Cv/iDmhd//Pa9jeahOZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"main\"\n        title=\"main\"\n        src=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n        srcset=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/63868/nodeMain.png 250w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/0b533/nodeMain.png 500w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在Start方法先对平台进行了初始化操作 主要关注下面的代码<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVQ4y5VUbY6bMBTMLbbi0wYCBtuYGBuyCWxIVlWlXqA/ev9zTGWTRNlmW2l/PD3LFuOZeYM3QgjM84TpeMDr64j9fodx7GCMhLUGfW8wDAP2+z2UUhisBWMMURQhSZKn2nBewfQSvS8BY1owVoGQFJTSe2VZBkKIX6dp+gEkjmNfHjDNKmRlg6auIYT0t2d5hjiKEIUBojBEGAYIgwBhGCKK1orjyLN0e4/Am4o1aLhE27a+hOCoawZabJGVa89LhrKskOcFsiz3ndIM2+0WVVVdGV4lZ5Si19p71XUdrLW+s1ZDmAMaPUDYA6Z5wvvlDafTEfN8wPnyhmEYvafOgrtk58ttw3W/ThIQv06QXqUYs8PhYNDUBRjL0ba19zMIgrvcO6A7cACPphNCr+v1Qr57RdPPyLlFKQxS1oFUClKPsMZgHEfkeX5lSCiSK6ADSh/AbwpcdKZpwnlZ/P4/Y0MoQUkT5CS+Azn6N6BVTgJrB5zeTricz56N1hrO/5vUW3Q2NKP4dZH4/dPi+48T5sni/f2I83LCspyxLG4QM5ZlRte1Po9uuq4/DuPO0B1yLiDlGp2iKPyU21aiU2uXkkGpGkoJb4nL3mOYH0E3Utbouhq7XQO949gWW7y8fPPTC32o1wCvIY6eGD0xdIykFF6OY8M5gxAMVVUiSdJPjf8b5EmyUh3cI+H+krZlnq37W1xk/vfxp4BN2WDgFoop/5qoTkP3wwewr4BuHLNxGH25x6HgGkwfkRelfwC+ws4B/gFXCsyHoBFOiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"init\"\n        title=\"init\"\n        src=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n        srcset=\"/blog/static/8b7bf7989faf13dade451e000d201e37/63868/init.png 250w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/0b533/init.png 500w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这创建了一个node的实例并且传递了一系列的参数(v8_thread_pool_size uv_default_loop 后续会对这些参数进行讲解) 最后调用StartNodeInstance开启了node的实例,然后顺着这个方法往下走发现node继续这行了LoadEnvironment()和下面这段代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmElEQVQoz22R227iMBRF+YtpCSQhsZ2LE99iQoBQOmj6/5+0RrhSpen0YWmf87C395E3tajx0RHPgbh4/GwJJ8dpPWKmnuXmmM+GMGviMnL7PRFPPs3LanFRU6kyIfuKTVVVtG1H23RIoRC1RIqGRikaJRh0g7WaQXeM4yezM1y8YXEj12Dxg0ZJRbbN2MhacD1feH9/436/8XisfHy8sa5HrutMCCPGarR+8gx/hvZpb5oGY0aC97Rty36/Z1MWJZdz4PHnwvV65BgNMfpkMMYyDCN5XqTXs2xHtt2RZVlit/t3zvP88+TyUFDJA/t8z6+XF16320S227LbZxRlTl7kSYuyoCjLZP5OaqiUYL1HjufAss4s68Tl7jldHPEUUJ1E9QLRVMiuTnslqmT+KXQjhCBOE8F/Yo2jazumEPAuMA6Wvu2wpqfvNc46pJDJXBTFf2zKQ4nqJY1WNMNTJbITiUYLulHSGYVsBVJUHA6HH5t9NazrCucdU5ywzuK8ZTQjve4xbiRMOv2yMZppGlBKfZ371O/8BY6zCINLY+oYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"exec\"\n        title=\"exec\"\n        src=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png\"\n        srcset=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/63868/execNode.png 250w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/0b533/execNode.png 500w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png 1000w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这段代码拿到lib/internal/bootstrap_node.js文件,将它编译解析并且转换成C++的函数最后执行。在lib/internal/bootstrap_node.js中其实就是一个匿名函数<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADBElEQVQ4y52U247bNhRF/RuJdaMkSryKulu+jO2ZuE3TvhT9/39ZhRV7ggkCFOjD1qEAYktrn0NuqlLSeY91Gjf1+MOC2020y4hpFKLMEGVCLhMKmRJtt0RRRBzHJEnyXp/aZGVFNR5pTm8080J/ONKeLoy3v+iWmet15HDes5vHVbVxlEXxS7PVUBQlOoyopke3A9Y5pDLodsR7RRsMJvSoZqD2HaZp0br+bpj8MHyab1JRkEqHChO6nZDKYoY9bn5B9Qest4yDwSrJqEqsLEjT7B07juIP+Js0u2ckyCvxyCtdVdSCLE/fJWRGIcWqUufr+33/fd+HPywyQRM62ssXmt2B7uVCd/nC8HYjHK+E3R7fNmscrg2r4d3s+aFcZj8hJzG5GZDtCeVa+tON/vqN+es/hN2Jy3ngeBgYrKaxlih6YiarogfyB8PCT9TDET8vDK9f2f3xN/3lhh8Xltcby+0bflgYx0DXGZwq6VVBWxfMtqbVFZWUjwzTlLyqkc6g+4Cd7h3XqNCRS0VdlTinMKYmBI31nsoFKutRLmCMJkvTH2OTpglCd6jhSDhcafdnwjhx/e3C8brnfB6YDgfm6xvLaWFsG8ZxRvmOQjtqVT/QoydygrQGN/fooLBjS7MfCYcdzRLwTU3fe3TTkusGpSTBVxhZUGcJeZqsgy6EeCCvhhbdt1RWrcMrTUCFkbI2aFXRd47aWIraonS9RqBKiSpyylxQ/GyoQqBZJtzQEE5nXOdY9h437fDzRCYSkmxLJrZE8ZY4jUjyiG30/VxHa92u6GuGubJUQ4scHfUc8NOE7nu0t/hlwc076qYhHF/QbYcd75Gc1uNZGY+oHMY1a3M294fpF9zhjWbsmI8TTdeTiZIsu5+eilzWJGm2dj0vK0Qu17UoJFlekGY5eVE+LgchEGlCsv1EGkfE289sP396INyHePu+jh6I8QMzfqzj+FljNmUpWE49tz9vvFwXTq9XjA/co/jV9fRf2lhl+P10w40H8tpQNQPKtwiR/S/DfwGj6A9fBUsu3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runCode\"\n        title=\"runCode\"\n        src=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png\"\n        srcset=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/63868/runOurJs.png 250w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/0b533/runOurJs.png 500w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png 1000w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png 1058w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里面先做一些挂载的操作(例如给js调用C++代码的挂载), 然后从命令行中获取到文件的名字并且读取文件进行warp,这个函数会被上面提到的位置去执行,这样node就加载并且执行了传入的server.js文件。</p>\n<h2>http.createServer()如何对网络请求提供服务</h2>\n<p>通过对上面代码的理解,node对网络请求提供服务其实是通过lib下的基础模块调用C++模块的代码来实现的,下面跟着http.createServer()来梳理下这个流程\nhttp.createServer(requestListener),它通过调用_http_server.js下的Server(requestListener)方法创建了一个net.Server(继承EventEmitter)并且将传入的构造函数绑定到request事件同时绑定了connection事件<br>\n上面的代码部分主要完成了一个server的创建.最后调用listen()方法的时候才能监听器对应的端口来对外提供服务.server.listen([port],[host],[backlog],[callback])其实调用的是net.Server的listen方法.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 895px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVQoz12Ry27bMAAE/R2NKPH9EEVKtBXbcdQmaeuc+/8/M0WMoKhzWOxtMNjdDcOAdZrDmpn3jTgf8ClRz9+Zt9+4OOK8xTtNLDPT44WyXrDWIISg7/t//ZGdUorRjyST8NphfELFivQTMUVicBjrkL6g4ox0GWstD113A32F7qSSjGGkhILXhtA20vYHt38hn35Sjm8sx43ltFHXjWU58LQUWnQEa2/wO0MpJZ3oEFLQdd/Q0x6/vqFiIZ7fcY9XyvHCus7MS+UwOq7HyuOcyVNGyuEeOAwSFwxln6gtUFogtcq0JlyWSPWAsgPK92gn6GWH8hIdFL4YpPkCFKKntcz79YkfrxdOL6/Mz7/I7YxPE6G02wEhV1I7MS4rxhhE97Fff0vfi8/+NNRakbMnpISJmUEZBu2xccTnijEalzKh7om1obW+s/rf8C9CdsvY254TIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen\"\n        title=\"listen\"\n        src=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n        srcset=\"/blog/static/ed775f0f74eb21887b354475a2e11427/63868/listen.png 250w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/0b533/listen.png 500w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png 895w\"\n        sizes=\"(max-width: 895px) 100vw, 895px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在net.Server的方法中主要对参数进行了判断,例如是否存在IP,port以及是否传出handle,通常的调用方法都是server.listen(port,callback) 这样会在特定的端口监听来自IPV4或者\u001cIPV6的网络请求,在listening事件触发的时候响应callback.下面在继续跟进listen方法.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVQoz5WS246bMBRF8xmTcLExBgMGnAAhhHQ6N0XtSJXax/7/j6wKMmmbTKRpH7bOkeWztbyPF3GSUjQDtukpMoN1DbYbKVyLlPIkIRAiJAxDhBBzDeeztz4815BFJCPSWJNaR5xXxIkhLdfEccy6NlQ2odAKZzQm0YRhQBD4BEFwU4tYKkxmyZseWzvc7oBtBxKTka9binYgL2uUUicqGSGEfJOYTc50M+H0nLo9MI4jPx8zjk8D7v5I2Wwpmh1lt8ftH7DdnqzaUEzRbHpM6UhNhu/7l4YqVmQqxeqMwFuxvLtjtVzOF33fI/C9uT+TXBBd0Z0MVYzUCVJF1HWJcyW5tajEEEXyYvhWZufzP0tRiu7lG/3LK8+vXzl+/0G3P6B0Om/3muBa7zKcgq36T1S7zxT9PTqv0HmJzibK9N3AR5oN3eGZ9uELxbohyS2m3mCqDUlWzF/kvwynnKrtSL0dkMLH91Z/yfv9rH8lXURSopOUKcvrL3Aro48MfwFwaTboCCOYlAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen2\"\n        title=\"listen2\"\n        src=\"/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png\"\n        srcset=\"/blog/static/5940d58735192e92131a71aab4c797d5/63868/listen2.png 250w,\n/blog/static/5940d58735192e92131a71aab4c797d5/0b533/listen2.png 500w,\n/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png 1000w,\n/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png 1116w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n继续跟进_listen2方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.39999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVRIx41VSXLjRhDkMzwigN53NDYCILhqGStCHvsL/v8z0tHNkUYaUbIOFQAOncjKyspe2bFFt5vxcNjix3nG7ejx748Ju7GB6g6w/R6buyf0pz9RjzvE+YTu8ID++B2+m2CbAX7YwtQtlDFYacURG4uNrXAKBYxREHUL6Tx0cFDWwsSYSzl/eXoPaRQYJyjLNYr1GmVR5FoRTkAVAXUca8NBDINwBMJTiMDALYVwFNwSSEehArtUzWEaCek4yrJCVV1qpbjEME2Iw4iH8w63uxHBaSjJ4LWElhxWCzgtwThDRSoQSnI9vyegsiwvgFpp3B8OmIceT02Fp44iaAmvBHqnEY1CNBLBKFBK88Fr9Qy6Yoxh6CNisLgPJe5qAiP5C2jnNIQQWCeNfh68Vi8MCWUgykO5GkwaEBVQlQWK9Q2KoshAN+sCxRtGFapXzF7XKrWhhYJretimRwgB0jUQNsKkSUuBxipYnabKfzH6gOmKEgLjasT5gGEecTxOmHdbLIctlv2UWx/6DZphA+M9XN1c2H0ESCiFoAxCaFTSg+oArgwEo2i1yAwrQrFOXntuufqflhnjGB/+Rnt8ROxnTG1EbTUUZ0gdEELeHvyMYQLkXKCdT2i2R7h2QPQ2MyuK97b4aMqvAAmkVNifntAvZ0idTC1RVeQNwFfAXgC5EKi3J8TlDN9P8N4h+fMrIOVv7a845xfjfvsD65tvKIp19t9X2Fxjv2KUIe2z8jWUNmDSgnKZQfPfiyL/5DlNytfvV/TNPtSuzq12bcB22WAzthiGGt0QEcZ9zjxTd9ChydnnhyUPz4aYXVCWxatdTpsiDYTrIHwLG9us4RA0pmhgnYWQAnlFqwpJomQzJiQoY0g+Jj9D44WhtBFh94A47THNHU63W5zujjjfHbA7LuiGHmGz5C0ZnIaRAi6ldLysq3EhS3DZFELgXcQy3SF4B+8EfLDQsYcKLZSPIMJCGA/t66vTfxNfydRcubxuyjcgLH3bLP4lcdY5fZ6/Xx++lomrZBnCVQbJEZZspA2qqrzE181Nrgz8icl/aSgMuPYwSYvYIQxb1Jsl69P0G5wff+D8+BeGeXnR6dNNYTpANzPa4wO6/T26w32+Hk07QxubB5EqefSjzXljbMIlmHb5vrCGo20sqPSQrobtRgjtYLsJ2vk3Zr52n1w0ZBI2tDA+QAqWbzbKOLiU4FLkPU+eS9omH1YpzijL4UEIfc+QMwHTLQj9iH7TY7ttcdx3mOcWm01A0zUQ2sJJhsZIaJ+2ZwcdInw3vrPRijAGUU+ol1uM3/9BN24wzNuckcVvN135TrP3OfkfVOAewXaWNUwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"handle\"\n        title=\"handle\"\n        src=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png\"\n        srcset=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/63868/handle.png 250w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/0b533/handle.png 500w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png 1000w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png 1171w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在这个方法中主要创建了一个server的handle并且绑定在之前传入的port并且在这个handle上添加onconnection的监听函数并且在nextTick的时候触发listening事件.createServerHandle其实做的是调用的C++层的接口,创建了一个TCP实例,并且将它监听到IPV4或者IPV6端口。node处理网络请求实际是通过触发这个handle的connection事件实现的\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 944px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVQ4y4WUWXMaRxSF+RMJzAKzz3TPwizAsAmQwUJCyJJdseUtdvkhVXlO5Q/kn3+paWwsx0J5uNXT25nb59x7Wp7M8fM5opxyv+nz+SLm41rychkjspJAxKT1GcXZhny+Js1LbMui2+3S6/V+ipbt+vj5jHJ1yWDxjHxYUy4uyQZjoqzAdhx10LJsepb19WKXbrf3OKBlOziBJIhT/CAgSjLivERkBSKvsG1bZfPfaEC/gTzMtuU4NotlxbCQ3BVdPtY93g90bssevueqw5b1eDYP4xtoy7EdfMcnjBNCz8XtGThNWCam2UXXDTTNUGMTpqFjdrvoholhNmfMI1gzthzbJkkrqsWaejIgTSRJ6BN4LkKGlGXCYJhRlTF5kREmfbVXyIC+CIki8WOGPauHlBnTasGwLAhDHxl4+K6jvpMkIs2EGmUs8EWM6zjqp8L38Hwf6yiW4tBRB0xNw9B0tE4brdNB1zronQ7tdodOu1nT0Npt9Pavak/TNDRdV9+GutvB0DVaruMSeRGiUTavSAZT4mqMKGpEPiQvCpJyRJhkiHxAOpohqxrRzJMMWQxJBmOS0Yy4rGnZlo2Ufepn14zW1ww3N1TTGfPVjEE9URx5YROReq4vErwoxvUDvCYieViXqVpvWbaFCGPG/Slp3MdyXVV7nmth25ZS0TQMTNM4jI3Kam5+31Nrh1B16Ng9Ou1f0LX2YUM/8Glq+skWOxUt23FxZIG7eYN79QlPpATZCHdQENQVURQdfmIadE3zWCIne7npAlGMGN68J13tyGdrytWO6vme/OwcP4xw/BA3iHA8/wHQCcBe1yRIcsbbOxWT3W/k0xX9yYrybM3g2U6tTa5fUy0vVM09RUOrqcGqnij5D2oluI2qkUCkfcK0IEgygjhTih6ebP5kCkfARvr9/SdW272qv3K5JZAJ9WzB/v4zxWiKrCaq/oJQ4MYVfiiOfD7CoaV8zrLt76NyGBvb9bBth8biLMf56omHc6cN1nGUkfqRVJ3QdEfzfCljGn4f88KH7vIToB+E3P/5F7e//0F1fqVE6A/H1OsdIklVuXx7xY+XT2Toeh7bV+9Ybm8IkgJRjnE9n7A/xAslhq5jGIYyCl3Xnszu6NhVFVMWUnlfWcTUoz5lGTOblQwGKePJiMXFnsniHOsJsCPg9W7O7e2SzWbMze2KF7cr9i+WvH235XI74uWbO778/Q83r99jW/8D2IiyuTxne7Xg8nLOcl6xez5lvRxxdTHh+e6CVx/ecffhC9uX98g4VryeBGxEabhLs4Q0FUjfpR/5ZKGPb/eo5muW+zcImXzlsPckh/8C/oPY8Ao+dPAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"connection\"\n        title=\"connection\"\n        src=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n        srcset=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/63868/connection.png 250w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/0b533/connection.png 500w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png 944w\"\n        sizes=\"(max-width: 944px) 100vw, 944px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上面的代码中,底层的C++代码会在connetion的时候传入clientHandle,然后node会创建一个Socket实例并且在通过connection事件将这个Socket实例传入对应的回调函数。这样就用回到了lib/_http_server.js中对connection的监听函数中<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fed65a33502990495432004fc0039796/d0143/request.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB70lEQVQ4y32S2XLjIBRE5zOSCIRYBUKLLTlWvMUz8///dKakJK5yypmHBl5oDt33l1KKqqqwlaHdvDIc35nngctx5Hrccn7bMvcNb0NmHrfM24GubYlNpI41QgjKsrzp183QWjbDzOu0p8mB2lpab+mCo/UaYwyu6fBNR4gJURRIKVeTZf863wwX9bsTp8uZy2XkvBCeJoa+RbmAdh7rHLIoEKK4o/oyuzM0RuNyT+47NkOirQO7XBOMJuQel1rq3FGWCik/qYS8o7wZaq0Z8sAubdDG8VIIlFYIpVC6opQCXUq0FJhSrqqUWmNYYB4SLqX004Hp8ofjYcv7aeLvaeT3ceS4aXnfZg7jwDxNzLuJ9rMYt8Tw0NBatv3MbtyTkiM6y5ACXe3J3hKtRluPjRmXMsa6teGHX/4qpR0PnK8nrtdXDseRfuqxwfNcFBRLXkKs7Yri5W5cfiQ0dSJ3DW1OVOo+m0f6TrcaLsuSQwo1pZA8PT3z/FKsxQgpP2hWFcj1kvzvA6uh955pujDv9/RdJHvHNgWcNR+D3HTUKVN+DvBPuhF65/ExE2JcmwvWkGuLXWYzRlwd8XWNUiXlN6nqQzfCJcMUEmPosa5BNxPaGnSsMKHCpWVXuEZjo8bWGpfMeja+wrcWnw2VUavhP+s9cWr9hXq5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"request\"\n        title=\"request\"\n        src=\"/blog/static/fed65a33502990495432004fc0039796/00d43/request.png\"\n        srcset=\"/blog/static/fed65a33502990495432004fc0039796/63868/request.png 250w,\n/blog/static/fed65a33502990495432004fc0039796/0b533/request.png 500w,\n/blog/static/fed65a33502990495432004fc0039796/00d43/request.png 1000w,\n/blog/static/fed65a33502990495432004fc0039796/d0143/request.png 1025w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个方法主要对之前创建的Socket进行一些解析处理和方法绑定最后将生成的req,res通过request事件传入到回调函数中.这样就回到了http.createServer(requsestListener)中来完成特定业务的处理</p>\n<h2>总结</h2>\n<p>从以上的两部分，主要从两方面来整理了下node启动和执行服务代码,node如何处理网络请求，但是node中还有很多有意思的东西还没有说清和弄明白.例如backlog 事件循环 v8_thread_pool_size(node的线程池)等等.</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":15,"pageCount":16,"additionalContext":{"pageAllCount":94}}},
    "staticQueryHashes": []}