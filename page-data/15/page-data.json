{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/15",
    "result": {"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"388dd88f-e3aa-5377-9812-6a8076d6dc92","html":"<h2>简介</h2>\n<p>在实际的工作中，发现自己对网络这方面的知识有些欠缺并且作为一个web开发者有必要了解网络中数据传输的基本过程，在阅读计算机网络自顶向下方法中把网络层的基础知识整理如下。主要分为三个方面网络层的基础，IP(网际协议)，相关协议简介来简单的学习下网络层。</p>\n<h2>基础</h2>\n<ul>\n<li>网络层提供的通信机制是多个协议族共同运行的结果。主要有以下三个组件：IP协议,路由选择协议,ICMP协议</li>\n<li>网络层提供的主要功能是提供分组的转发并且结合路由算法实现路由功能，也就是最终实现主机间的通信。运输层提供了主机上进程之间的通信。</li>\n<li>因特网的网络层提供的服务是一种尽力而为的服务，这样做能简化网络层的行为.当上层的服务需要对应的功能(例如运输层需要保证数据的按序接收等)时候，通过它自己去实现.</li>\n<li>网络层的有连接服务和无连接服务\r\n提供有连接服务和无连接服务的网络层形成了不同的网络体系。仅提供有连接服务计算机网络称为虚电路网络(ATM,帧中继)。仅提供无连接服务的网络称为数据报网络。</li>\n</ul>\n<h2>虚电路网络和数据报网络</h2>\n<h3>虚电路网络</h3>\n<ul>\n<li>连接建立 虚电路网络需要在路由器上维持连接信息，在虚电路建立阶段,需要在建立的路径上的路由器之间维持连接状态信息(对应连接的路径)，当连接建立后，这些路径信息存储在路由器的转发表中</li>\n<li>数据发送  发送对应的数据</li>\n<li>虚电路拆除 发送方通知网路层终止虚电路,在网络的路由器上就删除对应的路径信息</li>\n</ul>\n<h3>数据报网络</h3>\n<p>因特网是一种数据报网络，这种网络体系结构在发送数据的时候需要将目的端系统地址推进到网络中,通过逐个路由器的转发最终到达目的主机</p>\n<h2>网际协议</h2>\n<p>网际协议(IP)现在主要有两个版本：IPv4和IPv6<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 573px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABE0lEQVQY021Q2Y6DMAzk/39tW4ntwQIthENFCkkDCWlwnYNVG/Vpd2SNLM9Ylicp8nKa5uF2I6QxxsC6pml6znK0VmuN+HwXPh76cDiKafbeAwAizvOcMMalVFLKcRwpHZ1znHEhhPdeKTWOLFqfAH3XE9JM02StRUQpZbJtm3Nu28KyLPlPDgAhBO/8e1kWRTnNs7U2HjydzpSOIQRrrVIqqaqqKMq6rhm/L1pzxi7Xqm07pRSlVEoJAMMw7Hb78nKta8L4HQDWdRVCJMaYxwda68gAKyHN7mvftB0AxPlL+niMMZzzxDlnP0CMjN77vu2+0wNpWu89RuEtxdY59/r5FcYfAKxd12dZVtUEnv8gpv0LtNCK129tzhMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"数据报格式\"\n        title=\"数据报格式\"\n        src=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n        srcset=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/63868/IPv4.png 250w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/0b533/IPv4.png 500w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png 573w\"\n        sizes=\"(max-width: 573px) 100vw, 573px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>字段解释</h3>\n<ul>\n<li>版本号 \b指示当前数据报使用的\bIP协议版本</li>\n<li>首部长度  数据报长度  IP数据报可以提供可变数量的选项，可以通过这两个字段来确定数据报的首部和数据的长度</li>\n<li>标识、标志、片偏移  在\b数据报传输给链路层的时候，由于不同链路层协议的\b产生的链路层帧不同，通过这三个字段来完成数据报的分片与重组</li>\n<li>生存时间(TTL) 保证一个分组不会在网络之前循环的转发，数据报信息每通过一次路由TTL字段减1.为0的时候必须丢弃改该数据报。</li>\n<li>协议  与运输层的那种协议传输数据(TCP/UDP)</li>\n<li>首部校验和  每次到达路由器的时候，路由器都会对数据报的IP首部进行校验，丢弃出错的分组信息</li>\n<li>源IP地址和目的IP地址  实现主机间的通信</li>\n<li>数据  承载上层协议的数据(TCP/UDP(应用层 HTTP SMTP) ICMP )</li>\n</ul>\n<h2>网络编址</h2>\n<h3>IP地址</h3>\n<p>IP地址可以对应理解成主机与物理链路的接口，在每个子网中，子网中的主机的网络前缀相同为X,后面的32-X位决定该子网具体\b能容纳下多少台主机</p>\n<h4>地址获取(DHCP)</h4>\n<p>在一个子网中，需要为每个主机分配IP地址来实现通信，这个的通常实现是通过DHCP\b协议(也可以通过\b静态的配置)，通过DHCP获取IP地址主要有以下四个阶段</p>\n<ol>\n<li>新连接的主机广播DHCP发现报文</li>\n<li>DHCP 服务器收到发现报文，广播DHCP提供报文(在\b子网中存在多个DHCP服务器)</li>\n<li>\b主机根据DHCP提供报文发送对应的DHCP响应报文，将之前DHCP的\b提供报文的数据回显</li>\n<li>DHCP ACk DHCP服务器确定\b请求，主机可以进行通信.</li>\n</ol>\n<h4>地址转换(NAT)</h4>\n<p>NAT是一种地址管理策略的实现。他通过在NAT路由器中维护NAT转换表来实现对外界统一请求的转发和请求到外界的转发。\r\n实现 子网中的主机通过端口A连接NAT路由器，NAT在收到数据包的时候\b创建一个新的端口B并将数据的源端口改为B，IP地址改为改子网对外的统一IP地址,外部服务收到对应的报文，\b响应报文到NAT路由器，NAT路由器查找NAT\b转换表找到刚才转换的端口A和初始的请求主机IP地址将响应报文发送对请求的主机</p>\n<h2>相关协议简介</h2>\n<h3>因特网控制报文协议(ICMP)</h3>\n<p>ICMP用于主机与路由器之间沟通网络层信息，ICMP是运行在IP协议层之上的，也就是IP数据报的数据部分是包括ICMP的数据报文的内容的(跟IP承载TCP/UDP报文一样)</p>\n<h2>理解路由</h2>\n<ol>\n<li>当主机想发送一个IP数据报的时候,它会查看自己的路由表。如果目的IP地址就是在本地网络，就直接将数据进行封装发送给目的主机.如果目的IP地址\b不在本局域网中,数据被封装然后发送给路由器(此时\b在数据链路层的帧的目的地址是路由器的物理地址,IP报头的目的IP仍然为原来的目的IP地址).</li>\n<li>路由器接收到对应的数据\b传递给网络层,如果目的IP是自身则自己处理这个数据\b(用于更新路由表等)否则查询路由表将数据进行转发。</li>\n</ol>\n<h2>基础词汇解释</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>丢包</td>\n<td>在路由器中存在着缓存结构来缓存需要发送或者接受待转发的分组.<br>当这个缓存过大超出其内存空间的时候，路由器就会丢弃该分组，造成丢包</td>\n</tr>\n<tr>\n<td>IP数据报分片</td>\n<td>由于不同数据链路层所能承载的最大传输数据单元(MTU)不同.IP数据报在数据链路层会被进行分片和重组</td>\n</tr>\n<tr>\n<td>CIDR 无类别域间路由</td>\n<td>它通过扩展IP的网络位数来实现将一个IP\b地址对应成多个IP地址的行为</td>\n</tr>\n<tr>\n<td>ARP 地址解析协议</td>\n<td>在数据链路层提供将网络层的IP地址转换为物理地址</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null}}},{"node":{"id":"69a19dd0-548e-5c44-b271-3e7260f53247","html":"<h2>简介</h2>\n<p>node中的Stream模块在很多基础的模块都有使用下面就从官网的文档和源码上学习下Steam模块的基础知识</p>\n<h2>基础</h2>\n<ol>\n<li>node.js 中有四种形式的流 可读(Readable)  可写(Writable)  可读可写(Duplex)   转换流(Transform)</li>\n<li>流在内部维护了一个链表来完成缓存数据的读取,流继承了EventEmitter,通过事件的监听来完成数据的获取</li>\n<li>在进行流的初始化的时候通过设置highWaterMark来控制缓存区的大小 当读写速度出现差异，存储的数据到达highWaterMark的时候，就会出现背压。这样读写流就会停止读或者写入</li>\n</ol>\n<h2>可写流</h2>\n<p>可写流是可以写入数据的目的地的抽象</p>\n<h3>事件</h3>\n<p>drain  stream.write(chunk) 会返回true false来通知当前流是否可写。当它返回false的时候  当前流再次可用的时候 会触发drain事件<br>\nerror  读写数据出现error的时候会触发这个事件 但是不会关掉流<br>\nfinish  在stream.end(chunk,encoding,callback)的时候在数据发送完毕后会触发finish事件，传入的callback作为监听函数</p>\n<h3>方法</h3>\n<p>writable.cork()/writable.uncork()\r\nbuffer缓存和清除缓存 调用的次数必须一致,在使用writable.uncork()的时候 推荐使用process.nextTick()<br>\nwritable.write(chunk,encoding,callback)  返回的true /false 通知当前是否可写\r\n结合drain事件来完成持续的写入(即使return false 仍然能完成数据的写入造成内存的占用 给垃圾回收造成压力)<br>\nwritable.destory(error) 关掉这个流<br>\nwritable.end(chunk,encoding,callback) 通知不会在有其他的写入,callback会变成finish事件的回调函数</p>\n<h2>可读流</h2>\n<p>可读流是可以被消耗的数据源的抽象\r\n可读流有两种状态: flowing paused</p>\n<ol>\n<li>在flowing状态下通过对data事件的监听获取数据。</li>\n<li>在paused状态下通过对_read(size)方法的调用来完成数据的读取.</li>\n</ol>\n<p>在node的lib/_stream_readable.js中,在构造函数中会通过传入的options来初始化流的状态</p>\n<pre><code>  this.buffer = new BufferList(); //  链表 \r\n  this.length = 0;  // 存储的长度\r\n  this.pipes = null;  //  pipe 数组 目的地 (初始的时候是null) \r\n  this.pipesCount = 0; // pipe 长度\r\n  this.flowing = null;  //  state  null true false (flowing paused) \r\n  this.ended = false;   \r\n  this.endEmitted = false; // 是否发送end事件\r\n  this.reading = false;   // 是否正在读取  \n</code></pre>\n<p>在上面的代码中this.flowing就是控制stream的状态是否是flowing或者paused 通过pipe unpipe 或者data事件的监听能切换状态 (当this.flowing为false的时候通过data事件的监听不会造成this.flowing变成true 必须调用stream.resume())\r\n在实现可读流的时候,需要实现_read(size)方法触发底层数据的读取.可以使用size(size会根据背压动态变化)来完成读取的流量控制</p>\n<h3>事件</h3>\n<p>data  当流准备发送数据的时候会触发data事件( 切换成flowing 或者read() 方法的调用)\r\nend 当可读流的数据都被消费后会触发end事件 通知无数据可读取\r\nreadable  通知当前有数据可以读取或者流数据的结尾会触发 通过监听readable然后通过read事件来完成数据的读取</p>\n<h3>方法</h3>\n<p>readable.isPaused() 返回流当前的状态(对应上面的this.flowing)<br>\nreadable.pause() 切换this.flowing = false<br>\nreadable.pipe(dest)<br>\n(1)可以一个src多个dest(对应上面代码的this.pipes)<br>\n(2)返回dest支持链式调用  a.pipe(a).pipe(b)<br>\n(3)背压的控制 通过在src上注册drain事件并且在write的时候根据dest的状态来写入完成背压的控制</p>\n<pre><code>    src.on('data', ondata);\r\n    function ondata(chunk) {\r\n      increasedAwaitDrain = false;\r\n      var ret = dest.write(chunk);\r\n        if (false === ret &#x26;&#x26; !increasedAwaitDrain) {\r\n          // If the user unpiped during `dest.write()`, it is possible\r\n          // to get stuck in a permanently paused state if that write\r\n          // also returned false.\r\n          // => Check whether `dest` is still a piping destination.\r\n          if (((state.pipesCount === 1 &#x26;&#x26; state.pipes === dest) ||\r\n               (state.pipesCount > 1 &#x26;&#x26; state.pipes.indexOf(dest) !== -1)) &#x26;&#x26;\r\n              !cleanedUp) {\r\n            debug('false write response, pause', src._readableState.awaitDrain);\r\n            src._readableState.awaitDrain++;\r\n            increasedAwaitDrain = true;\r\n          }\r\n          src.pause();\r\n      }\r\n    }\n</code></pre>\n<p>当src接受到drain事件后会触发drain事件的监听函数重新完成数据的写入</p>\n<pre><code>//  pipe  end flag\r\nfunction pipeOnDrain(src) {\r\n  return function() {\r\n    var state = src._readableState;\r\n    debug('pipeOnDrain', state.awaitDrain);\r\n    if (state.awaitDrain)\r\n      state.awaitDrain--;\r\n    if (state.awaitDrain === 0 &#x26;&#x26; EE.listenerCount(src, 'data')) {\r\n      state.flowing = true;\r\n      flow(src);\r\n    }\r\n  };\r\n}\n</code></pre>\n<h3>实现一个可读流</h3>\n<pre><code>const { Readable } = require('stream');\r\n// Stream 实现\r\nclass MyReadable extends Readable {\r\n  constructor(dataSource, options) {\r\n    super(options);\r\n    this.dataSource = dataSource;\r\n  }\r\n  // 继承了 Readable 的类必须实现这个函数\r\n  // 触发系统底层对流的读取\r\n  _read() {\r\n    const data = this.dataSource.makeData();\r\n    this.push(data);\r\n  }\r\n}\r\n// 模拟资源池\r\nconst dataSource = {\r\n  data: ['1','2','3','4','5','6','7','8'],\r\n  // 每次读取时 pop 一个数据\r\n  makeData() {\r\n    if (!dataSource.data.length) return null;\r\n    return dataSource.data.pop();\r\n  }\r\n};\r\nconst myReadable = new MyReadable(dataSource);\r\nmyReadable.setEncoding('utf8');\r\nmyReadable.on('data', (chunk) => {\r\n  console.log(chunk);\r\n});\n</code></pre>\n<h4>从源码上理解上面的例子</h4>\n<p>通过data事件的监听</p>\n<pre><code>    Readable.prototype.on = function(ev, fn) {\r\n        const res = Stream.prototype.on.call(this, ev, fn);\r\n\r\n        if (ev === 'data') {\r\n        if (this._readableState.flowing !== false)\r\n          this.resume();\r\n        } else if (ev === 'readable') {\r\n        const state = this._readableState;\r\n        if (!state.endEmitted &#x26;&#x26; !state.readableListening) {\r\n          state.readableListening = state.needReadable = true;\r\n          state.emittedReadable = false;\r\n          if (!state.reading) {\r\n            process.nextTick(nReadingNextTick, this);\r\n          } else if (state.length) {\r\n            emitReadable(this, state);\r\n          }\r\n        }\r\n      }\r\n      return res;\r\n    };\n</code></pre>\n<p>当注册data事件的时候,会调用this.resume() 最后调用flow(stream) 来完成数据的持续读取</p>\n<pre><code>    function flow(stream) {\r\n      const state = stream._readableState;\r\n      debug('flow', state.flowing);\r\n      while (state.flowing &#x26;&#x26; stream.read() !== null);\r\n    }  \r\n    \n</code></pre>\n<h2>总结</h2>\n<p>上面就简单的介绍了下node中stream模块的基础知识,通过对流模块的学习能更好的帮助我们理解node中数据的发送处理过程,也可以尝试着去阅读一些简单的模块(send)来加深对Stream的理解.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903588649500679\">Node.js可读流和可写流</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null}}},{"node":{"id":"8597ed7d-d8ac-5f0e-86d4-ac66e2f71e30","html":"<h2>简介</h2>\n<p>koa利用生成器来解决回调函数的嵌套问题，实现的十分巧妙，下面跟着官网的例子逐步学习下koa的实现原理<br>\n官网 <a href=\"http://koa.bootcss.com/\">koa</a></p>\n<h2>使用</h2>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n});\r\napp.listen(8080);  \n</code></pre>\n<p>这个例子很像在Node中构建HTTP服务器的例子</p>\n<pre><code>var http = require('http');\r\nhttp.createServer(function(req,res){\r\n    res.writeHead(200,{'Content-Type':'text/plain'});\r\n    res.end('hello world');  \r\n}).listen(8080);  \n</code></pre>\n<p>通过app.use()设定中间件 app.listen()监听特定的端口这样整个web服务器就启动了 那我们的关注点就到了这句话 var app = koa();<br>\nkoa的源码lib下有四个文件 application.js context.js request.js response.js  在koa的package.json中main属性的值指向的是lib/application.js 也就是整个web服务器的生成过程都在这个js中 下面我们逐步的解读下application.js的部分源码</p>\n<pre><code>module.exports = Application;\r\nfunction Application() {\r\n    if (!(this instanceof Application)) return new Application;//确保不通过new调用构造函数的时候返回正确的值\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.subdomainOffset = 2;\r\n    this.middleware = [];//保存中间件的数组\r\n    this.proxy = false;\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);//通过指定的原型创建对象\r\n }  \n</code></pre>\n<p>通过上面这段代码，也就是在调用这句话的时候 var app = koa()实际上就是生成了一个Application实例 在实例上有一个数组用于保存中间件 三个属性 context request response</p>\n<pre><code>var app = Application.prototype;\r\napp.listen = function(){\r\n    debug('listen');\r\n    var server = http.createServer(this.callback());//this.callback()就是请求来的处理函数\r\n    return server.listen.apply(server, arguments);  \r\n    //这里上文中Node构建HTTP服务的例子 似曾相识 \r\n};  \n</code></pre>\n<p>在http.createServer(this.callback())中this.callback()就是请求来的处理函数也就是app.callback()这个函数 正是这个函数实现了koa的中间件机制</p>\n<h2>中间件</h2>\n<p>在介绍中间件的原理之前 先上一个例子</p>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(next){\r\n    console.log(1);\r\n    yield next;\r\n    console.log(2);\r\n});\r\napp.use(function *(next){\r\n    console.log(3);\r\n    yield next;\r\n    console.log(4);\r\n});\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n})；\r\napp.listen(3000);  \n</code></pre>\n<p>当对服务器发送一个请求的时候  会发现服务器的控制台log出的顺序是 1 3 4 2 下面我们来看一下这个神秘的app.callback()函数到底做了什么</p>\n<pre><code>app.use = function(fn){\r\n    if (!this.experimental) {\r\n      // es7 async functions are not allowed,\r\n      // so we have to make sure that `fn` is a generator function\r\n      assert(fn &#x26;&#x26; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);//将每次调用的生成器函数push到中间件数组\r\n    return this;//可以实现链式调用\r\n}; \n</code></pre>\n<p>app.use()就是收集所有设定的中间件，然后存储到数组中</p>\n<pre><code>app.callback = function(){\r\n  var fn = this.experimental\r\n    ? compose_es7(this.middleware)\r\n    : co.wrap(compose(this.middleware));\r\n  var self = this;  \r\n  return function handleRequest(req, res){\r\n    res.statusCode = 404;\r\n    var ctx = self.createContext(req, res);\r\n    onFinished(res, ctx.onerror);\r\n    fn.call(ctx).then(function handleResponse() {\r\n      respond.call(ctx);\r\n    }).catch(ctx.onerror);\r\n  }\r\n};  \n</code></pre>\n<p>app.callback()中的返回值 function handleRequest(req,res){}就是请求来的时候的处理函数 在这个处理函数中调用fn进行事件的处理 fn是什么呢？  我们只需要搞明白这句话 co.wrap(compose(this.middleware))</p>\n<p>第一步 compose对生成器函数数组进行了处理</p>\n<pre><code>function compose(middleware){\r\n  return function *(next){\r\n    if (!next) next = noop();\r\n    var i = middleware.length;\r\n    while (i--) {\r\n      next = middleware[i].call(this, next);//不断的获取后一个生成器对象 作为参数传入当前的生成器函数并且执行获得生成器对象\r\n    }\r\n    return yield *next;\r\n  }\r\n}\r\nfunction *noop(){}  \n</code></pre>\n<p>其实理解compose的作用要理解好通过app.use(function *(next) {}) 传递的生成器函数传递的next  整个compose的作用就是生成器函数的执行后进行从头到尾的串联 然后返回一个生成器<br>\n接下来就需要理解co的执行流程了</p>\n<h2>co源码解读</h2>\n<p>co是通过生成器避免了多个异步操作的回调嵌套</p>\n<pre><code>function *test() {\r\n  var a = yield readFile1();\r\n  var b = yield readFile2();\r\n}\n</code></pre>\n<p>简单理解co的作用就是首先获取之前执行的结果 保存下来当下次调用generator.next()的时候作为参数传入，这样就实现了异步操作的同步执行</p>\n<pre><code>function co(gen) {\r\n  var ctx = this;\r\n  var args = slice.call(arguments, 1)\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\r\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\r\n    onFulfilled();\r\n\r\n    function onFulfilled(res) {\r\n      var ret;\r\n      try {\r\n        ret = gen.next(res);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n\t}\r\n    function onRejected(err) {\r\n      var ret;\r\n      try {\r\n        ret = gen.throw(err);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n    }\r\n    function next(ret) {  //这里使用promise进行了封装 当之前的异步调用完成后 就会在调用onFullfilled将这次执行结果的返回值传入\r\n      if (ret.done) return resolve(ret.value);\r\n      var value = toPromise.call(ctx, ret.value);\r\n      if (value &#x26;&#x26; isPromise(value)) return value.then(onFulfilled, onRejected);\r\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\r\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\r\n    }\r\n  });\r\n}\n</code></pre>\n<p>通过上面的代码阶段我们就学习了koa的中间件机制 其实ES7的异步函数就是实现的co所做的事</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":true,"index":15,"pageCount":15,"additionalContext":{"pageAllCount":87}}},
    "staticQueryHashes": []}