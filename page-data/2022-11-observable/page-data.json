{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2022-11-observable",
    "result": {"data":{"markdownRemark":{"html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>观察者模式</h2>\n<p>观察者模式(发布订阅模式)是定义对象间一种一对多的依赖关系，使得当每一个被观察方改变状态，则所有依赖于它的观察者都会得到通知并自动更新。</p>\n<pre><code>// 被观察者提供观察者通知逻辑、订阅逻辑\r\nclass Observable {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    // 观察者订阅入口\r\n    subscribe(func) {\r\n        this.observers.push(func);\r\n    }\r\n\r\n    unsubscribe(func) {\r\n        this.observers = this.observers.filter(observer => observer !== func);\r\n    }\r\n    // 通知观察者\r\n    notify(data) {\r\n        this.observers.forEach(observer => observer(data));\r\n    }\r\n}\r\nfunction logger(data) {\r\n    console.log(data)\r\n}\r\nconst observable = new Observable() \r\n// 订阅操作\r\nobservable.subscribe(logger);\r\n// 通知操作\r\nobservable.notify('this is a test!')\n</code></pre>\n<p>观察者模式的优点是可以做到逻辑的分离，做到单一职责。缺点是当观察者数目较多的时候会有性能的问题</p>\n<h2>Mixin模式</h2>\n<p>Mixin模式可以在不通过继承的方式实现为类(对象)增加复用的能力。当你需要将一个特定的feature添加到不同的类或者为类提供可插拔能力的时候可以考虑Mixin模式。</p>\n<pre><code>// 基础类 只有name能力\r\nclass Dog {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n}\r\n// mixin方法 可以为基础类提供复用的能力\r\nconst dogFunctionality = {\r\n    bark: () => console.log(\"Woof!\"),\r\n    wagTail: () => console.log(\"Wagging my tail!\"),\r\n    play: () => console.log(\"Playing!\")\r\n};\r\n// 通过方法的拷贝 在Dog的原型上就有了对象的方法\r\nObject.assign(Dog.prototype, dogFunctionality);\r\nconst pet1 = new Dog(\"Daisy\");\r\npet1.bark(); // Woof!\n</code></pre>\n<p>可以在mixin函数中通过指定__proto__实现mixin的继承能力</p>\n<pre><code>const sayMixin = {\r\n    say(phrase) {\r\n        alert(phrase);\r\n    }\r\n};\r\nconst sayHiMixin = {\r\n    // 设置原型 实现mixin的继承\r\n    __proto__: sayMixin, // (可以在这儿使用 Object.setPrototypeOf 来设置原型)\r\n    sayHi() {\r\n        // 调用父类方法\r\n        super.say(`Hello ${this.name}`); // (*)\r\n    },\r\n    sayBye() {\r\n        super.say(`Bye ${this.name}`); // (*)\r\n    }\r\n};\r\nclass User {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n}\r\n// 拷贝方法\r\nObject.assign(User.prototype, sayHiMixin);\r\n\r\n// 现在 User 可以打招呼了\r\nnew User(\"Dude\").sayHi(); // Hello Dude!\n</code></pre>\n<p>mixin模式会存在覆盖功能和增加项目代码复杂度的问题</p>","frontmatter":{"date":"2022-11-03","path":"/2022-11-observable","title":"5分钟速读系列-观察者模式/Mixin模式"}}},"pageContext":{"readingTime":"3 min read"}},
    "staticQueryHashes": []}