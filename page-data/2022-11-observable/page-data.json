{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2022-11-observable",
    "result": {"data":{"markdownRemark":{"html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>观察者模式</h2>\n<p>观察者模式(发布订阅模式)是定义对象间一种一对多的依赖关系，使得当每一个被观察方改变状态，则所有依赖于它的观察者都会得到通知并自动更新。</p>\n<pre><code>// 被观察者提供观察者通知逻辑、订阅逻辑\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    // 观察者订阅入口\n    subscribe(func) {\n        this.observers.push(func);\n    }\n\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    // 通知观察者\n    notify(data) {\n        this.observers.forEach(observer => observer(data));\n    }\n}\nfunction logger(data) {\n    console.log(data)\n}\nconst observable = new Observable() \n// 订阅操作\nobservable.subscribe(logger);\n// 通知操作\nobservable.notify('this is a test!')\n</code></pre>\n<p>观察者模式的优点是可以做到逻辑的分离，做到单一职责。缺点是当观察者数目较多的时候会有性能的问题</p>\n<h2>Mixin模式</h2>\n<p>Mixin模式可以在不通过继承的方式实现为类(对象)增加复用的能力。当你需要将一个特定的feature添加到不同的类或者为类提供可插拔能力的时候可以考虑Mixin模式。</p>\n<pre><code>// 基础类 只有name能力\nclass Dog {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// mixin方法 可以为基础类提供复用的能力\nconst dogFunctionality = {\n    bark: () => console.log(\"Woof!\"),\n    wagTail: () => console.log(\"Wagging my tail!\"),\n    play: () => console.log(\"Playing!\")\n};\n// 通过方法的拷贝 在Dog的原型上就有了对象的方法\nObject.assign(Dog.prototype, dogFunctionality);\nconst pet1 = new Dog(\"Daisy\");\npet1.bark(); // Woof!\n</code></pre>\n<p>可以在mixin函数中通过指定__proto__实现mixin的继承能力</p>\n<pre><code>const sayMixin = {\n    say(phrase) {\n        alert(phrase);\n    }\n};\nconst sayHiMixin = {\n    // 设置原型 实现mixin的继承\n    __proto__: sayMixin, // (可以在这儿使用 Object.setPrototypeOf 来设置原型)\n    sayHi() {\n        // 调用父类方法\n        super.say(`Hello ${this.name}`); // (*)\n    },\n    sayBye() {\n        super.say(`Bye ${this.name}`); // (*)\n    }\n};\nclass User {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// 拷贝方法\nObject.assign(User.prototype, sayHiMixin);\n\n// 现在 User 可以打招呼了\nnew User(\"Dude\").sayHi(); // Hello Dude!\n</code></pre>\n<p>mixin模式会存在覆盖功能和增加项目代码复杂度的问题</p>","frontmatter":{"date":"2022-11-03","path":"/2022-11-observable","title":"5分钟速读系列-观察者模式/Mixin模式"}}},"pageContext":{"readingTime":"3 min read"}},
    "staticQueryHashes": []}