{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/rn-gesture",
    "result": {"data":{"markdownRemark":{"html":"<h2>前言</h2>\n<p>在react native开发中通常会使用Touchable<em>组件来实现对用户手势的处理.本篇文章从Touchable</em>组件的基本使用出发,逐步深入到react native中的手势处理的原理.</p>\n<h2>Touchable*组件</h2>\n<h3>基本使用</h3>\n<p>在react native中通常使用一下几种组件来实现点击的处理</p>\n<ol>\n<li>TouchableOpacity</li>\n<li>TouchableHighlight</li>\n<li>TouchableWithoutFeedback</li>\n</ol>\n<p>对于TouchableOpacity的基本使用如下,通过绑定onPress事件就能获取到用户的点击行为进行处理</p>\n<pre><code>    &#x3C;TouchableOpacity\n      style={styles.button}\n      onPress={(evt => { this.onPressEvt(evt)  })}\n    >\n      &#x3C;Text>Press Here&#x3C;/Text>\n    &#x3C;/TouchableOpacity>\n</code></pre>\n<p>在开发中不禁会有这样的疑问,为什么TouchableOpacity能响应用户的手势点击而普通的View组件却不行.这就引出了React Native中的手势处理流程</p>\n<h2>手势处理流程</h2>\n<p>React Native中组件对手势的响应是通过如下的阶段来实现:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 862px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAEWH/2gAIAQEAAT8hVFRU/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAABEAASFR/9oACAEBAAE/EH3VNXZv1f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 手势\"\n        title=\"react native 手势\"\n        src=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n        srcset=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/0479a/gesturelifecycle.jpg 250w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/41099/gesturelifecycle.jpg 500w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg 862w\"\n        sizes=\"(max-width: 862px) 100vw, 862px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在每个阶段会有相应的处理函数来处理当前阶段的行为</p>\n<h3>手势响应的阶段</h3>\n<h4>申请阶段</h4>\n<ol>\n<li>View.props.onStartShouldSetResponder: (evt) => bool(返回true 代表当前组件申请在触摸手势的时候成为响应者)</li>\n<li>View.props.onMoveShouldSetResponder: (evt) => true(返回true 代表当前组件申请在移动手势的时候成为响应者)</li>\n</ol>\n<h4>通知阶段</h4>\n<ol>\n<li>View.props.onResponderGrant: (evt) => {}(获取手势处理回调)</li>\n<li>View.props.onResponderReject: (evt) => {}(获取手势处理失败回调)</li>\n</ol>\n<h4>响应阶段</h4>\n<ol>\n<li>View.props.onResponderMove: (evt) => { }(手势移动回调)</li>\n<li>View.props.onResponderRelease: (evt) => { }(手势行为结束(touchUp)回调)</li>\n</ol>\n<h4>释放阶段</h4>\n<ol>\n<li>View.props.onResponderTerminationRequest: (evt) => bool (当其他组件想成为当前手势的处理者时会触发,返回true表示释放)</li>\n<li>View.props.onResponderTerminate: (evt) => {} (当前组件失去响应者身份触发）</li>\n</ol>\n<h3>手势拦截</h3>\n<p>手势的响应是冒泡的,父元素可以使用如下的方法来实现对手势的拦截处理.</p>\n<ol>\n<li>View.props.onStartShouldSetResponderCapture: (evt)=> bool (返回true成为手势的处理者, 子元素不响应)</li>\n<li>View.props.onMoveShouldSetResponderCapture: (evt)=> bool ((返回true成为手势的处理者, 子元素不响应))</li>\n</ol>\n<h3>自定义响应组件实现</h3>\n<p>通过对手势处理阶段的了解,在定义响应组件的时候可以通过添加相应的函数来实现,react native定义了PanResponder.create()方法来快速的实现组件的定义.PanResponder响应回调函数中封装了事件和手势的状态信息,能更细致的实现对手势的处理.</p>\n<pre><code>class App extends Component {\n  constructor(props) {\n    super(props)\n    this.PanResponder = PanResponder.create({\n      onStartShouldSetPanResponder: (evt, gestureState) => true, // 触摸的时候成为手势响应者\n      onPanResponderStart: (evt, gestureState) => { console.log('someone touch me') }, // 触摸时间回调\n    })\n  }\n  render() {\n    return (\n      &#x3C;View style={styles.container} {...this.PanResponder.panHandlers} >&#x3C;/View>\n    )\n  }\n}\n</code></pre>\n<h2>后记</h2>\n<p>最新会按照下面的思路逐步的梳理下React Native相关入门与实践的一些知识.\n<img src=\"reactNativeBasic.png\" alt=\"react native 入门\"></p>","frontmatter":{"date":"2020-04-15","path":"/rn-gesture","title":"react-native中的手势处理"}}},"pageContext":{"readingTime":"4 min read"}},
    "staticQueryHashes": ["256249292"]}