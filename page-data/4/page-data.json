{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/4",
    "result": {"pageContext":{"pageAllCount":89,"group":[{"node":{"id":"b554705e-f1cc-52f6-ab7b-0159784362a1","html":"<h2><a href=\"https://github.com/reactwg/react-18/discussions/37\">New Suspense SSR Architecture in React 18</a></h2>\n<p>这篇文章介绍react 18中流式渲染和Suspense的结合，实现更好的服务端渲染功能。相关文章还有<a href=\"https://juejin.cn/post/7064759195710521381\">浅析React 18 Streaming SSR</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍2022年热度比较高的React库</p>\n<h2><a href=\"https://developer.aliyun.com/article/781882\">一文详解 CSS-in-JS</a></h2>\n<p>这篇文章从CSS规范、CSS的设计模式说起，逐步覆盖到CSS-in-JS的细节，涉及的相关背景比较多，值得仔细阅读。</p>\n<h2><a href=\"https://weizman.github.io/page-what-is-a-realm-in-js/#identity-discontinuity\">What is a realm in JavaScript?</a></h2>\n<p>这篇文章介绍JavaScript中Realm的定义。也可以结合这篇<a href=\"https://2ality.com/2022/04/shadow-realms.html\">ShadowRealms – an ECMAScript proposal for a better eval()</a>介绍ShadowRealms API提议的文章一起了解。</p>\n<h2><a href=\"https://roadmap.sh/roadmaps/\">Developer Roadmaps</a></h2>\n<p>Developer Roadmaps收集了各个开发方向的技能路线图</p>\n<h2><a href=\"https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo\">How we configured pnpm and Turborepo for our monorepo</a></h2>\n<p>一篇比较详细的介绍monorepo技术方案选择工具的文章，从多项目开发的问题开始说起，逐步介绍<a href=\"https://github.com/pnpm/pnpm\">pnpm</a>(monorepo管理工具)和<a href=\"https://github.com/vercel/turbo\">Turborepo</a>(打包构建工具)</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart\">js-code-to-svg-flowchart</a></h3>\n<p>一个将JavaScript代码转化成svg图片的库。</p>\n<h3><a href=\"https://console-ninja.com/\">CONSOLE NINJA</a></h3>\n<p>一款VSCode插件，可以直接在代码中查看输入的console调试信息</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/shuding/react-wrap-balancer\">react-wrap-balancer</a></h3>\n<p>react-wrap-balancer能使文案比较智能的适应容器，占据容器的空间，达到比较好的展示效果，下面从源码上看它是如何实现的:\n<img src=\"/blog/9336733f998bb911bd52006bac3dd61b/blancer.gif\" alt=\"react-wrap-balancer\">\n通过简单的demo使用可以发现balancer在页面中注入了一段脚本并且为包裹的文本内容绑定的属性标识\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.399999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsElEQVQI1y2JQW6DMBQFuf/NWlGEDbaA2NDSUAL4QxopQFdTgbIYvRm9yMQFnS9xtsGVEzL/McsDmSYk3BFZmWUhjHf6YaUfnoRl5zaudP2TYVoZw3b24VESW8qiJlMarSw68+SmQClFqnIqf8UYi1KG96QkzRu0rflIKxLt0KYhzRxvsaXyHVGuf7h4wX0uVC5Qfy34/hd/e9DKxrdstLK/fKVb9nMPrvN2cnj7+v4B3u7bRFMr7ugAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"balancer-show\"\n        title=\"balancer-show\"\n        src=\"/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png\"\n        srcset=\"/blog/static/209d5af74aebd83c377943dd2258a96b/63868/blancerShow.png 250w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/0b533/blancerShow.png 500w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png 1000w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png 1088w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>    // react-wrap-balancer的主体代码逻辑\n    const Balancer: React.FC&#x3C;BalancerProps> = ({\n        as: Wrapper = 'span',\n        ratio = 1,\n        children,\n        ...props\n    }) => {\n        // 利用useId为组件生成唯一标识，useId可以根据组件的层级结构生成唯一标识\n        const id = React.useId()\n        const wrapperRef = React.useRef&#x3C;WrapperElement>()\n        const hasProvider = React.useContext(BalancerContext)\n\n        // 监听函数执行\n        // useIsomorphicLayoutEffect这里对服务端和客户端做了区分 在服务端调用useEffect,在客户端调用useLayoutEffect 解决客户端的闪动问题\n        useIsomorphicLayoutEffect(() => {\n            if (wrapperRef.current) {\n            // 调用绑定self上绑定的动态调整函数 并传入当前的入参执行\n            // self可以指代全局的window https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n            // 主要计算逻辑都在relayout函数中\n            ;(self[SYMBOL_KEY] = relayout)(0, ratio, wrapperRef.current)\n            }\n        }, [children, ratio])\n\n        // 自己卸载的时候 终止监听函数\n        useIsomorphicLayoutEffect(() => {\n            return () => {\n                if (!wrapperRef.current) return\n\n                const resizeObserver = wrapperRef.current[SYMBOL_OBSERVER_KEY]\n                if (!resizeObserver) return\n\n                resizeObserver.disconnect()\n                delete wrapperRef.current[SYMBOL_OBSERVER_KEY]\n            }\n        }, [])\n\n        return (\n            &#x3C;>\n                &#x3C;Wrapper\n                    {...props}\n                    // 绑定的唯一标识\n                    data-br={id}\n                    data-brr={ratio}\n                    ref={wrapperRef}\n                    style={{\n                    display: 'inline-block',\n                    verticalAlign: 'top',\n                    textDecoration: 'inherit',\n                    }}\n                    suppressHydrationWarning\n                >\n                    {children}\n                &#x3C;/Wrapper>\n                {createScriptElement(hasProvider, `self.${SYMBOL_KEY}(\"${id}\",${ratio})`)}\n            &#x3C;/>\n        )\n    }\n</code></pre>\n<p>通过上面的源码分析，主要的动态计算逻辑都在relayout函数中</p>\n<pre><code>    const relayout: RelayoutFn = (id, ratio, wrapper) => {\n        // 根据id获取包裹的wrapper组件\n        wrapper =\n            wrapper || document.querySelector&#x3C;WrapperElement>(`[data-br=\"${id}\"]`)\n        // wrapper的父容器\n        const container = wrapper.parentElement\n        // 更新wrapper的最大宽度\n        const update = (width: number) => (wrapper.style.maxWidth = width + 'px')\n\n        // 重置wrapper的最大宽度\n        wrapper.style.maxWidth = ''\n\n        // 获取wrapper的父容器的宽高\n        const width = container.clientWidth\n        const height = container.clientHeight\n\n        // 二分查找的方式计算wrapper的宽度\n        let left: number = width / 2\n        let right: number = width\n        let middle: number\n\n        if (width) {\n            while (left + 1 &#x3C; right) {\n                middle = ~~((left + right) / 2)\n                update(middle)\n                if (container.clientHeight === height) {\n                    // 缩放后 高度没有变 那么right= middle\n                    right = middle\n                } else {\n                    // 否则right = middle\n                    left = middle\n                }\n            }\n\n            // 更新wrapper的宽度\n            update(right * ratio + width * (1 - ratio))\n        }\n\n        // 通过ResizeObserver去监听wrapper父容器的变化 执行relayout函数\n        if (!wrapper['__wrap_o']) {\n            ;(wrapper['__wrap_o'] = new ResizeObserver(() => {\n            self.__wrap_b(0, +wrapper.dataset.brr, wrapper)\n            })).observe(container)\n        }\n    }\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null}}},{"node":{"id":"397dff62-95c9-527b-a1bb-bcd9b51c1901","html":"<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/react-hooks\">React Hooks源码解读</a>中有对React hooks的实现原理进行分析，本文主要结合React hooks的发展过程聊下对hooks的理解。hooks的提出主要解决了以下的问题:</p>\n<ul>\n<li>为react带来通用的代码逻辑复用的方式。相对于render props/高阶组件(HOC)等，hooks在代码复杂度上都有一定降低。声明式的hooks使用方式也符合函数式编程的思想。</li>\n<li>解决类组件生命周期函数复杂度和在新的react架构中的一些问题</li>\n<li>规范react使用范式，通过hooks的接口能更好的组织组件与组件/组件与渲染的原生DOM/组件与外部依赖之间的关系</li>\n</ul>\n<h2>通用的代码复用方式</h2>\n<p>react中可以通过render props/高阶组件(HOC)实现代码的能力的复用(组合)。</p>\n<pre><code>// render props通过传入渲染函数的方式复用逻辑\nclass Cat extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = { name: 111 }\n        // 可复用的逻辑\n    }\n    render() {\n        // 通过调用渲染函数的方式实现共享\n        return this.props.render(this.state)\n    }\n}\nclass App extends Component {\n    render() {\n        return (\n            &#x3C;Cat render={params => (&#x3C;div>{params.name}&#x3C;/div>)} />\n        )\n    }\n}\n// 高阶组件\nfunction HOC(WrappedComponent) {\n  return class extends Component {\n    componentDidMount() {\n      // 通用的业务逻辑\n    }\n    render() {\n      return (&#x3C;WrappedComponent {...this.props} />)\n    }\n  }\n}\n</code></pre>\n<p>从render props和高阶组件的实现方式上看，两者都引入了新的组件结构来实现复用，增加了理解成本从而导致一些问题。笔者在最开始对高阶组件不熟悉的时候就遇到过一次bug。包裹的高阶组件没有将外层传递的属性透传给被包裹的组件从而导致子组件渲染异常。<br>\nhooks通过函数声明式的方式实现代码复用，理解上更符合可见可得的思想，减少了理解成本。</p>\n<h2>解决老的问题</h2>\n<p>类组件的生命周期问题导致代码逻辑的分离，比如事件的监听与解绑</p>\n<pre><code>// 类组件示例\nclass Test extends Component {\n    componentDidMount() {\n        // 监听\n        document.addEventListener()\n    }\n    componentWillUnmount() {\n        // 解绑\n        document.removeEventListener()\n    }\n    render() {}\n}\n// 函数式组件示例\nfunction Test(props) {\n    useEffect(() => {\n        // 监听\n        document.addEventListener()\n        return () => {\n            // 解绑\n            document.removeEventListener()\n        }\n    }, [])\n    return xxx;\n}\n</code></pre>\n<p>在Concurrent Mode中会导致生命周期函数的多次执行，hooks的提出在结构上是与Fiber结构绑定的，服务于新的架构的</p>\n<h2>规范使用范式</h2>\n<p>react开发者都需要用一些库(redux等)来组合应用，react通过hooks为react增加了状态管理、操作DOM的入口、父子组件调用方式等，丰富且规范了React开发者的开发模式。通过这种规范可以让React更好的与社区结合，比如相关的库<a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>、<a href=\"https://github.com/streamich/react-use\">react-use</a>。</p>\n<h2>hooks使用注意</h2>\n<ul>\n<li>避免hooks依赖，比如useMemo/useCallback等是否需要使用。使用多个useState的时候是否引入其他的管理库来解</li>\n<li>UI逻辑与业务逻辑合理拆分。hooks做过多的业务逻辑会导致业务逻辑不明晰，需要进行适当的拆分。</li>\n<li>hooks的依赖问题会导致业务中存在隐藏逻辑，需要控制代码中隐藏逻辑和隐藏逻辑的依赖问题</li>\n<li>hooks更适合组件级别的代码复用和逻辑,跨组件逻辑需要仔细设计(比如是否需要useRef)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null}}},{"node":{"id":"5727745d-cc22-558e-b830-2ecc6b9c1e75","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\n    logMessage(user, message) {\n        const sender = user.getName();\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\n    }\n}\nclass User {\n    constructor(name, chatroom) {\n        this.name = name;\n        this.chatroom = chatroom;\n    }\n\n    getName() {\n        return this.name;\n    }\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\n    send(message) {\n        this.chatroom.logMessage(this, message);\n    }\n}\nconst chatroom = new ChatRoom();\nconst user1 = new User(\"John Doe\", chatroom);\nconst user2 = new User(\"Jane Doe\", chatroom);\nuser1.send(\"Hi there!\");\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\nconst books = new Map();\nconst createBook = (title, author, isbn) => {\n    const existingBook = books.has(isbn);\n    if (existingBook) {\n        // 已存在就查找返回\n        return books.get(isbn);\n    }\n    // 不存在新建返回\n    const book = new Book(title, author, isbn);\n    books.set(isbn, book);\n    return book;\n};\n//  存储书的列表\nconst bookList = [];\nconst addBook = (title, author, isbn, availability, sales) => {\n    const book = {\n        // 利用之前的共享对象创建新的实力\n        ...createBook(title, author, isbn),\n        sales,\n        availability,\n        isbn\n    };\n    bookList.push(book);\n    return book;\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\n    class OrderManager {\n        constructor() {\n            // 指令处理的对象\n            this.orders = [];\n        }\n\n        execute(command, ...args) {\n            // 匹配指令和指令处理的对象\n            return command.execute(this.orders, ...args);\n        }\n    }\n    // 指令创建类\n    class Command {\n        constructor(execute) {\n            this.execute = execute;\n        }\n    }\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\n    function PlaceOrderCommand(order, id) {\n        return new Command(orders => {\n            orders.push(id);\n            return `You have successfully ordered ${order} (${id})`;\n        });\n    }\n    const manager = new OrderManager();\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null}}},{"node":{"id":"794a572a-6aaf-51cf-854b-bb0077d6f89b","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>观察者模式</h2>\n<p>观察者模式(发布订阅模式)是定义对象间一种一对多的依赖关系，使得当每一个被观察方改变状态，则所有依赖于它的观察者都会得到通知并自动更新。</p>\n<pre><code>// 被观察者提供观察者通知逻辑、订阅逻辑\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    // 观察者订阅入口\n    subscribe(func) {\n        this.observers.push(func);\n    }\n\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    // 通知观察者\n    notify(data) {\n        this.observers.forEach(observer => observer(data));\n    }\n}\nfunction logger(data) {\n    console.log(data)\n}\nconst observable = new Observable() \n// 订阅操作\nobservable.subscribe(logger);\n// 通知操作\nobservable.notify('this is a test!')\n</code></pre>\n<p>观察者模式的优点是可以做到逻辑的分离，做到单一职责。缺点是当观察者数目较多的时候会有性能的问题</p>\n<h2>Mixin模式</h2>\n<p>Mixin模式可以在不通过继承的方式实现为类(对象)增加复用的能力。当你需要将一个特定的feature添加到不同的类或者为类提供可插拔能力的时候可以考虑Mixin模式。</p>\n<pre><code>// 基础类 只有name能力\nclass Dog {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// mixin方法 可以为基础类提供复用的能力\nconst dogFunctionality = {\n    bark: () => console.log(\"Woof!\"),\n    wagTail: () => console.log(\"Wagging my tail!\"),\n    play: () => console.log(\"Playing!\")\n};\n// 通过方法的拷贝 在Dog的原型上就有了对象的方法\nObject.assign(Dog.prototype, dogFunctionality);\nconst pet1 = new Dog(\"Daisy\");\npet1.bark(); // Woof!\n</code></pre>\n<p>可以在mixin函数中通过指定__proto__实现mixin的继承能力</p>\n<pre><code>const sayMixin = {\n    say(phrase) {\n        alert(phrase);\n    }\n};\nconst sayHiMixin = {\n    // 设置原型 实现mixin的继承\n    __proto__: sayMixin, // (可以在这儿使用 Object.setPrototypeOf 来设置原型)\n    sayHi() {\n        // 调用父类方法\n        super.say(`Hello ${this.name}`); // (*)\n    },\n    sayBye() {\n        super.say(`Bye ${this.name}`); // (*)\n    }\n};\nclass User {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// 拷贝方法\nObject.assign(User.prototype, sayHiMixin);\n\n// 现在 User 可以打招呼了\nnew User(\"Dude\").sayHi(); // Hello Dude!\n</code></pre>\n<p>mixin模式会存在覆盖功能和增加项目代码复杂度的问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"5分钟速读系列-观察者模式/Mixin模式","date":"2022-11-03","tags":"设计模式","path":"/2022-11-observable","top":null,"summary":null}}},{"node":{"id":"316e9ae9-368f-5e9a-993e-05e97265fb24","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>提供者模式</h2>\n<p>提供者模式通过封装方法给予应用订阅不同数据源的能力。react中通过外层的Provider来提供全局的store，在组件内部通过useContext来获取相关的Context值。</p>\n<pre><code>    // 根组件通过Provider的value绑定全局store\n    export const ThemeContext = React.createContext();\n    const themes = {\n        light: {\n            background: \"#fff\",\n            color: \"#000\"\n        },\n        dark: {\n            background: \"#171717\",\n            color: \"#fff\"\n        }\n    };\n    export default function App() {\n        const [theme, setTheme] = useState(\"dark\");\n        function toggleTheme() {\n            setTheme(theme === \"light\" ? \"dark\" : \"light\");\n        }\n        const providerValue = {\n            theme: themes[theme],\n            toggleTheme\n        };\n        return (\n            &#x3C;div className={`App theme-${theme}`}>\n                &#x3C;ThemeContext.Provider value={providerValue}>\n                    &#x3C;Toggle />\n                &#x3C;/ThemeContext.Provider>\n            &#x3C;/div>\n        );\n    }\n    // Toggle组件\n    import React, { useContext } from \"react\";\n    import { ThemeContext } from \"./App\";\n\n    export default function Toggle() {\n        const theme = useContext(ThemeContext);\n        return (\n            &#x3C;label className=\"switch\">\n                &#x3C;input type=\"checkbox\" onClick={theme.toggleTheme} />\n            &#x3C;/label>\n        );\n    }\n</code></pre>\n<p>在React应用中通过全局的context可以解决组件属性的传递问题，便于组件的设计。但是全局Context的更新会导致消费对应Context组件的更新，造成需要不必要的渲染。这里就需要对全局Context进行更细粒度的拆分。</p>\n<h2>原型模式</h2>\n<p>JavaScript通过原型完成对象间属性的共享。通过原型能减少相同属性或者方法的创建，相同类型的实例可以共享实例原型上的属性和方法。对于原型模式需要理解几下的几点:</p>\n<ul>\n<li>\n<p>实例对象的__proto__指向构造函数的prototype(实例与原型的关系).构造函数的prototype的constructor(构造函数与原型的关系).</p>\n<pre><code>  class Dog {\n      constructor(name) {\n          this.name = name;\n      }\n      bark() {\n          return `Woof!`;\n      }\n  }\n  const dog1 = new Dog(\"Daisy\");\n  dog1.__proto__ === Dog.prototype // true\n  Dog.prototype.constructor === Dog // true\n</code></pre>\n</li>\n<li>\n<p>对象属性的获取是顺着对象__proto__沿着原型链查找，会一直查找到Object.prototype(Object.prototype.__proto__是null)</p>\n</li>\n<li>\n<p>理解new关键字中原型的处理方式，new操作符主要做了如下的操作:</p>\n<ol>\n<li>\n<p>以构造器的原型为属性创建新对象</p>\n</li>\n<li>\n<p>将新对象作为this调用构造器</p>\n</li>\n<li>\n<p>如果构造器返回的是对象则返回否则返回第一步创建的对象</p>\n<pre><code> function myNew(Con, ...args) {\n     const obj = Object.create(Con.prototype);\n     const ret = Con.call(obj, args);\n     if(ret instanceof Object &#x26;&#x26; ret !== null) {\n         return ret;\n     }\n     return obj;\n }\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"5分钟速读系列-提供者模式/原型模式","date":"2022-11-02","tags":"设计模式","path":"/2022-11-provider","top":null,"summary":null}}},{"node":{"id":"8418a542-013e-52de-bd15-8927e0017b7f","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>单例模式</h2>\n<p>单例模式通过全局维护一个实例的方式来达到全局属性的共享和减少内存的占用。单例的简单实现如下:</p>\n<pre><code>    let instance;\n    let counter = 0;\n    class Counter {\n        constructor() {\n            if (instance) {\n                throw new Error(\"You can only create one instance!\");\n            }\n            instance = this;\n        }\n        getInstance() {\n            return this;\n        }\n        getCount() {\n            return counter;\n        }\n        increment() {\n            return ++counter;\n        }\n        decrement() {\n            return --counter;\n        }\n    }\n    const singletonCounter = Object.freeze(new Counter());\n    // 暴露给外部的单一实例\n    export default singletonCounter;\n</code></pre>\n<p>单例模式的优点也恰恰是他的缺点，由于全局属性的共享导致改动的全局污染问题、测试用例写法问题等。在react中全局的redux\\context store就是应用中的单例，store通过单向的数据流来规避单例的一些问题。</p>\n<h2>Proxy(代理)模式</h2>\n<p>代理模式通过为对象提供占位符来控制对象的访问。代理对象相当于中间人角色，可以在不改变被代理对象的接口的情况下扩展功能。在JavaScript中可以使用Proxy来实现代理的功能。</p>\n<pre><code>    const person = {\n        name: \"John Doe\",\n        age: 42,\n        nationality: \"American\"\n    };\n    const personProxy = new Proxy(person, {\n        // handler的get/set方法代理了被代理对象属性的访问方法\n        get: (obj, prop) => {\n            console.log(`The value of ${prop} is ${obj[prop]}`);\n            // 可以用Reflect修改代理对象的属性\n            Reflect.set(obj, prop);\n        },\n        set: (obj, prop, value) => {\n            console.log(`Changed ${prop} from ${obj[prop]} to ${value}`);\n            obj[prop] = value;\n            return true;\n        }\n    });\n    personProxy.name;\n    personProxy.age = 43;\n</code></pre>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"5分钟速读系列-单例模式/代理模式","date":"2022-11-01","tags":"设计模式","path":"/2022-11-singleton","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":4,"pageCount":15,"additionalContext":{"pageAllCount":89}}},
    "staticQueryHashes": []}