{"componentChunkName":"component---src-templates-index-js","path":"/4","result":{"pageContext":{"pageAllCount":88,"group":[{"node":{"id":"fd92a9b2-6634-513c-b581-0c6d7a60cd38","html":"<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-0-61fea500b180\">Frontend Web Performance: The Essentials [0]</a></h2>\n<p>这篇文章介绍前端页面渲染的过程，包括渲染的流程，优化的手段等。通过例子结合chrome的开发者工具给出优化的过程。</p>\n<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-1-cb6513e1c3a1\">Frontend Web Performance: The Essentials [1]</a></h2>\n<p>这篇文章介绍浏览器的事件循环，包括宏任务，微任务等，通过将微任务与宏任务结合的方式可以实现宏任务的拆分。</p>\n<h2><a href=\"https://www.toptal.com/javascript/10-most-common-javascript-mistakes\">The 10 Most Common JavaScript Issues Developers Face</a></h2>\n<p>这篇文章介绍了javascript中几个常见的问题点。比如this的确定、内存泄露、原型链等.</p>\n<h2><a href=\"https://www.robinwieruch.de/typescript-react-useref/\">TypeScript: React useRef Hook</a></h2>\n<p>介绍React useRef Hook的文章.\nReact提供了useCallback, useMemo来实现memoization能力，减少重复的计算。应该避免对应hook的滥用，在缓存大量计算逻辑的时候使用<br>\nuseImperativeHandle可以实现父组件对子组件的方法调用。在使用useImperativeHandle的时候思考是否可以将逻辑抽离到store层处理<br>\nuseRef可以用于存储值，改变useRef的值不需要重新渲染组件</p>\n<h2>工具</h2>\n<h3><a href=\"https://react-svgr.com/docs/what-is-svgr/\">SVGR</a></h3>\n<p>SVGR通过svgo优化，svg内容解析将svg转化成React组件使用</p>\n<h3><a href=\"https://github.com/thebuilder/react-intersection-observer\">react-intersection-observer</a></h3>\n<p>react-intersection-observer通过对IntersectionObserver的封装提供了react hook的方式来监听元素在视口中的位置</p>\n<h3><a href=\"https://github.com/pmndrs/react-spring\">react-spring</a></h3>\n<p>react实现spring动画的库</p>\n<h2>想法</h2>\n<h3>关于前端store设计</h3>\n<p>在<a href=\"https://icantunderstand.cn/2022-7-1\">上期前端快报</a>中聊到了前端的页面设计，要从数据逻辑去思考页面，实现数据逻辑和渲染逻辑的分离。\n在对前端store(View-Model)的设计上，可以从页面的角度，去拆分通用模块，页面级别模块实现更好的数据逻辑与渲染逻辑的隔离.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpElEQVQ4y51Ty07DMBDM/wvxAUj8CwckxBmpouJE2zRJ82iSPvxMB80GN6EBVDiMvLuxx7MTb2StxRjGGAHj4/GIpmkEVVWdY6XUZG9ANCYab3LO4XA4YLfbCUmSJBITrPP7QEhoiaNLdVy5WWstB7fbrWC9Xp9j1vszTsiM8TDmJPlEIdsk4jhGURSiLqhs21bWzWaDPM+htYIxDl2XoeveoPUe0bhVrnVdiwoeoFfMWffeS04v+Y1o2wZFUaNpHpCmt1Bq3isMZDxEFSQJnjEPXVA5VQeFVVUiz2nBE5S6h3PzQSE94+3L5VIU8iBJCRKNvabHQYhzHt638D6DtZ8tcwO9IVFZlqKMJLyAOTF+AQNCjX+8kzUKN7JNqsqyDPv9/qw44HvCnrR/Nj0iGp2mqYBKQkzSy/Yuh+A7RGx1sViId1TJdTabYbVaTabhGtKIftG7uu7fW1FUSJJMaj+N16+EXwsOzvERrybTczXhYK6GtYDWz8jzOyj1DmtPUv+HwjHhI8ryBs69whjI0Pd/8I+EYci9jwG8wNpC8uFJXEf4ASte1qZJXzjwAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"store设计\"\n        title=\"store设计\"\n        src=\"/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png\"\n        srcset=\"/blog/static/e6385772916f35fe16003bf9eb93be77/63868/storeDesign.png 250w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/0b533/storeDesign.png 500w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png 1000w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/187fa/storeDesign.png 1194w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-8-1-前端快报","date":"2022-08-05","tags":"前端快报","path":"/2022-8-1","top":null,"summary":null}}},{"node":{"id":"bf1c7d29-cf60-5ac9-b56f-e0daabe2565e","html":"<h2><a href=\"https://h3manth.com/ES2022/\">ES2022 Features!</a></h2>\n<p>这篇文章介绍ES2022的Features。</p>\n<h2><a href=\"https://mikevdv.dev/blog/2022-06-23-stop-the-screen-going-to-sleep-with-javascript\">Stop The Screen Going To Sleep With JavaScript</a></h2>\n<p>这篇文章介绍WakeLock api的使用方法。WakeLock用于防止用户屏幕变暗或者锁屏。<a href=\"https://github.com/richtr/NoSleep.js/\">NoSleep.js</a>就是封装了WakeLock的能力来实现对应的功能.</p>\n<p>NoSleep功能实现:</p>\n<ul>\n<li>在支持wakeLock的设备上使用wakeLock</li>\n<li>在老的ios设备上  通过设置当前href和window.stop的定时器来激活页面</li>\n<li>其他情况通过设置一个循环播放的video标签来实现</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/wbkd/react-flow\">react-flow</a></h3>\n<p>react绘制图表和流程图的工具库</p>\n<h2>想法</h2>\n<h3>关于前端页面设计</h3>\n<ul>\n<li>作为前端开发似乎很容易直接从页面的角度去考虑实现，因为接触的UI就是最直观的图形输入。但是页面不光是简单的UI展示，后面还承载着数据的流动。从数据流去思考业务的逻辑和设计实现页面和业务逻辑的分离。数据承接逻辑，页面承接UI渲染组合能更好的服务于页面的扩展。</li>\n</ul>\n<h3>react hooks的理解</h3>\n<p>hooks是react暴露给外部的接口。这个是react增加hooks提供的一个比较重要的能力。比如react query通过hooks的能力桥接了queryClient.</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/pierpo/react-archer\">react-archer</a>源码分析</h3>\n<p>react-archer通过箭头线绘制React节点之间的关联关系。它的实现主要:</p>\n<ul>\n<li>维护全局的节点关联关系(逻辑抽象 封装)</li>\n<li>解耦节点渲染和箭头线渲染(解耦)</li>\n</ul>\n<h4>节点关系处理逻辑</h4>\n<pre><code>    // 子节点注册逻辑\n    const registerTransitions = (newRelations: Array&#x3C;RelationType>) => {\n        // 格式化节点配置\n        const newSourceToTarget = generateSourceToTarget(id, newRelations);\n        assertContextExists(context);\n        // 更新全局节点配置\n        context.registerTransitions(id, newSourceToTarget);\n    }\n\n    // 根节点更新逻辑\n    const _registerTransitions = useCallback(\n        (elementId: string, newSourceToTargets: SourceToTargetType[]): void => {\n            // 节点关系在根节点中通过useState进行更新维护 触发组件更新\n            setSourceToTargetsMap((previousValue) => ({\n                ...previousValue,\n                [elementId]: newSourceToTargets,\n            }));\n        },\n        [],\n    );\n</code></pre>\n<h4>箭头渲染逻辑</h4>\n<p>在根组件中通过SvgArrows渲染节点连接逻辑</p>\n<pre><code>// 遍历节点关系数据 依次渲染\n{getSourceToTargets(props.sourceToTargetsMap).map((currentRelation) => (\n    &#x3C;AdaptedArrow\n      key={JSON.stringify({\n        source: currentRelation.source,\n        target: currentRelation.target,\n      })}\n      source={currentRelation.source}\n      target={currentRelation.target}\n      label={currentRelation.label}\n      style={currentRelation.style || {}}\n      startMarker={props.startMarker}\n      endMarker={props.endMarker}\n      endShape={props.endShape}\n      strokeColor={props.strokeColor}\n      strokeWidth={props.strokeWidth}\n      strokeDasharray={props.strokeDasharray}\n      noCurves={props.noCurves}\n      lineStyle={props.lineStyle}\n      offset={props.offset}\n      parentCoordinates={parentCoordinates}\n      refs={props.refs}\n      uniqueId={props.uniqueId}\n    />\n))}\n\n// 使用getBoundingClientRect和配置项计算绘制箭头的位置 最后使用svg进行关联线的绘制\nexport const getPointCoordinatesFromAnchorPosition = (\n    position: AnchorPositionType,\n    index: string,\n    parentCoordinates: Vector2,\n    refs: Record&#x3C;string, HTMLElement>,\n): Vector2 => {\n    const rect = getRectFromElement(refs[index]);\n\n    if (!rect) {\n        return new Vector2(0, 0);\n    }\n\n    const absolutePosition = computeCoordinatesFromAnchorPosition(position, rect);\n    return absolutePosition.substract(parentCoordinates);\n};\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null}}},{"node":{"id":"268dcea6-4865-5b5f-a888-e8af729278ed","html":"<p>本文梳理axios中使用CancelToken来实现中断请求的源码实现.\n(CancelToken已经是deprecated, axios已支持AbortController实现相应的功能)</p>\n<h2>简单使用</h2>\n<pre><code>    const CancelToken = axios.CancelToken;\n    // 创建cancelToken\n    const source = CancelToken.source();\n\n    axios.get('/user/12345', {\n        // 请求的时候 传入创建的cancelToken\n        cancelToken: source.token\n    }).catch(function (thrown) {\n        if (axios.isCancel(thrown)) {\n            console.log('Request canceled', thrown.message);\n        } else {\n            // handle error\n        }\n    });\n\n\n    // 调用cancelToken的cancel方法 取消请求\n    source.cancel('Operation canceled by the user.');\n</code></pre>\n<p>上面是axios官网的上使用CancelToken的例子，可以看到通过将创建的cancelToken传入对应的请求对象，就实现了请求控制能力暴露给外部的能力。</p>\n<h2>源码分析</h2>\n<p>XMLHttpRequest支持使用abort方法实现请求的终止，axios底层封装了XMLHttpRequest来实现请求的处理，通过将调用abort方法的能力暴露给外部就实现了请求中断的控制。axios引入了cancelToken来实现这个过程的解耦。下面从具体的源码来看实现的过程</p>\n<h3>创建cancelToken对象</h3>\n<pre><code>// 调用source方法 生成CancelToken 导出token和取消请求的cancel方法\nCancelToken.source = function source() {\n    var cancel;\n    var token = new CancelToken(function executor(c) {\n        cancel = c;\n    });\n    return {\n        token: token,\n        cancel: cancel\n    };\n};\n\nfunction CancelToken(executor) {\n    if (typeof executor !== 'function') {\n        throw new TypeError('executor must be a function.');\n    }\n\n    var resolvePromise;\n    // 设置CancelToken的promise函数\n    this.promise = new Promise(function promiseExecutor(resolve) {\n        resolvePromise = resolve;\n    });\n\n    var token = this;\n    // cancel函数的执行逻辑 在调用cancel接口的时候 执行下面的逻辑\n    executor(function cancel(message) {\n        if (token.reason) {\n            // Cancellation has already been requested\n            return;\n        }\n\n        token.reason = new Cancel(message);\n        resolvePromise(token.reason);\n    });\n}\n</code></pre>\n<h3>cancelToken与XMLHttpRequest绑定</h3>\n<pre><code>    // 代码是axios封装XMLHttpRequest的部分逻辑\n    if (config.cancelToken) {\n        // 如果传入的配置有cancelToken 就调用cancelToken的promise方法 \n        // 通过promise实现控制流的流转 调用cancelToken方法的时候 将resolve时机暴露给cancelToken\n        // 调用cancelToken的cancel方法时,resolve了当前的promise，控制流程回到当前的后续流程，执行request.abort()从而完成请求的终止\n        config.cancelToken.promise.then(function onCanceled(cancel) {\n            if (!request) {\n                return;\n            }\n\n            request.abort();\n            reject(cancel);\n            // Clean up request\n            request = null;\n        });\n    }\n\n    if (!requestData) {\n        requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n</code></pre>\n<p>通过对实现流程的源码梳理，在类似的功能中可以利用promise来完成流程的控制。</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"axios的cancel功能源码解读","date":"2022-06-22","tags":"JavaScript","path":"/axios-cancel","top":null,"summary":null}}},{"node":{"id":"bdbed110-909c-577e-9652-4e22fb148271","html":"<h2><a href=\"https://michel.codes/blogs/ui-as-an-afterthought\">UI AS AN AFTERTHOUGHT</a></h2>\n<p>这篇文章介绍作者对UI框架和状态管理的思考。在React中开发者通常会在组件中处理业务逻辑，这样导致UI和数据无法解耦。文章中的方式是让React做比较纯粹的渲染框架，业务逻辑组织在全局store中.</p>\n<h2><a href=\"https://mmazzarolo.com/blog/2022-02-16-track-down-the-javascript-code-responsible-for-polluting-the-global-scope/\">Track down the JavaScript code responsible for polluting the global scope</a></h2>\n<p>文章提供了基于ES6 proxy查找全局变量污染的方案</p>\n<h2><a href=\"https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md\">useEvent RFC</a></h2>\n<p>相关文章\n<a href=\"https://typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/\">What the useEvent React hook is (and isn't)</a><br>\nreact增加了useEvent提案，使用场景能帮我们缓存一个函数的回调。主要用于解决如下的问题:</p>\n<ol>\n<li>通常的场景在组件中声明中的函数会因为依赖项的问题导致在渲染的时候函数会新生成引用，这样在使用该函数的子组件就会触发重新渲染。</li>\n<li>react hooks的依赖解耦 比如在一个effect hook中有两段业务逻辑，这样就需要把两段业务逻辑的依赖都加入到effect hook的依赖中，导致effect执行不符合预期。</li>\n</ol>\n<p>useEvent简化实现如下:</p>\n<pre><code>    function useEvent(handler) {\n        const handlerRef = useRef(null);\n\n        // In a real implementation, this would run before layout effects\n        useLayoutEffect(() => {\n            handlerRef.current = handler;\n        });\n\n        return useCallback((...args) => {\n            // In a real implementation, this would throw if called during render\n            const fn = handlerRef.current;\n            return fn(...args);\n        }, []);\n    }\n</code></pre>\n<p>useEvent可以看出是官方的解决前面提到问题的方案，在往前走一会，有如下的一些思考:</p>\n<ol>\n<li>是否需要一个不变的callback => 性能 vs 代码复杂度</li>\n<li>组件是否做了组件该做的事 => 渲染和业务逻辑的设计</li>\n</ol>\n<h2><a href=\"https://www.youtube.com/watch?v=NZoRlVi3MjQ\">The Story of Concurrent React </a></h2>\n<p>视频介绍react Concurrent发展的过程</p>\n<h2><a href=\"https://www.developerway.com/posts/react-key-attribute\">React key attribute: best practices for performant lists</a></h2>\n<p>文章介绍React组件中key使用的注意事项</p>\n<h2><a href=\"https://www.robinwieruch.de/react-hook-detect-click-outside-component/\">React Hook: Detect Click outside of Component</a></h2>\n<p>文章介绍如何实现一个自定义的hook来监听组件外的点击</p>\n<h2><a href=\"https://www.robinwieruch.de/web-applications/\">Web Applications 101</a></h2>\n<p>文章介绍web应用前端技术的发展过程，从最开始的web1.0到web2.0娓娓道来。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/timc1/kbar\">kbar</a></h3>\n<p>kbar是一个给站点提供快捷操作的工具</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null}}},{"node":{"id":"a1e61cce-6af5-5210-a1d9-45d04f2a460b","html":"<p>本文整体记录自己在优化项目代码的思路和实现过程，主要从以下的方面展开:</p>\n<ul>\n<li>项目背景(技术方案，迭代上遇到的问题)</li>\n<li>使用的优化方式</li>\n<li>过程的总结思考</li>\n</ul>\n<h2>项目背景</h2>\n<p>页面的整体结构可以简化成如下的结构:</p>\n<ul>\n<li>顶部数据筛选区, 筛选数据变化触发表格数据更新</li>\n<li>数据表格渲染区域</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/5112c/pageStruct.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB7cTRoF//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQES/9oACAEBAAEFAusdYqJiP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/AYf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARMVFh/9oACAEBAAE/IYCrwU0chIf/2gAMAwEAAgADAAAAENcf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EC4//8QAGxABAAICAwAAAAAAAAAAAAAAAQAhETFBwfD/2gAIAQEAAT8Qw07IZnkha0i69p4MKUT/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"页面结构\"\n        title=\"页面结构\"\n        src=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/a2510/pageStruct.jpg\"\n        srcset=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/0479a/pageStruct.jpg 250w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/41099/pageStruct.jpg 500w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/a2510/pageStruct.jpg 1000w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/5112c/pageStruct.jpg 1149w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n数据渲染区域有比较复杂的渲染逻辑，需要根据顶部的筛选区域做数据条目的渲染，因此之前的方案通过useReducer引入全局的store做数据的存储和处理。useReducer的方案在当时看并没有问题，但是随着业务的发展遇到了如下的问题，对业务的迭代产生了一些限制:</p>\n<ol>\n<li>表格组件存在一对多问题，随着业务的发展顶部的筛选区域会产生更多业务类型的表格，导致单一组件中存在较多的\"非\"业务相关处理逻辑 => 页面渲染逻辑不清晰、组件渲染逻辑复用度低</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/aafa5a667beca13516314f38856d0a3d/5112c/tableProblem.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAduFlB//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQES/9oACAEBAAEFAq6xURH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPwGH/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBABAQEBAQAAAAAAAAAAAAAAEQABITH/2gAIAQEAAT8hKQb2O+QYbZi//9oADAMBAAIAAwAAABBPH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAQEBAAAAAAAAAAAAAAAAAAARIf/aAAgBAgEBPxCGP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESExQf/aAAgBAQABPxBzLXmHsaxJ5Sew1cRBIVfdj1F1hsKYT//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"表格组件渲染问题\"\n        title=\"表格组件渲染问题\"\n        src=\"/blog/static/aafa5a667beca13516314f38856d0a3d/a2510/tableProblem.jpg\"\n        srcset=\"/blog/static/aafa5a667beca13516314f38856d0a3d/0479a/tableProblem.jpg 250w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/41099/tableProblem.jpg 500w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/a2510/tableProblem.jpg 1000w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/5112c/tableProblem.jpg 1149w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n2. 在业务迭代中引入了新的概念去实现业务功能，这些概念在业务迭代过程中变得不再适用或者很难维护 => 提前封装\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/61d5f/concept.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB7VTRpBf/xAAYEAADAQEAAAAAAAAAAAAAAAAAARESEP/aAAgBAQABBQKmlyGUQ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/AYf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAEBAQADAAAAAAAAAAAAAAABABEQITH/2gAIAQEAAT8hTEaPlnvgAX//2gAMAwEAAgADAAAAEITf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAECAQE/EIbH/8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFhcZH/2gAIAQEAAT8QO1ZfE0KnjDaiuptp3nZ7fYbRc//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"渲染逻辑问题\"\n        title=\"渲染逻辑问题\"\n        src=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/a2510/concept.jpg\"\n        srcset=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/0479a/concept.jpg 250w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/41099/concept.jpg 500w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/a2510/concept.jpg 1000w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/61d5f/concept.jpg 1162w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上图中引入了一个统一的渲染处理逻辑,这个逻辑可以演化成字段、函数等，在业务的迭代中该业务逻辑可维护性差<br>\n3. 代码组织结构混乱。部分文件超过千行难以维护。useReducer相当于低配版的redux，新功能的增加需要添加更多的模板代码 => 功能&#x26;代码组织缺少梳理</p>\n<h2>优化思路&#x26;思考</h2>\n<h3>功能模块化&#x26;组件化</h3>\n<h4>组件化</h4>\n<p>在部分渲染逻辑上，依赖useReducer返回的全局store和dispatch方法触发action。这样有个问题是无法解耦业务组件与表格组件，表格组件和业务组件的逻辑不能有效地分离。代码缺少组件化，页面渲染逻辑不清晰\n对这部分的思考是引入useContext，通过组件内部获取到全局的store对象从而解耦了组件渲染和表格组件的绑定关系。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/82b8c/component.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB3IJQP//EABYQAAMAAAAAAAAAAAAAAAAAAAAQIf/aAAgBAQABBQIq/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAABAx/9oACAEBAAY/Air/xAAZEAABBQAAAAAAAAAAAAAAAAARAAEQMfH/2gAIAQEAAT8hYm0MI//aAAwDAQACAAMAAAAQh8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAGhAAAgIDAAAAAAAAAAAAAAAAABEBIUFRcf/aAAgBAQABPxDKguEspRez/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组件化\"\n        title=\"组件化\"\n        src=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/a2510/component.jpg\"\n        srcset=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/0479a/component.jpg 250w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/41099/component.jpg 500w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/a2510/component.jpg 1000w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/c58a3/component.jpg 1500w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/82b8c/component.jpg 1960w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>功能模块化</h4>\n<p>useReducer函数因为模板代码的问题导致代码行数逐渐增多，这样就在修改代码和熟悉业务增加了成本，降低的维护性。这里引入了combineReducers的概念，在实现新业务的时候，将对应的useReducer处理逻辑封装成独立的模块，在主useRefucer函数中引入从而使实现逻辑模块化。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/01ab0/reducer.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuzUAT/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAQABPyHR1z//2gAMAwEAAgADAAAAEOg//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQETFx/9oACAEBAAE/ENYNd6KEt9Ej/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reducer逻辑分离\"\n        title=\"reducer逻辑分离\"\n        src=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/a2510/reducer.jpg\"\n        srcset=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/0479a/reducer.jpg 250w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/41099/reducer.jpg 500w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/a2510/reducer.jpg 1000w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/01ab0/reducer.jpg 1300w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n随着业务迭代，应该适当地对组件进行隔离维持好组件单一职责的本心，如果多个模块都有类似的能力但是业务逻辑不一致就不要在一个组件中维护过多的能力。可以在上层收口再实现层分离。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/01ab0/single.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7NQA//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAABEBEg/9oACAEBAAE/Ibgr/9oADAMBAAIAAwAAABDoL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAICAwAAAAAAAAAAAAAAAAABEXEQITH/2gAIAQEAAT8QoNzPcpuxI//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组件逻辑拆分\"\n        title=\"组件逻辑拆分\"\n        src=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/a2510/single.jpg\"\n        srcset=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/0479a/single.jpg 250w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/41099/single.jpg 500w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/a2510/single.jpg 1000w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/01ab0/single.jpg 1300w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>引入新的技术方案降低模板代码</h3>\n<p>useReducer可以通过action的合理设计来减少模板代码，但是在增加新功能的时候，需要声明action、reducer处理逻辑，随着业务的迭代这些模板类代码会越来越重，这里引入的mobx方案去解决这个问题</p>\n<h3>对封装的思考</h3>\n<p>在业务迭代比较频繁的模块，可以通过封装简单的util函数来达到代码的复用能力。随着业务迭代，直接对整体业务模块的封装会导致代码的可理解性、可维护性下降。（这里讨论的问题并不是降低封装而是延迟封装）<br>\n在下图中，有多个业务处理模块都有使用A处理逻辑，但是在后续的模块中对A逻辑的能力都有限制和修改。如果在初期就抽离出A逻辑就会导致A逻辑中引入了后续模块的特定逻辑进而降低该模块的可维护性。在进行业务修改的时候覆盖的范围也是扩大的。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 612px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 128%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt2E0FikKX/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQABBQJP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwJP/8QAGhAAAwADAQAAAAAAAAAAAAAAAAEREFFhcf/aAAgBAQABPyG9PcVlfgil4Ii0Rax//9oADAMBAAIAAwAAABC8I8D/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAeEAEAAgEFAQEAAAAAAAAAAAABABEhMUFRYXGRof/aAAgBAQABPxB1YeXBc2OqYPcbnO/M5P1dxXebzFW4fYK3I9qJz0zepfks1HyAGgE//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"封装\"\n        title=\"封装\"\n        src=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg\"\n        srcset=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/0479a/module.jpg 250w,\n/blog/static/bd72f3db3c4c906ece570c5b72b785c1/41099/module.jpg 500w,\n/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg 612w\"\n        sizes=\"(max-width: 612px) 100vw, 612px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n比较好的思路是在业务比较稳定的时候再对A逻辑进行区分，在组织逻辑上通过入口划分不同的业务细节。</p>\n<p>以上就是自己在业务代码优化上的一些实践和思考。代码的优化并不是一蹴而就的，是渐进式的。最开始的设计相当于建筑的地基，这个地基的好坏能一定程度上为项目保驾护航。代码的优化则是自身对业务理解梳理，对功能实现的总结思考，相当于对建筑的添砖加瓦，是个有意思的过程。</p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"记一次项目代码优化","date":"2022-04-06","tags":"工程化","path":"/code-refactor","top":null,"summary":null}}},{"node":{"id":"b1129eb4-7e02-5c11-a5be-9651c06a747d","html":"<h2><a href=\"https://timothygu.me/es-howto/\">How to Read the ECMAScript Specification</a></h2>\n<p>这篇文章介绍如何阅读ECMAScript规范的一些思路，文章中有对规范章节内容的整体划分和规范写法的例子解读.规范比较难啃，可以通过例子熟悉规范的写法，在自己需要了解相关内容的时候去阅读规范</p>\n<h2><a href=\"https://dev.to/this-is-learning/conquering-javascript-hydration-a9f\">Conquering JavaScript Hydration</a></h2>\n<p>前端框架的服务端渲染可以在服务端输出组件的内容(html, data-fetch)，一定程度上加快FCP(First Contentful Paint).在用户侧浏览器根据服务端提供的内容执行前端脚本完成事件的绑定和组件相关逻辑的执行，这个过程称为Hydration(注水)。在Hydration过程中页面仍然是不可交互的，造成了页面可交互的假象。所以尽量减少在Hydration中执行的逻辑是优化性能的一个方向。这篇文章给出了这个方面的一些思考。</p>\n<h2><a href=\"https://www.chakshunyu.com/blog/a-fundamental-guide-to-react-suspense/\">A Fundamental Guide To React Suspense</a></h2>\n<p>这篇文章详细地介绍的React中使用Suspense解决问题的背景和优点。</p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍列举了React中一些通用的解决方案和工具库，包括状态管理、项目结构、代码规范等。</p>\n<h2><a href=\"https://uniqname.medium.com/why-i-avoid-async-await-7be98014b73e\">Why I avoid async/await</a></h2>\n<p>这篇文章介绍了作者对使用async/await的一些思考，主要的观点心智的转换和写法上的比较。async/await表面上将异步代码转换成同步代码的写法一定程度上改变了代码的运转模式。</p>\n<h2>ECMAScript规范</h2>\n<h3><a href=\"https://2ality.com/2022/03/properties-of-primitives.html\">How do primitive values get their properties?</a></h3>\n<p>这篇文章介绍ECMAScript语法层面上对初值的封装逻辑、属性的获取逻辑、方法的调用逻辑。</p>\n<h3><a href=\"https://github.com/tc39/proposal-type-annotations\">proposal-type-annotations</a></h3>\n<p>tc39新增Type Annotations的proposal,现在处于stage 1阶段。未来有可能javascript直接支持类型定义，可以理解ECMAScript在吸收javascript超集的优点。</p>\n<h3><a href=\"https://2ality.com/2022/04/shadow-realms.html#shadowrealm.evaluate()\">ShadowRealms – an ECMAScript proposal for a better eval()</a></h3>\n<p>这篇文章对ShadowRealms proposal进行了详细的介绍，现在处于stage 3阶段。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/nolimits4web/atropos\">atropos</a></h3>\n<p>atropos是一个做3D触摸特效的动画库</p>\n<h3><a href=\"https://stuk.github.io/jszip/\">JSZip</a></h3>\n<p>JSZip是一个JavaScript操作zip文件的库</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":4,"pageCount":15,"additionalContext":{"pageAllCount":88}}},"staticQueryHashes":[]}