{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/",
    "result": {"pageContext":{"pageAllCount":96,"group":[{"node":{"id":"6b14bd4d-1cc8-57ef-b81a-bdbe405e6d96","html":"<h2>1.0 - 2017-02-25</h2>\n<blockquote>\n<p>在这里记录下学习前端的过程。最近在博客园写自己之前的博客的时候，发现自己不是很善于描述东西，也发现博客园的书写体验没那么好，之前一直想弄一个这样的博客，这就算成型了。<br>\n希望通过这个博客来锻炼自己表达的能力同时起到督促自己目的。</p>\n</blockquote>\n<h2>2.0 - 2021-04-08</h2>\n<p>看到这个文档上次的修改记录已经是三年之前了,个人的博客在三年中有一直保持更新(虽然频率上😢不高).应该在去年建了一个公众号-前端小板凳和掘金账号.\n小板凳的初衷是我能跟大家一起坐在板凳上一起学习进步(我要是在胖下去 小板凳要变成大板凳了➳♥゛扎心),最近重新理了下思路以后小板凳和这个博客会主要以如下的内容进行更新(虽然搞不好哪天就不更了).\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVQ4y4WTW27bMBBFvfkC/elG0gL96Bby0zU0sRtbUiQ/JFKkxJfEU4iObSmNWwIEyBnO697LFW8rxpj2tNpWUdc1LoDqHFVVkRcFzrnr2/cxl/vqYjw7IsbB/nAiz3M6C6I1PK/XlGVFCOFuosv9lvDNaf3s4dStNuz3e6x1DMNACMMiwbIhWL2v0jvIipL1ek3bR6qjZrPZIISkrhuU1peARZezkWEYIQyRYTwn9D7gncMH6I1HqXYRNHU6xsg4jmnPu12dB7tVcn5ZWXeGXZahdYcNUJZ7mkYyRJCtQgix7FCbyLfHyMNj5MfPiOwhL0q2ux2diXQmIKXAOo/1E2EHXssDjdDkecHLy5bT6cQwjmcMawWfHuDz18iX75FGwzAEvPcJiq63STbWj3Q2opRCa40xPcbYhOkks/GSkAWnERfmcoBWTSwfkmTOmC2J+ICUmACegqfzpL3itSLLdigDeSkTy00jrlqdS+Uv2dwM5yrGRYx1WGsSZrXoF8D/V9hz45R1+inGWpzzyS6k4tfTE1LKNLa19orX3a83d04jZ3nJ8+Y3ou2RsuV4PNI0TQK/ESIRdjfh0hETs3Uj2G53lFX1TwI+GvkP6qVFIVq+nLwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"技术路线\"\n        title=\"技术路线\"\n        src=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png\"\n        srcset=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/63868/road.png 250w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/0b533/road.png 500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png 1000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/aa440/road.png 1500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/e8950/road.png 2000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png 2270w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>前端基础</h3>\n<ol>\n<li><a href=\"https://html.spec.whatwg.org/#toc-browsers\">HTML Standard</a> html标准</li>\n<li><a href=\"https://tc39.es/ecma262/\">javascript标准</a></li>\n<li>网络基础知识</li>\n</ol>\n<h3>前端框架</h3>\n<ol>\n<li>react</li>\n<li>前端状态管理(redux, hook, Mobx)</li>\n<li>next.js</li>\n<li>webpack</li>\n</ol>\n<h3>横向技术</h3>\n<ol>\n<li>跨端(端)技术</li>\n</ol>\n<ul>\n<li>跨端技术 flutter taro</li>\n<li>端技术 Android/ IOS</li>\n</ul>\n<ol start=\"2\">\n<li>服务端技术</li>\n</ol>\n<ul>\n<li>node.js egg.js(如何构建一个高可用的服务端系统)</li>\n<li>go</li>\n</ul>\n<h3>解决方案</h3>\n<ol>\n<li>微前端方案</li>\n<li>离线化(预加载)</li>\n<li>拆包</li>\n<li>骨架</li>\n<li>服务端渲染</li>\n</ol>\n<h3>工程化</h3>\n<ol>\n<li>服务部署运维(docker Kubernetes)</li>\n</ol>\n<h3>思考(做事方式)</h3>\n<p>这里会记录一些思考,会随着自己的认知定期修改这部分内容.一些内容会沉淀成记录\n要从把事做完到做好到做广.</p>\n<ol>\n<li>数据 => 业务</li>\n<li>做好监控(用户行为 异常监控)</li>\n<li>如何能做到业务技术两手抓</li>\n<li>探索推进业务的方式(往前看 多聊, 视角的切换(长期短期 用户视角))</li>\n<li>先想好在做 别急 这点不容易</li>\n</ol>\n<p>希望2.0版本能把我们的知识串成一个网,一起把事做好.希望事情会因你不同.</p>\n<h2>3.0-2022-04-12</h2>\n<p>距离上次更新这个文档差不多刚好一年的时间，博客的内容也大致按照之前2.0版本的内容在更新(万幸没有断更)。3.0版本的内容会在2.0的基础上更加<strong>系统化</strong>。这里对3.0版本的内容做下diff:</p>\n<ul>\n<li>形式上会结合做过的事或者看过的内容，结合自己的想法总结和输出(虽然有些想法比较基础和简单)，也是想在自己这边能把一些东西揉碎想明白的一种尝试，现在主要有以下两种方式:\n<ol>\n<li><a href=\"https://icantunderstand.github.io/blog/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\"><strong>前端快报</strong></a>收录近期阅读的前端技术类文章，月维度更新</li>\n<li><a href=\"https://icantunderstand.github.io/blog/%E8%AF%BB%E4%B9%A6%E7%9B%AE%E5%BD%95/\"><strong>读书目录</strong></a>收录自己读过的书和阅读过程中的一些想法，采取了打分推荐的方式(有个人喜好)，根据读书进度实时更新。</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"初心","date":"2019-07-10","tags":"思考","path":"/my-heart","top":true,"summary":null}}},{"node":{"id":"efb8a435-cea5-59e6-bc37-3b2058087a28","html":"<ul>\n<li>要有刨根问底的精神</li>\n<li>多思考这件事为什么是这样</li>\n<li>提取事物相同的模式 从更上层或者多角度去看相似的问题</li>\n<li>有深度的刻意练习才能产生提高</li>\n<li>做技术 可以从技术角度去产生技术方案也可以从用户产品视角去思考技术 不要把这两个孤立开来</li>\n</ul>\n<h2>跨端的本质</h2>\n<p>一句话概括: 如何技术手段以较低成本和较高的稳定性实现端业务的快速发展\n在讨论具体的跨端方案时，先看几个在选择跨端方案的场景</p>\n<table>\n<thead>\n<tr>\n<th>目标</th>\n<th>考量点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>动态化</td>\n<td>1. 包体积问题是一个app发展到一定阶段必定要考量的问题，也是一些大厂在内部推动跨端方案的一个核心诉求 2. 业务动态化诉求(快速迭代/动态更新)</td>\n</tr>\n<tr>\n<td>人效</td>\n<td>跨端方案可以实现一次开发多端使用，提升人效 1. 原生能力需要端接入或者端技术能力，长期需要多端技术能力 2. 多端展现存在差异，需要开发中磨平 3. 通常说跨端都从h5(动态化技术)的视角切入，h5和native不是非此即彼的关系，事是大家的</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>技术方案存在性能瓶颈，通过其他技术方案可以解决性能问题，优化业务体验</td>\n</tr>\n<tr>\n<td>技术基建能力</td>\n<td>1. 技术储备 2. 业务在不同技术方案下探索(小程序)</td>\n</tr>\n</tbody>\n</table>\n<h2>react理念(特点)</h2>\n<ul>\n<li>\n<p>数据驱动视图，MVVM框架</p>\n</li>\n<li>\n<p>虚拟Dom，可以实现多平台renderer和渲染优化</p>\n</li>\n<li>\n<p>组件化思维，更好的抽象/组合/代码复用</p>\n</li>\n<li>\n<p>函数式编程</p>\n</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"想法片段总结","date":"2020-12-21","tags":"思考","path":"/idea","top":true,"summary":null}}},{"node":{"id":"8bfa89f7-11b7-5efe-8eff-ce127cdb3e82","html":"<p>在<a href=\"https://icantunderstand.github.io/blog/2024-4-1\">板凳快报4月</a>中聊到了react组件中hooks的使用泛滥问题，当hooks使用过多会有如下的问题:</p>\n<ul>\n<li>代码阅读性差，逻辑分散</li>\n<li>性能差 过多的hooks更新会导致页面多次渲染，</li>\n<li>hooks之间的依赖耦合增加  本身hooks的依赖就已经很难治理，hooks之间的依赖更加不可控。</li>\n</ul>\n<p>在思考这个怎么解决这个问题的时候，希望可以通过规则限制的解法来解，因为只有可定义的规则才能在长期的代码维护中一直比较好的运行，在规则与人工review的结合下就能比较好的实现代码的长期治理。本文内容主要基于此，介绍eslint插件的开发过程和react hooks数量限制插件的使用</p>\n<h2>开发eslint插件</h2>\n<h3>生成插件项目</h3>\n<p>eslint提供了生成插件的工具<a href=\"https://github.com/eslint/generator-eslint\">generator-eslint</a></p>\n<pre><code>// 安装全局依赖\nnpm i -g yo\nnpm i -g generator-eslint\n\n// 进入到插件目录，生成插件模版\ncd testPlugin\nyo eslint:plugin\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 459px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d5cc76478b75cae9f4320f91e10e6e38/48711/createFolder.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSElEQVQY032P23KCMBCGA7XTKYpWBKylHEQ8QMIpCRCCHNSLvv8bdYLctjPf7uz+O7uzP1gkxTqvNgVfY7bBzGKtgggIkBRAcIikAEoBlI9QPkHpCOWxfSovJwjUtDr1j01empRbVevw3msGHTMtK2fHBOwj4I244VT4ULAfeUfUb+8faWEWza5sLNa5Tf/Nul11NWm9jOkyoQtETMqVMJ9DPAticfF5Yp4UQXvfktpirUm53921vLJ57zbDWHR23bnNsG9vBmZ+e/tIy9eISgESy28R/mStmldm0Ti8Dx8/OmZ23emYrdJSyyoVUYPwZUx1XBukNjCbIyqfc7EsfrhkABIFErvuHN5vaa3lFfAuwuF+xAun7IWT6I+fAx9KkICYqlnpXQdHGL6u01LoB/QXk2cR5xRcMgWRr7IxCFslhXyA0/hffgFEoEIJj3nRfgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建文件\"\n        title=\"创建文件\"\n        src=\"/blog/static/d5cc76478b75cae9f4320f91e10e6e38/48711/createFolder.png\"\n        srcset=\"/blog/static/d5cc76478b75cae9f4320f91e10e6e38/63868/createFolder.png 250w,\n/blog/static/d5cc76478b75cae9f4320f91e10e6e38/48711/createFolder.png 459w\"\n        sizes=\"(max-width: 459px) 100vw, 459px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>开发调试</h3>\n<p>在创建的文件夹中，在rules中增加自定义的规则。在这里我们要限制hooks的数据，添加了no-too-many-hooks.js,内容如下:</p>\n<pre><code>\"use strict\";\nmodule.exports = {\n    meta: {\n        docs: {\n            // 规则描述\n            description: \"no too many hooks\",\n            category: \"\",\n            recommended: false\n        },\n        fixable: null,  // or \"code\" or \"whitespace\"\n        // 规则的参数配置 这里设置了两个参数 list代表要关注的hooks列表，numLimit代表限制的数目\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                list: {\n                    type: \"array\",\n                },\n                numLimit: {\n                    type: \"number\"\n                }\n                },\n                additionalProperties: false,\n            },\n        ],\n        // 报错信息描述\n        messages: {\n            hooksLimit: \"too many hooks you called\",\n        },\n    },\n\n    create: function(context) {\n        // 累积的hooks数目\n        let currentNum = 0\n        return {\n            // 解析ast的节点 可以通过[astexplorer](https://astexplorer.net/)来查看对应的节点\n            'CallExpression Identifier': (node) => {\n                // 获取当前的配置\n                const options = context.options[0] || {}\n                const list = options.list || ['useState']\n                const numLimit = options.numLimit || 5\n                // 命中 当前是hook调用\n                if (list.includes(node.name)) {\n                    // 累积数自增\n                    currentNum++\n                    // 当前的累积数大于等于配置的数据 报错 匹配到too many hooks you called\n                    if(currentNum >= numLimit) {\n                        context.report({\n                            node,\n                            messageId: 'hooksLimit'\n                        });\n                    }\n                    \n                }\n            },\n        };\n    }\n};\n</code></pre>\n<p>在入口文件中导出规则</p>\n<pre><code>\"use strict\";\nmodule.exports = {\n    rules: {\n        // 规则名字\n        'no-too-many-hooks': require('./rules/no-too-many-hooks'),\n    },\n    configs: {\n        // 定义推荐用法 在使用的时候可以通过recommended或者自己添加当前rule的规则来设定\n        recommended: {\n            rules: {\n                'hooks-limit/no-too-many-hooks': [1, { list: [\"useEffect\", \"useState\", \"useCallback\"], numLimit: 5 }], // 可以省略 eslint-plugin 前缀\n            },\n        },\n    },\n};\n</code></pre>\n<p>在开发过程中，需要不断调试当前代码是否生效，可以通过npm link的方式，在插件的目录执行</p>\n<pre><code>npm link  \n</code></pre>\n<p>在需要使用插件的目录执行</p>\n<pre><code>npm link eslint-plugin-hooks-limit(定义的插件名字)\n</code></pre>\n<h2><a href=\"https://www.npmjs.com/package/eslint-plugin-hooks-limit\">eslint-plugin-hooks-limit</a></h2>\n<h3>安装插件</h3>\n<pre><code>// 安装eslit\nnpm i eslint --save-dev\n// 安装插件\nnpm install eslint-plugin-hooks-limit --save-dev\n\n// 在项目的eslint配置中加入配置 这里设置2个hooks的调用触发eslint的waring\n{\n    \"extends\": [\n        \"next/core-web-vitals\",\n        \"plugin:eslint-plugin-hooks-limit/recommended\"\n    ],\n    \"plugins\": [\n        \"hooks-limit\"\n    ],\n    \"rules\": {\n        \"hooks-limit/no-too-many-hooks\": [2, { \"list\": [\"useEffect\", \"useState\"], \"numLimit\": 2 } ] // 可以省略 eslint-plugin 前缀\n    }\n} \n</code></pre>\n<p>假设react组件中有这样一段代码:</p>\n<pre><code> useEffect(() => {\n    console.time();\n}, [])\nuseEffect(() => {\n    console.time();\n}, [])\n</code></pre>\n<p>这个时候运行项目的lint脚本\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bc351a5e58200d9eaf8c5fa11931db9d/25260/linInfo.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVQY03XPSw6DMAxF0ayCOLIdf4GkA/a/vAoqmKCegXU9fEVE5pzuToi1VgB4338KdbZYUawhthsAtAZP1z8KCqZ7bHtue2bGxd0iwtwzQ1XphZmJqJBYrusc4zPnGOM4Dndn5i7SL9JFVc1M5aSq7mZmIloaQHtG3DvflmW54+zf+wV4oiC+TrPnpgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"lint报错信息\"\n        title=\"lint报错信息\"\n        src=\"/blog/static/bc351a5e58200d9eaf8c5fa11931db9d/00d43/linInfo.png\"\n        srcset=\"/blog/static/bc351a5e58200d9eaf8c5fa11931db9d/63868/linInfo.png 250w,\n/blog/static/bc351a5e58200d9eaf8c5fa11931db9d/0b533/linInfo.png 500w,\n/blog/static/bc351a5e58200d9eaf8c5fa11931db9d/00d43/linInfo.png 1000w,\n/blog/static/bc351a5e58200d9eaf8c5fa11931db9d/25260/linInfo.png 1113w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<hr>\n<h2>ps: lint插件写的比较简单，大家可以自己根据代码自己修改使用</h2>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"react hooks过多，你需要这个eslint插件","date":"2024-04-18","tags":"工程化","path":"/eslit-plugin","top":null,"summary":null}}},{"node":{"id":"07e87675-1f6b-534f-90d0-a7fd71b800c3","html":"<h2><a href=\"https://github.com/tc39/proposal-iterator-helpers\">proposal-iterator-helpers</a></h2>\n<p>tc39增加了迭代器helpers函数的proposal.已经到了Stage 3阶段。通过这些迭代函数可以很方便的对迭代器进行处理。比如</p>\n<pre><code>    function* naturals() {\n        let i = 0;\n        while (true) {\n            yield i;\n            i += 1;\n        }\n    }\n\n    const result = naturals()\n    .map(value => {\n        return value * value;\n    });\n    result.next(); //  {value: 0, done: false};\n    result.next(); //  {value: 1, done: false};\n    result.next(); //  {value: 4, done: false};\n</code></pre>\n<h2><a href=\"https://github.com/proposal-signals/proposal-signals\">proposal-signals</a></h2>\n<p>tc39增加了signals的proposal。现在是Stage 0阶段。在<a href=\"https://www.solidjs.com/\">solidjs</a>中就有对signals的封装和使用。通过signals可以一定程度上简化在业务逻辑中的依赖关系覆盖和监听逻辑。</p>\n<h2><a href=\"https://itnext.io/frontend-development-beyond-react-svelte-1-3-f47eda22cba5\">Frontend Development Beyond React: Svelte</a></h2>\n<p>这篇文章介绍Svelte的基本原理和相关使用。对比react，Svelte的没有虚拟dom、有编译时优化、响应式更加高效。React也在编译时优化做尝试，React Compiler已经在instagram有使用</p>\n<h2><a href=\"https://www.lydiahallie.com/blog/promise-execution\">JavaScript Visualized: Promise Execution</a></h2>\n<p>这篇文章通过动图的方式介绍JavaScript中Promise的执行过程</p>\n<h2><a href=\"https://romgrk.com/posts/react-functional-components/\">The problem with functional components</a></h2>\n<p>在之前的文章中<a href=\"https://icantunderstand.github.io/blog/thinking-in-react\">聊聊我对React Hooks的理解</a>中,梳理了对react引入hooks的理解</p>\n<ul>\n<li>通过的代码复用方式</li>\n<li>解决老的问题 比如生命周期函数可能存在多次调用、组件内监听解绑逻辑分离</li>\n<li>规范使用范式</li>\n</ul>\n<p>这篇文章的作者通过例子说明在使用函数组件的一些问题，比如hooks很多缺少治理，hooks的依赖问题，代码可读性问题等。对于这个问题的确在react中没有强制的一些限制解法。自己在开发中也遇到一个组件多个useState声明造成代码可读性下降的问题。对于函数组件的hooks它更应该是可插拔的复用能力或者偏向于与组件结合的业务逻辑，一些数据或者非视图层逻辑应该做到更好的拆分.</p>\n<h2><a href=\"https://miaomiaozhenren.com/index.php/2023/01/20/dynamic-form/\">动态表单的设计思想及实现策略</a></h2>\n<p>这篇文章主要介绍动态表单的设计思想，在中后台系统的一些表单项是可以通过动态表单来实现的。</p>\n<h2><a href=\"https://web.dev/articles/bfcache?ref=sabatino.dev&#x26;hl=zh-cn\">bfcache</a></h2>\n<p>浏览器的往返缓存，在一些特定场景需要针对bfcache做处理逻辑</p>\n<h2>工具</h2>\n<h3><a href=\"https://bun.sh/blog/bun-v1.1\">Bun</a></h3>\n<p>Bun现在支持windows了，Bun选择的JavaScript执行引擎和实现语言使得Bun有一定的性能优势，值得尝试</p>\n<h3><a href=\"https://github.com/yocontra/react-responsive\">react-responsive</a></h3>\n<p>一个用于在react代码中做媒体查询实现动态逻辑的库。在阅读源码的过程中发现它使用了css-mediaquery实现静态查询的匹配</p>\n<pre><code>    var mediaQuery = require('css-mediaquery');\n    \n    var isMatch = mediaQuery.match('screen and (min-width: 40em)', {\n        type : 'screen',\n        width: '1024px'\n    });\n</code></pre>\n<p>使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia\">window.matchMedia</a>做动态的查询变更通知能力</p>\n<h3><a href=\"https://previewjs.com/\">Preview.js</a></h3>\n<p>Previerw.js可以实现一些UI组件的预览，可以实现动态属性修改的预览、控制台的console输出、不同设备下查看样式等</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/astoilkov/use-local-storage-state\">use-local-storage-state</a></h3>\n<pre><code>    import useLocalStorageState from 'use-local-storage-state'\n\n    export default function Todos() {\n        const [todos, setTodos] = useLocalStorageState('todos', {\n            defaultValue: ['buy avocado', 'do 50 push-ups']\n        })\n    }\n</code></pre>\n<p>在之前的<a href=\"https://icantunderstand.github.io/blog/window-message\">聊聊页面间的通信机制</a>中有介绍到localStorage可以实现跨Tab的消息通信，在前端的数据存储中localStorage是一种常用的前端存储方案，use-local-storage-state这个库实现了数据的存储和数据的变更通知，下面分别从这两个点看下具体实现</p>\n<h3>数据存储</h3>\n<pre><code>try {\n    // 支持localStorage的时候使用localStorage存储\n    localStorage.setItem(key, stringify(value))\n    inMemoryData.delete(key)\n} catch {\n    // 不支持localStorage的时候使用内存对数据存储\n    inMemoryData.set(key, value)\n}\n</code></pre>\n<h3>数据变更通知</h3>\n<pre><code>   const value = useSyncExternalStore(\n    useCallback(\n        (onStoreChange) => {\n            const onChange = (localKey: string): void => {\n                if (key === localKey) {\n                    onStoreChange()\n                }\n            }\n            // callback注入，当onStoreChange执行 会触发页面更新\n            callbacks.add(onChange)\n            return (): void => {\n                callbacks.delete(onChange)\n            }\n        },\n        [key],\n    ),\n    () => {\n        // 通过ref存储当前的值 返回\n    },\n    () => defaultValue,\n)\n\nuseEffect(() => {\n    // 当不需要通知同步的时候直接返回\n    if (!storageSync) {\n        return undefined\n    }\n    const onStorage = (e: StorageEvent): void => {\n        if (e.storageArea === goodTry(() => localStorage) &#x26;&#x26; e.key === key) {\n            triggerCallbacks(key)\n        }\n    }\n    // 订阅storage 触发更新回调\n    window.addEventListener('storage', onStorage)\n\n    return (): void => window.removeEventListener('storage', onStorage)\n}, [key, storageSync])\n</code></pre>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"2024-4-第一期","date":"2024-04-15","tags":"前端快报","path":"/2024-4-1","top":null,"summary":null}}},{"node":{"id":"1b4968b4-2a2a-5a14-9be0-5e4ab155f789","html":"<p>通常在登录系统的时候，服务端会通过设置Cookies来实现用户登录信息的存储</p>\n<pre><code>Set-Cookie: &#x3C;cookie-name>=&#x3C;cookie-value>; Expires=&#x3C;expiration-date>; Path=&#x3C;path>; Domain=&#x3C;domain>; Secure; HttpOnly\n</code></pre>\n<p>在用户二次登录的时候，相同域的cookies会随着用户请求发送到服务端，服务端会根据session中保存的信息校验，完成用户对特定资源的访问。在实际系统中，比如同公司的不同子系统如果登录态不能共享，就会造成不好的用户体验，比如你在一个购物app里面，商品页是电商系统，下单支付页是财务系统的。如果在正常下单跳转到下单支付页弹出登录框，那觉得是个P000的问题。所以这就引出了单点登录系统的实现。下面主要从同域名下单点登录和不同域名下的单点登录展开。</p>\n<h2>同域下的单点登录</h2>\n<p>在设置cookies的时候，我们可以指定cookies的path。那么假设现在有下面的场景。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5a822e779b8a65d7c5552bde52e673de/2edea/sameSite.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd5NQD//xAAVEAEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAQABBQJa/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGxAAAQQDAAAAAAAAAAAAAAAAAQAQETEhUWH/2gAIAQEAAT8hABIU7wp61U3/2gAMAwEAAgADAAAAEPPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAQEBAAMAAAAAAAAAAAAAAREAITFRcf/aAAgBAQABPxAzVHFFr6xRTjQ9YDgTed//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"同域名单点登录\"\n        title=\"同域名单点登录\"\n        src=\"/blog/static/5a822e779b8a65d7c5552bde52e673de/a2510/sameSite.jpg\"\n        srcset=\"/blog/static/5a822e779b8a65d7c5552bde52e673de/0479a/sameSite.jpg 250w,\n/blog/static/5a822e779b8a65d7c5552bde52e673de/41099/sameSite.jpg 500w,\n/blog/static/5a822e779b8a65d7c5552bde52e673de/a2510/sameSite.jpg 1000w,\n/blog/static/5a822e779b8a65d7c5552bde52e673de/2edea/sameSite.jpg 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n有两个子系统xxx.test.com和ccc.test.com要实现在登录任何一个系统之后，都不需要再登录就能访问到另外的一个系统。\n两个子系统其实不需要维护相关的登录逻辑，只需要将登录代理给统一的域名登录系统sso.test.com来实现即可，在实现子系统间相互登录的时候需要注意:</p>\n<ul>\n<li>登录系统在设置cookies的时候，可以设置到根域名下，也就是上面的例子设置到test.com上，这样用户访问xxx.test.com和ccc.test.com的时候都能携带上设置的cookies</li>\n<li>登录的session可以通过一些session共享技术实现</li>\n</ul>\n<h2>不同域下的单点登录</h2>\n<p>不同域下的单点登录不能使用cookies来实现，因为cookies有域名限制。实现单点登录的方式有CAS(Central Authentication Service),OAuth(主要用于授权第三方登录)，JWT安全令牌等方式，下面主要介绍CAS的实现方式\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 737px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/d125e/sso.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAIAAAC+dZmEAAAACXBIWXMAAAsTAAALEwEAmpwYAAADN0lEQVQ4y5VTWY7cRBjum3AQTsMBuAOvnIEDJMATL0wSCSkSgigkg0KGYTJMuttLt5dyuVz7+lcVsj2jWWAE/E+2/H9V3+ZNubs6ffVDcXkanJE+nFD6ddN8YCwDvFXqade9RANAUMwW78n27SSpBQgxxnEcN3woqjdPq5+/ihIPOX+C8eb01y/LKuf8mVKb388//e0sZxgr/90X9Tefo/7K5GU45xslhWJYUiQFV8acU/qeMR5CznkI4UKpo5m3ISSGDOtdcJByyjkzxjbeB82JUtI6l5w7av2yrh2leCLgHGidY0xp3o8JUoo55/n1FsyQ1XIlU8V40rZeCKkVJqRuGkKps84HV23baeBSCi7EDTgERRFn03xmjEUIrwhhfd8PA+fce59SAoCcc79nuw8H67TW+hYsKSLjYJ2P1m61frbbTV2H8NA0DcbYWmuMcd619WCU+zvtQUkOKeUY996/5jynBItUay0AhNm/VF/hP959xCMSt7QXsNFi1VwCvJGz/ri8wmL7elVf8Muz/Ugw6tF1VA/AFcBPhOSlByEEjHEIYdGc2j0tr1omKCHkEXCMP2KcrZVa931XV1WPkNbGB3csey3tP2i+S/u1EDmlEKNzbrbKOYBZRLufij+PTNA7bt+A59PSDP5l8WPRnIwxKaUU54/tll282xEyIDQIISila8Pw3ZI8Pxw851JrJWXXddbaECDliBvOic45BR9SjGvOICmiBJNp0pQWzp00jed8JERJmRd56wBAjA/qGYJiM1hrbY3GnB3GMQEEAGPMDuN7YJjDv28YH7S6NmzOx7mYUgTIKT+pD2Vdl0VBCDHGrD191O0Y47qxzvfTxNjcdCFZ/RE1JVJKPNqwh2BCvHOETBDDUItjMfhg16j4fwH3Xde2Xdu1xfagpfsftJ8zlq8Nyt2eXZ7t8ThQSlNK/w5+RmmKkXORcuz27Oq8UlpM03RdEue8okhLvvK5+QHzGum3TdP1PUJoohMZuNX+Hm2AqDmWgq1XUTrhJdt148U4Wu+DnydGWENOy7lCiE1VVcfjoWmO7TJN0xyPN89tWxwOqL+epmnqqt7tdrvttizLi4uLvwCQgY3VfIS/ggAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"CAS登录流程\"\n        title=\"CAS登录流程\"\n        src=\"/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/d125e/sso.png\"\n        srcset=\"/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/63868/sso.png 250w,\n/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/0b533/sso.png 500w,\n/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/d125e/sso.png 737w\"\n        sizes=\"(max-width: 737px) 100vw, 737px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上图中系统1和系统2是两个独立的系统，在登录系统的时候有如下的步骤:</p>\n<h3>未登录态下登录流程</h3>\n<ul>\n<li>如果系统1中没有登录，会跳转到SSO系统中进行校验，发现SSO系统也没有登录，弹出用户登录页</li>\n<li>用户填写用户名、密码登录SSO系统，SSO系统写入SSO域的cookies并且在SSO系统保存登录session</li>\n<li>SSO系统返回给系统1一个ST(Service Ticket),跳转到系统1</li>\n<li>系统1拿到获取到的ST，去向SSO后台进行校验，ST有效则在系统1写入当前登录的session和系统1域下的cookies</li>\n</ul>\n<h3>已登录下流程</h3>\n<p>用户已经登录SSO系统，此时他尝试登录系统2</p>\n<ul>\n<li>系统2校验当前用户未登录，跳转到SSO系统</li>\n<li>SSO系统中用户是已登录状态，SSO会跳转回系统2并且携带ST</li>\n<li>系统2用获取到的ST去SSO系统做令牌校验，ST有效则在系统2中写入当前登录的session和系统2域下的cookies</li>\n</ul>\n<h2>同域名和不同域名下单点登录的差异</h2>\n<ul>\n<li>session的状态  在同域名登录下session状态应该是可以共享或者不共享的，不同域名下session状态是不共享的</li>\n<li>服务端设置cookies的方式 他们都是在sso域下设置cookies，同域名刚好有cookies在同domain下可以共享，所以相对于不同域名下更简单一些。</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"从cookies再聊单点登录实现","date":"2024-04-05","tags":"前端基础","path":"/sso","top":null,"summary":null}}},{"node":{"id":"e7dba02a-4655-564c-ad4b-5a136e44fcf2","html":"<p>在浏览器中会涉及到一些跨页面的通信来完成一些特定的业务逻辑，下面梳理下一些跨页面通信相关的技术点。</p>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">postMessage</a></h2>\n<h3>postMessage用法解释</h3>\n<pre><code>otherWindow.postMessage(message, targetOrigin, [transfer]);\n</code></pre>\n<ul>\n<li>otherWindow 其他窗口的引用，比如iframe的contentWindow、执行window.open的返回的窗口对象、window.parent获取的父窗口对象。利用window.open返回的窗口对象可以实现跟新窗口的通信</li>\n<li>message 需要发送的数据，它会被结构化克隆算法序列化,无法被结构化克隆的数据会导致异常或者丢失属性，比如函数/原型链的丢失等</li>\n<li>targetOrigin 指定哪些源可以接收数据，这里就可以实现跨源的通信和安全控制</li>\n<li>transfer 可选的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Transferable_objects\">Transferable</a>对象</li>\n</ul>\n<h3>父子窗口通信</h3>\n<h4>父窗口发送消息给子窗口</h4>\n<p>在父窗口通过获取子iframe的conentWindow获取子窗口的引用，调用postMessage方法就可以实现对子窗口发送消息</p>\n<pre><code>// 父窗口发送消息\niframe.contentWindow.postMessage('message from parent', '*')\n\n// 子窗口监听消息\nwindow.addEventListener('message', function(event) {\n    // 处理接收到的消息\n    console.log(event.data);\n});\n</code></pre>\n<h4>子窗口发送消息给父窗口</h4>\n<p>子窗口通过window.parent获取父窗口的引用，调用postMesage方法就可以实现对父窗口发送消息</p>\n<pre><code>// 子窗口发送消息\nwindow.parent.postMessage('message from child', '*')\n\n // 父窗口监听消息\nwindow.addEventListener('message', function(event) {\n    // 处理接收到的消息\n    console.log(event.data);\n});\n</code></pre>\n<h2>浏览器不同tab间通信</h2>\n<p>跨tab通信有可能涉及到不同tab的数据同步逻辑，是一个相对常见的场景</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">localStorage</a></h3>\n<p>sessionStrage在chrome中打开同源的tab时候不会共享sessionStorage,所以主要介绍localStorage的实现方案.localStorage是在同域名下共享的浏览器存储，在同域的不同tab下监听localStorage的storage事件就可以实现跨tab通信</p>\n<pre><code>// 在第一个标签页中设置数据到 sessionStorage 中\nsessionStorage.setItem('message', 'Hello from Tab 1!');\n\n// 第二个标签页也打开当前页面 监听 storage 事件 接收其他标签页的数据\nwindow.addEventListener('storage', function(event) {\n    if (event.key === 'message') {\n        console.log('Received message in Tab 1:', event.newValue);\n    }\n});\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket\">WebSocket</a></h3>\n<p>这种方案依赖需要依赖服务服务端</p>\n<pre><code>// 建立websocke连接\nconst socket = new WebSocket(\"ws://localhost:8080\");\n\n// 连接建立，跟服务端发送事件，服务端对所有连接的websocket client广播事件\nsocket.addEventListener(\"open\", function (event) {\n    socket.send(\"Hello Server!\");\n});\n\n// 接收事件消息\nsocket.addEventListener(\"message\", function (event) {\n    console.log(\"Message from server \", event.data);\n});\n</code></pre>\n<p>使用websocket这种方案相对重，除非已有websocket长连接并且需要考虑websocket的断连造成的通信失败</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel\">BroadcastChannel</a></h3>\n<p>BroadcastChannel可以做到同源窗口间的通信能力.它基于发布-订阅的模式实现消息通知。</p>\n<pre><code>// 发送方逻辑\n// 创建BroadcastChannel 在实现跨tab通信的时候，创建BroadcastChannel的channelName需要是一个\nconst channel = new BroadcastChannel('myChannel');\n\n// 发送消息到其他标签页 \nchannel.postMessage('Hello from Tab 1!');\n\n// 监听方逻辑\n// 创建BroadcastChannel 与发送方channelName一致\nconst channe2 = new BroadcastChannel('myChannel');\n// 监听消息\nchanne2.onmessage = function(event) {\n    console.log('Received message in Tab 2:', event.data);\n};\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\">Service Worker</a>/<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker\">SharedWorker</a></h3>\n<p>Service Worker和SharedWorker方案类似，都是运行worker实现消息通信，下面主要举例SharedWorker的实现方案。</p>\n<h4>定义worker脚本</h4>\n<pre><code>// shared-worker.js\n// 定义一个变量来保存所有连接的客户端\nlet clients = [];\n\n// 监听连接事件\nself.addEventListener('connect', function(event) {\n    // 获取与该连接关联的端口\n    const port = event.ports[0];\n\n    // 将端口添加到客户端列表中\n    clients.push(port);\n\n    // 监听来自客户端的消息\n    port.addEventListener('message', function(event) {\n        // 广播消息给所有其他客户端\n        clients.forEach(function(client) {\n        if (client !== port) {\n            client.postMessage(event.data);\n        }\n        });\n    });\n\n    // 监听客户端关闭事件\n    port.addEventListener('close', function() {\n        // 从客户端列表中移除关闭的端口\n        clients = clients.filter(function(client) {\n        return client !== port;\n        });\n    });\n\n    // 向客户端发送连接成功消息\n    port.postMessage('Connected to SharedWorker.');\n});\n</code></pre>\n<h4>页面中加载脚本</h4>\n<pre><code>    // 在你的网页中连接到 SharedWorker\n    const worker = new SharedWorker('shared-worker.js');\n\n    // 监听连接成功事件\n    worker.port.addEventListener('message', function(event) {\n        console.log('Received message:', event.data);\n    });\n</code></pre>\n<h3>cookies</h3>\n<p>这种方案不大推荐，涉及到js可以通过脚本对cookies进行读写</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"聊聊页面间的通信机制","date":"2024-04-05","tags":"前端基础","path":"/window-message","top":null,"summary":null}}}],"pathPrefix":"","first":true,"last":false,"index":1,"pageCount":16,"additionalContext":{"pageAllCount":96}}},
    "staticQueryHashes": []}