{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/",
    "result": {"pageContext":{"pageAllCount":95,"group":[{"node":{"id":"6b14bd4d-1cc8-57ef-b81a-bdbe405e6d96","html":"<h2>1.0 - 2017-02-25</h2>\n<blockquote>\n<p>在这里记录下学习前端的过程。最近在博客园写自己之前的博客的时候，发现自己不是很善于描述东西，也发现博客园的书写体验没那么好，之前一直想弄一个这样的博客，这就算成型了。<br>\n希望通过这个博客来锻炼自己表达的能力同时起到督促自己目的。</p>\n</blockquote>\n<h2>2.0 - 2021-04-08</h2>\n<p>看到这个文档上次的修改记录已经是三年之前了,个人的博客在三年中有一直保持更新(虽然频率上😢不高).应该在去年建了一个公众号-前端小板凳和掘金账号.\n小板凳的初衷是我能跟大家一起坐在板凳上一起学习进步(我要是在胖下去 小板凳要变成大板凳了➳♥゛扎心),最近重新理了下思路以后小板凳和这个博客会主要以如下的内容进行更新(虽然搞不好哪天就不更了).\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVQ4y4WTW27bMBBFvfkC/elG0gL96Bby0zU0sRtbUiQ/JFKkxJfEU4iObSmNWwIEyBnO697LFW8rxpj2tNpWUdc1LoDqHFVVkRcFzrnr2/cxl/vqYjw7IsbB/nAiz3M6C6I1PK/XlGVFCOFuosv9lvDNaf3s4dStNuz3e6x1DMNACMMiwbIhWL2v0jvIipL1ek3bR6qjZrPZIISkrhuU1peARZezkWEYIQyRYTwn9D7gncMH6I1HqXYRNHU6xsg4jmnPu12dB7tVcn5ZWXeGXZahdYcNUJZ7mkYyRJCtQgix7FCbyLfHyMNj5MfPiOwhL0q2ux2diXQmIKXAOo/1E2EHXssDjdDkecHLy5bT6cQwjmcMawWfHuDz18iX75FGwzAEvPcJiq63STbWj3Q2opRCa40xPcbYhOkks/GSkAWnERfmcoBWTSwfkmTOmC2J+ICUmACegqfzpL3itSLLdigDeSkTy00jrlqdS+Uv2dwM5yrGRYx1WGsSZrXoF8D/V9hz45R1+inGWpzzyS6k4tfTE1LKNLa19orX3a83d04jZ3nJ8+Y3ou2RsuV4PNI0TQK/ESIRdjfh0hETs3Uj2G53lFX1TwI+GvkP6qVFIVq+nLwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"技术路线\"\n        title=\"技术路线\"\n        src=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png\"\n        srcset=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/63868/road.png 250w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/0b533/road.png 500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png 1000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/aa440/road.png 1500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/e8950/road.png 2000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png 2270w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>前端基础</h3>\n<ol>\n<li><a href=\"https://html.spec.whatwg.org/#toc-browsers\">HTML Standard</a> html标准</li>\n<li><a href=\"https://tc39.es/ecma262/\">javascript标准</a></li>\n<li>网络基础知识</li>\n</ol>\n<h3>前端框架</h3>\n<ol>\n<li>react</li>\n<li>前端状态管理(redux, hook, Mobx)</li>\n<li>next.js</li>\n<li>webpack</li>\n</ol>\n<h3>横向技术</h3>\n<ol>\n<li>跨端(端)技术</li>\n</ol>\n<ul>\n<li>跨端技术 flutter taro</li>\n<li>端技术 Android/ IOS</li>\n</ul>\n<ol start=\"2\">\n<li>服务端技术</li>\n</ol>\n<ul>\n<li>node.js egg.js(如何构建一个高可用的服务端系统)</li>\n<li>go</li>\n</ul>\n<h3>解决方案</h3>\n<ol>\n<li>微前端方案</li>\n<li>离线化(预加载)</li>\n<li>拆包</li>\n<li>骨架</li>\n<li>服务端渲染</li>\n</ol>\n<h3>工程化</h3>\n<ol>\n<li>服务部署运维(docker Kubernetes)</li>\n</ol>\n<h3>思考(做事方式)</h3>\n<p>这里会记录一些思考,会随着自己的认知定期修改这部分内容.一些内容会沉淀成记录\n要从把事做完到做好到做广.</p>\n<ol>\n<li>数据 => 业务</li>\n<li>做好监控(用户行为 异常监控)</li>\n<li>如何能做到业务技术两手抓</li>\n<li>探索推进业务的方式(往前看 多聊, 视角的切换(长期短期 用户视角))</li>\n<li>先想好在做 别急 这点不容易</li>\n</ol>\n<p>希望2.0版本能把我们的知识串成一个网,一起把事做好.希望事情会因你不同.</p>\n<h2>3.0-2022-04-12</h2>\n<p>距离上次更新这个文档差不多刚好一年的时间，博客的内容也大致按照之前2.0版本的内容在更新(万幸没有断更)。3.0版本的内容会在2.0的基础上更加<strong>系统化</strong>。这里对3.0版本的内容做下diff:</p>\n<ul>\n<li>形式上会结合做过的事或者看过的内容，结合自己的想法总结和输出(虽然有些想法比较基础和简单)，也是想在自己这边能把一些东西揉碎想明白的一种尝试，现在主要有以下两种方式:\n<ol>\n<li><a href=\"https://icantunderstand.github.io/blog/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\"><strong>前端快报</strong></a>收录近期阅读的前端技术类文章，月维度更新</li>\n<li><a href=\"https://icantunderstand.github.io/blog/%E8%AF%BB%E4%B9%A6%E7%9B%AE%E5%BD%95/\"><strong>读书目录</strong></a>收录自己读过的书和阅读过程中的一些想法，采取了打分推荐的方式(有个人喜好)，根据读书进度实时更新。</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"初心","date":"2019-07-10","tags":"思考","path":"/my-heart","top":true,"summary":null}}},{"node":{"id":"efb8a435-cea5-59e6-bc37-3b2058087a28","html":"<ul>\n<li>要有刨根问底的精神</li>\n<li>多思考这件事为什么是这样</li>\n<li>提取事物相同的模式 从更上层或者多角度去看相似的问题</li>\n<li>有深度的刻意练习才能产生提高</li>\n<li>做技术 可以从技术角度去产生技术方案也可以从用户产品视角去思考技术 不要把这两个孤立开来</li>\n</ul>\n<h2>跨端的本质</h2>\n<p>一句话概括: 如何技术手段以较低成本和较高的稳定性实现端业务的快速发展\n在讨论具体的跨端方案时，先看几个在选择跨端方案的场景</p>\n<table>\n<thead>\n<tr>\n<th>目标</th>\n<th>考量点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>动态化</td>\n<td>1. 包体积问题是一个app发展到一定阶段必定要考量的问题，也是一些大厂在内部推动跨端方案的一个核心诉求 2. 业务动态化诉求(快速迭代/动态更新)</td>\n</tr>\n<tr>\n<td>人效</td>\n<td>跨端方案可以实现一次开发多端使用，提升人效 1. 原生能力需要端接入或者端技术能力，长期需要多端技术能力 2. 多端展现存在差异，需要开发中磨平 3. 通常说跨端都从h5(动态化技术)的视角切入，h5和native不是非此即彼的关系，事是大家的</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>技术方案存在性能瓶颈，通过其他技术方案可以解决性能问题，优化业务体验</td>\n</tr>\n<tr>\n<td>技术基建能力</td>\n<td>1. 技术储备 2. 业务在不同技术方案下探索(小程序)</td>\n</tr>\n</tbody>\n</table>\n<h2>react理念(特点)</h2>\n<ul>\n<li>\n<p>数据驱动视图，MVVM框架</p>\n</li>\n<li>\n<p>虚拟Dom，可以实现多平台renderer和渲染优化</p>\n</li>\n<li>\n<p>组件化思维，更好的抽象/组合/代码复用</p>\n</li>\n<li>\n<p>函数式编程</p>\n</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"想法片段总结","date":"2020-12-21","tags":"思考","path":"/idea","top":true,"summary":null}}},{"node":{"id":"07e87675-1f6b-534f-90d0-a7fd71b800c3","html":"<h2><a href=\"https://github.com/tc39/proposal-iterator-helpers\">proposal-iterator-helpers</a></h2>\n<p>tc39增加了迭代器helpers函数的proposal.已经到了Stage 3阶段。通过这些迭代函数可以很方便的对迭代器进行处理。比如</p>\n<pre><code>    function* naturals() {\n        let i = 0;\n        while (true) {\n            yield i;\n            i += 1;\n        }\n    }\n\n    const result = naturals()\n    .map(value => {\n        return value * value;\n    });\n    result.next(); //  {value: 0, done: false};\n    result.next(); //  {value: 1, done: false};\n    result.next(); //  {value: 4, done: false};\n</code></pre>\n<h2><a href=\"https://github.com/proposal-signals/proposal-signals\">proposal-signals</a></h2>\n<p>tc39增加了signals的proposal。现在是Stage 0阶段。在<a href=\"https://www.solidjs.com/\">solidjs</a>中就有对signals的封装和使用。通过signals可以一定程度上简化在业务逻辑中的依赖关系覆盖和监听逻辑。</p>\n<h2><a href=\"https://itnext.io/frontend-development-beyond-react-svelte-1-3-f47eda22cba5\">Frontend Development Beyond React: Svelte</a></h2>\n<p>这篇文章介绍Svelte的基本原理和相关使用。对比react，Svelte的没有虚拟dom、有编译时优化、响应式更加高效。React也在编译时优化做尝试，React Compiler已经在instagram有使用</p>\n<h2><a href=\"https://www.lydiahallie.com/blog/promise-execution\">JavaScript Visualized: Promise Execution</a></h2>\n<p>这篇文章通过动图的方式介绍JavaScript中Promise的执行过程</p>\n<h2><a href=\"https://romgrk.com/posts/react-functional-components/\">The problem with functional components</a></h2>\n<p>在之前的文章中<a href=\"https://icantunderstand.github.io/blog/thinking-in-react\">聊聊我对React Hooks的理解</a>中,梳理了对react引入hooks的理解</p>\n<ul>\n<li>通过的代码复用方式</li>\n<li>解决老的问题 比如生命周期函数可能存在多次调用、组件内监听解绑逻辑分离</li>\n<li>规范使用范式</li>\n</ul>\n<p>这篇文章的作者通过例子说明在使用函数组件的一些问题，比如hooks很多缺少治理，hooks的依赖问题，代码可读性问题等。对于这个问题的确在react中没有强制的一些限制解法。自己在开发中也遇到一个组件多个useState声明造成代码可读性下降的问题。对于函数组件的hooks它更应该是可插拔的复用能力或者偏向于与组件结合的业务逻辑，一些数据或者非视图层逻辑应该做到更好的拆分.</p>\n<h2><a href=\"https://miaomiaozhenren.com/index.php/2023/01/20/dynamic-form/\">动态表单的设计思想及实现策略</a></h2>\n<p>这篇文章主要介绍动态表单的设计思想，在中后台系统的一些表单项是可以通过动态表单来实现的。</p>\n<h2><a href=\"https://web.dev/articles/bfcache?ref=sabatino.dev&#x26;hl=zh-cn\">bfcache</a></h2>\n<p>浏览器的往返缓存，在一些特定场景需要针对bfcache做处理逻辑</p>\n<h2>工具</h2>\n<h3><a href=\"https://bun.sh/blog/bun-v1.1\">Bun</a></h3>\n<p>Bun现在支持windows了，Bun选择的JavaScript执行引擎和实现语言使得Bun有一定的性能优势，值得尝试</p>\n<h3><a href=\"https://github.com/yocontra/react-responsive\">react-responsive</a></h3>\n<p>一个用于在react代码中做媒体查询实现动态逻辑的库。在阅读源码的过程中发现它使用了css-mediaquery实现静态查询的匹配</p>\n<pre><code>    var mediaQuery = require('css-mediaquery');\n    \n    var isMatch = mediaQuery.match('screen and (min-width: 40em)', {\n        type : 'screen',\n        width: '1024px'\n    });\n</code></pre>\n<p>使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia\">window.matchMedia</a>做动态的查询变更通知能力</p>\n<h3><a href=\"https://previewjs.com/\">Preview.js</a></h3>\n<p>Previerw.js可以实现一些UI组件的预览，可以实现动态属性修改的预览、控制台的console输出、不同设备下查看样式等</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/astoilkov/use-local-storage-state\">use-local-storage-state</a></h3>\n<pre><code>    import useLocalStorageState from 'use-local-storage-state'\n\n    export default function Todos() {\n        const [todos, setTodos] = useLocalStorageState('todos', {\n            defaultValue: ['buy avocado', 'do 50 push-ups']\n        })\n    }\n</code></pre>\n<p>在之前的<a href=\"https://icantunderstand.github.io/blog/window-message\">聊聊页面间的通信机制</a>中有介绍到localStorage可以实现跨Tab的消息通信，在前端的数据存储中localStorage是一种常用的前端存储方案，use-local-storage-state这个库实现了数据的存储和数据的变更通知，下面分别从这两个点看下具体实现</p>\n<h3>数据存储</h3>\n<pre><code>try {\n    // 支持localStorage的时候使用localStorage存储\n    localStorage.setItem(key, stringify(value))\n    inMemoryData.delete(key)\n} catch {\n    // 不支持localStorage的时候使用内存对数据存储\n    inMemoryData.set(key, value)\n}\n</code></pre>\n<h3>数据变更通知</h3>\n<pre><code>   const value = useSyncExternalStore(\n    useCallback(\n        (onStoreChange) => {\n            const onChange = (localKey: string): void => {\n                if (key === localKey) {\n                    onStoreChange()\n                }\n            }\n            // callback注入，当onStoreChange执行 会触发页面更新\n            callbacks.add(onChange)\n            return (): void => {\n                callbacks.delete(onChange)\n            }\n        },\n        [key],\n    ),\n    () => {\n        // 通过ref存储当前的值 返回\n    },\n    () => defaultValue,\n)\n\nuseEffect(() => {\n    // 当不需要通知同步的时候直接返回\n    if (!storageSync) {\n        return undefined\n    }\n    const onStorage = (e: StorageEvent): void => {\n        if (e.storageArea === goodTry(() => localStorage) &#x26;&#x26; e.key === key) {\n            triggerCallbacks(key)\n        }\n    }\n    // 订阅storage 触发更新回调\n    window.addEventListener('storage', onStorage)\n\n    return (): void => window.removeEventListener('storage', onStorage)\n}, [key, storageSync])\n</code></pre>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"2024-4-第一期","date":"2024-04-15","tags":"前端快报","path":"/2024-4-1","top":null,"summary":null}}},{"node":{"id":"1b4968b4-2a2a-5a14-9be0-5e4ab155f789","html":"<p>通常在登录系统的时候，服务端会通过设置Cookies来实现用户登录信息的存储</p>\n<pre><code>Set-Cookie: &#x3C;cookie-name>=&#x3C;cookie-value>; Expires=&#x3C;expiration-date>; Path=&#x3C;path>; Domain=&#x3C;domain>; Secure; HttpOnly\n</code></pre>\n<p>在用户二次登录的时候，相同域的cookies会随着用户请求发送到服务端，服务端会根据session中保存的信息校验，完成用户对特定资源的访问。在实际系统中，比如同公司的不同子系统如果登录态不能共享，就会造成不好的用户体验，比如你在一个购物app里面，商品页是电商系统，下单支付页是财务系统的。如果在正常下单跳转到下单支付页弹出登录框，那觉得是个P000的问题。所以这就引出了单点登录系统的实现。下面主要从同域名下单点登录和不同域名下的单点登录展开。</p>\n<h2>同域下的单点登录</h2>\n<p>在设置cookies的时候，我们可以指定cookies的path。那么假设现在有下面的场景。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5a822e779b8a65d7c5552bde52e673de/2edea/sameSite.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd5NQD//xAAVEAEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAQABBQJa/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGxAAAQQDAAAAAAAAAAAAAAAAAQAQETEhUWH/2gAIAQEAAT8hABIU7wp61U3/2gAMAwEAAgADAAAAEPPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAQEBAAMAAAAAAAAAAAAAAREAITFRcf/aAAgBAQABPxAzVHFFr6xRTjQ9YDgTed//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"同域名单点登录\"\n        title=\"同域名单点登录\"\n        src=\"/blog/static/5a822e779b8a65d7c5552bde52e673de/a2510/sameSite.jpg\"\n        srcset=\"/blog/static/5a822e779b8a65d7c5552bde52e673de/0479a/sameSite.jpg 250w,\n/blog/static/5a822e779b8a65d7c5552bde52e673de/41099/sameSite.jpg 500w,\n/blog/static/5a822e779b8a65d7c5552bde52e673de/a2510/sameSite.jpg 1000w,\n/blog/static/5a822e779b8a65d7c5552bde52e673de/2edea/sameSite.jpg 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n有两个子系统xxx.test.com和ccc.test.com要实现在登录任何一个系统之后，都不需要再登录就能访问到另外的一个系统。\n两个子系统其实不需要维护相关的登录逻辑，只需要将登录代理给统一的域名登录系统sso.test.com来实现即可，在实现子系统间相互登录的时候需要注意:</p>\n<ul>\n<li>登录系统在设置cookies的时候，可以设置到根域名下，也就是上面的例子设置到test.com上，这样用户访问xxx.test.com和ccc.test.com的时候都能携带上设置的cookies</li>\n<li>登录的session可以通过一些session共享技术实现</li>\n</ul>\n<h2>不同域下的单点登录</h2>\n<p>不同域下的单点登录不能使用cookies来实现，因为cookies有域名限制。实现单点登录的方式有CAS(Central Authentication Service),OAuth(主要用于授权第三方登录)，JWT安全令牌等方式，下面主要介绍CAS的实现方式\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 737px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/d125e/sso.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAIAAAC+dZmEAAAACXBIWXMAAAsTAAALEwEAmpwYAAADN0lEQVQ4y5VTWY7cRBjum3AQTsMBuAOvnIEDJMATL0wSCSkSgigkg0KGYTJMuttLt5dyuVz7+lcVsj2jWWAE/E+2/H9V3+ZNubs6ffVDcXkanJE+nFD6ddN8YCwDvFXqade9RANAUMwW78n27SSpBQgxxnEcN3woqjdPq5+/ihIPOX+C8eb01y/LKuf8mVKb388//e0sZxgr/90X9Tefo/7K5GU45xslhWJYUiQFV8acU/qeMR5CznkI4UKpo5m3ISSGDOtdcJByyjkzxjbeB82JUtI6l5w7av2yrh2leCLgHGidY0xp3o8JUoo55/n1FsyQ1XIlU8V40rZeCKkVJqRuGkKps84HV23baeBSCi7EDTgERRFn03xmjEUIrwhhfd8PA+fce59SAoCcc79nuw8H67TW+hYsKSLjYJ2P1m61frbbTV2H8NA0DcbYWmuMcd619WCU+zvtQUkOKeUY996/5jynBItUay0AhNm/VF/hP959xCMSt7QXsNFi1VwCvJGz/ri8wmL7elVf8Muz/Ugw6tF1VA/AFcBPhOSlByEEjHEIYdGc2j0tr1omKCHkEXCMP2KcrZVa931XV1WPkNbGB3csey3tP2i+S/u1EDmlEKNzbrbKOYBZRLufij+PTNA7bt+A59PSDP5l8WPRnIwxKaUU54/tll282xEyIDQIISila8Pw3ZI8Pxw851JrJWXXddbaECDliBvOic45BR9SjGvOICmiBJNp0pQWzp00jed8JERJmRd56wBAjA/qGYJiM1hrbY3GnB3GMQEEAGPMDuN7YJjDv28YH7S6NmzOx7mYUgTIKT+pD2Vdl0VBCDHGrD191O0Y47qxzvfTxNjcdCFZ/RE1JVJKPNqwh2BCvHOETBDDUItjMfhg16j4fwH3Xde2Xdu1xfagpfsftJ8zlq8Nyt2eXZ7t8ThQSlNK/w5+RmmKkXORcuz27Oq8UlpM03RdEue8okhLvvK5+QHzGum3TdP1PUJoohMZuNX+Hm2AqDmWgq1XUTrhJdt148U4Wu+DnydGWENOy7lCiE1VVcfjoWmO7TJN0xyPN89tWxwOqL+epmnqqt7tdrvttizLi4uLvwCQgY3VfIS/ggAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"CAS登录流程\"\n        title=\"CAS登录流程\"\n        src=\"/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/d125e/sso.png\"\n        srcset=\"/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/63868/sso.png 250w,\n/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/0b533/sso.png 500w,\n/blog/static/64817061d63be0dcfe8814e4c0bc4b7a/d125e/sso.png 737w\"\n        sizes=\"(max-width: 737px) 100vw, 737px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上图中系统1和系统2是两个独立的系统，在登录系统的时候有如下的步骤:</p>\n<h3>未登录态下登录流程</h3>\n<ul>\n<li>如果系统1中没有登录，会跳转到SSO系统中进行校验，发现SSO系统也没有登录，弹出用户登录页</li>\n<li>用户填写用户名、密码登录SSO系统，SSO系统写入SSO域的cookies并且在SSO系统保存登录session</li>\n<li>SSO系统返回给系统1一个ST(Service Ticket),跳转到系统1</li>\n<li>系统1拿到获取到的ST，去向SSO后台进行校验，ST有效则在系统1写入当前登录的session和系统1域下的cookies</li>\n</ul>\n<h3>已登录下流程</h3>\n<p>用户已经登录SSO系统，此时他尝试登录系统2</p>\n<ul>\n<li>系统2校验当前用户未登录，跳转到SSO系统</li>\n<li>SSO系统中用户是已登录状态，SSO会跳转回系统2并且携带ST</li>\n<li>系统2用获取到的ST去SSO系统做令牌校验，ST有效则在系统2中写入当前登录的session和系统2域下的cookies</li>\n</ul>\n<h2>同域名和不同域名下单点登录的差异</h2>\n<ul>\n<li>session的状态  在同域名登录下session状态应该是可以共享或者不共享的，不同域名下session状态是不共享的</li>\n<li>服务端设置cookies的方式 他们都是在sso域下设置cookies，同域名刚好有cookies在同domain下可以共享，所以相对于不同域名下更简单一些。</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"从cookies再聊单点登录实现","date":"2024-04-05","tags":"计前端基础","path":"/sso","top":null,"summary":null}}},{"node":{"id":"e7dba02a-4655-564c-ad4b-5a136e44fcf2","html":"<p>在浏览器中会涉及到一些跨页面的通信来完成一些特定的业务逻辑，下面梳理下一些跨页面通信相关的技术点。</p>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">postMessage</a></h2>\n<h3>postMessage用法解释</h3>\n<pre><code>otherWindow.postMessage(message, targetOrigin, [transfer]);\n</code></pre>\n<ul>\n<li>otherWindow 其他窗口的引用，比如iframe的contentWindow、执行window.open的返回的窗口对象、window.parent获取的父窗口对象。利用window.open返回的窗口对象可以实现跟新窗口的通信</li>\n<li>message 需要发送的数据，它会被结构化克隆算法序列化,无法被结构化克隆的数据会导致异常或者丢失属性，比如函数/原型链的丢失等</li>\n<li>targetOrigin 指定哪些源可以接收数据，这里就可以实现跨源的通信和安全控制</li>\n<li>transfer 可选的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Transferable_objects\">Transferable</a>对象</li>\n</ul>\n<h3>父子窗口通信</h3>\n<h4>父窗口发送消息给子窗口</h4>\n<p>在父窗口通过获取子iframe的conentWindow获取子窗口的引用，调用postMessage方法就可以实现对子窗口发送消息</p>\n<pre><code>// 父窗口发送消息\niframe.contentWindow.postMessage('message from parent', '*')\n\n// 子窗口监听消息\nwindow.addEventListener('message', function(event) {\n    // 处理接收到的消息\n    console.log(event.data);\n});\n</code></pre>\n<h4>子窗口发送消息给父窗口</h4>\n<p>子窗口通过window.parent获取父窗口的引用，调用postMesage方法就可以实现对父窗口发送消息</p>\n<pre><code>// 子窗口发送消息\nwindow.parent.postMessage('message from child', '*')\n\n // 父窗口监听消息\nwindow.addEventListener('message', function(event) {\n    // 处理接收到的消息\n    console.log(event.data);\n});\n</code></pre>\n<h2>浏览器不同tab间通信</h2>\n<p>跨tab通信有可能涉及到不同tab的数据同步逻辑，是一个相对常见的场景</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">localStorage</a></h3>\n<p>sessionStrage在chrome中打开同源的tab时候不会共享sessionStorage,所以主要介绍localStorage的实现方案.localStorage是在同域名下共享的浏览器存储，在同域的不同tab下监听localStorage的storage事件就可以实现跨tab通信</p>\n<pre><code>// 在第一个标签页中设置数据到 sessionStorage 中\nsessionStorage.setItem('message', 'Hello from Tab 1!');\n\n// 第二个标签页也打开当前页面 监听 storage 事件 接收其他标签页的数据\nwindow.addEventListener('storage', function(event) {\n    if (event.key === 'message') {\n        console.log('Received message in Tab 1:', event.newValue);\n    }\n});\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket\">WebSocket</a></h3>\n<p>这种方案依赖需要依赖服务服务端</p>\n<pre><code>// 建立websocke连接\nconst socket = new WebSocket(\"ws://localhost:8080\");\n\n// 连接建立，跟服务端发送事件，服务端对所有连接的websocket client广播事件\nsocket.addEventListener(\"open\", function (event) {\n    socket.send(\"Hello Server!\");\n});\n\n// 接收事件消息\nsocket.addEventListener(\"message\", function (event) {\n    console.log(\"Message from server \", event.data);\n});\n</code></pre>\n<p>使用websocket这种方案相对重，除非已有websocket长连接并且需要考虑websocket的断连造成的通信失败</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel\">BroadcastChannel</a></h3>\n<p>BroadcastChannel可以做到同源窗口间的通信能力.它基于发布-订阅的模式实现消息通知。</p>\n<pre><code>// 发送方逻辑\n// 创建BroadcastChannel 在实现跨tab通信的时候，创建BroadcastChannel的channelName需要是一个\nconst channel = new BroadcastChannel('myChannel');\n\n// 发送消息到其他标签页 \nchannel.postMessage('Hello from Tab 1!');\n\n// 监听方逻辑\n// 创建BroadcastChannel 与发送方channelName一致\nconst channe2 = new BroadcastChannel('myChannel');\n// 监听消息\nchanne2.onmessage = function(event) {\n    console.log('Received message in Tab 2:', event.data);\n};\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\">Service Worker</a>/<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker\">SharedWorker</a></h3>\n<p>Service Worker和SharedWorker方案类似，都是运行worker实现消息通信，下面主要举例SharedWorker的实现方案。</p>\n<h4>定义worker脚本</h4>\n<pre><code>// shared-worker.js\n// 定义一个变量来保存所有连接的客户端\nlet clients = [];\n\n// 监听连接事件\nself.addEventListener('connect', function(event) {\n    // 获取与该连接关联的端口\n    const port = event.ports[0];\n\n    // 将端口添加到客户端列表中\n    clients.push(port);\n\n    // 监听来自客户端的消息\n    port.addEventListener('message', function(event) {\n        // 广播消息给所有其他客户端\n        clients.forEach(function(client) {\n        if (client !== port) {\n            client.postMessage(event.data);\n        }\n        });\n    });\n\n    // 监听客户端关闭事件\n    port.addEventListener('close', function() {\n        // 从客户端列表中移除关闭的端口\n        clients = clients.filter(function(client) {\n        return client !== port;\n        });\n    });\n\n    // 向客户端发送连接成功消息\n    port.postMessage('Connected to SharedWorker.');\n});\n</code></pre>\n<h4>页面中加载脚本</h4>\n<pre><code>    // 在你的网页中连接到 SharedWorker\n    const worker = new SharedWorker('shared-worker.js');\n\n    // 监听连接成功事件\n    worker.port.addEventListener('message', function(event) {\n        console.log('Received message:', event.data);\n    });\n</code></pre>\n<h3>cookies</h3>\n<p>这种方案不大推荐，涉及到js可以通过脚本对cookies进行读写</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"聊聊页面间的通信机制","date":"2024-04-05","tags":"前端基础","path":"/window-message","top":null,"summary":null}}},{"node":{"id":"e81f7a43-5d01-51bf-8d79-3dd6690b23cb","html":"<hr>\n<pre><code>好像到了容易回忆过去的年纪\n</code></pre>\n<hr>\n<p>有时候觉得记忆力好并不是一件特别值得夸耀的事。比如我现在还能记着小时候我把汽油倒进家里炉子，炉子火光照射在我脸上的感觉。现在想应该是家里的汽油放久了挥发了，否则我就走入下一个分支了。记忆好能记住像上面的蠢事，如果有空跟你讲应该能讲上小半天。记忆好同样能记住快乐的事，有些快乐的场景存在我不大灵光的脑袋里面就像做梦梦到不喜欢的人或者事，梦醒了忍不住想要骂一句一样真实。我只拿两件小时候比较有意思的事跟你说，如果你愿意听我唠叨，那等以后有机会再跟你说。\n小时候的自己是个不愿意说话的人，看起来有点木讷，当然现在也有一点点，看我这么坦诚，就允许把我这一点点给四舍五入吧。是那样一个场景: 在家后面的小道玩耍的我，不知道为什么画面中没有跟我一起玩的人，似乎只有我和当时跟我对话的人。\n对面的人问我: 多大了？\n我: 僵住(内心倒是也没有飞速旋转)，因为我忘记我多大了\n我有些无法确切地想起来当时的感受，我应该迟疑了有一会才懵了一个年龄，忘记最后是跟父母确认了年龄还是怎么，那一年应该是8-9岁的样子感觉。\n另一个场景我跟小伙伴一起房前屋后跑，小时候我一直认为自己是个跑的快的人，因为我那时候很瘦，跑起来真的有风。我们一小群估计应该有三四个的样子，跑一大圈之后就去小卖店买一瓶冰镇的大白梨。当时的喝法就是一口闷，那股透心凉的感觉至今还能回想起来，后来听父母说跑步喘了迅速喝凉的容易炸肺，有些庆幸我没有走到那个不好的分支。耳边似乎还能听到当时嗓子喝水的咕咕声和头凉的疼的感觉。\n难得有机会去安静的回忆自己的一些小事，希望你不至于厌烦。总觉得自己是个普通的人并且也在渐渐认可这个事实，小时候的自己似乎没有什么远大的理想，与我同龄的伙伴如果被问起长大想当什么，应该会有科学家等等。我在想当时如果我被采访了，你长大想做什么呀？。我有可能又会像之前回答我年龄那样，我也想当科学家，不过我不想考清华北大(手动狗头)。\n好了已经知道我是个有可能没什么理想的人了。容我再从我的性格上入手给你介绍一下。\n人们似乎会搞混两个情况:</p>\n<ul>\n<li>木讷 不会表达</li>\n<li>孤僻 不那么想表达</li>\n</ul>\n<p>也许我有一层大大咧咧的外衣，不过我也许得承认我的前小半段人生，其实是孤僻的，用东北话来说就是性子独。此处应该有若干例子来举证我的\"独\"，为了不加深你对我的坏印象，我决定省略这一万字，这样我在你面前就还是个活泼的人。\n说了好多过去小时候，似乎没那么多代入感，就聊聊最近。前年开始比较系统的阅读，原因似乎是我想看懂正在经历的事或者说时代。我似乎有了思考我这件事了。想想有点晚，从这点上我是隔壁班的差生无疑了。不过想想我应该还能再我的剧本上在书写几十年，想的慢似乎也比不想好一些（这安慰我自己的话 你就让我说吧）。\n原谅我思路有点跳脱，刚说自己有可能没什么理想，却又发现其实自己也有过一些微不足道的理想。似乎一直有个想法在我脑海里，不知道是不是因为本山大叔的一句话:脑袋大脖子粗不是大款就是伙夫。脑袋大基因上已经占据，脖子粗在我后天的\"努力\"下成功换上了大粗脖病，我想我已经具备了大款或者伙夫的先决条件，虽然我觉得我还是有那么万分之一的机会成为大款，不过我还是喜欢那个百分之99的伙夫。还有就是上大学的时候踢球真的很认真，那个时候就想着一定要好好踢，虽然在学校也没踢出什么名堂，不过很喜欢那段时光。还有一段认真锻炼的日子，那个时候想着把身体练好，虽然现在的我胖的已经造成画面模糊不过偶尔还有些异想天开的想法比如努力练出个好形体啥的。\n如果有人在问我多大了？我似乎会想说自己刚到学会了思考一些事的年龄，虽然好多事还是想不明白，有些事似乎还没想起来想\n如果有人在我问有什么理想？ 我似乎会想说更好的学会自己的一些身份，因为有些身份我也是最近才似乎学着做或者做好。比如成为一个丈夫，一个父母的孩子，一个朋友。\n很久以前写过不像小说的小说，故事的结尾有个安静不爱说话的妻子，我想那是因为我想我会安静或者说平淡的过完这辈子。我看到了开头，似乎也看到了结尾。但是我还是会因为中间有很多未知会犹豫不知所措。就跟之前看完日本恐怖电影的我一样，有时候我似乎又回到了那个小孩的状态，把自己包裹起来。说着说着好像就到了文章的结尾，我老说自己是个记忆好的人，其实谁不是呢，似乎偶尔都能想起一两件有意思的事然后不明所以的笑了。往前走的时候偶尔回头看看不也挺有意思的吗？</p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"写给再年长几岁的自己和再年轻些的自己","date":"2024-04-04","tags":"随想","path":"/age-old","top":null,"summary":null}}}],"pathPrefix":"","first":true,"last":false,"index":1,"pageCount":16,"additionalContext":{"pageAllCount":95}}},
    "staticQueryHashes": []}