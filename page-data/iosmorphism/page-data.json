{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/iosmorphism",
    "result": {"data":{"markdownRemark":{"html":"<h2>简介</h2>\n<p>　　WEB同构应用指的是通过代码的编译转换手段(通常借助于babel)来让代码在不同端client(浏览器), server(服务器)运行.同构的web应用主要有以下的优点:</p>\n<ol>\n<li>一套代码多处运行减少维护成本</li>\n<li>任务拆分,通过同构可以实现更多的功能(SSR, fetchData)</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/isomorphism.png\" alt=\"isomorphism\"></p>\n<h2>简单的实现思路</h2>\n<ol>\n<li>将client端的代码转换成server可以执行的代码(es6 => commonjs).</li>\n<li>在两端组合出一套模式相同的代码逻辑.下面的例子中在server和client端使用不同的react-router提供的组件.</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/app.png\" alt=\"App\"><br>\n3. server端路由匹配,组装资源(css, js, data), 可以通过不同的中间件根据请求信息来组装.<br>\n4. client端路由匹配,匹配资源(data, 检查页面渲染结果是否正确).</p>\n<h2>过程</h2>\n<h3>代码转换</h3>\n<p>　　在进行代码转换的时候,首先要明白代码转换的目的才能明确对不同文件的转换策略.比如为了实现同构将client端的代码转换成server端可以运行的代码,对不同类型CSS文件的不同处理策略.通常借助于webpack来实现代码的转换功能.webpack会根据入口文件依次的解析引用的各种文件类型,通过配置的webpack loader可以实现对应文件类型的转换.以下主要从不同类型文件处理的角度进行介绍:</p>\n<h4>javascript</h4>\n<p>转换的目标是client端的代码(排除node_modules).\r\n将client转换成server端可以运行的代码\r\n<img src=\"./javascriptbasestatic/isomorphism/srctolib.png\" alt=\"srcToLib\"></p>\n<h4>css</h4>\n<p>对于CSS可以有以下两种的处理方法:</p>\n<ol>\n<li>css-in-js (css-loader style-loader)处理,包括node_modules,client端不需要提取的CSS</li>\n<li>client端全局样式或者通过mini-css-extract-plugin提取的样式</li>\n</ol>\n<h4>代码转换优化</h4>\n<h5>公有代码提取</h5>\n<p>可以使用DllPlugin对使用的基础组件库进行统一的提取和引用.提取公有模块代码主要有以下的好处:</p>\n<ol>\n<li>通过DllPlugin对公有代码的提取,能一定程度上加快webpack构建代码的速度</li>\n<li>公有部分的逻辑相对来说是变化的较少,可以充分的利用缓存</li>\n<li>减少其他bundle的体积,页面加载的资源更少</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/dll.png\" alt=\"dll\"></p>\n<h5>加快编译速度</h5>\n<p>可以使用happyPack加快编译速度,happyPack通过多进程的方式来加快代码的打包过程.\r\n使用happyPack的例子:\r\n<img src=\"./javascriptbasestatic/isomorphism/happy1.png\" alt=\"happyPack\">\r\n<img src=\"./javascriptbasestatic/isomorphism/happy2.png\" alt=\"happyPack\"></p>\n<h3>资源匹配</h3>\n<h4>静态资源(CSS js)</h4>\n<p>可以通过webpack-manifest-plugin生成资源的位置信息文件,然后通过该文件查找资源的位置.\r\n资源位置文件\r\n<img src=\"./javascriptbasestatic/isomorphism/manifest1.png\" alt=\"manifest\">\r\n通过manifest查找资源的位置\r\n<img src=\"./javascriptbasestatic/isomorphism/manifest2.png\" alt=\"manifest\"></p>\n<h4>data</h4>\n<ol>\n<li>server端执行匹配到组件的获取数据的方法(返回promise),primose执行完毕获取到最新的数据储存.将数据通过脚本挂载到window上的属性上.</li>\n<li>client端通过window属性的获取,生成存储数据.</li>\n</ol>\n<p>服务端获取数据和注入数据\r\n<img src=\"./javascriptbasestatic/isomorphism/serverStore.png\" alt=\"serverStore\">\r\nclient端提取数据\r\n<img src=\"./javascriptbasestatic/isomorphism/clientStore.png\" alt=\"clientStore\"></p>\n<h2>扩展性</h2>\n<h3>配置单页是否支持服务端渲染</h3>\n<p>通过中间项配置是否支持服务端渲染\r\n<img src=\"./javascriptbasestatic/isomorphism/configServerRender.png\" alt=\"configServerRender\"></p>\n<h2>思考</h2>\n<p>在是否在项目中使用同构应用的时候,还是要结合具体的场景.可以有以下的几点考虑:</p>\n<ol>\n<li>项目中是否需要进行服务端渲染 => 使用者角度</li>\n<li>是否有引入node中间层(api转发)的必要, 其他的替代方案是否可行(nginx) => 整体设计的角度</li>\n</ol>","frontmatter":{"date":"2019-04-24","path":"/iosmorphism","title":"如何构建一个WEB同构应用"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}