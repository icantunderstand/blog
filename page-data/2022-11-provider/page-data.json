{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2022-11-provider",
    "result": {"data":{"markdownRemark":{"html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>提供者模式</h2>\n<p>提供者模式通过封装方法给予应用订阅不同数据源的能力。react中通过外层的Provider来提供全局的store，在组件内部通过useContext来获取相关的Context值。</p>\n<pre><code>    // 根组件通过Provider的value绑定全局store\n    export const ThemeContext = React.createContext();\n    const themes = {\n        light: {\n            background: \"#fff\",\n            color: \"#000\"\n        },\n        dark: {\n            background: \"#171717\",\n            color: \"#fff\"\n        }\n    };\n    export default function App() {\n        const [theme, setTheme] = useState(\"dark\");\n        function toggleTheme() {\n            setTheme(theme === \"light\" ? \"dark\" : \"light\");\n        }\n        const providerValue = {\n            theme: themes[theme],\n            toggleTheme\n        };\n        return (\n            &#x3C;div className={`App theme-${theme}`}>\n                &#x3C;ThemeContext.Provider value={providerValue}>\n                    &#x3C;Toggle />\n                &#x3C;/ThemeContext.Provider>\n            &#x3C;/div>\n        );\n    }\n    // Toggle组件\n    import React, { useContext } from \"react\";\n    import { ThemeContext } from \"./App\";\n\n    export default function Toggle() {\n        const theme = useContext(ThemeContext);\n        return (\n            &#x3C;label className=\"switch\">\n                &#x3C;input type=\"checkbox\" onClick={theme.toggleTheme} />\n            &#x3C;/label>\n        );\n    }\n</code></pre>\n<p>在React应用中通过全局的context可以解决组件属性的传递问题，便于组件的设计。但是全局Context的更新会导致消费对应Context组件的更新，造成需要不必要的渲染。这里就需要对全局Context进行更细粒度的拆分。</p>\n<h2>原型模式</h2>\n<p>JavaScript通过原型完成对象间属性的共享。通过原型能减少相同属性或者方法的创建，相同类型的实例可以共享实例原型上的属性和方法。对于原型模式需要理解几下的几点:</p>\n<ul>\n<li>\n<p>实例对象的__proto__指向构造函数的prototype(实例与原型的关系).构造函数的prototype的constructor(构造函数与原型的关系).</p>\n<pre><code>  class Dog {\n      constructor(name) {\n          this.name = name;\n      }\n      bark() {\n          return `Woof!`;\n      }\n  }\n  const dog1 = new Dog(\"Daisy\");\n  dog1.__proto__ === Dog.prototype // true\n  Dog.prototype.constructor === Dog // true\n</code></pre>\n</li>\n<li>\n<p>对象属性的获取是顺着对象__proto__沿着原型链查找，会一直查找到Object.prototype(Object.prototype.__proto__是null)</p>\n</li>\n<li>\n<p>理解new关键字中原型的处理方式，new操作符主要做了如下的操作:</p>\n<ol>\n<li>\n<p>以构造器的原型为属性创建新对象</p>\n</li>\n<li>\n<p>将新对象作为this调用构造器</p>\n</li>\n<li>\n<p>如果构造器返回的是对象则返回否则返回第一步创建的对象</p>\n<pre><code> function myNew(Con, ...args) {\n     const obj = Object.create(Con.prototype);\n     const ret = Con.call(obj, args);\n     if(ret instanceof Object &#x26;&#x26; ret !== null) {\n         return ret;\n     }\n     return obj;\n }\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>","frontmatter":{"date":"2022-11-02","path":"/2022-11-provider","title":"5分钟速读系列-提供者模式/原型模式"}}},"pageContext":{"readingTime":"3 min read"}},
    "staticQueryHashes": []}