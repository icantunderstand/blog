{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/code-refactor",
    "result": {"data":{"markdownRemark":{"html":"<p>广告平台投中阶段的广告列表有着交互复杂，逻辑分散等特点，导致在长期的业务迭代中容易变成‘老大难’。在进行技术方案设计的时候需要考虑好模块之间的依赖和防劣化的能力，才能满足业务的长期发展。下面是自己在迭代过程中对技术方案设计的一些思考。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 972px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/473c65e756e0a861a042fe5ebbc63256/95c6e/plan.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB7OUZsL//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQECEiEx/9oACAEBAAEFAmMryasw3WEf/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAEDAQE/ATV//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BCf/EABcQAAMBAAAAAAAAAAAAAAAAAAAQMUH/2gAIAQEABj8CpVhi/8QAHBAAAgICAwAAAAAAAAAAAAAAABEBITFBkbHx/9oACAEBAAE/IZldsjeiTyZyjuDZ0E1WdH//2gAMAwEAAgADAAAAEGQ//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERMf/aAAgBAwEBPxBaFh//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/EATrJl//xAAcEAACAwEAAwAAAAAAAAAAAAABEQAhMVFhcbH/2gAIAQEAAT8QAsDOgfZ5r9YwLW1gw+mysU5MrqMUBkaKf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/473c65e756e0a861a042fe5ebbc63256/95c6e/plan.jpg\"\n        srcset=\"/blog/static/473c65e756e0a861a042fe5ebbc63256/0479a/plan.jpg 250w,\n/blog/static/473c65e756e0a861a042fe5ebbc63256/41099/plan.jpg 500w,\n/blog/static/473c65e756e0a861a042fe5ebbc63256/95c6e/plan.jpg 972w\"\n        sizes=\"(max-width: 972px) 100vw, 972px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>基础层</h2>\n<h3>性能建设</h3>\n<p>拆包/按需加载 @babel/plugin-syntax-dynamic-import<br>\n大文件扫描(针对build结果扫描)\n页面性能</p>\n<h3>约束防劣化卡口</h3>\n<ul>\n<li>\n<p>文件强约束(max-len卡口/complexity复杂度卡口)</p>\n</li>\n<li>\n<p>基础组件修改代码提交提示</p>\n<pre><code>#! /bin/bash shell\n// 需要重点关注的目录\nSUB='src/post/weeklyReport'\nCOMPARE=\"master\"\nLINE=\"-----------------------------\"\n// 默认对比master\nif [[ $1 ]]; then\n    COMPARE=$1\nfi\narray=$(git diff --quite $COMPARE --name-only)\nresultArr=()\necho $LINE\n\nif [[ $array ]]; then\n       for i in $array\n        do\n            // 改动的文件中命中了匹配规则\n            if [[ \"$i\" == *\"$SUB\"* ]]; then\n            resultArr+=(\"$i\")\n            fi\n        done \nfi\nresultLength=${#resultArr[@]} \necho $resultLength\n// \nif [ \"$resultLength\" -gt 0 ]; then \n    echo '修改了关键内容，请注意改动范围'\n    for i in \"${resultArr[@]}\"\n        do\n            echo $i\n        done\nfi\n</code></pre>\n</li>\n</ul>\n<h3>配置化能力</h3>\n<ul>\n<li>表格基础展示项配置化实现</li>\n<li>文案类/筛选项下发</li>\n</ul>\n<h2>工具层</h2>\n<h3>工具函数/getter方法</h3>\n<p>通用计算逻辑提取工具函数\n依赖数据计算逻辑提取全局getter方法</p>\n<h3>列表操作封装</h3>\n<p>封装列表操作相关逻辑,在视图层和数据层之间增加一个桥梁，这样数据层和视图层能相对解耦，代码逻辑清晰，\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 642px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa3dc47ff2757330f866b046d310c6c5/46b1b/mvc.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9NCKP/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAEAAgMAAAAAAAAAAAAAAAABABEQYXH/2gAIAQEAAT8hvcOwbMk//9oADAMBAAIAAwAAABBTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAAAEAIREx/9oACAEBAAE/EEKmLg3cQMB3wkOeQAwv/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mvc\"\n        title=\"mvc\"\n        src=\"/blog/static/fa3dc47ff2757330f866b046d310c6c5/46b1b/mvc.jpg\"\n        srcset=\"/blog/static/fa3dc47ff2757330f866b046d310c6c5/0479a/mvc.jpg 250w,\n/blog/static/fa3dc47ff2757330f866b046d310c6c5/41099/mvc.jpg 500w,\n/blog/static/fa3dc47ff2757330f866b046d310c6c5/46b1b/mvc.jpg 642w\"\n        sizes=\"(max-width: 642px) 100vw, 642px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n使用MVC模型之后，将原本糅合在数据层的页面逻辑分离，可维护性增加，调用逻辑也更加清晰</p>\n<h3>统一弹层方法</h3>\n<p>通过统一的弹层方法，约束弹层内容的按需加载(lazy/Suspense/@babel/plugin-syntax-dynamic-import)并且在方法内部管理显隐状态</p>\n<h2>日志</h2>\n<p>通过对相关逻辑的封装，就能通过在入口处统一实现打点逻辑，比如调用打开弹层的方法的入口就可以实现埋点逻辑</p>\n<h2>数据层</h2>\n<h3>store模块依赖注入</h3>\n<p>比较简单的方案是在模块初始化时传入依赖的模块去减少查询依赖的代码逻辑，也可以借助一些实现依赖注入的库<a href=\"https://github.com/wessberg/DI\">DI</a>等实现依赖的管理</p>\n<h3>Loading态接管</h3>\n<p>通过<a href=\"https://github.com/jpillora/xhook\">xhook</a>对特定接口进行接管，完成自动化的loading态处理</p>\n<pre><code>const useLoading = (url: string) => {\n  const [loading, setLoading] = useState(false)\n  xhook.before(function (request) {\n      if (request.url === url) {\n          setLoading(true)\n      }\n\n    });\n  xhook.after(function (request) {\n      if (request.url === url) {\n          setLoading(false)\n      }\n\n  });\n  return {\n      loading\n  }\n}\n\nexport default useLoading\n</code></pre>\n<h3>数据变更通知</h3>\n<p>通过在store初始化的时候传入配置，在对应值变更的时候执行对应的逻辑, 通过mobx的reaction完成变化的通知，完成模块间的解耦</p>\n<h2>组件层</h2>\n<p>组件层有基础组件和功能模块。基础组件是纯的UI展示类组件，这部分组件需要控制业务逻辑的入侵，在上层进行逻辑的分发控制。功能模块是列表内相对独立的模块，可以通过较少的属性传递完成逻辑的收敛。</p>\n<h2>2023.11.21</h2>\n<ul>\n<li>对技术债的理解\n在引入一种新的解决方案比如useContext这种，对业务入侵很多。他虽然解决了属性跨层级传递的问题但是对组件的复用度有一定的影响。主要先要想明白A才去做B.比如先做好基础组件的拆分在这个基础上去组合技术方案</li>\n<li>视图/数据层\n<ol>\n<li>视图层尽可能减少数据层面的操作，只要UI逻辑。操作逻辑通过封装逻辑调用数据层接口实现</li>\n<li>数据层要做好依赖的管理和拆分，防止出现改不动的现象。通过通知或者监听变更的方式去完成视图层与数据层的解耦</li>\n</ol>\n</li>\n</ul>","frontmatter":{"date":"2023-12-27","path":"/code-refactor","title":"列表技术方案设计(迭代版)"}}},"pageContext":{"readingTime":"6 min read"}},
    "staticQueryHashes": []}