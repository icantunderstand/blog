{"componentChunkName":"component---src-templates-post-js","path":"/react-virtual-dom","result":{"data":{"markdownRemark":{"html":"<h2>前言</h2>\n<p>React在处理界面更新的时候,是通过对比虚拟DOM(js对象)之间的差异来更新UI的.这种方式能一定程度上的减少对DOM的操作.通过虚拟DOM这个中间层结合多平台的renderer使React实现了跨平台.本文梳理了在medium上关于Virtual DOM的两篇文章来介绍如何简单实现一个Virtual DOM.</p>\n<h2>为什么虚拟DOM</h2>\n<ol>\n<li>UI = F(data)  Virtual DOM使数据,操作,属性可以集中在一起,这种方式能一定程度上降低项目长期维护的复杂性.</li>\n<li>页面性能 通过虚拟DOM的对比,进行差异的更新能提升页面的性能.</li>\n</ol>\n<h2>如何实现虚拟DOM</h2>\n<p>虚拟DOM可以理解是真实DOM的映射,如何实现虚拟DOM主要需要考虑一下几点:</p>\n<ol>\n<li>如何描述虚拟DOM(create)</li>\n<li>如何绘制虚拟DOM(render)</li>\n<li>如何差异化的更新虚拟DOM并且更新UI(update)</li>\n</ol>\n<p>下面主要从上面的三点来逐步实现一个简易版的虚拟DOM实现.</p>\n<h3>创建Virtual DOM</h3>\n<p>DOM的节点可以通过type(节点类型),props(styles, event), children(子元素)来描述.可以通过下面的函数来创建虚拟节点.</p>\n<pre><code>// 创建虚拟节点\nfunction h(type, props, children) {\n  return { type, props: props || [], children: children || [] };\n}\nconst root = h('ul', { name: 100, onClick: () => { console.log(1); } }, [\n  h('li', {}, ['sss'])\n])\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVQY022PyW7DMAxE8/8/1muBXtogrpN4k0wvihfJm/SK2EUPQQcYgCQGj+RJa839fkeXmjRL6Jqaoevo+x7TthhjdidJglKKqqrI8wLnHEPf77lxHBmtZZpXTiEE8jwn+vymVQ32mjHVDWmW8nU+01tLKYK1lsfjgYhQliVN26JESLKMNE3JC01nAyeAVgzqXaM/hCIS4vjGJbpglGITwTtHPww7TBUFTdPgrcWLMImwLAuHfoHzOHN/Symjik4KsujCYB1+npmrisW5/cInqK5rWmPY5pm1bZiMYV3XAxfC8bKzjkfW0ekeWw0sbiKOY663G90w8J/Cax/CAVy2Z+GPgQ/4LeB92Lc+X/He/4Wffu1f/QOtmsze8Gl17gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"virtualDom\"\n        title=\"virtualDom\"\n        src=\"/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n        srcset=\"/static/e8d0c0010655ddccb98b99cd8e63f2b4/63868/virtualDom.png 250w,\n/static/e8d0c0010655ddccb98b99cd8e63f2b4/0b533/virtualDom.png 500w,\n/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>绘制Virtual DOM</h3>\n<p>在下面的实现中,以$开头的元素指代真实的DOM节点,node指代虚拟节点.</p>\n<h4>绘制元素</h4>\n<p>在绘制元素的时候,如果节点的内容是文本,就直接创建文本节点.否则就创建当前类型的DOM节点并且遍历它的children节点递归的调用自身并且添加到创建的节点.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\nconst root = h(\"ul\", { name: '111', className: 'test' }, [\n  h('li', { name: 'child' }, ['text'])\n]);\n// app是页面中已经存在的容器节点\nconst container = document.getElementById('app');\ncontainer.appendChild(createElement(root)); // 已经能绘制到页面\n</code></pre>\n<h4>添加属性</h4>\n<p>在添加属性的时候,有以下的节点需要注意:</p>\n<ul>\n<li>对DOM节点上不存在的属性名字进行转换,例如ClassName</li>\n<li>布尔属性值的设置</li>\n<li>增加属性过滤功能来实现特有的实现</li>\n</ul>\n<h5>实现</h5>\n<pre><code>//设置布尔属性\nfunction setBooleanProp($target, name, value) {\n  if(value) {\n    $target.setAttribute(name, value);\n    $target[name] = value;\n  } else {\n    $target[name] = false;\n  }\n}\n// 属性过滤\nfunction isCustomProp(name) {\n  return false;\n}\n// 设置所有属性的入口\nfunction setProps($target, props) {\n  Object.keys(props).forEach(name => {\n    setProp($target, name, props[name]);\n  });\n}\n// 对单一属性的设置,实现过滤,转换\nfunction setProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.setAttribute('class', value);\n  } else if(typeof value === 'boolean') {\n    setBooleanProp(name, value);\n  } else {\n    $target.setAttribute(name, value);\n  }\n}\n</code></pre>\n<p>通过将设置属性的操作加入到之前的createElement函数中,来实现DOM属性的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n} \n</code></pre>\n<p>通过运行之前的代码,发现属性已经添加到DOM中了.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABIElEQVQoz6XO207CQBSF4b7/I3nphcSEKFAoyqkoh0Kn9DhMp8PM/IYYTUw8XLiSL3tf7bWD8UtJv7dlOBaMJnOGjyPuh4LbfspTIgl3NQ+rjCg5syo9i9z+KmjOkmR2IO6tOb4KmkohZimnWGCdx3vw3uOcx33Mj/0bQWc6xEtKfBdT7E50Mke1jv1e0umOP/Pe+CkAj9Yt2aug3Obk6wnJckk0EazjHK00phFIscN2LVmmSMX5x7Kgbi2VupCViu3yxHax4rl3w2GzIZwWjKOMKFwTDQaE0ZzpNCXs7zkeaxrtqJX9ImiNo7Oe6nrw6UBVKGRV0tQNUllORUclHVJbsqKh1QZ9Nqj2gr54tHFfBNc3rTEcnxPSRcrFGP6TN4i4F/4kEuvBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domWithProp\"\n        title=\"domWithProp\"\n        src=\"/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n        srcset=\"/static/6ba2dffdd4a79427500d57a2d8c07e87/63868/propShow.png 250w,\n/static/6ba2dffdd4a79427500d57a2d8c07e87/0b533/propShow.png 500w,\n/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>添加事件</h4>\n<p>在对事件的添加上,由于具体的事件也是在创建Virtual DOM的时候添加到props的,如果不想通过之前声明的setProps函数进行事件的处理,就需要将这些属性过滤出来,具体实现如下:</p>\n<pre><code>//判断是否是event属性\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n// 获取属性的后缀  例如 onClick => click\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n// 修改之前的过滤属性函数,加入对event属性的过滤\nfunction isCustomProp(name) {\n  return isEventProp(name)\n}\n// 添加属性函数\nfunction addEventListeners($target, props) {\n  Object.keys(props).forEach(name => {\n    if(isEventProp(name)) {\n      $target.addEventListener(extractEventName(name), props[name]);\n    }\n  })\n}\n</code></pre>\n<p>将添加事件的函数增加到createElement函数中,完成对事件的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  addEventListeners($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\n</code></pre>\n<h3>对比差异更新UI</h3>\n<p>如果完全的对比两个树形结构的差异,时间复杂度是O(n^3)的.为了一定的性能优化,可以有以下的假设:</p>\n<ol>\n<li>节点的类型变更,两个DOM的结构就是不同的.这种情况可以直接进行替换操作.</li>\n<li>很少存在跨层级的节点移动</li>\n<li>同一类型的节点的DOM结构是相同的</li>\n</ol>\n<p>通过对上面假设的分析,在更新Virtual DOM的时候,主要有以下几种情况</p>\n<ol>\n<li>对比两个node的类型不同,直接替换</li>\n<li>最新的node中没有元素和属性,需要删除对应的节点的属性</li>\n<li>最新的node中增加了元素和属性,需要添加对应的属性和节点</li>\n<li>节点类型相同,对子节点实现1 2 3的操作</li>\n</ol>\n<h4>更新节点</h4>\n<pre><code>// 判断两个node是否是同一个节点\nfunction changed(node1, node2) {\n  return typeof node1 !== typeof node2 || typeof node1 === 'string' &#x26;&#x26; node1 !== node2 || node1.type !== node2.type;\n}\n\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  // index是子元素的位置\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新属性</h4>\n<p>在更新属性的时候跟更新节点的步骤类似</p>\n<pre><code>// 删除布尔属性\nfunction removeBooleanProp($target, name) {\n  $target.removeAttribute(name);\n  $target[name] = false;\n}\n// 移除属性\nfunction removeProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.removeAttribute('class');\n  } else if(typeof value === 'boolean') {\n    removeBooleanProp($target, name);\n  } else {\n    $target.removeAttribute(name);\n  }\n}\n// 当不存在newVal的时候,remove对应的属性.其他情况进行覆盖\nfunction updateProp($target, name, newVal, oldVal) {\n  if(!newVal) {\n    removeProp($target, name, oldVal);\n  } else {\n    setProp($target, name, newVal);\n  }\n}\nfunction updateProps($target, newProps, oldProps = {}) {\n  const props = Object.assign({}, newProps, oldProps);\n  Object.keys(props).forEach(name => {\n    updateProp($target, name, newProps[name], oldProps[name]);\n  });\n}\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    // 增加属性的更新\n    updateProps($parent.childNodes[index], newNode.props, oldNode.props)\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新事件</h4>\n<p>函数是不好判断是否有变化的,可以通过一些参数来完成事件的更新(触发重新更新,通过节点替换来完成事件的更新这样不好)</p>\n<pre><code>function changed(node1, node2) {\n  return typeof node1 !== typeof node2 ||\n      typeof node1 === ‘string’ &#x26;&#x26; node1 !== node2 ||\n      node1.type !== node2.type ||\n      node1.props.forceUpdate;\n}\nfunction isCustomProp(name) {\n  return isEventProp(name) || name === ‘forceUpdate’;\n}\n</code></pre>\n<h3>参考</h3>\n<p><a href=\"https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060\">How to write your own Virtual DOM\n</a><br>\n<a href=\"https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76\">Write your Virtual DOM 2: Props &#x26; Events</a><br>\n<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>","frontmatter":{"date":"2019-04-02","path":"/react-virtual-dom","title":"How to wirte your own Virtual DOM(译)"}}},"pageContext":{"readingTime":"9 min read"}},"staticQueryHashes":[]}