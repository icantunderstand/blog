{"componentChunkName":"component---src-templates-post-js","path":"/chain-responsibility","result":{"data":{"markdownRemark":{"html":"<p>责任链模式将多个处理对象连成一条链并且沿着链传递该请求，直到有一个对象处理它为止。它实现了请求的发送者和接收者之间的解耦合。</p>\n<h2>结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVQ4y42TWauFMAyE/f+/0PMiiPu+70IPXyDi8Va4D0PbNB0nk+js+24U27Zd6xu4P89TwHmapp93zp3wTnochxXzPJskSUxZliZNU9M0zV/CuwIejeNoiqKQZBQAiPI8N1VVGd/3hTCOY1F6F+LoRoMQdl0nKiDt+14wDIMJw9BEUSSAjDj5PwqVgAf3SwUx9Y078rIsE7I7kbXkt8ZABkHbtrJSLiuWLMtyfcxa8vMD67qKh5RY17V4yR0+4ym2EPuXQiX0PE/guq4QaOzz+QjwVu2yEj7PkOAbjVLv6DYKAVZcCm0l24hts2qLvSp8DveT4C0uY0O3KEv3lKejAZg7yuXPwC9ytSlBEEguOayXQoxmz5zRTXyhe4A9MXzTkWFcyCXGHXHyvvBK7ODndxtOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"责任链结构\"\n        title=\"责任链结构\"\n        src=\"/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png\"\n        srcset=\"/blog/static/cd8a720c52b440ad2410037748a084bd/63868/chainstruct.png 250w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/0b533/chainstruct.png 500w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png 1000w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png 1225w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Handler</li>\n</ul>\n<p>定义一个处理请求的接口，实现后继链</p>\n<ul>\n<li>ConcreteHandler</li>\n</ul>\n<p>实现Handler接口，如果可以处理该请求就处理否则将该请求转发给它的后继者</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>向链上的具体ConcreteHandler提交请求</p>\n<h2>适用性</h2>\n<ul>\n<li>当多个对象都可以处理请求且哪个对象处理请求是运行时刻动态确定的</li>\n<li>在不想明确指定接收者的情况下，向多个对象的中的一个提交请求</li>\n<li>可处理一个请求的对象集合应是动态指定的</li>\n</ul>\n<h2>优缺点</h2>\n<ul>\n<li>降低耦合度 请求对象无需知道是其他哪个对象在处理其请求</li>\n<li>增强了给对象指派职责的灵活性  可以在运行中动态的对责任链中的对象进行添加或删除</li>\n<li>不保证被接受</li>\n</ul>\n<h2>实现</h2>\n<ul>\n<li>\n<p>实现后继者链</p>\n</li>\n<li>\n<p>连接后继者</p>\n</li>\n<li>\n<p>表示请求</p>\n<pre><code>  class Handler {\n  public:\n      virtual void handleRequest(Request* theRequest)\n      // _successor 实现后继链\n      Handler(Handler* s) : _successor(s) {}\n  private:\n      Handler*  _successor\n  }\n\n  class ConcreteHandler: public Handler {\n      public:\n      handleRequest(Request* theRequest) {\n          case:\n          /* 省略若干判断*/\n          default:\n          /*转发给后继处理*/    \n      }\n  }\n</code></pre>\n</li>\n</ul>","frontmatter":{"date":"2021-09-06","path":"/chain-responsibility","title":"10分钟设计模式-责任链"}}},"pageContext":{"readingTime":"2 min read"}},"staticQueryHashes":[]}