{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/3",
    "result": {"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"e3ace596-3e3b-503f-9749-e050e7ba90aa","html":"<p>在聊关于价值的一点想法之前，请让我介绍一部我喜欢的电影作为引子-Once upon a time in America(美国往事)。我微信的昵称是noodles，也是因为这部电影。</p>\n<p>美国往事是一部讲述美国20世纪60年代生活的犯罪电影，主角noodles(面条)在街区中结识了一群小伙伴，最开始过着调皮捣蛋的快乐生活，随着新搬来的邻居Max(麦克斯)的到来，大家逐渐去做一些犯罪和帮派的活动，在剧情不断发展中，跟随noodles经历了童年的欢乐、青涩的爱情、友情、遗憾、无奈。在'生意'逐渐做大的时候，他们一伙人想要铤而走险，noodles为了挽救他们的生命，选择了举报他们的行动，结果行动被破坏但是伙伴们都死于那次举报。noodles抱着悔恨远走他乡。多年以后，一封信把noodles叫回了故乡，此时的noodles已经头发发白，岁月在他身上有了明显的痕迹。这次他遇到了之前痛而不得的爱人，也遇到了自己的老友-Max.原来Max在之前的行动中做了个局，在那次行动中，Max并没有死而noodles被迫远走之后，Max占据了大家一起打拼的事业，‘一帆风顺’当上了部长。Max此时已经无法自保，他想向noodles坦白自己之前做的事，让noodles了结他的生命。印象中深刻的台词就这里发生了，当Max坦白，noodles却不愿意拿枪杀死他，画面切回了之前他们一起经历的快乐时光。noodles说: it`s just the way i see things(这是我对人生的看法)，I hava a story alse(我也有一个关于你说的故事)。在noodles讲述的故事中他因为自己的举报导致挚友去世感到悔恨一生，但是他们之间有真挚的友谊。最后nodles走之间对Max说希望调查的结果没有问题，否则一生的忙碌到最后没有结果很遗憾。最后Max自杀，电影闪回了noodles去烟管吸烟的场景，最后电影定格在noodles的笑容中。</p>\n<p>最近看了好几遍电影的后面部分，还是有些理解不好nooldes最后的笑容，不过渐渐地理解noodles的: I hava a story alse(我也有一个关于你说的故事).也许人生的价值或者意义就在于我们的看法。同样的人生也会因为看法不同导致感受。</p>\n<p>----一个长的引子的分割线----</p>\n<h2>什么是价值</h2>\n<p>亚里士多德将生活分为三类：动物式的生活，政治的生活和沉思的生活。</p>\n<ul>\n<li>动物式的生活指受到动物本能的指引，在缺少理智的参与下，过着无节制的生活</li>\n<li>政治的生活指人具有社会属性，可以放弃一些动物的本能去追求荣誉、善</li>\n<li>沉思的生活指通过思考达到精神的愉悦状态</li>\n</ul>\n<p>我理解在对这三种生活划分的时候，是没有贬义的，因为我们都或多或少的因为生活的阶段、能力的限制在间插似的体验不同的生活。在这个过程中不可避免的会对我们做的事，过的生活进行思考。这里其实就引入了价值的思考。如果生活的最终目的是幸福，当然这个幸福是相对的主观的。也许一个人的幸福是到老了回忆起年轻的一个蠢事或者儿孙满堂或者家缠万贯，幸福的定义虽有不同却大致相似。那价值就是那些拓宽我们关于幸福定义的事。</p>\n<h2>追求价值的方式</h2>\n<p>在去年开始相对集中的阅读，因为觉得自己在好像还看不明白一些事也想不明白。最近在看张维迎《经济学原理》一书中引发了我对价值这个问题的思考。在经济学中有个概念叫-生产可能性边界，用来表示经济社会在既定资源和技术条件下所能生产的各种商品最大数量的组合。这里可以用这个边界来类比幸福的范围.那我们生活的目标就集中在如何扩大幸福的边界和范围了。<br>\n我想年龄的焦虑一个主要的原因可能是在可见的未来能预测到幸福的边界会收缩，比如职场的35岁年龄焦虑，认为在未来年龄不在具有竞争力，那幸福的面积就可预测的缩小了。所以我理解追求幸福其实就是个逐步的拓宽边界的行为。这个行为可以很简单，比如早起、多运动、多陪伴家人。也可以相对复杂，比如创办一个家乡企业、写一本有意思的书。也可以比较抽象，比如在夏天的时候做个清凉的白日梦、在冬天的时候听听雪。</p>\n<h2>价值的相对性</h2>\n<p>说到底人生经历的事情还是自己和最亲密的人一起经历的，那价值就有很强的主观性，如果一直想让自己适应社会的价值想法会一直处于比较较劲的状态。不过关于价值这个问题自己也没有想的特别明白，也希望自己能一直想想这个问题。也希望跟看到这里的你一起想好这个问题，也许当有天有人带着鄙夷的语气问你生活的价值和意义的时候，你会告诉他: I hava a story alse(我对人生有不同的看法)</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"关于价值的一点想法","date":"2023-02-26","tags":"思考","path":"/thought-about-value","top":null,"summary":null}}},{"node":{"id":"4aeddc08-5bbe-5228-a3e4-90e1eae191bd","html":"<h2><a href=\"https://www.builder.io/blog/structured-clone\">Deep Cloning Objects in JavaScript, the Modern Way</a></h2>\n<p>structured-clone是在结构化克隆算法的基础上实现的克隆方案。结构化克隆算法会有一些限制:</p>\n<ul>\n<li>Function对象和DOM节点是不能被结构化克隆算法复制,会抛出DATA_CLONE_ERR</li>\n<li>对象的某些特定参数也不会被保留,比如RegExp 对象的 lastIndex 字段不会被保留、属性描述符、原型链上的属性等</li>\n</ul>\n<p>对比几种clone方案:</p>\n<ul>\n<li>对象扩展符和Object.assign不能实现深克隆</li>\n<li>JSON.parse(JSON.stringify(x))  JSON.stringify无法处理循环引用数据、丢失内置类型(Map/Set/Date/Symbol等)、无法复制函数</li>\n<li>cloneDeep是一个比较成熟的方案，但是它的包体积有点大材小用(在平时的使用中其实很少用到那么复杂结构的数据)</li>\n</ul>\n<h2><a href=\"https://jakearchibald.com/2023/unhandled-rejections/#unhandled-rejections-are-problematic\">The gotcha of unhandled promise rejections</a></h2>\n<p>这篇文章介绍for wait中unhandled promise的处理方式</p>\n<h2><a href=\"https://blog.codeminer42.com/everything-you-need-to-know-about-concurrent-react-with-a-little-bit-of-suspense/\">Everything you need to know about Concurrent React (with a little bit of Suspense)</a></h2>\n<p>这篇文章介绍React Concurrent mode.通过例子引入Concurrent mode中高优先级和低优先级任务的处理，比较生动。</p>\n<h2><a href=\"https://www.macarthur.me/posts/options-for-removing-event-listeners\">You’ve Got Options for Removing Event Listeners</a></h2>\n<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/axios-cancel\">axios的cancel功能源码解读</a>中axios已经AbortController来实现请求的终止，这篇文章中介绍了使用AbortController实现网页中元素绑定事件的移除</p>\n<h2><a href=\"https://deno.com/blog/the-future-of-web-is-on-the-edge\">The Future of the Web is on the Edge</a></h2>\n<p>这篇文章简单介绍Serverless的概念，可以结合<a href=\"https://juejin.cn/post/6996271746898722830\">为什么我不使用Serverless</a>，<a href=\"https://www.zhihu.com/question/506704568\">如何评价无服务器计算（serverless）的未来前景？你认为 serverless 有未来吗？</a>进一步了解Serverless</p>\n<h2>工具</h2>\n<h3><a href=\"https://mafs.dev/\">Mafs</a></h3>\n<p>实现可交互的数学视图的React库</p>\n<h3><a href=\"https://github.com/mswjs/msw\">msw</a></h3>\n<p>一个支持在浏览器和node环境中实现Mock Server的库，在浏览器中它通过Service Worker或者通过拦截原生的fetch实现mock，在node中通过拦截器封装原生的http模块实现mock.</p>\n<h3><a href=\"https://github.com/nolimits4web/swiper\">swiper</a></h3>\n<p>移动端的swiper组件，有比较多的动效支持</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/7044934738431180830\">最新HTML规范——structuredClone深拷贝函数，能取代JSON或者lodash吗？</a>\n<a href=\"https://stackoverflow.com/questions/59694309/for-await-of-vs-promise-all\">for await of VS Promise.all</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2023-2-1-前端快报","date":"2023-02-13","tags":"前端快报","path":"/2023-2-1","top":null,"summary":null}}},{"node":{"id":"240f03c5-3aa3-5133-a076-80d06778e48d","html":"<p>这里记录下2023读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2023年已阅读: 30本</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>张维迎寓言经济学 岑科 傅小永 邓新华</h2>\n<h3>推荐指数 4</h3>\n<p>通过寓言比喻的方式阐述了经济学,自由市场,国企等相关观点 一些观点难免有些激进 不过需要不同的观点来冲撞才有不同的视角来看世界,推动改革.张老师对于自由市场和国企改革的想法很多,也让我对大国企和自由市场有了一些简单的思考.改革是大题,需要慢慢答,特别是在人口超规模的中国,无论如何希望还是拥有改革开放时候的魄力,能积极改进</p>\n<h2>美丽新世界 4.5 奥尔德斯·赫胥黎</h2>\n<h3>推荐指数 4.5</h3>\n<p>读过《1984》里面塑造了一个可怕和压抑的社会,但这个社会还有一些美好就是有主人公一样的角色在思考,在试图反抗\n《动物农场》则是用童话故事去反映团体中成员的无助和统治者的行为\n《美丽新世界》里面塑界了一个高度塑造的社会,有些毛骨悚然.通过作者后面的论证和文中的一些场景,似乎这样社会的某些方面已经在现实生活中发生</p>\n<h2>叫魂: 1768年中国妖术大恐慌 孔飞力</h2>\n<h3>推荐指数 4.5</h3>\n<p>作者从叫魂的一个小案件开始叙述,从社会背景多方面讲述了那段历史.其中看到了官僚制度与帝王制度的抵抗、百姓对于未知恐惧、权力的恐慌与无助</p>\n<h2>约翰·克里斯多夫 罗曼·罗兰 许渊冲译</h2>\n<h3>推荐指数 5</h3>\n<p>在初高中有段时间比较喜欢看书，在书店总能看到这本《约翰·克里斯多夫》，印象中在书架上摆放了上中下三本，深灰色的包装。当时觉得这么长的书肯定不好看。这次鼓足了气翻开了这本书，一下子就被吸引住了。罗曼罗兰对于细腻情感的把握真的很好，比较能打动人。喜欢文中对自然景色，人物性格的描写都扣人心弦。在书中跟随着克里斯多夫走完了他的一生，从最开始莽莽撞撞的小伙子到最后老年的平静，在他身上似乎总有一种火在燃烧，那朵火并没有因为年龄或者阅历而熄灭。最开始喜欢克里斯多夫不断碰壁的莽撞的性格，从德国到巴黎，中间夹杂了很多对艺术的描写。现在的我也许还不能对这些艺术的描写有那么深的领悟，只能体会到艺术或者音乐在磨难中一直陪伴着克里斯多夫。克里斯多夫还有真诚的性格，他与奥利维的友谊一直延续到他人生的终点，从现实的生活中很难发现这样的友谊当然也很羡慕这种友谊。在爱情上似乎一直都有暗线在行进，后面与葛拉齐亚的故事是有克制的爱情，那种相知多年的爱人的感觉，读起来也很温馨，推荐这本书，也许等到在成长一些在看一遍这本书会有不同的感悟</p>\n<h2>经济学原理 张维迎</h2>\n<h3>推荐指数 4.5</h3>\n<p>一直没有仔细阅读过经济学原理方面的书籍都是相对概括介绍的读物。本书系统的介绍了微观经济学和宏观经济学中的相关概念，有些知识点自己之前只是简单了解或者理解的不对都在阅读的过程中得到了深化，特别是宏观经济学中观于经济周期与经济波动的部份读起来兴趣昂然。推荐</p>\n<h2>好好告别 凯瑟琳·曼尼克斯</h2>\n<h3>推荐指数 4</h3>\n<p>本书从临终的模式开始说起，讲到对待死亡的告别方式、态度、谈论死亡的时机、对生命的预期、对生命的看法。书中的故事很有趣也很感人，作者的叙事方式感觉就像在你身边跟你讲一件熟悉的事一样。推荐这本书，能激发一些思考，对死亡的准备和人生的意义</p>\n<h2>你是你吃出来的: 吃对少生病，病了这样吃 夏萌</h2>\n<h3>推荐指数 3.5</h3>\n<p>对饮食跟身体的关系有了全新的认识，书的内容不错从营养素的介绍到缺乏对应营养素身体的反应都讲解的通俗易懂。适合快速翻阅</p>\n<h2>理想国 柏拉图</h2>\n<h3>推荐指数 4</h3>\n<p>理想国是论证一个理想的城邦或者国家应有的样子，包括教育、统治者、人的行为等。通过对话辩论的方式阐释观点，其中会有些晦涩难懂或者绕的方式。不过并没有掩盖书中的一些重要的观点。</p>\n<ul>\n<li>要注重身体各部分的感受，感受身体和灵魂</li>\n<li>感受事物的真实，对观察思考</li>\n<li>要有求知欲，去看更广阔的世界</li>\n<li>精力有限，要追求更‘好’的欲望</li>\n</ul>\n<h2>芯片战争 余盛</h2>\n<h3>推荐指数 4</h3>\n<p>因为在A股有投资半导体企业所以通过这本书来了解半导体整个行业的背景和现状。书中详细的介绍全球半导体的发展过程。日本半导体的崛起和衰落、韩国半导体的崛起、荷兰的阿斯麦尔的发展过程读起来都饶有兴致。书中对于中国半导体行业的发展介绍的也很详细。让我了解到了一些中国半导体的至暗时刻，也看到国内半导体行业为突破技术封锁的尝试。作为一本介绍半导体行业的书本书通俗易懂，故事性强，推荐阅读。</p>\n<h2>农民笔记 候永禄</h2>\n<h3>推荐指数 3.5</h3>\n<p>跟着书读完作者的一生,经历了那些只在书本中的年代,书的名字是农民笔记。但是作者是一个有知识、思考、坚持的人,在那些年代很不容易.很感谢这本书让那些年代的记忆鲜活了，也让我意识到在自己的内心中有坚持也能过好一生</p>\n<h2>一个无政府主义者的意外的意外死亡 达里奥·福</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过剧本的方式呈现生动有趣的故事，描述的细节很精彩感觉人物栩栩如生，推荐</p>\n<h2>蛤蟆先生去看心理医生  罗伯特·戴博德</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过这本书跟着蛤蟆先生一起成长。成长的过程在于认识自己的内心，去理解自己的情绪，摆脱过去消极的思维模式。很有意思的故事。推荐</p>\n<h2>疯人说: 精神病院医生手记 穆戈</h2>\n<h3>推荐指数 4</h3>\n<p>书的内容是讲述在精神病院中病人的故事，精神病人的故事很有意思，通过对故事了解了精神病相关的背景知识。感受最深的一点就是家庭的因素对精神病人病情影响很大。比如索引病人，其实就是这个家庭成员状态的索引，需要调整好家庭的状态病人回归家庭才能好。小说有意思的是把几个精神病人的故事连成了一个故事，这个故事的命题</p>\n<ul>\n<li>你是相信世界是不好的但怀着热情生活</li>\n<li>你知道世界不好选择无视他或者逃避它生活下去</li>\n</ul>\n<p>很有意思的小说，虽然部分剧情比较牵强，但是不影响整体，推荐</p>\n<h2>百年孤独 加西亚·马尔克斯</h2>\n<h3>推荐指数 5</h3>\n<p>记不清是第几次准备看这本书了，每次都是被开头的人物名字弄迷糊然后就放下了。这次耐下心来一周就看完了。百年孤独有故事的魔幻性、历史的厚重和轮回。在书中见证了一家人从最开始的兴旺到没落。结尾中破解了羊皮卷发现内容就是预言整个家族的事的时候很震撼。</p>\n<ul>\n<li>似乎并没有理解好文中孤独的概念。孤独是不是就是上校重复制作的小金鱼(对生活失去了理想只是让自己有事可做)或者是不想织不完的寿衣(不想面对老去的现实)。</li>\n<li>有种空虚感，文中人物故事的轮回，我们自己的人生也是否是空欢喜一场，上校会被人忘记，事实也会被篡改</li>\n</ul>\n<p>推荐，是本值得反复品味的书</p>\n<h2>置身事内: 中国政府与经济发展 兰小欢</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过阅读这本书对国家和政府一些经济行为有了比较深入的了解。作者表达的内容也很客观和辩证</p>\n<h2>默里·麦克布莱德的五个愿望 乔·西普尔</h2>\n<h3>推荐指数 3.5</h3>\n<p>书的内容讲述一个老人帮助一个患有心脏病孩子完成'遗愿'的故事，想起了电影《菊次郎的夏天》</p>\n<h2>挑灯看剑:观察经济大时代  周其仁</h2>\n<h3>推荐指数 3.5</h3>\n<p>书的内容收录周教授发布的一些文章，涉及到垄断、教育、土地制度等，对一些感兴趣的话题可以着重阅读</p>\n<h2>名人传 罗曼·罗兰</h2>\n<h3>推荐指数 3</h3>\n<p>整体感觉一般，不推荐</p>\n<h2>小镇喧嚣:一个乡镇政治运作的演绎与阐释 吴毅</h2>\n<h3>推荐指数 5</h3>\n<p>非常推荐。作为一部了解乡镇地方政治的读物，书中从故事展开乡镇中因利益导致的多方博弈，细节翔实很是精彩。在利益博弈中，处于“弱者”地位的农民以“刁”的方式从利益谈判中获取更多的利益空间。村干部在本书中的介绍十分精彩，在面对上级压力和农村的人情社会中，村干部用“媒”的方式来完成一些必须完成的任务。乡镇因为直面基层，处于权力的触角底端和社会结构特性演变出了更生活的政治运行方式，在阅读的过程中不觉得一方绝对的“恶”或者绝对的“正义”。小镇的博弈也充满了时代的特点，小镇的博弈也并不会完结，对于这种博弈是否能在演化中形成一种正向循环的结果，作者似乎给了一种方式-尊重人\n，以人为目的而不是手段。这似乎是一个任重而道远的过程。\n财富的变化需要几代人去积累，社会人文法治的变化更是一个长期潜移默化的过程。通过这本书可以不再以冷眼来观看这小段历史的演进，我们在这个时代中，虽然个人并不一定能改变什么或者留下足够的印记，但是我们的一些想法所做所为都会反应到当前这个时代的群体特征中。了解和认识也许就是改变的开始。</p>\n<h2>以利为利：财政关系与地方政府行为 周飞舟</h2>\n<h3>推荐指数 4.5</h3>\n<p>在回家火车的路上几乎一口气看完本书的后半段.通过本书对我国税费改革历史以及税费改革中中央与地方的关系有了较为详细的认识。\n中央和地方的收放关系其实覆盖改革的全过程。顶层的政策设计也造成了一些不可预估的问题。比如基层财政的悬空，土地财政的疯狂等\n阅读的过程中脑海中蹦出一个词竭泽而渔。也找到了答案。只有以人为本才能长期可持续</p>\n<h2>地下室手记 陀思妥耶夫斯基</h2>\n<h3>推荐指数 5</h3>\n<p>作者对人物内心的刻画十分到位,能拿捏住人内心的小心思。书中讲述主人公对抗自我认知焦虑和社交焦虑的过程,在描述的过程中会觉得主人公身上有自己的影子。虽然主人公在对待朋友，相识的妓女一些行为上有些不可理喻，但是始终提不起对主人公恶的看法。感觉他像个拼命想要爬出平面却没有扶手的落水者。推荐</p>\n<h2>转型中的地方政府:官员激励与治理(第二版) 周黎安</h2>\n<h3>推荐指数 5</h3>\n<p>对中央与地方政府的关系有了深刻的了解 本书比较系统的介绍了中央和地方政府行政和财政方面制度的演进,整本书读起来很有层次，内容层层递进。能引发一些对当下问题的思考</p>\n<h2>历史的面孔 徐涛</h2>\n<h3>推荐指数 4</h3>\n<p>我们总是容易关注历史中的'大人物'却容易忽略一些也在推动历史前进的'小人物'。通过本书了解到了一些历史人物的细节和性格特点。比较喜欢这样的历史人物讲述方式。</p>\n<h2>历史的面孔2 徐涛</h2>\n<h3>推荐指数 4</h3>\n<p>从这本书里面又认识的几个历史人物，或者用作者的话-认识了几个‘朋友’。喜欢读历史其实并没有那些从历史中借鉴的功利之心，就觉得想了解那段时间或者具体的历史人物在那个阶段都做了什么就很有趣。在读的过程中反而会引发你的思考这个也许就是读历史有趣的地方。</p>\n<h2>精神与爱欲 赫尔曼·黑塞</h2>\n<h3>推荐指数 4.5</h3>\n<p>了解自己并且按照自己的心性去实现自我价值也许是这本书在讨论的内容之一。有时候忙碌到忘记关照内心的想法，这个时候要是有一个纳尔齐斯来点醒一下应该不错。书中主要描写歌尔德蒙看似放荡不羁的一生，好多处能读出历史的沧桑的感觉。黑塞在这本书中还表达的其他的内容，比如对于美、对于母性等，希望后面再重读这本书的时候有更深的感悟</p>\n<h2>罪与罚 陀思妥耶夫斯基</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中对于人物内心的描写很细致到位，主人公抱着所谓‘伟大’的出发点杀死了典当铺的老妪，书中的内容就围绕他对犯下罪行的掩盖和内心的惩罚展开。书中的角色塑造都有比较丰满。结尾作者给出的答案是用爱来化解所犯下的罪行。仿佛看到了那个场景，在寒冷的西伯利亚两个人互相依偎取暖。</p>\n<h2>告别百年激进 温铁军</h2>\n<h3>推荐指数 5</h3>\n<p>这本书虽然是温铁军2004年-2014年的演讲收录，但是书中的一些内容仍然不过时，读起来有种醍醐灌顶的感觉，书中从资本的全球化展开，对全球的经济发展有了更好的全局视角，才能更好的理解到当前我国的问题。逐步递进到现代化的困境、我们在现代化过程中的发展&#x26;困境、区域发展等。内容层层递进。读完有种意犹未尽豁然开朗的感觉。有一个最大的感受就是在阅读或者生活中，要学会或者试着用自己的视角去看待事物，养成独立思考的模式，避免隐形的框式思维限制住。</p>\n<h2>生死疲劳 莫言</h2>\n<h3>推荐指数 5</h3>\n<p>这本书是一本有历史厚重感的书，可以跟着牛、驴、猪、狗不同的‘动物’或者人的视角去看发生在西门屯的事。西门闹(身份地主)被枪毙经过多次轮回好像渐渐失去了几辈子之前的记忆也忘记了之前的怨恨。有种错觉自己是否也是经历了几个轮回刚好忘记了之前的事而冥冥中跟不同的人存在的命运的羁绊。比较喜欢书中的蓝脸，能在混乱的时代坚持住自己，认住‘死’理很不容易。书中的人物有血有肉，当然也有所谓’对错‘，不过看到最后好像也能理解当阎王问西门闹(主人公)心中是否还有仇恨的时候，西门闹摇了摇头。生死疲劳，从贪欲起。少欲无为，身心自在还需要更多的理解。</p>\n<h2>长安的荔枝 马伯庸</h2>\n<h3>推荐指数 4</h3>\n<p>历史的兴衰从小事中可以看出来。一骑红尘妃子笑、烽火戏诸侯都加速了王朝的灭亡。作者的写法很有代入感，感觉自己就是变成了那个荔枝使。不同的是最后的结果普通人是否有勇气向’右相杨国忠‘反应真实的情况并且能落得一个’善终‘。</p>\n<h2>四世同堂  老舍</h2>\n<h3>推荐指数 5</h3>\n<p>在初中的时候读过老舍的《骆驼祥子》。那个时候对文字没有现在的感受力，这次读《四世同堂》感觉书中发生在小羊圈的故事就真实地展现在自己的眼前。本书主要围绕在北平沦陷后祁家四代人的故事展示。有所谓‘因循守旧’的祁老人、有安守本分的掌柜天佑、有处于新老文化交接思想冲突激烈的瑞宣、有代表未来的小孩。在这本书中更加深刻的理解了家国的概念，有大国才能有小家。</p>","fields":{"readingTime":{"text":"24 min read"}},"frontmatter":{"title":"读书目录-2023","date":"2023-01-28","tags":"读书目录","path":"/book-list-2023","top":null,"summary":null}}},{"node":{"id":"b554705e-f1cc-52f6-ab7b-0159784362a1","html":"<h2><a href=\"https://github.com/reactwg/react-18/discussions/37\">New Suspense SSR Architecture in React 18</a></h2>\n<p>这篇文章介绍react 18中流式渲染和Suspense的结合，实现更好的服务端渲染功能。相关文章还有<a href=\"https://juejin.cn/post/7064759195710521381\">浅析React 18 Streaming SSR</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍2022年热度比较高的React库</p>\n<h2><a href=\"https://developer.aliyun.com/article/781882\">一文详解 CSS-in-JS</a></h2>\n<p>这篇文章从CSS规范、CSS的设计模式说起，逐步覆盖到CSS-in-JS的细节，涉及的相关背景比较多，值得仔细阅读。</p>\n<h2><a href=\"https://weizman.github.io/page-what-is-a-realm-in-js/#identity-discontinuity\">What is a realm in JavaScript?</a></h2>\n<p>这篇文章介绍JavaScript中Realm的定义。也可以结合这篇<a href=\"https://2ality.com/2022/04/shadow-realms.html\">ShadowRealms – an ECMAScript proposal for a better eval()</a>介绍ShadowRealms API提议的文章一起了解。</p>\n<h2><a href=\"https://roadmap.sh/roadmaps/\">Developer Roadmaps</a></h2>\n<p>Developer Roadmaps收集了各个开发方向的技能路线图</p>\n<h2><a href=\"https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo\">How we configured pnpm and Turborepo for our monorepo</a></h2>\n<p>一篇比较详细的介绍monorepo技术方案选择工具的文章，从多项目开发的问题开始说起，逐步介绍<a href=\"https://github.com/pnpm/pnpm\">pnpm</a>(monorepo管理工具)和<a href=\"https://github.com/vercel/turbo\">Turborepo</a>(打包构建工具)</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart\">js-code-to-svg-flowchart</a></h3>\n<p>一个将JavaScript代码转化成svg图片的库。</p>\n<h3><a href=\"https://console-ninja.com/\">CONSOLE NINJA</a></h3>\n<p>一款VSCode插件，可以直接在代码中查看输入的console调试信息</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/shuding/react-wrap-balancer\">react-wrap-balancer</a></h3>\n<p>react-wrap-balancer能使文案比较智能的适应容器，占据容器的空间，达到比较好的展示效果，下面从源码上看它是如何实现的:\n<img src=\"/blog/9336733f998bb911bd52006bac3dd61b/blancer.gif\" alt=\"react-wrap-balancer\">\n通过简单的demo使用可以发现balancer在页面中注入了一段脚本并且为包裹的文本内容绑定的属性标识\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.399999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsElEQVQI1y2JQW6DMBQFuf/NWlGEDbaA2NDSUAL4QxopQFdTgbIYvRm9yMQFnS9xtsGVEzL/McsDmSYk3BFZmWUhjHf6YaUfnoRl5zaudP2TYVoZw3b24VESW8qiJlMarSw68+SmQClFqnIqf8UYi1KG96QkzRu0rflIKxLt0KYhzRxvsaXyHVGuf7h4wX0uVC5Qfy34/hd/e9DKxrdstLK/fKVb9nMPrvN2cnj7+v4B3u7bRFMr7ugAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"balancer-show\"\n        title=\"balancer-show\"\n        src=\"/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png\"\n        srcset=\"/blog/static/209d5af74aebd83c377943dd2258a96b/63868/blancerShow.png 250w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/0b533/blancerShow.png 500w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png 1000w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png 1088w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>    // react-wrap-balancer的主体代码逻辑\n    const Balancer: React.FC&#x3C;BalancerProps> = ({\n        as: Wrapper = 'span',\n        ratio = 1,\n        children,\n        ...props\n    }) => {\n        // 利用useId为组件生成唯一标识，useId可以根据组件的层级结构生成唯一标识\n        const id = React.useId()\n        const wrapperRef = React.useRef&#x3C;WrapperElement>()\n        const hasProvider = React.useContext(BalancerContext)\n\n        // 监听函数执行\n        // useIsomorphicLayoutEffect这里对服务端和客户端做了区分 在服务端调用useEffect,在客户端调用useLayoutEffect 解决客户端的闪动问题\n        useIsomorphicLayoutEffect(() => {\n            if (wrapperRef.current) {\n            // 调用绑定self上绑定的动态调整函数 并传入当前的入参执行\n            // self可以指代全局的window https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n            // 主要计算逻辑都在relayout函数中\n            ;(self[SYMBOL_KEY] = relayout)(0, ratio, wrapperRef.current)\n            }\n        }, [children, ratio])\n\n        // 自己卸载的时候 终止监听函数\n        useIsomorphicLayoutEffect(() => {\n            return () => {\n                if (!wrapperRef.current) return\n\n                const resizeObserver = wrapperRef.current[SYMBOL_OBSERVER_KEY]\n                if (!resizeObserver) return\n\n                resizeObserver.disconnect()\n                delete wrapperRef.current[SYMBOL_OBSERVER_KEY]\n            }\n        }, [])\n\n        return (\n            &#x3C;>\n                &#x3C;Wrapper\n                    {...props}\n                    // 绑定的唯一标识\n                    data-br={id}\n                    data-brr={ratio}\n                    ref={wrapperRef}\n                    style={{\n                    display: 'inline-block',\n                    verticalAlign: 'top',\n                    textDecoration: 'inherit',\n                    }}\n                    suppressHydrationWarning\n                >\n                    {children}\n                &#x3C;/Wrapper>\n                {createScriptElement(hasProvider, `self.${SYMBOL_KEY}(\"${id}\",${ratio})`)}\n            &#x3C;/>\n        )\n    }\n</code></pre>\n<p>通过上面的源码分析，主要的动态计算逻辑都在relayout函数中</p>\n<pre><code>    const relayout: RelayoutFn = (id, ratio, wrapper) => {\n        // 根据id获取包裹的wrapper组件\n        wrapper =\n            wrapper || document.querySelector&#x3C;WrapperElement>(`[data-br=\"${id}\"]`)\n        // wrapper的父容器\n        const container = wrapper.parentElement\n        // 更新wrapper的最大宽度\n        const update = (width: number) => (wrapper.style.maxWidth = width + 'px')\n\n        // 重置wrapper的最大宽度\n        wrapper.style.maxWidth = ''\n\n        // 获取wrapper的父容器的宽高\n        const width = container.clientWidth\n        const height = container.clientHeight\n\n        // 二分查找的方式计算wrapper的宽度\n        let left: number = width / 2\n        let right: number = width\n        let middle: number\n\n        if (width) {\n            while (left + 1 &#x3C; right) {\n                middle = ~~((left + right) / 2)\n                update(middle)\n                if (container.clientHeight === height) {\n                    // 缩放后 高度没有变 那么right= middle\n                    right = middle\n                } else {\n                    // 否则right = middle\n                    left = middle\n                }\n            }\n\n            // 更新wrapper的宽度\n            update(right * ratio + width * (1 - ratio))\n        }\n\n        // 通过ResizeObserver去监听wrapper父容器的变化 执行relayout函数\n        if (!wrapper['__wrap_o']) {\n            ;(wrapper['__wrap_o'] = new ResizeObserver(() => {\n            self.__wrap_b(0, +wrapper.dataset.brr, wrapper)\n            })).observe(container)\n        }\n    }\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null}}},{"node":{"id":"397dff62-95c9-527b-a1bb-bcd9b51c1901","html":"<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/react-hooks\">React Hooks源码解读</a>中有对React hooks的实现原理进行分析，本文主要结合React hooks的发展过程聊下对hooks的理解。hooks的提出主要解决了以下的问题:</p>\n<ul>\n<li>为react带来通用的代码逻辑复用的方式。相对于render props/高阶组件(HOC)等，hooks在代码复杂度上都有一定降低。声明式的hooks使用方式也符合函数式编程的思想。</li>\n<li>解决类组件生命周期函数复杂度和在新的react架构中的一些问题</li>\n<li>规范react使用范式，通过hooks的接口能更好的组织组件与组件/组件与渲染的原生DOM/组件与外部依赖之间的关系</li>\n</ul>\n<h2>通用的代码复用方式</h2>\n<p>react中可以通过render props/高阶组件(HOC)实现代码的能力的复用(组合)。</p>\n<pre><code>// render props通过传入渲染函数的方式复用逻辑\nclass Cat extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = { name: 111 }\n        // 可复用的逻辑\n    }\n    render() {\n        // 通过调用渲染函数的方式实现共享\n        return this.props.render(this.state)\n    }\n}\nclass App extends Component {\n    render() {\n        return (\n            &#x3C;Cat render={params => (&#x3C;div>{params.name}&#x3C;/div>)} />\n        )\n    }\n}\n// 高阶组件\nfunction HOC(WrappedComponent) {\n  return class extends Component {\n    componentDidMount() {\n      // 通用的业务逻辑\n    }\n    render() {\n      return (&#x3C;WrappedComponent {...this.props} />)\n    }\n  }\n}\n</code></pre>\n<p>从render props和高阶组件的实现方式上看，两者都引入了新的组件结构来实现复用，增加了理解成本从而导致一些问题。笔者在最开始对高阶组件不熟悉的时候就遇到过一次bug。包裹的高阶组件没有将外层传递的属性透传给被包裹的组件从而导致子组件渲染异常。<br>\nhooks通过函数声明式的方式实现代码复用，理解上更符合可见可得的思想，减少了理解成本。</p>\n<h2>解决老的问题</h2>\n<p>类组件的生命周期问题导致代码逻辑的分离，比如事件的监听与解绑</p>\n<pre><code>// 类组件示例\nclass Test extends Component {\n    componentDidMount() {\n        // 监听\n        document.addEventListener()\n    }\n    componentWillUnmount() {\n        // 解绑\n        document.removeEventListener()\n    }\n    render() {}\n}\n// 函数式组件示例\nfunction Test(props) {\n    useEffect(() => {\n        // 监听\n        document.addEventListener()\n        return () => {\n            // 解绑\n            document.removeEventListener()\n        }\n    }, [])\n    return xxx;\n}\n</code></pre>\n<p>在Concurrent Mode中会导致生命周期函数的多次执行，hooks的提出在结构上是与Fiber结构绑定的，服务于新的架构的</p>\n<h2>规范使用范式</h2>\n<p>react开发者都需要用一些库(redux等)来组合应用，react通过hooks为react增加了状态管理、操作DOM的入口、父子组件调用方式等，丰富且规范了React开发者的开发模式。通过这种规范可以让React更好的与社区结合，比如相关的库<a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>、<a href=\"https://github.com/streamich/react-use\">react-use</a>。</p>\n<h2>hooks使用注意</h2>\n<ul>\n<li>避免hooks依赖，比如useMemo/useCallback等是否需要使用。使用多个useState的时候是否引入其他的管理库来解</li>\n<li>UI逻辑与业务逻辑合理拆分。hooks做过多的业务逻辑会导致业务逻辑不明晰，需要进行适当的拆分。</li>\n<li>hooks的依赖问题会导致业务中存在隐藏逻辑，需要控制代码中隐藏逻辑和隐藏逻辑的依赖问题</li>\n<li>hooks更适合组件级别的代码复用和逻辑,跨组件逻辑需要仔细设计(比如是否需要useRef)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null}}},{"node":{"id":"5727745d-cc22-558e-b830-2ecc6b9c1e75","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\n    logMessage(user, message) {\n        const sender = user.getName();\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\n    }\n}\nclass User {\n    constructor(name, chatroom) {\n        this.name = name;\n        this.chatroom = chatroom;\n    }\n\n    getName() {\n        return this.name;\n    }\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\n    send(message) {\n        this.chatroom.logMessage(this, message);\n    }\n}\nconst chatroom = new ChatRoom();\nconst user1 = new User(\"John Doe\", chatroom);\nconst user2 = new User(\"Jane Doe\", chatroom);\nuser1.send(\"Hi there!\");\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\nconst books = new Map();\nconst createBook = (title, author, isbn) => {\n    const existingBook = books.has(isbn);\n    if (existingBook) {\n        // 已存在就查找返回\n        return books.get(isbn);\n    }\n    // 不存在新建返回\n    const book = new Book(title, author, isbn);\n    books.set(isbn, book);\n    return book;\n};\n//  存储书的列表\nconst bookList = [];\nconst addBook = (title, author, isbn, availability, sales) => {\n    const book = {\n        // 利用之前的共享对象创建新的实力\n        ...createBook(title, author, isbn),\n        sales,\n        availability,\n        isbn\n    };\n    bookList.push(book);\n    return book;\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\n    class OrderManager {\n        constructor() {\n            // 指令处理的对象\n            this.orders = [];\n        }\n\n        execute(command, ...args) {\n            // 匹配指令和指令处理的对象\n            return command.execute(this.orders, ...args);\n        }\n    }\n    // 指令创建类\n    class Command {\n        constructor(execute) {\n            this.execute = execute;\n        }\n    }\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\n    function PlaceOrderCommand(order, id) {\n        return new Command(orders => {\n            orders.push(id);\n            return `You have successfully ordered ${order} (${id})`;\n        });\n    }\n    const manager = new OrderManager();\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":3,"pageCount":15,"additionalContext":{"pageAllCount":87}}},
    "staticQueryHashes": []}