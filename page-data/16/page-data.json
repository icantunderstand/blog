{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/16",
    "result": {"pageContext":{"pageAllCount":91,"group":[{"node":{"id":"cfb62610-6cf5-58f8-94ad-207f2e5dfb04","html":"<h2>简介</h2>\n<p>koa利用生成器来解决回调函数的嵌套问题，实现的十分巧妙，下面跟着官网的例子逐步学习下koa的实现原理<br>\n官网 <a href=\"http://koa.bootcss.com/\">koa</a></p>\n<h2>使用</h2>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n});\r\napp.listen(8080);  \n</code></pre>\n<p>这个例子很像在Node中构建HTTP服务器的例子</p>\n<pre><code>var http = require('http');\r\nhttp.createServer(function(req,res){\r\n    res.writeHead(200,{'Content-Type':'text/plain'});\r\n    res.end('hello world');  \r\n}).listen(8080);  \n</code></pre>\n<p>通过app.use()设定中间件 app.listen()监听特定的端口这样整个web服务器就启动了 那我们的关注点就到了这句话 var app = koa();<br>\nkoa的源码lib下有四个文件 application.js context.js request.js response.js  在koa的package.json中main属性的值指向的是lib/application.js 也就是整个web服务器的生成过程都在这个js中 下面我们逐步的解读下application.js的部分源码</p>\n<pre><code>module.exports = Application;\r\nfunction Application() {\r\n    if (!(this instanceof Application)) return new Application;//确保不通过new调用构造函数的时候返回正确的值\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.subdomainOffset = 2;\r\n    this.middleware = [];//保存中间件的数组\r\n    this.proxy = false;\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);//通过指定的原型创建对象\r\n }  \n</code></pre>\n<p>通过上面这段代码，也就是在调用这句话的时候 var app = koa()实际上就是生成了一个Application实例 在实例上有一个数组用于保存中间件 三个属性 context request response</p>\n<pre><code>var app = Application.prototype;\r\napp.listen = function(){\r\n    debug('listen');\r\n    var server = http.createServer(this.callback());//this.callback()就是请求来的处理函数\r\n    return server.listen.apply(server, arguments);  \r\n    //这里上文中Node构建HTTP服务的例子 似曾相识 \r\n};  \n</code></pre>\n<p>在http.createServer(this.callback())中this.callback()就是请求来的处理函数也就是app.callback()这个函数 正是这个函数实现了koa的中间件机制</p>\n<h2>中间件</h2>\n<p>在介绍中间件的原理之前 先上一个例子</p>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(next){\r\n    console.log(1);\r\n    yield next;\r\n    console.log(2);\r\n});\r\napp.use(function *(next){\r\n    console.log(3);\r\n    yield next;\r\n    console.log(4);\r\n});\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n})；\r\napp.listen(3000);  \n</code></pre>\n<p>当对服务器发送一个请求的时候  会发现服务器的控制台log出的顺序是 1 3 4 2 下面我们来看一下这个神秘的app.callback()函数到底做了什么</p>\n<pre><code>app.use = function(fn){\r\n    if (!this.experimental) {\r\n      // es7 async functions are not allowed,\r\n      // so we have to make sure that `fn` is a generator function\r\n      assert(fn &#x26;&#x26; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);//将每次调用的生成器函数push到中间件数组\r\n    return this;//可以实现链式调用\r\n}; \n</code></pre>\n<p>app.use()就是收集所有设定的中间件，然后存储到数组中</p>\n<pre><code>app.callback = function(){\r\n  var fn = this.experimental\r\n    ? compose_es7(this.middleware)\r\n    : co.wrap(compose(this.middleware));\r\n  var self = this;  \r\n  return function handleRequest(req, res){\r\n    res.statusCode = 404;\r\n    var ctx = self.createContext(req, res);\r\n    onFinished(res, ctx.onerror);\r\n    fn.call(ctx).then(function handleResponse() {\r\n      respond.call(ctx);\r\n    }).catch(ctx.onerror);\r\n  }\r\n};  \n</code></pre>\n<p>app.callback()中的返回值 function handleRequest(req,res){}就是请求来的时候的处理函数 在这个处理函数中调用fn进行事件的处理 fn是什么呢？  我们只需要搞明白这句话 co.wrap(compose(this.middleware))</p>\n<p>第一步 compose对生成器函数数组进行了处理</p>\n<pre><code>function compose(middleware){\r\n  return function *(next){\r\n    if (!next) next = noop();\r\n    var i = middleware.length;\r\n    while (i--) {\r\n      next = middleware[i].call(this, next);//不断的获取后一个生成器对象 作为参数传入当前的生成器函数并且执行获得生成器对象\r\n    }\r\n    return yield *next;\r\n  }\r\n}\r\nfunction *noop(){}  \n</code></pre>\n<p>其实理解compose的作用要理解好通过app.use(function *(next) {}) 传递的生成器函数传递的next  整个compose的作用就是生成器函数的执行后进行从头到尾的串联 然后返回一个生成器<br>\n接下来就需要理解co的执行流程了</p>\n<h2>co源码解读</h2>\n<p>co是通过生成器避免了多个异步操作的回调嵌套</p>\n<pre><code>function *test() {\r\n  var a = yield readFile1();\r\n  var b = yield readFile2();\r\n}\n</code></pre>\n<p>简单理解co的作用就是首先获取之前执行的结果 保存下来当下次调用generator.next()的时候作为参数传入，这样就实现了异步操作的同步执行</p>\n<pre><code>function co(gen) {\r\n  var ctx = this;\r\n  var args = slice.call(arguments, 1)\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\r\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\r\n    onFulfilled();\r\n\r\n    function onFulfilled(res) {\r\n      var ret;\r\n      try {\r\n        ret = gen.next(res);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n\t}\r\n    function onRejected(err) {\r\n      var ret;\r\n      try {\r\n        ret = gen.throw(err);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n    }\r\n    function next(ret) {  //这里使用promise进行了封装 当之前的异步调用完成后 就会在调用onFullfilled将这次执行结果的返回值传入\r\n      if (ret.done) return resolve(ret.value);\r\n      var value = toPromise.call(ctx, ret.value);\r\n      if (value &#x26;&#x26; isPromise(value)) return value.then(onFulfilled, onRejected);\r\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\r\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\r\n    }\r\n  });\r\n}\n</code></pre>\n<p>通过上面的代码阶段我们就学习了koa的中间件机制 其实ES7的异步函数就是实现的co所做的事</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":true,"index":16,"pageCount":16,"additionalContext":{"pageAllCount":91}}},
    "staticQueryHashes": []}