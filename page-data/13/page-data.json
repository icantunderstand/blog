{"componentChunkName":"component---src-templates-index-js","path":"/13","result":{"pageContext":{"pageAllCount":88,"group":[{"node":{"id":"49d0ecf8-e0ff-5395-8dc8-4d548df3162b","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有先入先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这个在一定程度上也解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定(<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>).</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a></p>\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a></p>\n<p><a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a></p>\n<p><a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null}}},{"node":{"id":"16f13582-3dfd-5fca-8a6c-cd780c714f5f","html":"<h2>简介</h2>\n<p>最近在做业务中,需求的场景是需要在原有的组件上添加点击事件并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.高阶组件能最好化的复用代码.实现高阶组件有如下几种方式:</p>\n<ol>\n<li>属性代理(操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(子组件先DidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有调用,不会执行Wrapped的DidMount)\n    }\n    render() {\n      return super.render() //在这个可以实现渲染劫持,例如常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的时候通过在定义一个render函数来决定组件的具体内容.(children API)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的可以复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null}}},{"node":{"id":"efc0f5b3-aa07-511b-a4cf-49525fafa951","html":"<h2>简介</h2>\n<p>如何利用缓存在计算机系统或者网络服务中都是提升系统体验的的一个很重要的思考方向.相对于网络(磁盘)的I/O,直接将需要的数据存储到一个相对较快的获取位置,这样就能尽快的获取到需要的资源.这里主要总结下在前端开发中一些缓存方面的知识.</p>\n<h2>请求资源</h2>\n<p>下面这个图总结了网络请求中缓存涉及的几个方面,下面将具体的从每个方面进行展开.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvTUgo/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQITFh/9oACAEBAAE/IWxwjVLNf//aAAwDAQACAAMAAAAQO8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJVpB//EABsQAQADAQADAAAAAAAAAAAAAAEAEUEhMVFx/9oACAEBAAE/EKAD7uLzWqMJSlfrK2AtzJQeCf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"缓存\"\n        title=\"缓存\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/0479a/cache.jpg 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/41099/cache.jpg 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>本地-强缓存</h3>\n<p>强缓存是浏览器在请求具体的资源的时候,直接使用本地缓存的资源的副本而不通过服务器去验证资源的相关信息的一种方式.通常有通过expires和Cache-Control中的max-age来控制.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"right\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>expires</td>\n<td align=\"center\">指定缓存的过期时间(与客户端的时间设置相关)</td>\n<td align=\"right\">HTTP 1.0  max-age优先expires</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">指定请求资源过后多少秒后资源过期</td>\n<td align=\"right\">HTTP 1.1 max-age有优先expires</td>\n</tr>\n</tbody>\n</table>\n<p>当请求的资源存在本地缓存副本并且处于新鲜期的时候,直接返回本地资源.<br>\n当请求的资源没有本地缓存的时候,向服务器拉取对应的资源.<br>\n当资源存在缓存但是已经过期的时候,通过是缓存协商去服务器获取资源.</p>\n<h3>请求-缓存协商</h3>\n<p>缓存协商是指通过与服务端交互缓存资源的信息来判断当前缓存是否可用的一种机制.<br>\n当通过缓存协商服务端认为当前的资源是可用的,返回304(响应体是空).客户端可以时候当前的缓存资源并且可以更新缓存的相关信息.<br>\n当服务端认为资源不可用的时候,返回200(响应体中包含请求的资源).</p>\n<h4>Cache-Control</h4>\n<p>Cache-Control 被用于在http请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求设置的指令,在响应中不一定包含相同的指令.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td align=\"center\">下次请求是强制验证资源有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td align=\"center\">不进行缓存</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">相对于请求时间设置的最大过期时间</td>\n</tr>\n<tr>\n<td>public</td>\n<td align=\"center\">可以被客户端和代理缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">只能客户端缓存,不能被代理缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td align=\"center\">缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源</td>\n</tr>\n</tbody>\n</table>\n<h4>last-modified和Etag</h4>\n<p>last-modified和Etag(Etag还可以结合If-Match来判断当前提交的内容跟服务端存储的内容是否一致)都是在响应头中返回的对资源的一些设置信息,可以通过这两个值来缓存协商当前缓存资源时候可用.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">作用方式</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>last-modified</td>\n<td align=\"center\">资源在服务端的上次修改时间</td>\n<td align=\"center\">通过在请求头中设置If-Modified-Since的值为缓存资源的last-modified值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td align=\"center\">代表资源的实体标识,当资源的内容在服务端修改的时候,需要重新生成Etag</td>\n<td align=\"center\">通过在请求头中设置If-None-Match的值为缓存资源的Etag值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n</tbody>\n</table>\n<h5>last-modified和Etag的区分</h5>\n<p>Etag的出现更像是为了弥补last-modified的不足.例如:</p>\n<ol>\n<li>last-modified的时间只能精确到秒</li>\n<li>一个资源的频繁修改但是内容并没有修改</li>\n</ol>\n<h2>存储-协商存储</h2>\n<p>协商存储就是根据上面学习的相关字段来决定获取到的资源是否可以被存储被下次请求使用的策略.上文已经对响应的字段进行了说明.</p>\n<h2>CDN</h2>\n<h3>CDN简介</h3>\n<p>CDN(内容分发网络)指的是一组分布在各个地区的服务器.这些服务器存储着数据的副本,当用户访问资源的时候,CDN服务器可以根据用户的IP,服务集群的负载状态等信息尽快的返回给用户所需要的资源.</p>\n<h3>CDN优点</h3>\n<p>CDN主要的功能是托管静态资源,项目中对静态资源进行CDN的配置已经是标配,使用CDN主要有以下优点:</p>\n<ol>\n<li>将静态资源托管给CDN起到给源站分流的作用,降低服务端负载,解决网络网络带宽问题和不同服务商网络速度不同的问题.</li>\n<li>对资源的请求大部分都在CDN的边缘节点完成,访问延迟降低,用户能尽快的看到内容.</li>\n<li>CDN域名与源站域名不同,源站的cookie不会随着静态资源的请求发送,能一定程度上减少网络数据的发送.</li>\n</ol>\n<h3>CDN请求资源流程</h3>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器.</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户.</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求.</li>\n<li>CDN全局负载均衡设备根据用户IP地址,以及用户请求的内容URL,选择一台用户所属区域的区域负载均衡设备,告诉用户向这台设备发起请求.</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近;根据用户所请求的URL中携带的内容名称,判断哪一台服务器上有用户所需内容;查询各个服务器当前的负载情况,判断哪一台服务器尚有服务能力.基于以上这些条件的综合分析之后,区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址.</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户.</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地.</li>\n</ol>\n<h3>CDN优化</h3>\n<ol>\n<li>合理设置CDN节点的缓存时间，保证用户能及时同步到最新的内容</li>\n<li>根据不同的路径 配置不同的缓存规则，实现缓存的最大化</li>\n<li>CDN缓存节点预热</li>\n</ol>\n<h2>缓存的意义</h2>\n<ol>\n<li>资源或者服务的尽快到达和可用</li>\n<li>解决网络带宽问题和服务负载</li>\n<li>减少网络流量,让流量做更加有意义的事</li>\n</ol>\n<h2>思考</h2>\n<p>缓存能给应用带来一定的好处,同时也给服务增加了一些负载(保证资源的更新,增加缓存的成本等等).在对系统的一些基础服务做修改的时候,先要把这些有可能出现问题的点考虑清楚或者为什么这么做想好,在去做事.</p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null}}},{"node":{"id":"1fb1edfc-861c-5caa-b89b-103e6dd6af2a","html":"<h2>简介</h2>\n<p>作为web开发者,CSS是必备的一项基础技能,下面将从CSS的盒模型开始,来展开了解CSS的相关基础知识.</p>\n<h2>盒模型</h2>\n<p>当对一个元素进行布局的时候,渲染引擎会根据CSS-Box模型(box-sizing)将对应元素表示为一个矩形盒子.理解好盒模型能让我们更好的理解生成元素的大小和布局.生成布局的盒子由以下的属性决定\n<img src=\"./javascriptbasestatic/css/box.png\" alt=\"盒模型\">\nbox-sizing是设置盒模型的属性，分为IE盒模型(border-box)和W3C标准盒模型(content-box).</p>\n<ol>\n<li>W3C标准盒模型: 属性width和height只包含content, 不包含 padding border 也就是标准盒模型的实际宽度 = border-left + padding-left + content(width) + padding-right + border-right 在实际布局的时候还需要将margin考虑在内</li>\n<li>IE盒模型:  属性width 包含content, padding, border. IE盒模型的实际宽度 = content(width)</li>\n</ol>\n<h2>布局</h2>\n<h3>Box</h3>\n<p>Box是CSS布局的基本单位.元素的类型和display共同决定着这个Box类型.不同的Box类型会参与到不同的格式化上下文中.</p>\n<ol>\n<li>block-level: display属性为 block, table, list-item.</li>\n<li>inline-level: display属性为 inline-block, inline-table,inline</li>\n</ol>\n<h3>布局模式</h3>\n<p>在进行布局的时候，浏览器采用一种dirty位系统，如果某个呈现器（需要渲染布局的元素）发生了更改，将其自身或者子代标记为dirty，则需要布局，在进行布局的时候，元素会确认自己宽度和高度.</p>\n<ol>\n<li>父呈现器确认自己的宽度</li>\n<li>父呈现器依次处理子呈现器\n<ol>\n<li>放置子呈现器（设置x y 坐标)</li>\n<li>如果有必要，调用子呈现器的布局</li>\n</ol>\n</li>\n<li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用</li>\n<li>将dirty设置为false</li>\n</ol>\n<h3>布局上下文</h3>\n<p>布局上下文决定在渲染容器中各种盒子的布局方式,主要有以下几种(本文简单介绍BFC和FFC):</p>\n<ol>\n<li>块级格式化上下文(BFC)</li>\n<li>行级格式化上下文(IFC)</li>\n<li>网格布局格式化上下文(GFC)</li>\n<li>自适应格式化上下文(flexbox)</li>\n</ol>\n<h4>BFC(Block formatting context)</h4>\n<p>通过为元素进行一些属性的设置,可以生成块级格式化上下文,其中的块级元素会按照BFC的规则进行布局</p>\n<h5>生成规则</h5>\n<ol>\n<li>根元素，即HTML元素</li>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为inline-block、table-cell、table-caption</li>\n<li>position的值为absolute或fixed</li>\n</ol>\n<h5>布局规则</h5>\n<ol>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。不与float box重叠.</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h5>作用</h5>\n<p>关于BFC的作用和例子可以阅读下这边文章,博主写的很详细.<a href=\"https://juejin.im/post/5909db2fda2f60005d2093db\">关于CSS-BFC深入理解</a></p>\n<h4>FFC(flexbox)</h4>\n<p>FFC就是CSS3所说的弹性盒子布局. 详细的使用指南可以参考这篇<a href=\"https://css-tricks.com/snippets/a-guide-to-flexbox/\">A Complte Guide to Flexbox </a></p>\n<h2>定位</h2>\n<p>Box一共有以下三种定位方式:</p>\n<ol>\n<li>Normal flow: 包括块级的格式上下文, 行级的格式化上下文, 相对定位的(position relative)的块级和inline-block</li>\n<li>Float: 这种情况脱离了文档流,但是会影响之后元素的content(环绕)</li>\n<li>绝对定位(position absolute): 脱离文档流, 不会影响之后元素的位置和内容</li>\n</ol>\n<h3>position</h3>\n<p>position相关属性及含义</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>absolute</td>\n<td align=\"center\">绝对定位,相对于static以外的第一个父元素进行定位</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td align=\"center\">绝对定位,相对于浏览器窗口进行定位</td>\n</tr>\n<tr>\n<td>relative</td>\n<td align=\"center\">相对定位,相对与正常位置进行定位</td>\n</tr>\n<tr>\n<td>static</td>\n<td align=\"center\">默认值,没有定位.</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td align=\"center\">粘性布局 可以认为是固定定位和相对定位的结合.元素在跨越特定阈值前为相对定位,之后为固定定位</td>\n</tr>\n</tbody>\n</table>\n<h3>float</h3>\n<p>浮动是一种脱离文档流，对之后或者之前的盒子中的content flow产生影响的一个属性(区别于定位  例如position absolute 也是脱离文档流 但是它不会对之后之前的盒子产生影响),浮动元素会产生一个块级框,即使它本身是一个行内元素</p>\n<h4>浮动规则</h4>\n<ol>\n<li>浮动元素的左右外边界不能超出其包含块的左右内边界</li>\n<li>浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动的(或右浮动)元素的右（或左)边界，除非后出现的浮动元素的顶端在先出现浮动元素的底端下面（防止浮动元素之间的覆盖）</li>\n<li>左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边 右浮动元素的左外边界不会在其左边左浮动元素的右外边界的左边</li>\n<li>一个浮动元素的顶端不能比其父元素的内顶端更高   浮动元素的顶端不能比之前所有的浮动元素的顶端或块级元素更高</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/css/float1.png\" alt=\"float示例1\"><br>\n这里例子中三个元素均为浮动元素,包含块的宽度固定,由于规则2 导致第二个浮动元素bbb移动到aaa下面.由于4的限制，浮动元素ccc的顶端是跟bbb一致的，不能超过bbb或者跟aaa平齐.<br>\n5. 如果源文档中一个浮动元素之前出现了另一个元素 浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高<br>\n6. 左浮动元素必须向左尽可能的远 右浮动元素必须向右尽可能的远 位置越高 就会向左或者向右尽可能的远<br>\n7. 浮动元素与正常内容流重叠的情况:\n1. 行内框与一个浮动元素重叠的时候，其边框 背景 和内容都在该浮动元素之上显示.\n2. 块框与一个浮动元素重叠时候 其边框和背景在该浮动之下显示 内容在浮动元素之上显示</p>\n<h2>居中</h2>\n<p>可以阅读下自己之前翻译的一篇文章<a href=\"https://www.cnblogs.com/tiantianwaigong/p/5291370.html\">CSS居中完全指南翻译</a></p>\n<h2>参考链接</h2>\n<p><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#4_1\">浏览器的工作原理:新式网络浏览器幕后揭幕</a>\n<a href=\"https://www.zhihu.com/question/24529373/answer/29135021\">css脱离文档流是什么意思</a>\nCSS权威指南\n<a href=\"https://www.w3.org/TR/CSS21/visuren.html\">Visual formatting model</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"CSS基础总结","date":"2018-10-18","tags":"CSS","path":"/css-basic","top":null,"summary":null}}},{"node":{"id":"cd56cd7c-4adc-5c34-be0f-983b3549de82","html":"<h2>简介</h2>\n<p>事件循环是不同的宿主环境(浏览器或node)对javascript任务进行调度的一种机制,在讨论事件循环的时候首先应该区分node和浏览器(不同宿主环境实现的事件循环机制不同).下面通过介绍一些javascript的基础知识,进而简单的介绍浏览器中的事件循环和node中事件循环.</p>\n<h2>基本概念</h2>\n<ol>\n<li>javascript程序的执行机制是通过栈来管理的.当进入一个函数,就创建了这个函数的执行环境并将这个执行环境推入栈顶,执行完当前的函数后,从栈顶移除对应的执行环境,进入到外层的执行环境.</li>\n</ol>\n<p><img src=\"/blog/ee34151d44d3f796b1f1436e0926a2a7/stack.gif\" alt=\"stack\">\n2. javascript的执行是单线程的.但是由于整个事件循环的调度,赋予了javascript对异步任务的强大处理能力.对于异步任务(网络请求,按钮点击)javascript代码调用宿主环境提供的api,将异步任务交给其他的线程去完成.当对应的异步任务完成的时候,将回调函数添加到回调函数的队列中,由事件循环来实现会回调函数的调用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>marcotasks microtasks</h2>\n<p>将macrotasks和micortasks单拉出来讲解,是因为理解好这点能更好的理解浏览器或node的任务队列.在实际的实现环境中不同的任务可以放置在不同的任务队列中,然后通过对多个任务队列的调用来完成整个事件循环.</p>\n<ol>\n<li>macrotasks:</li>\n</ol>\n<ul>\n<li>定时器(timer) setTimeout setInterval setImmediate</li>\n<li>message channel  (message channel执行的优先级高于timer)</li>\n<li>I/O</li>\n<li>UI rendering</li>\n</ul>\n<ol start=\"2\">\n<li>microtasks:</li>\n</ol>\n<ul>\n<li>Promises</li>\n<li>MutationObserver(监听DOM)</li>\n</ul>\n<ol start=\"3\">\n<li>其他api</li>\n</ol>\n<ul>\n<li>\n<p>queueMicrotask(fn)\n将Fn推入微任务执行队列</p>\n</li>\n<li>\n<p>requestAnimationFrame<br>\n通知浏览器在下次重绘之前调用传入的回调函数，回调函数默认传入函数执行的时间戳.requestAnimationFrame不属于宏任务和微任务，在微任务执行之后执行</p>\n</li>\n<li>\n<p>process.nextTick\nprocess.nextTick是node上的api，具体的执行时机是在微任务之前执行。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVQ4y42T227aQBRF+QwItudqjw12bGyMuQQCCRENtE9VK7X//x+r8uSiRkmkPGwdzRnN1lkzewbKWHTeYos5dTujW9V0q4Z6XhPHCWEYEkXRO33WHyilUPGUpKjJ2xVuWpBVDWlRkkxywiB4o6Cvz2YfmQ6klBTJFCcNURgiTYxU2ktEEUJIdOzQxqJih4kdSsp3Zi9rP6GWirbdUa9vqfcn2rszy8svuvtHqs2B+eEbi/szy4fv1G1Hf+YjXG+otSYMxuTdlmb/SN4sqW6OlMs9Rbcju679lFJZpFSeIhj3+CFBEPrqFT5poLTyaPEkIy0zXJkxbUuS3CFtgHEC4xQ2lWgnsZnGpMrXF/X7QkZE4hlZCIGOIyYzTT43ZJUiKxVZZUgrS1Zb3LV+rUlumC4crrToRL2aSiN6ZEUQRtzXhr+nip93Bb+PBX+OBZdDQ96tmcwaqps7quWaOE3xVEr4Owv+R++Re8MoEuTOcbqcOP04s9jsKNuOax+jkrSYkbcbf7/5fIW1sY/PpznUShEnFmsVUghGwxHD4ZDRaMT46upJoyHjq5FX+GoWvovPoH+5fsrH84bLZcf2Zk5TF1jT9yVKPSkS4ms/pX+Q1CXcrjs22479w579ccf2sGW9W7FoSxZd47P3mcnbHBqNS1KcchibYLMCk05J8hk2nWKtJUliH62vGP4DF253f3L9M/QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nextTick\"\n        title=\"nextTick\"\n        src=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png\"\n        srcset=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/63868/nextTick.png 250w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/0b533/nextTick.png 500w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png 1000w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png 1150w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>setTimeout(function(){\n  console.log(1);\n});\nnew Promise(function(resolve){\n  console.log(2)\n  for( var i=100000 ; i>0 ; i-- ){\n      i==1 &#x26;&#x26; resolve()\n  }\n  console.log(3)\n}).then(function(){\n  console.log(4)\n});  \n\nconsole.log(5);\nprocess.nextTick(() => { console.log('nextTick'); })\n输出的顺序依次是 2 3 5 nextTick 4 1 \n</code></pre>\n</li>\n<li>\n<p>requestIdleCallback\nwindow.requestIdleCallback(callback[, options])</p>\n<ol>\n<li>callback是一个在事件循环空闲时即将被调用的函数的引用，接收一个IdleDeadline参数，通过该参数可以获取当前空闲时间(timeRemaining())以及回调是否在超时时间前已执行的状态(didTimeout)</li>\n<li>options 可选参数 可以配置timeout  表示超时毫秒数未调用回调函数，回调函数将在下一次空闲期间被强制执行。</li>\n</ol>\n</li>\n</ul>\n<p>在具体的实现中只会有一个microTasks队列,简单的理解事件循:</p>\n<ol>\n<li>浏览器或者node会按照顺序执行自己环境的多个macrotasks队列</li>\n<li>每执行完一个macrotask队列就会拿出micortasks队列的任务全部执行，然后继续执行下一个macrotask队列</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1CLID/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRR5Ef/aAAwDAQACAAMAAAAQ48//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAAAATFBEVEhcfD/2gAIAQEAAT8Qy3TXN2M1O2ZJuxz7aIH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runTask\"\n        title=\"runTask\"\n        src=\"/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg\"\n        srcset=\"/blog/static/9a253bb0db2af3498f93ce723c928568/0479a/runTask.jpg 250w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/41099/runTask.jpg 500w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg 1000w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg 1098w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in browser</h2>\n<p>其实通过对上面相关的知识的介绍,已经可以大致的了解浏览器中事件循环的任务队列 主要有以下几种macrotasks队列</p>\n<ol>\n<li>事件callback</li>\n<li>I/O(xhr)</li>\n<li>timers</li>\n<li>UI渲染</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in node</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAACzklEQVRIx5WVC0/qQBCF/f//RQMKUfAJCpIoAYxBBBGjEfABgkApbWFuviHbFCwpt8lkutvu2TMzZ2d3ZO1ZLBbqHceRwWAg39/fav1+X/3Pz498fX2ptyxL7NlM/505jsznc9kBYN14AMtmsxKLxdQODw/l4OBAfTKZlKOjI3l5eZHp1JbZbKbg0+l0CRjG0LZt+fz89BliMMN4//j4kNFo5K+DnQUgA8/zlLbruiugwYdv/LMpRa7rLQH56f39XVqtlry9vfm7MgcLE/7d3Z1cX18rw263K8/PzysbQ0oBf39/5fb2Vs7Pz6VQKMjr66tY1lR6vZ70en2ZTCZSq9UknU5r/vgX0E6nqyB/AAnl/v5erq6u5ObmRobD4Z+wmON7JpNR5ibHoYBGIhQANptyOB6P/RQsx5NwwE1VZhPySehojjySnuAYmYQyDNMhi4rFomru5ORE9vf3VXtYIpGQXC6nRQwFXAflQaxGc0Ed4mFJikjDRsD1cBuNhhYL//j4KA8PD9JsNrXiSIi5arXqy4zibgTkGCEhQj07O1N/enoqx8fH+h70aDISkI+Eg1F5NsB4pxDG+E5qVk5KGCALn56eVMQwoQCpVEouLy+VMYXh1BA2+YxkyO4AYuTM5NB4rF6v65i2FglIxdAZlUQ+sGBh0PONE2QaRmTI+Xze73tokJ5o+iHjvb09LRTAWxUFJrCEISckaMxjMKVYkYAc/E6no5Jot9tSKpWkUqlozsrlsrYuzjXfttIhIQOAAUB1MaqNUX3EzdE0DSOyKGiMpOON7sy9wYbMw24rHbKQ8Eg6zLis0OHFxYU2YpotY1j+tw7RmznPeIw5o0OKtlWVCcd0F3P7UXkKZW4/UrJVyOSHxKNDY/F4XEPd3d3VdzTJlWCagxPF0HTooPZgSUFgjzFnGIb2w033iXlY4HlzcT1PAXh3HFdBl0qw5R8VVUHLG1SyuAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node\"\n        title=\"node\"\n        src=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n        srcset=\"/blog/static/624c9768d8888b109a4649298c0cb091/63868/node.png 250w,\n/blog/static/624c9768d8888b109a4649298c0cb091/0b533/node.png 500w,\n/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>注意点</h2>\n<ol>\n<li>在浏览器或者node中某些代码的执行会导致event loop失效(停留在处理一个事件队列导致无法进入其他的事件队列的处理).比如浏览器中javascript的长时间执行会导致UI无法交互,node中process.nextTick的递归调用</li>\n</ol>\n<h2>相关资料</h2>\n<p><a href=\"https://tuobaye.com/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/\">通过microtasks和macrotasks看JavaScript异步任务执行顺序</a><br>\n<a href=\"http://docs.libuv.org/en/v1.x/design.html\">libuv Design overview</a>\n<a href=\"https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f\">How JavaScript works in browser and node?</a>\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&#x26;utm_medium=email\">Tasks, microtasks, queues and schedules</a><br>\n<a href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\">Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018</a>\n<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;t=55s\">菲利普·罗伯茨：到底什么是Event Loop呢？ | 欧洲 JSConf 2014</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null}}},{"node":{"id":"5c525025-174b-524b-9859-df9f3934b5a4","html":"<h2>简介</h2>\n<p>在不同的场景下,需要页面实现不同的滚动效果例如滚动到最底部、滚动到最顶部。以下首先对滚动的几个基本的属性进行总结并给出实现滚动的一些方案</p>\n<h2>基础属性简介</h2>\n<p>当元素的子元素比元素高且overflow=scroll时,元素会scroll.此时移动滚动条出触发本元素的scroll事件</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th align=\"center\">定义</th>\n<th align=\"right\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clientHeight</td>\n<td align=\"center\">与元素的高度有关,代表元素的高度加上padding(不包括border、水平滚动条的高度、margin),对于inline元素该属性的值为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>clientWidth</td>\n<td align=\"center\">与clientHeight相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetHeight</td>\n<td align=\"center\">与元素的高度有关,不同于clientHeight,它包括border、水平滚动条的高度,不包括margin.对于inline元素该属性为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetWidth</td>\n<td align=\"center\">与offsetWidth相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>scrollHeight</td>\n<td align=\"center\">当出现滚动时,scrollHeight代表元素内容的高度(包括在不在内容区域的内容)  当一个元素出现滚动, 它的相关属性 判读元素是否滚动到底部 scrollHeight - scrollTop === clientHeight</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>scrollTop</td>\n<td align=\"center\">当元素出现滚动的时候,scrollTop代表元素可见内容距离该元素顶部的高度.不存在滚动条的时候,scrollTop为0</td>\n<td align=\"right\">可读可写</td>\n</tr>\n<tr>\n<td>offsetTop</td>\n<td align=\"center\">获取当前元素跟offsetParent父元素顶部(position不为static的父元素)的距离</td>\n<td align=\"right\">只读</td>\n</tr>\n</tbody>\n</table>\n<h2>实现滚动的几种思路</h2>\n<p>在实现滚动上首先要确定的一个点是你需要知道此刻这个元素的子元素已经绘制完成(高度确定)。比如在react的项目中可以在didUpdate中触发元素的scroll事件,下面介绍下实现滚动的几种方法:</p>\n<ol>\n<li>锚点 通过在页面中设置锚点能在实现跳转到页面相应位置的目的,这种方式也比较好操作.缺点是需要在url中添加其他信息</li>\n<li>offsetTop, scrollTop</li>\n</ol>\n<ul>\n<li>offsetTop 可以在页面隐藏一个元素 通过获取这个元素的offsetTop来设置滚动元素的scrollTop</li>\n<li>scrollTop 直接设置scrollTop来实现定位 当scrollTop设置的值超出元素的最大值(scrollHeight) 会被设置成最大值(定位到最底部)</li>\n</ul>\n<ol start=\"3\">\n<li>scrollIntoView(alignToTop)</li>\n</ol>\n<ul>\n<li>alignToTop默认是true 通过item.scrollIntoView()/item.scrollIntoView(true)会使元素的顶部跟可视区域的顶部对齐</li>\n<li>item.scrollIntoView(false)会使元素的底部跟可视区域的底部对齐</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"页面滚动","date":"2018-08-26","tags":"JavaScript","path":"/js-scroll","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":13,"pageCount":15,"additionalContext":{"pageAllCount":88}}},"staticQueryHashes":[]}