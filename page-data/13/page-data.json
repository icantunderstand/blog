{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/13",
    "result": {"pageContext":{"pageAllCount":89,"group":[{"node":{"id":"90a974f9-2094-555f-8e7b-5b57b6e455b7","html":"<h2>简介</h2>\n<p>　　WEB同构应用指的是通过代码的编译转换手段(通常借助于babel)来让代码在不同端client(浏览器), server(服务器)运行.同构的web应用主要有以下的优点:</p>\n<ol>\n<li>一套代码多处运行减少维护成本</li>\n<li>任务拆分,通过同构可以实现更多的功能(SSR, fetchData)</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/isomorphism.png\" alt=\"isomorphism\"></p>\n<h2>简单的实现思路</h2>\n<ol>\n<li>将client端的代码转换成server可以执行的代码(es6 => commonjs).</li>\n<li>在两端组合出一套模式相同的代码逻辑.下面的例子中在server和client端使用不同的react-router提供的组件.</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/app.png\" alt=\"App\"><br>\n3. server端路由匹配,组装资源(css, js, data), 可以通过不同的中间件根据请求信息来组装.<br>\n4. client端路由匹配,匹配资源(data, 检查页面渲染结果是否正确).</p>\n<h2>过程</h2>\n<h3>代码转换</h3>\n<p>　　在进行代码转换的时候,首先要明白代码转换的目的才能明确对不同文件的转换策略.比如为了实现同构将client端的代码转换成server端可以运行的代码,对不同类型CSS文件的不同处理策略.通常借助于webpack来实现代码的转换功能.webpack会根据入口文件依次的解析引用的各种文件类型,通过配置的webpack loader可以实现对应文件类型的转换.以下主要从不同类型文件处理的角度进行介绍:</p>\n<h4>javascript</h4>\n<p>转换的目标是client端的代码(排除node_modules).\n将client转换成server端可以运行的代码\n<img src=\"./javascriptbasestatic/isomorphism/srctolib.png\" alt=\"srcToLib\"></p>\n<h4>css</h4>\n<p>对于CSS可以有以下两种的处理方法:</p>\n<ol>\n<li>css-in-js (css-loader style-loader)处理,包括node_modules,client端不需要提取的CSS</li>\n<li>client端全局样式或者通过mini-css-extract-plugin提取的样式</li>\n</ol>\n<h4>代码转换优化</h4>\n<h5>公有代码提取</h5>\n<p>可以使用DllPlugin对使用的基础组件库进行统一的提取和引用.提取公有模块代码主要有以下的好处:</p>\n<ol>\n<li>通过DllPlugin对公有代码的提取,能一定程度上加快webpack构建代码的速度</li>\n<li>公有部分的逻辑相对来说是变化的较少,可以充分的利用缓存</li>\n<li>减少其他bundle的体积,页面加载的资源更少</li>\n</ol>\n<p><img src=\"./javascriptbasestatic/isomorphism/dll.png\" alt=\"dll\"></p>\n<h5>加快编译速度</h5>\n<p>可以使用happyPack加快编译速度,happyPack通过多进程的方式来加快代码的打包过程.\n使用happyPack的例子:\n<img src=\"./javascriptbasestatic/isomorphism/happy1.png\" alt=\"happyPack\">\n<img src=\"./javascriptbasestatic/isomorphism/happy2.png\" alt=\"happyPack\"></p>\n<h3>资源匹配</h3>\n<h4>静态资源(CSS js)</h4>\n<p>可以通过webpack-manifest-plugin生成资源的位置信息文件,然后通过该文件查找资源的位置.\n资源位置文件\n<img src=\"./javascriptbasestatic/isomorphism/manifest1.png\" alt=\"manifest\">\n通过manifest查找资源的位置\n<img src=\"./javascriptbasestatic/isomorphism/manifest2.png\" alt=\"manifest\"></p>\n<h4>data</h4>\n<ol>\n<li>server端执行匹配到组件的获取数据的方法(返回promise),primose执行完毕获取到最新的数据储存.将数据通过脚本挂载到window上的属性上.</li>\n<li>client端通过window属性的获取,生成存储数据.</li>\n</ol>\n<p>服务端获取数据和注入数据\n<img src=\"./javascriptbasestatic/isomorphism/serverStore.png\" alt=\"serverStore\">\nclient端提取数据\n<img src=\"./javascriptbasestatic/isomorphism/clientStore.png\" alt=\"clientStore\"></p>\n<h2>扩展性</h2>\n<h3>配置单页是否支持服务端渲染</h3>\n<p>通过中间项配置是否支持服务端渲染\n<img src=\"./javascriptbasestatic/isomorphism/configServerRender.png\" alt=\"configServerRender\"></p>\n<h2>思考</h2>\n<p>在是否在项目中使用同构应用的时候,还是要结合具体的场景.可以有以下的几点考虑:</p>\n<ol>\n<li>项目中是否需要进行服务端渲染 => 使用者角度</li>\n<li>是否有引入node中间层(api转发)的必要, 其他的替代方案是否可行(nginx) => 整体设计的角度</li>\n</ol>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"如何构建一个WEB同构应用","date":"2019-04-24","tags":"工程化","path":"/iosmorphism","top":null,"summary":null}}},{"node":{"id":"8ffc1de2-ace1-5c44-a4a5-a422b43a1af7","html":"<h2>函数</h2>\n<h3>函数声明</h3>\n<p>函数声明包含函数的名字,形参列表,返回值列表(可选)以及函数体构成.</p>\n<pre><code>func name(parameter-list) (result-list) {\n  body\n}\n</code></pre>\n<p>需要注意一下几点:</p>\n<ol>\n<li>\n<p>函数的形参列表和返回值列表组成函数的签名,函数的签名会在函数被调用的时候做校验是否调用合法.</p>\n</li>\n<li>\n<p>参数的传递是按值传递的.当传递引用类型作为实参的时候,可能会修改实参变量.</p>\n</li>\n<li>\n<p>支持多返回值.</p>\n<p>func test(a [3]int) (int x, int y) {\nreturn x, y\n}\nfunc add(vals ...int) int {  // 变长参数声明\nsum := 0\nfor _, v := range vals {\nsum += v\n}\nreturn sum\n}</p>\n</li>\n</ol>\n<h4>函数变量声明</h4>\n<p>函数声明只能定义在包级别的作用域,函数变量声明可以在任何表达式内指定.函数变量生命能获取到整个词法环境(可以访问外部的变量)</p>\n<pre><code>func test() func(int) int {\n  x := 2\n  return func (y int) int {\n    return x * y\n  } // 这里的函数变量(匿名函数)可以访问到外部的x\n}\n</code></pre>\n<h3>函数流程控制</h3>\n<h4>defer</h4>\n<p>defer语句是普通的函数调用,defer语句能确保函数的return语句或函数执行完毕之后执行对应的defer函数.主要为了在函数的执行完毕后做特定的行为.</p>\n<pre><code>func test(x int) int {\n    defer func() { fmt.Print(x) }() // defer语句必须返回一个可执行的语句\n    return x\n} // 这个函数会在返回后打印入参\n</code></pre>\n<h2>方法</h2>\n<h3>方法声明</h3>\n<p>方法是声明特定类型(对象)上可以执行的函数. 通常可以使用如下的方式声明:</p>\n<pre><code>func (p structName) funcName(parameter-list) (result-list) {\n  body\n}  \n// 声明可以在p类型上调用funcName的方法 \nfunc (p Point) add() int {\n  return p.x + p.y\n}\np := Point{ 2, 3}\n  p.add()\n</code></pre>\n<p>注意:</p>\n<ol>\n<li>由于方法的调用是p.funcName和获取p结构体上的属性一致,要注意同一类型上的命名冲突.</li>\n</ol>\n<h3>指针接收者方法</h3>\n<p>由于方法会复制实参,当需要方法的调用对外界产生影响的时候,就需要通过指针类型来完成方法的声明,如下面的例子:</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10} // 获取指针\n  p.ScaleBy(2) // p{20, 20}\n  q := Point{1,2}\n  q.ScaleBy(3)  // q{3,6} 当类型符合的时候,会进行隐式转换 相当于 (&#x26;q).ScaleBy(3)\n}  \n</code></pre>\n<h3>方法变量和方法表达式</h3>\n<h4>方法变量</h4>\n<p>可以将一个特定类型的方法赋值给一个变量,这个变量称为方法变量.该方法变量已绑定到特定的接收者上(caller),通过传递形参就可以完成方法的调用.通常用于绑定特定的接受者.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := p.ScaleBy\n  scaleBy(2) // p{20, 20}\n}  \n</code></pre>\n<h4>方法表达式</h4>\n<p>方便表达式必须在调用的时候,提供接受者.方法表达式是把对应结构的函数行为进行声明.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := (*Point).ScaleBy // 方法表达式\n  scaleBy(p,2)\n}\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"go语言入门之-函数和方法","date":"2019-04-19","tags":"Go","path":"/go-func","top":null,"summary":null}}},{"node":{"id":"7e5d1f2a-ee54-59e1-a3fd-71ffbe5c68a5","html":"<h2>go数据类型</h2>\n<p>go语言数据类型主要分为以下的四个大类:</p>\n<ol>\n<li>基础类型(整数,浮点数,负数,布尔值等)</li>\n<li>聚合类型(数组,结构体)</li>\n<li>引用类型(slice,指针,map,函数,通道)</li>\n<li>接口类型</li>\n</ol>\n<p>go语言是拥有类型系统的语言,相对于笔者最熟悉的javascript这种动态且无类型的语言来说有着长远的好处.通过类型系统能在编译阶段减少一定的运行时错误.例如在go语言中不同类型值之间必须通过显示转换来进行赋值操作.本文主要从go语言中的基础类型开始,逐步的讲解go语言中几种基本的引用类型.</p>\n<h2>基础类型</h2>\n<h3>字符串</h3>\n<p>字符串是不可改变的字节序列.可以通过[i:j]操作符截取对应字符串的子串.由于字符串不可改变的特点,子串和母串共用一端底层内存.</p>\n<pre><code>s := \"hello world\"\nb := s[6:] // [i:j] 从i开始不包括j 注意越界 b world\nb[0] = 'a' // 错误 \n</code></pre>\n<h3>常量</h3>\n<p>常量是一种表达式,可以在编译的阶段来确定相应的值.在声明常量的时候可以指定类型和值(如果没有指定类型会通过值来推断常量的类型).在连续声明多个常量的时候,主要有以下两种方式:</p>\n<ol>\n<li>\n<p>在声明枚举值的时候,可以通过iota常量生成器来实现.iota从0开始,逐项加1</p>\n</li>\n<li>\n<p>省略赋值语句的一项会复用前一项的表达式和类型</p>\n<pre><code> const (\n a  = iota\n b\n c\n d\n )\n // a b c d 0 1 2 3\n const (\n a = 1\n b\n c = 2\n d\n )\n // a b c d 1 1 2 2\n</code></pre>\n</li>\n</ol>\n<h4>无类型常量</h4>\n<p>无类型常量(常量字面量)是还没有确定从属类型的常量值.无类型常量相对于同样的有类型的常量有更大的精度.例如0.0相对有浮点数拥有更大的精度.在将无类型常量复制给对应的变量的时候,赋值的变量会转换为无类型常量默认的类型.</p>\n<pre><code>i := 0 // int(0)\nb := 0.0 // float64(0.0)\n</code></pre>\n<h2>聚合类型</h2>\n<h3>数组</h3>\n<p>数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列.由于数组在声明的时候对长度有限制,当存储元素到达数组的容量的时候就需要申请新的内存空间来进行数据的存储.所以在存储数据上一般不会使用数组.数组元素的初始值是该类型的零值.在声明数组的时候需要显示的指定长度和类型.</p>\n<ol>\n<li>\n<p>声明数组需要有长度的定义和类型定义,可以通过定义长度或者数据数量来确定数组的长度.元素类型和长度相同的数组是可以比较和复制的</p>\n</li>\n<li>\n<p>数组元素的初始值为该数组元素类型的初值</p>\n</li>\n<li>\n<p>在函数中使用数组指针来完成对原数组的修改</p>\n<p>b := [...]int{1,2,3}  // 通过初始化数组元素的个数决定数组的长度\na := [3]int{1,2,3}\na == b // true\nr := [...]int{99: -1} // 定义一个含100元素的数组r 最后一个元素是-1 其余都初始化int类型的零值 0</p>\n</li>\n</ol>\n<h3>结构体</h3>\n<p>结构体是将多个命名变量组合到一起的聚合数据类型.可以通过下面的方式声明一个结构体:</p>\n<pre><code>type Person struct {\n    name string\n    id int\n}\n</code></pre>\n<p>在声明结构体的时候需要注意以下的几点:</p>\n<ol>\n<li>结构体变量的大小写决定变量是否可以导出(可以被其他导出的包读写),</li>\n<li>结构体变量不可以拥有自己本身的结构体类型,可以通过自身结构体类型的指针来实现递归结构</li>\n</ol>\n<h4>结构体字面量</h4>\n<ol>\n<li>\n<p>可以按照声明的顺序来初始化结构体变量或者指定变量名称来初始化结构体字面量</p>\n</li>\n<li>\n<p>可以获取结构体指针来设置结构体的值</p>\n<pre><code> a := Person{ name: \"haha\" } // 指定变量名声明\n b := Person{ \"haha\", 20 }\n var copyPerson *Person = &#x26;a // 获取结构体指针\n copyPerson.name = \"100\"\n</code></pre>\n</li>\n</ol>\n<h4>结构体嵌套</h4>\n<p>在定义结构体的成员的时候,go允许只指定成员的类型来实现成员的声明.通过这种方式定义的结构体成员成为匿名成员.匿名成员的类型必须是一种命名类型或者指向命名类型的指针.匿名成员可以为方便变量提供便捷的操作.</p>\n<pre><code>type Circle struct {\n    x int\n    y int \n    radius int\n}\ntype Wheel struct {\t\n  Circle\n  color string\n}\nwheel := Wheel{Circle{ 10, 10, 19}, \"red\"}\n// wheel.x = 10\n</code></pre>\n<h2>引用类型</h2>\n<h3>slice(切片)</h3>\n<p>slice是用相同类型元素的可变长度序列.可以基于一个已有的数组来创建这个数组的slice.slice有三个属性:指针,容量,长度.可以在一个数组的基础上产生多个slice,它们共享内存空间.需要注意的是slice可以理解为对原数组的引用,通过对slice的修改是会影响到底层数组的.</p>\n<h4>声明切片</h4>\n<p>主要有以下两种方式声明切片:</p>\n<ol>\n<li>\n<p>通过切片字面量和内置的make函数</p>\n</li>\n<li>\n<p>slice的操作符[i:j]操作数组或者切片字面量</p>\n<pre><code> var b = make(int[], 3, 5) // make(type[], len, cap) 声明一个长度为3容量为5的切片\n var b = []int{1,2} // 声明一个长度和容量都为2的切片\n var c = []int{ 99: 1 } // 声明一个长度和容量为100的切片,初始化第100的元素为1\n slice := []int{1,2,3,4,5}\n newSlice := slice[1:3]  // 通过切片创建切片\n var num = [10]int{1,2,3,4,5,6,7,8,9,10}\n a := num[1:4] // 操作符[i:j]创建一个新的slice,引用原数组i到j-1个元素.slice的容量是slice起始元素到底层数组最后一个元素之间的个数,切片a只能看到底层数组i以及之后的元素\n len(a) // 3 获取切片的长度\n cap(a) // 9 获取切片的容量\n b := a[:5] // 可以在一个已有的slice上扩充容量,产生新的slice\n len(b) // 4\n cap(b) // 9\n</code></pre>\n</li>\n</ol>\n<h4>操作切片</h4>\n<ol>\n<li>\n<p>slice相当于对底层数组的引用,通过操作slice可以修改底层数组</p>\n<pre><code> a := [3]int{1,2,3}  \n b := a[:2]\n b[0] = 100  // a[0]也是100\n</code></pre>\n</li>\n<li>\n<p>append函数可以动态的添加元素到slice.append函数会返回一个新的slice</p>\n<pre><code> slice := []int{1,2,3,4,5}\n newSlice := slice[1:2] \n newSlice = append(newSlice, 10) // newSlice容量足够,修改底层数组返回新的slice. a[2] = 10\n a := slice[1:2]\n b := slice[2:3]\n c = append(a, b...) // 支持批量添加\n</code></pre>\n</li>\n</ol>\n<h3>map</h3>\n<p>在go中map是对散列表的引用.散列表是无序的键值的结合.可以通过如下的方式创建map:</p>\n<pre><code>var test = make(map[string]int) // 声明map的键值的类型 \ntest[\"name\"] = 100  // 赋值\nvar person = map[string]int{ \"card\": 1, id: \"2\" }  //声明并初始map\nperson[\"card\"] // 1\n</code></pre>\n<p>map有以下几点需要特别注意:</p>\n<ol>\n<li>在赋值map类型的值的时候,需要对map进行初始化.初始化的map的值是对应类型的零值.</li>\n<li>map是引用类型,在函数间传递的时候会对原值进行修改.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null}}},{"node":{"id":"570eee31-e50d-5468-bf5e-ed48bc58dde3","html":"<h2>go语言简介</h2>\n<p>go语言是一种编译型语言,在设计上融入了设计者对复杂项目中易出现问题的思考,go语言在设计上突显了简单性.这种简单性在长期来看是会为项目带来收益的.下面主要从go的环境配置开始进而通过一个简单的go程序\b来认识go.</p>\n<h2>go环境配置</h2>\n<p>当go安装完毕后,可以通过go env来查看相应的环境配置,如图\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 641px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABiUlEQVQ4y51U2VLCQBBcOQRFzoCgFo+inELuhJCEcMj//9BYPZsNFmUh8DC1u7Op3u6emYjS1KOHL5/aTkJNK+Yoz3zKDS0SHwaJT/O66Ppb6kcH6rgJ1c2Qut6GOu6GcqMbATvehvrhgVp2TIWxQ2Kgk3hfkBgYEvBc4NvTnOasWe7LckcNM6KmFZHmJNm+qq9kzl5T3QipYcXUdhPSbGkP8rgHofupKxn2ljsCcHnmUX5kU3HiMFus+fHxXEj36nw/cbPvWJ2SDP/wKopzNzSlZBVnJf+RQwGeU5ZYH+dLfhkrGN9UFPjX9bb0GuzZC3j1tvrm/dWVBsOeL9kpMMjHvgSTFeDpeo5hz99mQKju0yKQLaHiUjDFEM2NKgOsnbZMzQj5kZYVc+tcLB1S4R1Aa/qK2aGfMJJqLLklLgXUuKn3LBeMOMmTov+aGv3/qVEBhqgoerEyD7ixEWjiYzhZXt4dz8WTO6HGDl5VFgGPEWTLv08kfeQxi9hnjBv8rab24A524R6AP/kYq3qmQSoOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"go env\"\n        title=\"go env\"\n        src=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n        srcset=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/63868/goEnv.png 250w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/0b533/goEnv.png 500w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png 641w\"\n        sizes=\"(max-width: 641px) 100vw, 641px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n其中GOPATH,GOROOT是我们需要关注的两个配置.GOPATH指定的工作区间的根目录,在GOPATH下通常有三个目录:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 596px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQoz53OSY7CMBSEYd/EwXHiAWXhDMgWqJsM4gAsEFIvcv9T/C0jOIBZfHp6tSiVWNeVfd+Z55lxHEkpEWP8ilIK4b0nhMCyLPR9jzEG5xzWlquqCuHckRBGtu3GMEwY48iZteVehSn9cr3eeDz+uN+fTNOFnMVY6gel9GfhwLJsnE6RtrXvhb6YlBVC6wbvj5zPF7quQ6manGmti0kpEU3TUteaw0G9bv6/lQv/AcdU1m38VSPNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n        srcset=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/63868/category.png 250w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/0b533/category.png 500w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png 596w\"\n        sizes=\"(max-width: 596px) 100vw, 596px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在src目录下的每个子目录是一个包.pkg子目录是构建工具存储编译后的包的位置.bin子目录放置可执行程序.GOROOT主要提供标准库的包.</p>\n<h3>go语言的基础结构-hello world</h3>\n<p>在GOPATH下的src目录创建helloworld文件夹,在该文件夹中创建helloworld.go.(通常文件的名字都跟包名一致),通过在命令行使用go run hellowrld.go</p>\n<pre><code>package main // 定义包名\nimport (\n  \"fmt\"  // 导入包\n)\n//  main函数可执行程序的主入口\nfunc main() {\n  var a = \"hello world\"  // 定义变量并且在控制台输出\n  fmt.Print(a)\n}\n</code></pre>\n<h2>go中的包</h2>\n<h3>包的初始化</h3>\n<p>包的初始化从初始化包级别变量开始,按照这些变量的声明顺序进行初始化,对于一些复杂的初始化场景,可以定义init函数来初始化变量,在其他包对当前包进行引用的时候,init函数会被调用.</p>\n<pre><code>var a = b + c\nc = 100\nb = f()\nfunc f() {\n  return 1\n}  // 会按照 c b a 的顺序依次初始化\n</code></pre>\n<h3>包的命名</h3>\n<p>在go源文件的开头都需要进行包名的声明,同一个包下的所有源文件同属一个包(有一个例外是当前go文件是一个可执行的go程序时,只能声明main包来生成可执行的文件)</p>\n<h3>包的引入</h3>\n<p>包是go实现代码复用的一种主要形成.在声明包名之后,可以通过import语句对需要使用的包进行引入.通常有下面几种方式导入对应的包:</p>\n<pre><code>import (\n  \"fmt\"  //正常导入\n  XXX \"fmt\" // 别名导入 XXX可以作为fmt包的别名来使用\n  _ \"image/png\" // 空导入 通常为了执行包的初始化函数来获取副作用\n  import \"github.com/xxx\" // 导入远程包\n)\n</code></pre>\n<p>包的查找是先查找go的安装目录,然后GOPATH</p>\n<h2>声明</h2>\n<p>实体的声明主要有以下的规则:</p>\n<ol>\n<li>如果声明的实体在函数体内,该实体只在函数局部(存在块级作用域)有效.实体声明在函数外,该声明对当前包所有的文件可见.</li>\n<li>实体的第一个字母的大小写决定其是否可以被其他包调用</li>\n</ol>\n<h3>变量声明</h3>\n<p>在go语言中可以通过下面的几种方式来创建和声明变量.</p>\n<h4>常规变量声明</h4>\n<pre><code>var name type = expression\n</code></pre>\n<p>上面这种声明方式指定了变量的类型和初始值表达式,类型和表达式可以忽略一个:</p>\n<ol>\n<li>当类型忽略的时候,变量的类型会由初始化表达式的类型决定</li>\n<li>当初始化表达式忽略的时候,变量的初始值对应着相应类型的零值.</li>\n<li>当把一个类型的变量赋值给另一个类型的时候,需要通过显示转换.</li>\n</ol>\n<h4>短变量声明</h4>\n<pre><code>name := expression\n</code></pre>\n<p>上面这种方式称为短变量声明,这种方式声明的变量类型由表达式返回的类型决定.在使用短变量声明的时候,需要注意一下两点:</p>\n<ol>\n<li>短变量声明在左侧已经存在对应变量的声明的时候,相当于赋值</li>\n<li>短变量声明要求至少声明一个变量</li>\n</ol>\n<h4>new操作符</h4>\n<p>new(T)创建一个未命名的T类型变量并且初始化T类型的零值,返回其地址(指针).</p>\n<pre><code>p := new(int) // 初始化一个int类型的变量返回地址\nfmt.Println(*p) // 输出0\n*p = 2\nfmt.Println(*p)  // 输出2\n</code></pre>\n<h4>指针</h4>\n<pre><code>x := 1\np := &#x26;x  // &#x26;操作符获取变量地址 复制给一个int类型的指针p\nfmt.Println(*p) // 输出1 *操作符获取指针指向的变量的值\n*p = 2 // 通过指针修改变量的值 \nfmt.Println(x) // 输出2\n</code></pre>\n<h4>变量的生命周期和作用域</h4>\n<h5>生命周期</h5>\n<ol>\n<li>\n<p>包级别变量存在于整个程序的执行时间</p>\n</li>\n<li>\n<p>局部变量有动态的声明周期,在执行声明语句的时候会创建一个新的实体.当局部变量不可访问时会被回收.</p>\n<pre><code> a := []int{1,2,3,4,5}\n for _, num := range a {\n   fmt.Printf(\"%d\", num)  // num变量在每次循环创建\n }  \n</code></pre>\n</li>\n</ol>\n<h5>作用域</h5>\n<p>作用域指的是用到对应变量声明的源代码段。go语言中声明的作用域是词法块的，词法块决定着声明作用域的大小。</p>\n<h3>变量赋值</h3>\n<ol>\n<li>\n<p>在进行变量赋值的时候,go语言有对应的类型检测(例如你不能把一个int类型赋值给string类型的变量).</p>\n</li>\n<li>\n<p>支持多重赋值语法</p>\n<pre><code> x,y := 1, 2\n x, y = y, x\n</code></pre>\n</li>\n</ol>\n<h3>类型声明</h3>\n<p>类型声明提供了一种方式来区分底层类型的不同或者不兼容的使用方式。相同类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，不同命名类型的值不能直接比较.</p>\n<pre><code>type name string\ntype id string\n\nfunc main() {\n  var a name = \"\"\n  var b id = \"\"\n  fmt.Println(a == b) // 这里会报错 a b 不是相同的类型无法比较\n}\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://golang.google.cn/cmd/go/\">go命令行使用</a></p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null}}},{"node":{"id":"49d0ecf8-e0ff-5395-8dc8-4d548df3162b","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有后进先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这在一定程度上解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定<br>\n<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>.</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a><br>\n<a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a><br>\n<a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a><br>\n<a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null}}},{"node":{"id":"16f13582-3dfd-5fca-8a6c-cd780c714f5f","html":"<h2>简介</h2>\n<p>最近在做业务中,需求的场景是需要在原有的组件上添加点击事件并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.高阶组件能最好化的复用代码.实现高阶组件有如下几种方式:</p>\n<ol>\n<li>属性代理(操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(子组件先DidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有调用,不会执行Wrapped的DidMount)\n    }\n    render() {\n      return super.render() //在这个可以实现渲染劫持,例如常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的时候通过在定义一个render函数来决定组件的具体内容.(children API)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的可以复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><br>\n<a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":13,"pageCount":15,"additionalContext":{"pageAllCount":89}}},
    "staticQueryHashes": []}