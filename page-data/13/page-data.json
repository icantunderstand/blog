{"componentChunkName":"component---src-templates-index-js","path":"/13","result":{"pageContext":{"pageAllCount":89,"group":[{"node":{"id":"3ea7527a-ad27-58ee-b153-3d20f4d97a51","html":"<h2>前言</h2>\n<p>React在处理界面更新的时候,是通过对比虚拟DOM(js对象)之间的差异来更新UI的.这种方式能一定程度上的减少对DOM的操作.通过虚拟DOM这个中间层结合多平台的renderer使React实现了跨平台.本文梳理了在medium上关于Virtual DOM的两篇文章来介绍如何简单实现一个Virtual DOM.</p>\n<h2>为什么虚拟DOM</h2>\n<ol>\n<li>UI = F(data)  Virtual DOM使数据,操作,属性可以集中在一起,这种方式能一定程度上降低项目长期维护的复杂性.</li>\n<li>页面性能 通过虚拟DOM的对比,进行差异的更新能提升页面的性能.</li>\n</ol>\n<h2>如何实现虚拟DOM</h2>\n<p>虚拟DOM可以理解是真实DOM的映射,如何实现虚拟DOM主要需要考虑一下几点:</p>\n<ol>\n<li>如何描述虚拟DOM(create)</li>\n<li>如何绘制虚拟DOM(render)</li>\n<li>如何差异化的更新虚拟DOM并且更新UI(update)</li>\n</ol>\n<p>下面主要从上面的三点来逐步实现一个简易版的虚拟DOM实现.</p>\n<h3>创建Virtual DOM</h3>\n<p>DOM的节点可以通过type(节点类型),props(styles, event), children(子元素)来描述.可以通过下面的函数来创建虚拟节点.</p>\n<pre><code>// 创建虚拟节点\nfunction h(type, props, children) {\n  return { type, props: props || [], children: children || [] };\n}\nconst root = h('ul', { name: 100, onClick: () => { console.log(1); } }, [\n  h('li', {}, ['sss'])\n])\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVQY022PyW7DMAxE8/8/1muBXtogrpN4k0wvihfJm/SK2EUPQQcYgCQGj+RJa839fkeXmjRL6Jqaoevo+x7TthhjdidJglKKqqrI8wLnHEPf77lxHBmtZZpXTiEE8jwn+vymVQ32mjHVDWmW8nU+01tLKYK1lsfjgYhQliVN26JESLKMNE3JC01nAyeAVgzqXaM/hCIS4vjGJbpglGITwTtHPww7TBUFTdPgrcWLMImwLAuHfoHzOHN/Symjik4KsujCYB1+npmrisW5/cInqK5rWmPY5pm1bZiMYV3XAxfC8bKzjkfW0ekeWw0sbiKOY663G90w8J/Cax/CAVy2Z+GPgQ/4LeB92Lc+X/He/4Wffu1f/QOtmsze8Gl17gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"virtualDom\"\n        title=\"virtualDom\"\n        src=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n        srcset=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/63868/virtualDom.png 250w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/0b533/virtualDom.png 500w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>绘制Virtual DOM</h3>\n<p>在下面的实现中,以$开头的元素指代真实的DOM节点,node指代虚拟节点.</p>\n<h4>绘制元素</h4>\n<p>在绘制元素的时候,如果节点的内容是文本,就直接创建文本节点.否则就创建当前类型的DOM节点并且遍历它的children节点递归的调用自身并且添加到创建的节点.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\nconst root = h(\"ul\", { name: '111', className: 'test' }, [\n  h('li', { name: 'child' }, ['text'])\n]);\n// app是页面中已经存在的容器节点\nconst container = document.getElementById('app');\ncontainer.appendChild(createElement(root)); // 已经能绘制到页面\n</code></pre>\n<h4>添加属性</h4>\n<p>在添加属性的时候,有以下的节点需要注意:</p>\n<ul>\n<li>对DOM节点上不存在的属性名字进行转换,例如ClassName</li>\n<li>布尔属性值的设置</li>\n<li>增加属性过滤功能来实现特有的实现</li>\n</ul>\n<h5>实现</h5>\n<pre><code>//设置布尔属性\nfunction setBooleanProp($target, name, value) {\n  if(value) {\n    $target.setAttribute(name, value);\n    $target[name] = value;\n  } else {\n    $target[name] = false;\n  }\n}\n// 属性过滤\nfunction isCustomProp(name) {\n  return false;\n}\n// 设置所有属性的入口\nfunction setProps($target, props) {\n  Object.keys(props).forEach(name => {\n    setProp($target, name, props[name]);\n  });\n}\n// 对单一属性的设置,实现过滤,转换\nfunction setProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.setAttribute('class', value);\n  } else if(typeof value === 'boolean') {\n    setBooleanProp(name, value);\n  } else {\n    $target.setAttribute(name, value);\n  }\n}\n</code></pre>\n<p>通过将设置属性的操作加入到之前的createElement函数中,来实现DOM属性的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n} \n</code></pre>\n<p>通过运行之前的代码,发现属性已经添加到DOM中了.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABIElEQVQoz6XO207CQBSF4b7/I3nphcSEKFAoyqkoh0Kn9DhMp8PM/IYYTUw8XLiSL3tf7bWD8UtJv7dlOBaMJnOGjyPuh4LbfspTIgl3NQ+rjCg5syo9i9z+KmjOkmR2IO6tOb4KmkohZimnWGCdx3vw3uOcx33Mj/0bQWc6xEtKfBdT7E50Mke1jv1e0umOP/Pe+CkAj9Yt2aug3Obk6wnJckk0EazjHK00phFIscN2LVmmSMX5x7Kgbi2VupCViu3yxHax4rl3w2GzIZwWjKOMKFwTDQaE0ZzpNCXs7zkeaxrtqJX9ImiNo7Oe6nrw6UBVKGRV0tQNUllORUclHVJbsqKh1QZ9Nqj2gr54tHFfBNc3rTEcnxPSRcrFGP6TN4i4F/4kEuvBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domWithProp\"\n        title=\"domWithProp\"\n        src=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n        srcset=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/63868/propShow.png 250w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/0b533/propShow.png 500w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>添加事件</h4>\n<p>在对事件的添加上,由于具体的事件也是在创建Virtual DOM的时候添加到props的,如果不想通过之前声明的setProps函数进行事件的处理,就需要将这些属性过滤出来,具体实现如下:</p>\n<pre><code>//判断是否是event属性\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n// 获取属性的后缀  例如 onClick => click\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n// 修改之前的过滤属性函数,加入对event属性的过滤\nfunction isCustomProp(name) {\n  return isEventProp(name)\n}\n// 添加属性函数\nfunction addEventListeners($target, props) {\n  Object.keys(props).forEach(name => {\n    if(isEventProp(name)) {\n      $target.addEventListener(extractEventName(name), props[name]);\n    }\n  })\n}\n</code></pre>\n<p>将添加事件的函数增加到createElement函数中,完成对事件的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  addEventListeners($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\n</code></pre>\n<h3>对比差异更新UI</h3>\n<p>如果完全的对比两个树形结构的差异,时间复杂度是O(n^3)的.为了一定的性能优化,可以有以下的假设:</p>\n<ol>\n<li>节点的类型变更,两个DOM的结构就是不同的.这种情况可以直接进行替换操作.</li>\n<li>很少存在跨层级的节点移动</li>\n<li>同一类型的节点的DOM结构是相同的</li>\n</ol>\n<p>通过对上面假设的分析,在更新Virtual DOM的时候,主要有以下几种情况</p>\n<ol>\n<li>对比两个node的类型不同,直接替换</li>\n<li>最新的node中没有元素和属性,需要删除对应的节点的属性</li>\n<li>最新的node中增加了元素和属性,需要添加对应的属性和节点</li>\n<li>节点类型相同,对子节点实现1 2 3的操作</li>\n</ol>\n<h4>更新节点</h4>\n<pre><code>// 判断两个node是否是同一个节点\nfunction changed(node1, node2) {\n  return typeof node1 !== typeof node2 || typeof node1 === 'string' &#x26;&#x26; node1 !== node2 || node1.type !== node2.type;\n}\n\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  // index是子元素的位置\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新属性</h4>\n<p>在更新属性的时候跟更新节点的步骤类似</p>\n<pre><code>// 删除布尔属性\nfunction removeBooleanProp($target, name) {\n  $target.removeAttribute(name);\n  $target[name] = false;\n}\n// 移除属性\nfunction removeProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.removeAttribute('class');\n  } else if(typeof value === 'boolean') {\n    removeBooleanProp($target, name);\n  } else {\n    $target.removeAttribute(name);\n  }\n}\n// 当不存在newVal的时候,remove对应的属性.其他情况进行覆盖\nfunction updateProp($target, name, newVal, oldVal) {\n  if(!newVal) {\n    removeProp($target, name, oldVal);\n  } else {\n    setProp($target, name, newVal);\n  }\n}\nfunction updateProps($target, newProps, oldProps = {}) {\n  const props = Object.assign({}, newProps, oldProps);\n  Object.keys(props).forEach(name => {\n    updateProp($target, name, newProps[name], oldProps[name]);\n  });\n}\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    // 增加属性的更新\n    updateProps($parent.childNodes[index], newNode.props, oldNode.props)\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新事件</h4>\n<p>函数是不好判断是否有变化的,可以通过一些参数来完成事件的更新(触发重新更新,通过节点替换来完成事件的更新这样不好)</p>\n<pre><code>function changed(node1, node2) {\n  return typeof node1 !== typeof node2 ||\n      typeof node1 === ‘string’ &#x26;&#x26; node1 !== node2 ||\n      node1.type !== node2.type ||\n      node1.props.forceUpdate;\n}\nfunction isCustomProp(name) {\n  return isEventProp(name) || name === ‘forceUpdate’;\n}\n</code></pre>\n<h3>参考</h3>\n<p><a href=\"https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060\">How to write your own Virtual DOM\n</a><br>\n<a href=\"https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76\">Write your Virtual DOM 2: Props &#x26; Events</a><br>\n<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"How to wirte your own Virtual DOM(译)","date":"2019-04-02","tags":"React","path":"/react-virtual-dom","top":null,"summary":null}}},{"node":{"id":"7e5d1f2a-ee54-59e1-a3fd-71ffbe5c68a5","html":"<h2>go数据类型</h2>\n<p>go语言数据类型主要分为以下的四个大类:</p>\n<ol>\n<li>基础类型(整数,浮点数,负数,布尔值等)</li>\n<li>聚合类型(数组,结构体)</li>\n<li>引用类型(slice,指针,map,函数,通道)</li>\n<li>接口类型</li>\n</ol>\n<p>go语言是拥有类型系统的语言,相对于笔者最熟悉的javascript这种动态且无类型的语言来说有着长远的好处.通过类型系统能在编译阶段减少一定的运行时错误.例如在go语言中不同类型值之间必须通过显示转换来进行赋值操作.本文主要从go语言中的基础类型开始,逐步的讲解go语言中几种基本的引用类型.</p>\n<h2>基础类型</h2>\n<h3>字符串</h3>\n<p>字符串是不可改变的字节序列.可以通过[i:j]操作符截取对应字符串的子串.由于字符串不可改变的特点,子串和母串共用一端底层内存.</p>\n<pre><code>s := \"hello world\"\nb := s[6:] // [i:j] 从i开始不包括j 注意越界 b world\nb[0] = 'a' // 错误 \n</code></pre>\n<h3>常量</h3>\n<p>常量是一种表达式,可以在编译的阶段来确定相应的值.在声明常量的时候可以指定类型和值(如果没有指定类型会通过值来推断常量的类型).在连续声明多个常量的时候,主要有以下两种方式:</p>\n<ol>\n<li>\n<p>在声明枚举值的时候,可以通过iota常量生成器来实现.iota从0开始,逐项加1</p>\n</li>\n<li>\n<p>省略赋值语句的一项会复用前一项的表达式和类型</p>\n<pre><code> const (\n a  = iota\n b\n c\n d\n )\n // a b c d 0 1 2 3\n const (\n a = 1\n b\n c = 2\n d\n )\n // a b c d 1 1 2 2\n</code></pre>\n</li>\n</ol>\n<h4>无类型常量</h4>\n<p>无类型常量(常量字面量)是还没有确定从属类型的常量值.无类型常量相对于同样的有类型的常量有更大的精度.例如0.0相对有浮点数拥有更大的精度.在将无类型常量复制给对应的变量的时候,赋值的变量会转换为无类型常量默认的类型.</p>\n<pre><code>i := 0 // int(0)\nb := 0.0 // float64(0.0)\n</code></pre>\n<h2>聚合类型</h2>\n<h3>数组</h3>\n<p>数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列.由于数组在声明的时候对长度有限制,当存储元素到达数组的容量的时候就需要申请新的内存空间来进行数据的存储.所以在存储数据上一般不会使用数组.数组元素的初始值是该类型的零值.在声明数组的时候需要显示的指定长度和类型.</p>\n<ol>\n<li>\n<p>声明数组需要有长度的定义和类型定义,可以通过定义长度或者数据数量来确定数组的长度.元素类型和长度相同的数组是可以比较和复制的</p>\n</li>\n<li>\n<p>数组元素的初始值为该数组元素类型的初值</p>\n</li>\n<li>\n<p>在函数中使用数组指针来完成对原数组的修改</p>\n<p>b := [...]int{1,2,3}  // 通过初始化数组元素的个数决定数组的长度\na := [3]int{1,2,3}\na == b // true\nr := [...]int{99: -1} // 定义一个含100元素的数组r 最后一个元素是-1 其余都初始化int类型的零值 0</p>\n</li>\n</ol>\n<h3>结构体</h3>\n<p>结构体是将多个命名变量组合到一起的聚合数据类型.可以通过下面的方式声明一个结构体:</p>\n<pre><code>type Person struct {\n    name string\n    id int\n}\n</code></pre>\n<p>在声明结构体的时候需要注意以下的几点:</p>\n<ol>\n<li>结构体变量的大小写决定变量是否可以导出(可以被其他导出的包读写),</li>\n<li>结构体变量不可以拥有自己本身的结构体类型,可以通过自身结构体类型的指针来实现递归结构</li>\n</ol>\n<h4>结构体字面量</h4>\n<ol>\n<li>\n<p>可以按照声明的顺序来初始化结构体变量或者指定变量名称来初始化结构体字面量</p>\n</li>\n<li>\n<p>可以获取结构体指针来设置结构体的值</p>\n<pre><code> a := Person{ name: \"haha\" } // 指定变量名声明\n b := Person{ \"haha\", 20 }\n var copyPerson *Person = &#x26;a // 获取结构体指针\n copyPerson.name = \"100\"\n</code></pre>\n</li>\n</ol>\n<h4>结构体嵌套</h4>\n<p>在定义结构体的成员的时候,go允许只指定成员的类型来实现成员的声明.通过这种方式定义的结构体成员成为匿名成员.匿名成员的类型必须是一种命名类型或者指向命名类型的指针.匿名成员可以为方便变量提供便捷的操作.</p>\n<pre><code>type Circle struct {\n    x int\n    y int \n    radius int\n}\ntype Wheel struct {\t\n  Circle\n  color string\n}\nwheel := Wheel{Circle{ 10, 10, 19}, \"red\"}\n// wheel.x = 10\n</code></pre>\n<h2>引用类型</h2>\n<h3>slice(切片)</h3>\n<p>slice是用相同类型元素的可变长度序列.可以基于一个已有的数组来创建这个数组的slice.slice有三个属性:指针,容量,长度.可以在一个数组的基础上产生多个slice,它们共享内存空间.需要注意的是slice可以理解为对原数组的引用,通过对slice的修改是会影响到底层数组的.</p>\n<h4>声明切片</h4>\n<p>主要有以下两种方式声明切片:</p>\n<ol>\n<li>\n<p>通过切片字面量和内置的make函数</p>\n</li>\n<li>\n<p>slice的操作符[i:j]操作数组或者切片字面量</p>\n<pre><code> var b = make(int[], 3, 5) // make(type[], len, cap) 声明一个长度为3容量为5的切片\n var b = []int{1,2} // 声明一个长度和容量都为2的切片\n var c = []int{ 99: 1 } // 声明一个长度和容量为100的切片,初始化第100的元素为1\n slice := []int{1,2,3,4,5}\n newSlice := slice[1:3]  // 通过切片创建切片\n var num = [10]int{1,2,3,4,5,6,7,8,9,10}\n a := num[1:4] // 操作符[i:j]创建一个新的slice,引用原数组i到j-1个元素.slice的容量是slice起始元素到底层数组最后一个元素之间的个数,切片a只能看到底层数组i以及之后的元素\n len(a) // 3 获取切片的长度\n cap(a) // 9 获取切片的容量\n b := a[:5] // 可以在一个已有的slice上扩充容量,产生新的slice\n len(b) // 4\n cap(b) // 9\n</code></pre>\n</li>\n</ol>\n<h4>操作切片</h4>\n<ol>\n<li>\n<p>slice相当于对底层数组的引用,通过操作slice可以修改底层数组</p>\n<pre><code> a := [3]int{1,2,3}  \n b := a[:2]\n b[0] = 100  // a[0]也是100\n</code></pre>\n</li>\n<li>\n<p>append函数可以动态的添加元素到slice.append函数会返回一个新的slice</p>\n<pre><code> slice := []int{1,2,3,4,5}\n newSlice := slice[1:2] \n newSlice = append(newSlice, 10) // newSlice容量足够,修改底层数组返回新的slice. a[2] = 10\n a := slice[1:2]\n b := slice[2:3]\n c = append(a, b...) // 支持批量添加\n</code></pre>\n</li>\n</ol>\n<h3>map</h3>\n<p>在go中map是对散列表的引用.散列表是无序的键值的结合.可以通过如下的方式创建map:</p>\n<pre><code>var test = make(map[string]int) // 声明map的键值的类型 \ntest[\"name\"] = 100  // 赋值\nvar person = map[string]int{ \"card\": 1, id: \"2\" }  //声明并初始map\nperson[\"card\"] // 1\n</code></pre>\n<p>map有以下几点需要特别注意:</p>\n<ol>\n<li>在赋值map类型的值的时候,需要对map进行初始化.初始化的map的值是对应类型的零值.</li>\n<li>map是引用类型,在函数间传递的时候会对原值进行修改.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null}}},{"node":{"id":"570eee31-e50d-5468-bf5e-ed48bc58dde3","html":"<h2>go语言简介</h2>\n<p>go语言是一种编译型语言,在设计上融入了设计者对复杂项目中易出现问题的思考,go语言在设计上突显了简单性.这种简单性在长期来看是会为项目带来收益的.下面主要从go的环境配置开始进而通过一个简单的go程序\b来认识go.</p>\n<h2>go环境配置</h2>\n<p>当go安装完毕后,可以通过go env来查看相应的环境配置,如图\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 641px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABiUlEQVQ4y51U2VLCQBBcOQRFzoCgFo+inELuhJCEcMj//9BYPZsNFmUh8DC1u7Op3u6emYjS1KOHL5/aTkJNK+Yoz3zKDS0SHwaJT/O66Ppb6kcH6rgJ1c2Qut6GOu6GcqMbATvehvrhgVp2TIWxQ2Kgk3hfkBgYEvBc4NvTnOasWe7LckcNM6KmFZHmJNm+qq9kzl5T3QipYcXUdhPSbGkP8rgHofupKxn2ljsCcHnmUX5kU3HiMFus+fHxXEj36nw/cbPvWJ2SDP/wKopzNzSlZBVnJf+RQwGeU5ZYH+dLfhkrGN9UFPjX9bb0GuzZC3j1tvrm/dWVBsOeL9kpMMjHvgSTFeDpeo5hz99mQKju0yKQLaHiUjDFEM2NKgOsnbZMzQj5kZYVc+tcLB1S4R1Aa/qK2aGfMJJqLLklLgXUuKn3LBeMOMmTov+aGv3/qVEBhqgoerEyD7ixEWjiYzhZXt4dz8WTO6HGDl5VFgGPEWTLv08kfeQxi9hnjBv8rab24A524R6AP/kYq3qmQSoOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"go env\"\n        title=\"go env\"\n        src=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n        srcset=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/63868/goEnv.png 250w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/0b533/goEnv.png 500w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png 641w\"\n        sizes=\"(max-width: 641px) 100vw, 641px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n其中GOPATH,GOROOT是我们需要关注的两个配置.GOPATH指定的工作区间的根目录,在GOPATH下通常有三个目录:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 596px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQoz53OSY7CMBSEYd/EwXHiAWXhDMgWqJsM4gAsEFIvcv9T/C0jOIBZfHp6tSiVWNeVfd+Z55lxHEkpEWP8ilIK4b0nhMCyLPR9jzEG5xzWlquqCuHckRBGtu3GMEwY48iZteVehSn9cr3eeDz+uN+fTNOFnMVY6gel9GfhwLJsnE6RtrXvhb6YlBVC6wbvj5zPF7quQ6manGmti0kpEU3TUteaw0G9bv6/lQv/AcdU1m38VSPNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n        srcset=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/63868/category.png 250w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/0b533/category.png 500w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png 596w\"\n        sizes=\"(max-width: 596px) 100vw, 596px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在src目录下的每个子目录是一个包.pkg子目录是构建工具存储编译后的包的位置.bin子目录放置可执行程序.GOROOT主要提供标准库的包.</p>\n<h3>go语言的基础结构-hello world</h3>\n<p>在GOPATH下的src目录创建helloworld文件夹,在该文件夹中创建helloworld.go.(通常文件的名字都跟包名一致),通过在命令行使用go run hellowrld.go</p>\n<pre><code>package main // 定义包名\nimport (\n  \"fmt\"  // 导入包\n)\n//  main函数可执行程序的主入口\nfunc main() {\n  var a = \"hello world\"  // 定义变量并且在控制台输出\n  fmt.Print(a)\n}\n</code></pre>\n<h2>go中的包</h2>\n<h3>包的初始化</h3>\n<p>包的初始化从初始化包级别变量开始,按照这些变量的声明顺序进行初始化,对于一些复杂的初始化场景,可以定义init函数来初始化变量,在其他包对当前包进行引用的时候,init函数会被调用.</p>\n<pre><code>var a = b + c\nc = 100\nb = f()\nfunc f() {\n  return 1\n}  // 会按照 c b a 的顺序依次初始化\n</code></pre>\n<h3>包的命名</h3>\n<p>在go源文件的开头都需要进行包名的声明,同一个包下的所有源文件同属一个包(有一个例外是当前go文件是一个可执行的go程序时,只能声明main包来生成可执行的文件)</p>\n<h3>包的引入</h3>\n<p>包是go实现代码复用的一种主要形成.在声明包名之后,可以通过import语句对需要使用的包进行引入.通常有下面几种方式导入对应的包:</p>\n<pre><code>import (\n  \"fmt\"  //正常导入\n  XXX \"fmt\" // 别名导入 XXX可以作为fmt包的别名来使用\n  _ \"image/png\" // 空导入 通常为了执行包的初始化函数来获取副作用\n  import \"github.com/xxx\" // 导入远程包\n)\n</code></pre>\n<p>包的查找是先查找go的安装目录,然后GOPATH</p>\n<h2>声明</h2>\n<p>实体的声明主要有以下的规则:</p>\n<ol>\n<li>如果声明的实体在函数体内,该实体只在函数局部(存在块级作用域)有效.实体声明在函数外,该声明对当前包所有的文件可见.</li>\n<li>实体的第一个字母的大小写决定其是否可以被其他包调用</li>\n</ol>\n<h3>变量声明</h3>\n<p>在go语言中可以通过下面的几种方式来创建和声明变量.</p>\n<h4>常规变量声明</h4>\n<pre><code>var name type = expression\n</code></pre>\n<p>上面这种声明方式指定了变量的类型和初始值表达式,类型和表达式可以忽略一个:</p>\n<ol>\n<li>当类型忽略的时候,变量的类型会由初始化表达式的类型决定</li>\n<li>当初始化表达式忽略的时候,变量的初始值对应着相应类型的零值.</li>\n<li>当把一个类型的变量赋值给另一个类型的时候,需要通过显示转换.</li>\n</ol>\n<h4>短变量声明</h4>\n<pre><code>name := expression\n</code></pre>\n<p>上面这种方式称为短变量声明,这种方式声明的变量类型由表达式返回的类型决定.在使用短变量声明的时候,需要注意一下两点:</p>\n<ol>\n<li>短变量声明在左侧已经存在对应变量的声明的时候,相当于赋值</li>\n<li>短变量声明要求至少声明一个变量</li>\n</ol>\n<h4>new操作符</h4>\n<p>new(T)创建一个未命名的T类型变量并且初始化T类型的零值,返回其地址(指针).</p>\n<pre><code>p := new(int) // 初始化一个int类型的变量返回地址\nfmt.Println(*p) // 输出0\n*p = 2\nfmt.Println(*p)  // 输出2\n</code></pre>\n<h4>指针</h4>\n<pre><code>x := 1\np := &#x26;x  // &#x26;操作符获取变量地址 复制给一个int类型的指针p\nfmt.Println(*p) // 输出1 *操作符获取指针指向的变量的值\n*p = 2 // 通过指针修改变量的值 \nfmt.Println(x) // 输出2\n</code></pre>\n<h4>变量的生命周期和作用域</h4>\n<h5>生命周期</h5>\n<ol>\n<li>\n<p>包级别变量存在于整个程序的执行时间</p>\n</li>\n<li>\n<p>局部变量有动态的声明周期,在执行声明语句的时候会创建一个新的实体.当局部变量不可访问时会被回收.</p>\n<pre><code> a := []int{1,2,3,4,5}\n for _, num := range a {\n   fmt.Printf(\"%d\", num)  // num变量在每次循环创建\n }  \n</code></pre>\n</li>\n</ol>\n<h5>作用域</h5>\n<p>作用域指的是用到对应变量声明的源代码段。go语言中声明的作用域是词法块的，词法块决定着声明作用域的大小。</p>\n<h3>变量赋值</h3>\n<ol>\n<li>\n<p>在进行变量赋值的时候,go语言有对应的类型检测(例如你不能把一个int类型赋值给string类型的变量).</p>\n</li>\n<li>\n<p>支持多重赋值语法</p>\n<pre><code> x,y := 1, 2\n x, y = y, x\n</code></pre>\n</li>\n</ol>\n<h3>类型声明</h3>\n<p>类型声明提供了一种方式来区分底层类型的不同或者不兼容的使用方式。相同类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，不同命名类型的值不能直接比较.</p>\n<pre><code>type name string\ntype id string\n\nfunc main() {\n  var a name = \"\"\n  var b id = \"\"\n  fmt.Println(a == b) // 这里会报错 a b 不是相同的类型无法比较\n}\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://golang.google.cn/cmd/go/\">go命令行使用</a></p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null}}},{"node":{"id":"49d0ecf8-e0ff-5395-8dc8-4d548df3162b","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有先入先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这个在一定程度上也解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定(<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>).</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a></p>\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a></p>\n<p><a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a></p>\n<p><a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null}}},{"node":{"id":"16f13582-3dfd-5fca-8a6c-cd780c714f5f","html":"<h2>简介</h2>\n<p>最近在做业务中,需求的场景是需要在原有的组件上添加点击事件并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.高阶组件能最好化的复用代码.实现高阶组件有如下几种方式:</p>\n<ol>\n<li>属性代理(操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(子组件先DidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有调用,不会执行Wrapped的DidMount)\n    }\n    render() {\n      return super.render() //在这个可以实现渲染劫持,例如常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的时候通过在定义一个render函数来决定组件的具体内容.(children API)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的可以复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null}}},{"node":{"id":"efc0f5b3-aa07-511b-a4cf-49525fafa951","html":"<h2>简介</h2>\n<p>如何利用缓存在计算机系统或者网络服务中都是提升系统体验的的一个很重要的思考方向.相对于网络(磁盘)的I/O,直接将需要的数据存储到一个相对较快的获取位置,这样就能尽快的获取到需要的资源.这里主要总结下在前端开发中一些缓存方面的知识.</p>\n<h2>请求资源</h2>\n<p>下面这个图总结了网络请求中缓存涉及的几个方面,下面将具体的从每个方面进行展开.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvTUgo/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQITFh/9oACAEBAAE/IWxwjVLNf//aAAwDAQACAAMAAAAQO8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJVpB//EABsQAQADAQADAAAAAAAAAAAAAAEAEUEhMVFx/9oACAEBAAE/EKAD7uLzWqMJSlfrK2AtzJQeCf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"缓存\"\n        title=\"缓存\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/0479a/cache.jpg 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/41099/cache.jpg 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>本地-强缓存</h3>\n<p>强缓存是浏览器在请求具体的资源的时候,直接使用本地缓存的资源的副本而不通过服务器去验证资源的相关信息的一种方式.通常有通过expires和Cache-Control中的max-age来控制.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"right\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>expires</td>\n<td align=\"center\">指定缓存的过期时间(与客户端的时间设置相关)</td>\n<td align=\"right\">HTTP 1.0  max-age优先expires</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">指定请求资源过后多少秒后资源过期</td>\n<td align=\"right\">HTTP 1.1 max-age有优先expires</td>\n</tr>\n</tbody>\n</table>\n<p>当请求的资源存在本地缓存副本并且处于新鲜期的时候,直接返回本地资源.<br>\n当请求的资源没有本地缓存的时候,向服务器拉取对应的资源.<br>\n当资源存在缓存但是已经过期的时候,通过是缓存协商去服务器获取资源.</p>\n<h3>请求-缓存协商</h3>\n<p>缓存协商是指通过与服务端交互缓存资源的信息来判断当前缓存是否可用的一种机制.<br>\n当通过缓存协商服务端认为当前的资源是可用的,返回304(响应体是空).客户端可以时候当前的缓存资源并且可以更新缓存的相关信息.<br>\n当服务端认为资源不可用的时候,返回200(响应体中包含请求的资源).</p>\n<h4>Cache-Control</h4>\n<p>Cache-Control 被用于在http请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求设置的指令,在响应中不一定包含相同的指令.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td align=\"center\">下次请求是强制验证资源有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td align=\"center\">不进行缓存</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">相对于请求时间设置的最大过期时间</td>\n</tr>\n<tr>\n<td>public</td>\n<td align=\"center\">可以被客户端和代理缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">只能客户端缓存,不能被代理缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td align=\"center\">缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源</td>\n</tr>\n</tbody>\n</table>\n<h4>last-modified和Etag</h4>\n<p>last-modified和Etag(Etag还可以结合If-Match来判断当前提交的内容跟服务端存储的内容是否一致)都是在响应头中返回的对资源的一些设置信息,可以通过这两个值来缓存协商当前缓存资源时候可用.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">作用方式</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>last-modified</td>\n<td align=\"center\">资源在服务端的上次修改时间</td>\n<td align=\"center\">通过在请求头中设置If-Modified-Since的值为缓存资源的last-modified值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td align=\"center\">代表资源的实体标识,当资源的内容在服务端修改的时候,需要重新生成Etag</td>\n<td align=\"center\">通过在请求头中设置If-None-Match的值为缓存资源的Etag值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n</tbody>\n</table>\n<h5>last-modified和Etag的区分</h5>\n<p>Etag的出现更像是为了弥补last-modified的不足.例如:</p>\n<ol>\n<li>last-modified的时间只能精确到秒</li>\n<li>一个资源的频繁修改但是内容并没有修改</li>\n</ol>\n<h2>存储-协商存储</h2>\n<p>协商存储就是根据上面学习的相关字段来决定获取到的资源是否可以被存储被下次请求使用的策略.上文已经对响应的字段进行了说明.</p>\n<h2>CDN</h2>\n<h3>CDN简介</h3>\n<p>CDN(内容分发网络)指的是一组分布在各个地区的服务器.这些服务器存储着数据的副本,当用户访问资源的时候,CDN服务器可以根据用户的IP,服务集群的负载状态等信息尽快的返回给用户所需要的资源.</p>\n<h3>CDN优点</h3>\n<p>CDN主要的功能是托管静态资源,项目中对静态资源进行CDN的配置已经是标配,使用CDN主要有以下优点:</p>\n<ol>\n<li>将静态资源托管给CDN起到给源站分流的作用,降低服务端负载,解决网络网络带宽问题和不同服务商网络速度不同的问题.</li>\n<li>对资源的请求大部分都在CDN的边缘节点完成,访问延迟降低,用户能尽快的看到内容.</li>\n<li>CDN域名与源站域名不同,源站的cookie不会随着静态资源的请求发送,能一定程度上减少网络数据的发送.</li>\n</ol>\n<h3>CDN请求资源流程</h3>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器.</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户.</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求.</li>\n<li>CDN全局负载均衡设备根据用户IP地址,以及用户请求的内容URL,选择一台用户所属区域的区域负载均衡设备,告诉用户向这台设备发起请求.</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近;根据用户所请求的URL中携带的内容名称,判断哪一台服务器上有用户所需内容;查询各个服务器当前的负载情况,判断哪一台服务器尚有服务能力.基于以上这些条件的综合分析之后,区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址.</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户.</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地.</li>\n</ol>\n<h3>CDN优化</h3>\n<ol>\n<li>合理设置CDN节点的缓存时间，保证用户能及时同步到最新的内容</li>\n<li>根据不同的路径 配置不同的缓存规则，实现缓存的最大化</li>\n<li>CDN缓存节点预热</li>\n</ol>\n<h2>缓存的意义</h2>\n<ol>\n<li>资源或者服务的尽快到达和可用</li>\n<li>解决网络带宽问题和服务负载</li>\n<li>减少网络流量,让流量做更加有意义的事</li>\n</ol>\n<h2>思考</h2>\n<p>缓存能给应用带来一定的好处,同时也给服务增加了一些负载(保证资源的更新,增加缓存的成本等等).在对系统的一些基础服务做修改的时候,先要把这些有可能出现问题的点考虑清楚或者为什么这么做想好,在去做事.</p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":13,"pageCount":15,"additionalContext":{"pageAllCount":89}}},"staticQueryHashes":[]}