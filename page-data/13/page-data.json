{"componentChunkName":"component---src-templates-index-js","path":"/13","result":{"pageContext":{"pageAllCount":86,"group":[{"node":{"id":"570eee31-e50d-5468-bf5e-ed48bc58dde3","html":"<h2>go语言简介</h2>\n<p>go语言是一种编译型语言,在设计上融入了设计者对复杂项目中易出现问题的思考,go语言在设计上突显了简单性.这种简单性在长期来看是会为项目带来收益的.下面主要从go的环境配置开始进而通过一个简单的go程序\b来认识go.</p>\n<h2>go环境配置</h2>\n<p>当go安装完毕后,可以通过go env来查看相应的环境配置,如图\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 641px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABiUlEQVQ4y51U2VLCQBBcOQRFzoCgFo+inELuhJCEcMj//9BYPZsNFmUh8DC1u7Op3u6emYjS1KOHL5/aTkJNK+Yoz3zKDS0SHwaJT/O66Ppb6kcH6rgJ1c2Qut6GOu6GcqMbATvehvrhgVp2TIWxQ2Kgk3hfkBgYEvBc4NvTnOasWe7LckcNM6KmFZHmJNm+qq9kzl5T3QipYcXUdhPSbGkP8rgHofupKxn2ljsCcHnmUX5kU3HiMFus+fHxXEj36nw/cbPvWJ2SDP/wKopzNzSlZBVnJf+RQwGeU5ZYH+dLfhkrGN9UFPjX9bb0GuzZC3j1tvrm/dWVBsOeL9kpMMjHvgSTFeDpeo5hz99mQKju0yKQLaHiUjDFEM2NKgOsnbZMzQj5kZYVc+tcLB1S4R1Aa/qK2aGfMJJqLLklLgXUuKn3LBeMOMmTov+aGv3/qVEBhqgoerEyD7ixEWjiYzhZXt4dz8WTO6HGDl5VFgGPEWTLv08kfeQxi9hnjBv8rab24A524R6AP/kYq3qmQSoOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"go env\"\n        title=\"go env\"\n        src=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n        srcset=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/63868/goEnv.png 250w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/0b533/goEnv.png 500w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png 641w\"\n        sizes=\"(max-width: 641px) 100vw, 641px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n其中GOPATH,GOROOT是我们需要关注的两个配置.GOPATH指定的工作区间的根目录,在GOPATH下通常有三个目录:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 596px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQoz53OSY7CMBSEYd/EwXHiAWXhDMgWqJsM4gAsEFIvcv9T/C0jOIBZfHp6tSiVWNeVfd+Z55lxHEkpEWP8ilIK4b0nhMCyLPR9jzEG5xzWlquqCuHckRBGtu3GMEwY48iZteVehSn9cr3eeDz+uN+fTNOFnMVY6gel9GfhwLJsnE6RtrXvhb6YlBVC6wbvj5zPF7quQ6manGmti0kpEU3TUteaw0G9bv6/lQv/AcdU1m38VSPNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n        srcset=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/63868/category.png 250w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/0b533/category.png 500w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png 596w\"\n        sizes=\"(max-width: 596px) 100vw, 596px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在src目录下的每个子目录是一个包.pkg子目录是构建工具存储编译后的包的位置.bin子目录放置可执行程序.GOROOT主要提供标准库的包.</p>\n<h3>go语言的基础结构-hello world</h3>\n<p>在GOPATH下的src目录创建helloworld文件夹,在该文件夹中创建helloworld.go.(通常文件的名字都跟包名一致),通过在命令行使用go run hellowrld.go</p>\n<pre><code>package main // 定义包名\nimport (\n  \"fmt\"  // 导入包\n)\n//  main函数可执行程序的主入口\nfunc main() {\n  var a = \"hello world\"  // 定义变量并且在控制台输出\n  fmt.Print(a)\n}\n</code></pre>\n<h2>go中的包</h2>\n<h3>包的初始化</h3>\n<p>包的初始化从初始化包级别变量开始,按照这些变量的声明顺序进行初始化,对于一些复杂的初始化场景,可以定义init函数来初始化变量,在其他包对当前包进行引用的时候,init函数会被调用.</p>\n<pre><code>var a = b + c\nc = 100\nb = f()\nfunc f() {\n  return 1\n}  // 会按照 c b a 的顺序依次初始化\n</code></pre>\n<h3>包的命名</h3>\n<p>在go源文件的开头都需要进行包名的声明,同一个包下的所有源文件同属一个包(有一个例外是当前go文件是一个可执行的go程序时,只能声明main包来生成可执行的文件)</p>\n<h3>包的引入</h3>\n<p>包是go实现代码复用的一种主要形成.在声明包名之后,可以通过import语句对需要使用的包进行引入.通常有下面几种方式导入对应的包:</p>\n<pre><code>import (\n  \"fmt\"  //正常导入\n  XXX \"fmt\" // 别名导入 XXX可以作为fmt包的别名来使用\n  _ \"image/png\" // 空导入 通常为了执行包的初始化函数来获取副作用\n  import \"github.com/xxx\" // 导入远程包\n)\n</code></pre>\n<p>包的查找是先查找go的安装目录,然后GOPATH</p>\n<h2>声明</h2>\n<p>实体的声明主要有以下的规则:</p>\n<ol>\n<li>如果声明的实体在函数体内,该实体只在函数局部(存在块级作用域)有效.实体声明在函数外,该声明对当前包所有的文件可见.</li>\n<li>实体的第一个字母的大小写决定其是否可以被其他包调用</li>\n</ol>\n<h3>变量声明</h3>\n<p>在go语言中可以通过下面的几种方式来创建和声明变量.</p>\n<h4>常规变量声明</h4>\n<pre><code>var name type = expression\n</code></pre>\n<p>上面这种声明方式指定了变量的类型和初始值表达式,类型和表达式可以忽略一个:</p>\n<ol>\n<li>当类型忽略的时候,变量的类型会由初始化表达式的类型决定</li>\n<li>当初始化表达式忽略的时候,变量的初始值对应着相应类型的零值.</li>\n<li>当把一个类型的变量赋值给另一个类型的时候,需要通过显示转换.</li>\n</ol>\n<h4>短变量声明</h4>\n<pre><code>name := expression\n</code></pre>\n<p>上面这种方式称为短变量声明,这种方式声明的变量类型由表达式返回的类型决定.在使用短变量声明的时候,需要注意一下两点:</p>\n<ol>\n<li>短变量声明在左侧已经存在对应变量的声明的时候,相当于赋值</li>\n<li>短变量声明要求至少声明一个变量</li>\n</ol>\n<h4>new操作符</h4>\n<p>new(T)创建一个未命名的T类型变量并且初始化T类型的零值,返回其地址(指针).</p>\n<pre><code>p := new(int) // 初始化一个int类型的变量返回地址\nfmt.Println(*p) // 输出0\n*p = 2\nfmt.Println(*p)  // 输出2\n</code></pre>\n<h4>指针</h4>\n<pre><code>x := 1\np := &#x26;x  // &#x26;操作符获取变量地址 复制给一个int类型的指针p\nfmt.Println(*p) // 输出1 *操作符获取指针指向的变量的值\n*p = 2 // 通过指针修改变量的值 \nfmt.Println(x) // 输出2\n</code></pre>\n<h4>变量的生命周期和作用域</h4>\n<h5>生命周期</h5>\n<ol>\n<li>\n<p>包级别变量存在于整个程序的执行时间</p>\n</li>\n<li>\n<p>局部变量有动态的声明周期,在执行声明语句的时候会创建一个新的实体.当局部变量不可访问时会被回收.</p>\n<pre><code> a := []int{1,2,3,4,5}\n for _, num := range a {\n   fmt.Printf(\"%d\", num)  // num变量在每次循环创建\n }  \n</code></pre>\n</li>\n</ol>\n<h5>作用域</h5>\n<p>作用域指的是用到对应变量声明的源代码段。go语言中声明的作用域是词法块的，词法块决定着声明作用域的大小。</p>\n<h3>变量赋值</h3>\n<ol>\n<li>\n<p>在进行变量赋值的时候,go语言有对应的类型检测(例如你不能把一个int类型赋值给string类型的变量).</p>\n</li>\n<li>\n<p>支持多重赋值语法</p>\n<pre><code> x,y := 1, 2\n x, y = y, x\n</code></pre>\n</li>\n</ol>\n<h3>类型声明</h3>\n<p>类型声明提供了一种方式来区分底层类型的不同或者不兼容的使用方式。相同类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，不同命名类型的值不能直接比较.</p>\n<pre><code>type name string\ntype id string\n\nfunc main() {\n  var a name = \"\"\n  var b id = \"\"\n  fmt.Println(a == b) // 这里会报错 a b 不是相同的类型无法比较\n}\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://golang.google.cn/cmd/go/\">go命令行使用</a></p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null}}},{"node":{"id":"49d0ecf8-e0ff-5395-8dc8-4d548df3162b","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有后进先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这在一定程度上解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定<br>\n<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>.</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a><br>\n<a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a><br>\n<a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a><br>\n<a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null}}},{"node":{"id":"16f13582-3dfd-5fca-8a6c-cd780c714f5f","html":"<h2>简介</h2>\n<p>最近在做业务中,需求的场景是需要在原有的组件上添加点击事件并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.高阶组件能最好化的复用代码.实现高阶组件有如下几种方式:</p>\n<ol>\n<li>属性代理(操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(子组件先DidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有调用,不会执行Wrapped的DidMount)\n    }\n    render() {\n      return super.render() //在这个可以实现渲染劫持,例如常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的时候通过在定义一个render函数来决定组件的具体内容.(children API)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的可以复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null}}},{"node":{"id":"efc0f5b3-aa07-511b-a4cf-49525fafa951","html":"<h2>简介</h2>\n<p>如何利用缓存在计算机系统或者网络服务中都是提升系统体验的的一个很重要的思考方向.相对于网络(磁盘)的I/O,直接将需要的数据存储到一个相对较快的获取位置,这样就能尽快的获取到需要的资源.这里主要总结下在前端开发中一些缓存方面的知识.</p>\n<h2>请求资源</h2>\n<p>下面这个图总结了网络请求中缓存涉及的几个方面,下面将具体的从每个方面进行展开.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvTUgo/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQITFh/9oACAEBAAE/IWxwjVLNf//aAAwDAQACAAMAAAAQO8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJVpB//EABsQAQADAQADAAAAAAAAAAAAAAEAEUEhMVFx/9oACAEBAAE/EKAD7uLzWqMJSlfrK2AtzJQeCf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"缓存\"\n        title=\"缓存\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/0479a/cache.jpg 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/41099/cache.jpg 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>本地-强缓存</h3>\n<p>强缓存是浏览器在请求具体的资源的时候,直接使用本地缓存的资源的副本而不通过服务器去验证资源的相关信息的一种方式.通常有通过expires和Cache-Control中的max-age来控制.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"right\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>expires</td>\n<td align=\"center\">指定缓存的过期时间(与客户端的时间设置相关)</td>\n<td align=\"right\">HTTP 1.0  max-age优先expires</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">指定请求资源过后多少秒后资源过期</td>\n<td align=\"right\">HTTP 1.1 max-age有优先expires</td>\n</tr>\n</tbody>\n</table>\n<p>当请求的资源存在本地缓存副本并且处于新鲜期的时候,直接返回本地资源.<br>\n当请求的资源没有本地缓存的时候,向服务器拉取对应的资源.<br>\n当资源存在缓存但是已经过期的时候,通过是缓存协商去服务器获取资源.</p>\n<h3>请求-缓存协商</h3>\n<p>缓存协商是指通过与服务端交互缓存资源的信息来判断当前缓存是否可用的一种机制.<br>\n当通过缓存协商服务端认为当前的资源是可用的,返回304(响应体是空).客户端可以时候当前的缓存资源并且可以更新缓存的相关信息.<br>\n当服务端认为资源不可用的时候,返回200(响应体中包含请求的资源).</p>\n<h4>Cache-Control</h4>\n<p>Cache-Control 被用于在http请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求设置的指令,在响应中不一定包含相同的指令.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td align=\"center\">下次请求是强制验证资源有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td align=\"center\">不进行缓存</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">相对于请求时间设置的最大过期时间</td>\n</tr>\n<tr>\n<td>public</td>\n<td align=\"center\">可以被客户端和代理缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">只能客户端缓存,不能被代理缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td align=\"center\">缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源</td>\n</tr>\n</tbody>\n</table>\n<h4>last-modified和Etag</h4>\n<p>last-modified和Etag(Etag还可以结合If-Match来判断当前提交的内容跟服务端存储的内容是否一致)都是在响应头中返回的对资源的一些设置信息,可以通过这两个值来缓存协商当前缓存资源时候可用.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">作用方式</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>last-modified</td>\n<td align=\"center\">资源在服务端的上次修改时间</td>\n<td align=\"center\">通过在请求头中设置If-Modified-Since的值为缓存资源的last-modified值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td align=\"center\">代表资源的实体标识,当资源的内容在服务端修改的时候,需要重新生成Etag</td>\n<td align=\"center\">通过在请求头中设置If-None-Match的值为缓存资源的Etag值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n</tbody>\n</table>\n<h5>last-modified和Etag的区分</h5>\n<p>Etag的出现更像是为了弥补last-modified的不足.例如:</p>\n<ol>\n<li>last-modified的时间只能精确到秒</li>\n<li>一个资源的频繁修改但是内容并没有修改</li>\n</ol>\n<h2>存储-协商存储</h2>\n<p>协商存储就是根据上面学习的相关字段来决定获取到的资源是否可以被存储被下次请求使用的策略.上文已经对响应的字段进行了说明.</p>\n<h2>CDN</h2>\n<h3>CDN简介</h3>\n<p>CDN(内容分发网络)指的是一组分布在各个地区的服务器.这些服务器存储着数据的副本,当用户访问资源的时候,CDN服务器可以根据用户的IP,服务集群的负载状态等信息尽快的返回给用户所需要的资源.</p>\n<h3>CDN优点</h3>\n<p>CDN主要的功能是托管静态资源,项目中对静态资源进行CDN的配置已经是标配,使用CDN主要有以下优点:</p>\n<ol>\n<li>将静态资源托管给CDN起到给源站分流的作用,降低服务端负载,解决网络网络带宽问题和不同服务商网络速度不同的问题.</li>\n<li>对资源的请求大部分都在CDN的边缘节点完成,访问延迟降低,用户能尽快的看到内容.</li>\n<li>CDN域名与源站域名不同,源站的cookie不会随着静态资源的请求发送,能一定程度上减少网络数据的发送.</li>\n</ol>\n<h3>CDN请求资源流程</h3>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器.</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户.</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求.</li>\n<li>CDN全局负载均衡设备根据用户IP地址,以及用户请求的内容URL,选择一台用户所属区域的区域负载均衡设备,告诉用户向这台设备发起请求.</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近;根据用户所请求的URL中携带的内容名称,判断哪一台服务器上有用户所需内容;查询各个服务器当前的负载情况,判断哪一台服务器尚有服务能力.基于以上这些条件的综合分析之后,区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址.</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户.</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地.</li>\n</ol>\n<h3>CDN优化</h3>\n<ol>\n<li>合理设置CDN节点的缓存时间，保证用户能及时同步到最新的内容</li>\n<li>根据不同的路径 配置不同的缓存规则，实现缓存的最大化</li>\n<li>CDN缓存节点预热</li>\n</ol>\n<h2>缓存的意义</h2>\n<ol>\n<li>资源或者服务的尽快到达和可用</li>\n<li>解决网络带宽问题和服务负载</li>\n<li>减少网络流量,让流量做更加有意义的事</li>\n</ol>\n<h2>思考</h2>\n<p>缓存能给应用带来一定的好处,同时也给服务增加了一些负载(保证资源的更新,增加缓存的成本等等).在对系统的一些基础服务做修改的时候,先要把这些有可能出现问题的点考虑清楚或者为什么这么做想好,在去做事.</p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null}}},{"node":{"id":"cd56cd7c-4adc-5c34-be0f-983b3549de82","html":"<h2>简介</h2>\n<p>事件循环是不同的宿主环境(浏览器或node)对javascript任务进行调度的一种机制,在讨论事件循环的时候首先应该区分node和浏览器(不同宿主环境实现的事件循环机制不同).下面通过介绍一些javascript的基础知识,进而简单的介绍浏览器中的事件循环和node中事件循环.</p>\n<h2>基本概念</h2>\n<ol>\n<li>javascript程序的执行机制是通过栈来管理的.当进入一个函数,就创建了这个函数的执行环境并将这个执行环境推入栈顶,执行完当前的函数后,从栈顶移除对应的执行环境,进入到外层的执行环境.</li>\n</ol>\n<p><img src=\"/blog/ee34151d44d3f796b1f1436e0926a2a7/stack.gif\" alt=\"stack\">\n2. javascript的执行是单线程的.但是由于整个事件循环的调度,赋予了javascript对异步任务的强大处理能力.对于异步任务(网络请求,按钮点击)javascript代码调用宿主环境提供的api,将异步任务交给其他的线程去完成.当对应的异步任务完成的时候,将回调函数添加到回调函数的队列中,由事件循环来实现会回调函数的调用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>marcotasks microtasks</h2>\n<p>将macrotasks和micortasks单拉出来讲解,是因为理解好这点能更好的理解浏览器或node的任务队列.在实际的实现环境中不同的任务可以放置在不同的任务队列中,然后通过对多个任务队列的调用来完成整个事件循环.</p>\n<ol>\n<li>macrotasks:</li>\n</ol>\n<ul>\n<li>定时器(timer) setTimeout setInterval setImmediate</li>\n<li>message channel  (message channel执行的优先级高于timer)</li>\n<li>I/O</li>\n<li>UI rendering</li>\n</ul>\n<ol start=\"2\">\n<li>microtasks:</li>\n</ol>\n<ul>\n<li>Promises</li>\n<li>MutationObserver(监听DOM)</li>\n</ul>\n<ol start=\"3\">\n<li>其他api</li>\n</ol>\n<ul>\n<li>\n<p>queueMicrotask(fn)\n将Fn推入微任务执行队列</p>\n</li>\n<li>\n<p>requestAnimationFrame<br>\n通知浏览器在下次重绘之前调用传入的回调函数，回调函数默认传入函数执行的时间戳.requestAnimationFrame不属于宏任务和微任务，在微任务执行之后执行</p>\n</li>\n<li>\n<p>process.nextTick\nprocess.nextTick是node上的api，具体的执行时机是在微任务之前执行。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVQ4y42T227aQBRF+QwItudqjw12bGyMuQQCCRENtE9VK7X//x+r8uSiRkmkPGwdzRnN1lkzewbKWHTeYos5dTujW9V0q4Z6XhPHCWEYEkXRO33WHyilUPGUpKjJ2xVuWpBVDWlRkkxywiB4o6Cvz2YfmQ6klBTJFCcNURgiTYxU2ktEEUJIdOzQxqJih4kdSsp3Zi9rP6GWirbdUa9vqfcn2rszy8svuvtHqs2B+eEbi/szy4fv1G1Hf+YjXG+otSYMxuTdlmb/SN4sqW6OlMs9Rbcju679lFJZpFSeIhj3+CFBEPrqFT5poLTyaPEkIy0zXJkxbUuS3CFtgHEC4xQ2lWgnsZnGpMrXF/X7QkZE4hlZCIGOIyYzTT43ZJUiKxVZZUgrS1Zb3LV+rUlumC4crrToRL2aSiN6ZEUQRtzXhr+nip93Bb+PBX+OBZdDQ96tmcwaqps7quWaOE3xVEr4Owv+R++Re8MoEuTOcbqcOP04s9jsKNuOax+jkrSYkbcbf7/5fIW1sY/PpznUShEnFmsVUghGwxHD4ZDRaMT46upJoyHjq5FX+GoWvovPoH+5fsrH84bLZcf2Zk5TF1jT9yVKPSkS4ms/pX+Q1CXcrjs22479w579ccf2sGW9W7FoSxZd47P3mcnbHBqNS1KcchibYLMCk05J8hk2nWKtJUliH62vGP4DF253f3L9M/QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nextTick\"\n        title=\"nextTick\"\n        src=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png\"\n        srcset=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/63868/nextTick.png 250w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/0b533/nextTick.png 500w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png 1000w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png 1150w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>setTimeout(function(){\n  console.log(1);\n});\nnew Promise(function(resolve){\n  console.log(2)\n  for( var i=100000 ; i>0 ; i-- ){\n      i==1 &#x26;&#x26; resolve()\n  }\n  console.log(3)\n}).then(function(){\n  console.log(4)\n});  \n\nconsole.log(5);\nprocess.nextTick(() => { console.log('nextTick'); })\n输出的顺序依次是 2 3 5 nextTick 4 1 \n</code></pre>\n</li>\n<li>\n<p>requestIdleCallback\nwindow.requestIdleCallback(callback[, options])</p>\n<ol>\n<li>callback是一个在事件循环空闲时即将被调用的函数的引用，接收一个IdleDeadline参数，通过该参数可以获取当前空闲时间(timeRemaining())以及回调是否在超时时间前已执行的状态(didTimeout)</li>\n<li>options 可选参数 可以配置timeout  表示超时毫秒数未调用回调函数，回调函数将在下一次空闲期间被强制执行。</li>\n</ol>\n</li>\n</ul>\n<p>在具体的实现中只会有一个microTasks队列,简单的理解事件循:</p>\n<ol>\n<li>浏览器或者node会按照顺序执行自己环境的多个macrotasks队列</li>\n<li>每执行完一个macrotask队列就会拿出micortasks队列的任务全部执行，然后继续执行下一个macrotask队列</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1CLID/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRR5Ef/aAAwDAQACAAMAAAAQ48//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAAAATFBEVEhcfD/2gAIAQEAAT8Qy3TXN2M1O2ZJuxz7aIH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runTask\"\n        title=\"runTask\"\n        src=\"/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg\"\n        srcset=\"/blog/static/9a253bb0db2af3498f93ce723c928568/0479a/runTask.jpg 250w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/41099/runTask.jpg 500w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg 1000w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg 1098w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in browser</h2>\n<p>其实通过对上面相关的知识的介绍,已经可以大致的了解浏览器中事件循环的任务队列 主要有以下几种macrotasks队列</p>\n<ol>\n<li>事件callback</li>\n<li>I/O(xhr)</li>\n<li>timers</li>\n<li>UI渲染</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in node</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAACzklEQVRIx5WVC0/qQBCF/f//RQMKUfAJCpIoAYxBBBGjEfABgkApbWFuviHbFCwpt8lkutvu2TMzZ2d3ZO1ZLBbqHceRwWAg39/fav1+X/3Pz498fX2ptyxL7NlM/505jsznc9kBYN14AMtmsxKLxdQODw/l4OBAfTKZlKOjI3l5eZHp1JbZbKbg0+l0CRjG0LZt+fz89BliMMN4//j4kNFo5K+DnQUgA8/zlLbruiugwYdv/LMpRa7rLQH56f39XVqtlry9vfm7MgcLE/7d3Z1cX18rw263K8/PzysbQ0oBf39/5fb2Vs7Pz6VQKMjr66tY1lR6vZ70en2ZTCZSq9UknU5r/vgX0E6nqyB/AAnl/v5erq6u5ObmRobD4Z+wmON7JpNR5ibHoYBGIhQANptyOB6P/RQsx5NwwE1VZhPySehojjySnuAYmYQyDNMhi4rFomru5ORE9vf3VXtYIpGQXC6nRQwFXAflQaxGc0Ed4mFJikjDRsD1cBuNhhYL//j4KA8PD9JsNrXiSIi5arXqy4zibgTkGCEhQj07O1N/enoqx8fH+h70aDISkI+Eg1F5NsB4pxDG+E5qVk5KGCALn56eVMQwoQCpVEouLy+VMYXh1BA2+YxkyO4AYuTM5NB4rF6v65i2FglIxdAZlUQ+sGBh0PONE2QaRmTI+Xze73tokJ5o+iHjvb09LRTAWxUFJrCEISckaMxjMKVYkYAc/E6no5Jot9tSKpWkUqlozsrlsrYuzjXfttIhIQOAAUB1MaqNUX3EzdE0DSOyKGiMpOON7sy9wYbMw24rHbKQ8Eg6zLis0OHFxYU2YpotY1j+tw7RmznPeIw5o0OKtlWVCcd0F3P7UXkKZW4/UrJVyOSHxKNDY/F4XEPd3d3VdzTJlWCagxPF0HTooPZgSUFgjzFnGIb2w033iXlY4HlzcT1PAXh3HFdBl0qw5R8VVUHLG1SyuAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node\"\n        title=\"node\"\n        src=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n        srcset=\"/blog/static/624c9768d8888b109a4649298c0cb091/63868/node.png 250w,\n/blog/static/624c9768d8888b109a4649298c0cb091/0b533/node.png 500w,\n/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>注意点</h2>\n<ol>\n<li>在浏览器或者node中某些代码的执行会导致event loop失效(停留在处理一个事件队列导致无法进入其他的事件队列的处理).比如浏览器中javascript的长时间执行会导致UI无法交互,node中process.nextTick的递归调用</li>\n</ol>\n<h2>相关资料</h2>\n<p><a href=\"https://tuobaye.com/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/\">通过microtasks和macrotasks看JavaScript异步任务执行顺序</a><br>\n<a href=\"http://docs.libuv.org/en/v1.x/design.html\">libuv Design overview</a>\n<a href=\"https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f\">How JavaScript works in browser and node?</a>\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&#x26;utm_medium=email\">Tasks, microtasks, queues and schedules</a><br>\n<a href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\">Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018</a>\n<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;t=55s\">菲利普·罗伯茨：到底什么是Event Loop呢？ | 欧洲 JSConf 2014</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null}}},{"node":{"id":"d9a2727c-f773-51a0-ae91-74deed50be73","html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.下面从几个方面来拆分这个小例子来重新学习下XMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,顺序对应着请求的方法、地址、是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中增加query的方法进行数据的发送并且在调用send方法时必须send(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, 注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error 请求发生错误的时候的监听函数</li>\n<li>loadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>xhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载并且可以通过download进行文件名的设置.这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件名,这个时候可以通过设置responseType为blob,生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的时数据上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么上传阶段完成是mock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的切分上传阶段和数据接收阶段的比例来完成对用户接受更合理的进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>作为一个web前端开发者离不开XMLHttpRequest的使用,以上通过对xhr基础的介绍和自己在项目中遇到的问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":13,"pageCount":15,"additionalContext":{"pageAllCount":86}}},"staticQueryHashes":[]}