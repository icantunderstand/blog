{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2022-3-7",
    "result": {"data":{"markdownRemark":{"html":"<h2><a href=\"https://monorepo.tools/\">Understanding Monorepos</a></h2>\n<p>这篇文章通过对Monorepo/Polyrepo(多仓库模式)、实现Monorepo的工具进行对比，对使用Monorepo模式进行开发有参考价值。</p>\n<ol>\n<li>Monorepo是什么: Monorepo在主体仓库中组合了多个子仓库并且这些子仓库的功能是相关联的,对应的例子可以参考<a href=\"https://github.com/facebook/react\">react</a>项目的仓库</li>\n<li>为什么使用Monorepo: Monorepo在组织关联业务代码上有优势，能减少代码复用、技术统一、开发调试中的问题</li>\n</ol>\n<p>关于Monorepos和Polyrepo的思考可以参考这篇文章<a href=\"https://earthly.dev/blog/monorepo-vs-polyrepo/\">Monorepo vs Polyrepo</a></p>\n<h2><a href=\"https://www.modularmanagement.com/blog/what-is-a-good-modular-system\">What is a Good Modular System?</a></h2>\n<p>这篇文章介绍了系统设计的思考点</p>\n<ul>\n<li>模块的功能界定  通过引入模块系统可以降低系统的复杂性，提高系统的灵活性,但是对于引入的模块功能的界定划分需要考量。如果功能没有界限好会导致功能代码从一个位置移动到另一个位置增加了模块维护的复杂度。比如之前的中台概念，需要划分好中台的功能才能更好的实现中台的能力，拆分出模块系统一方面做得更多去帮助系统更好，一方面也要思考如果做得更少去实现最初的目标</li>\n<li>生命周期 功能的稳定和灵活性能提高模块的生命周期</li>\n<li>模块收益的衡量标准</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/229fda9f40ca0f98ddc71334373fb9b4/37048/modular-value.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABBklEQVQY00WQS0sDMRSF+/9/irhTF9KVKAiCm2IXtQVtaes88jDJNJNMZuaTyVA8cO6Bm9wv4S76YWBk1jDCmD1mT2d9P9CnRDKaznu61NN1HbFLpBhJU69xxLbNjIVzDefTiZ/jES0EdVUhhMi21hK6hNcK9/TI4WPF4XzmsN/zud1hNmvc8xL9cEu9Xs1AHyLydKRY3qHub1BvLxjXYI2hbVtCCHjv8THSxpgf3H59Y3Yb7Psrl8bhrEHUYgaGEJl+ebEWVRTIskTrX5TSSKWQUv2nVAgpKasaWdeIosiz1jmMtTNwKtO+JhnrqIVAZYDMebXWGiVl7ldlOd9RmqHvJwJX/QEnGnxAG52VgwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"模块收益衡量标准\"\n        title=\"模块收益衡量标准\"\n        src=\"/static/229fda9f40ca0f98ddc71334373fb9b4/00d43/modular-value.png\"\n        srcset=\"/static/229fda9f40ca0f98ddc71334373fb9b4/63868/modular-value.png 250w,\n/static/229fda9f40ca0f98ddc71334373fb9b4/0b533/modular-value.png 500w,\n/static/229fda9f40ca0f98ddc71334373fb9b4/00d43/modular-value.png 1000w,\n/static/229fda9f40ca0f98ddc71334373fb9b4/37048/modular-value.png 1352w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>通过模块衡量的公式，在进行模块系统设计的时候可以有以下的考虑:</p>\n<ol>\n<li>平台的功能边界考量\n<ol>\n<li>不是越少越好，前期的投入能力后期带来收益</li>\n<li>前期的忽视需要后续弥补，要仔细思考</li>\n<li>用小范围的能力边界限制实现整体的灵活扩展</li>\n</ol>\n</li>\n<li>整体和部分的考量\n<ol>\n<li>不用一步到位，部分功能提升到独立的系统也能产生比较大的价值，后期再进行统一</li>\n<li>在资源可能的情况下，相关的依赖系统要统一升级</li>\n</ol>\n</li>\n<li>从长期的视角去看系统的模块设计 从现在的能力出发结合系统未来的发展诉求去做系统设计(能力建设)，这个角度的考虑也是在为未来打地基</li>\n</ol>\n<p>对于模块系统的介绍可以参考这篇文章<a href=\"https://www.modularmanagement.com/blog/all-you-need-to-know-about-modularization\">All You Need to Know About Modularization</a>,模块的实现应该在部分能力抽象的情况下实现系统整体的灵活性</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d7d6648389feb5a893a977469c14fc77/f3abf/modular-define.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7ElEQVQ4y4VTTZOUMBCd/3/3H3jz7MmDVnnZ0ot60XI+dhYyQEISkgwJ4SM8K9mFkdHSrkoBTef169fdOwBQ5grnOvh+gPMene/T0/c9QghYbMb/bRfmGZRLKG1Q1AIXxkFonQ6XCvMMtE0N3+p0YRgGaK3Rtu0m2Qq4vEzThN571IyhKguopkn+EAHJT3z48g0fMw6nFYqiBGMMnPOUYAN4tQ5S6fRjGPqUeZ5nEJIn3xhmOJrhzaevePXwA4ZTkEuBqqogpcQ4jltAJhs8XcrEMJpzNgXF4PDiU+SAnGSwAZjGIbEryxLOuT9LLhhHXrHELMuyFdj7Hq1zsJ2HEAJXHat4ZhMruC91BSxrgbyksNbidDomwSNoPLzRuNAaTCqUXIKK5xIj4HrChBCmG2BjrmDipkV/NyqpMSFgmsYUExNFOQghyPMcVKiV9abLqQEvFxaQxXdvSqkEdjoecfr8DujkOqm7ZbCjhgtAZLkAqWsLKhrUjULUO35HdllO8Lj/Dvb+NejDW5iuvzE0rU2di6Cxcz5uifcJWBuDquZJFloLiEbhfD6jqkpQxmBah+NhD2XMtmSpDcbpJm7U5JEUOGQE50uZJmH/lKOqxab8yFxbt67m7l97GXfaWJf22roOcQmGv2j6+9j8AlVn7ZLxM/+tAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"模块化系统的定义\"\n        title=\"模块化系统的定义\"\n        src=\"/static/d7d6648389feb5a893a977469c14fc77/00d43/modular-define.png\"\n        srcset=\"/static/d7d6648389feb5a893a977469c14fc77/63868/modular-define.png 250w,\n/static/d7d6648389feb5a893a977469c14fc77/0b533/modular-define.png 500w,\n/static/d7d6648389feb5a893a977469c14fc77/00d43/modular-define.png 1000w,\n/static/d7d6648389feb5a893a977469c14fc77/f3abf/modular-define.png 1474w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n模块化系统能带来效率、灵活度、敏捷的特点。</p>\n<ol>\n<li>效率 模块的复用/功能的组装  这里可以通过比喻装配式建筑来理解,通过对预制模块在工地快速的组装就快速完成了建筑的装配。</li>\n<li>灵活性 基础模块能快速的组装出新的功能模块/通过统一的接口设计能快速的实现模块的功能替换</li>\n<li>敏捷性 由于基础模块的拆分，通过基础模块的改变就可以快速地影响整个系统</li>\n</ol>\n<h2><a href=\"https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd\">Deep dive into React Native’s New Architecture</a></h2>\n<p>这篇文章通过React Native前后架构的对比对新旧架构进行了介绍</p>\n<h2><a href=\"https://kentcdodds.com/blog/javascript-to-know-for-react\">JavaScript to Know for React</a></h2>\n<p>这篇文章介绍了React中JavaScript的一些常用的语法，比如模板字符串、可选链、空值合并预算符等</p>\n<h2><a href=\"https://blog.bitsrc.io/some-reasons-for-disliking-react-hooks-80f1e18eb9b3\">Some reasons for disliking React hooks</a></h2>\n<p>这篇文章作者介绍了使用react hooks的优缺点</p>\n<ul>\n<li>优点 hooks可以更好实现代码的复用组合/逻辑集中</li>\n<li>缺点 hooks的写法上有上手成本和调试成本，容易引发一些bug，还有不要过于过度使用hooks.hooks的调用方式是通过数组的方式调用函数，过多或者依赖关系复杂的hooks会降低页面的性能</li>\n</ul>\n<h2><a href=\"https://blog.bitsrc.io/inversion-of-control-with-react-584533e49245\">Build Decoupled React Components with Inversion of Control</a></h2>\n<p>这篇通过例子的方式介绍通过反转控制的方式解耦组件的实现来应对未来逻辑的变更</p>","frontmatter":{"date":"2022-03-07","path":"/2022-3-7","title":"2022-3-1-前端快报"}}},"pageContext":{"readingTime":"6 min read"}},
    "staticQueryHashes": []}