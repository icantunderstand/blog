{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/react-hoc",
    "result": {"data":{"markdownRemark":{"html":"<h2>简介</h2>\n<p>最近在做业务中,需求的场景是需要在原有的组件上添加点击事件并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.高阶组件能最好化的复用代码.实现高阶组件有如下几种方式:</p>\n<ol>\n<li>属性代理(操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\r\nclass WrappedComponent extends Component {\r\n  componentDidMount() {\r\n    console.log('Wrapped');// wrappedComponent先Didmount(子组件先DidMount)\r\n  }\r\n  render() {\r\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\r\n  }\r\n}\r\nconst HOC = (Wrapped) => {\r\n  return class extends Component {\r\n    constructor(...args) {\r\n      super(...args)\r\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\r\n    }\r\n    componentDidMount() {\r\n      console.log(\"HOC\");\r\n    }\r\n    render() {\r\n      return (&#x3C;div\r\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\r\n          console.log(this.state.count);\r\n        }) }}\r\n      >\r\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\r\n      &#x3C;/div>)\r\n    }\r\n  }\r\n}\r\nconst HOCComponent = HOC(WrappedComponent);\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      &#x3C;div\r\n      >\r\n      &#x3C;HOCComponent/>\r\n      &#x3C;/div>\r\n    );\r\n  }\r\n}\r\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\r\nclass WrappedComponent extends Component {\r\n  constructor(...args) {\r\n    super(...agrs);\r\n    this.state = { name: 1 };\r\n  }\r\n  componentDidMount() {\r\n    console.log('Wrapped');\r\n  }\r\n  render() {\r\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\r\n  }\r\n}\r\nconst HOC = (Wrapped) => {\r\n  return class extends Wrapped {\r\n    static displayName = 'HOC' //定义高阶组件的名字\r\n    componentDidMount() {\r\n      console.log(\"HOC\");\r\n      console.log(this.state) // { name: 1 }\r\n      super.componentDidMount();// 通过super调用(如果没有调用,不会执行Wrapped的DidMount)\r\n    }\r\n    render() {\r\n      return super.render() //在这个可以实现渲染劫持,例如常规的loading态加载\r\n    }\r\n  }\r\n}\r\nconst HOCComponent = HOC(WrappedComponent);\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      &#x3C;div\r\n      >\r\n      &#x3C;HOCComponent/>\r\n      &#x3C;/div>\r\n    );\r\n  }\r\n}\r\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的时候通过在定义一个render函数来决定组件的具体内容.(children API)</p>\n<pre><code>import React, { Component } from 'react';\r\nclass Cat extends React.Component {\r\n  render() {\r\n    const mouse = this.props.mouse;\r\n    return (\r\n      &#x3C;div>\r\n        {mouse.x}\r\n        {mouse.y}\r\n      &#x3C;/div>\r\n    );\r\n  }\r\n}\r\nclass Mouse extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.handleMouseMove = this.handleMouseMove.bind(this);\r\n    this.state = { x: 0, y: 0 };\r\n  }\r\n  handleMouseMove(event) {\r\n    this.setState({\r\n      x: event.clientX,\r\n      y: event.clientY\r\n    });\r\n  }\r\n  render() {\r\n    return (\r\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\r\n      {this.props.render(this.state)}\r\n      &#x3C;/div>\r\n    );\r\n  }\r\n}\r\nclass MouseTracker extends React.Component {\r\n  render() {\r\n    return (\r\n      &#x3C;div>\r\n          &#x3C;Mouse render={(mouse) => (\r\n            &#x3C;Cat mouse={mouse} />\r\n          )}//  这里每次都会生成一个新的方法,可以定义一个实例的方法\r\n          />\r\n      &#x3C;/div>\r\n    );\r\n  }\r\n}\r\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的可以复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","frontmatter":{"date":"2018-12-11","path":"/react-hoc","title":"React高阶组件"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}