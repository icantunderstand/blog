{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/xhr",
    "result": {"data":{"markdownRemark":{"html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收\b事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.\b下面从几个方面来拆分这个小例子来重新学习下\bXMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 \b启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受\b收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息\b,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合\b来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,\b\b顺序对应着请求的方法、地址、\b是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中\b增加query的方法进行数据的发送并且在调用send方法时必须\bsend(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, \b\b注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open\b之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error \b请求发生错误的时候的监听函数</li>\n<li>\bloadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>\bxhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载\b并且可以\b通过download\b进行文件名的设置.\b这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件\b名,这个时候可以通过设置\bresponseType为blob,\b生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的\b时数据\b上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress\b这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload\b.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么\b\b\b上传阶段完成是\bmock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的\b切分\b上传阶段和\b数据接收阶段的比例来完成\b对用户接受更合理的\b进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>\b作为一个web前端开发者\b离不开\bXMLHttpRequest的使用,以上通过\b对xhr基础的介绍和自己在项目中遇到的\b问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","frontmatter":{"date":"2018-08-12","path":"/xhr","title":"XMLHttpRequest之查缺补漏"}}},"pageContext":{"readingTime":"8 min read"}},
    "staticQueryHashes": []}