{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2023-1-1",
    "result": {"data":{"markdownRemark":{"html":"<h2><a href=\"https://github.com/reactwg/react-18/discussions/37\">New Suspense SSR Architecture in React 18</a></h2>\n<p>这篇文章介绍react 18中流式渲染和Suspense的结合，实现更好的服务端渲染功能。相关文章还有<a href=\"https://juejin.cn/post/7064759195710521381\">浅析React 18 Streaming SSR</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍2022年热度比较高的React库</p>\n<h2><a href=\"https://developer.aliyun.com/article/781882\">一文详解 CSS-in-JS</a></h2>\n<p>这篇文章从CSS规范、CSS的设计模式说起，逐步覆盖到CSS-in-JS的细节，涉及的相关背景比较多，值得仔细阅读。</p>\n<h2><a href=\"https://weizman.github.io/page-what-is-a-realm-in-js/#identity-discontinuity\">What is a realm in JavaScript?</a></h2>\n<p>这篇文章介绍JavaScript中Realm的定义。也可以结合这篇<a href=\"https://2ality.com/2022/04/shadow-realms.html\">ShadowRealms – an ECMAScript proposal for a better eval()</a>介绍ShadowRealms API提议的文章一起了解。</p>\n<h2><a href=\"https://roadmap.sh/roadmaps/\">Developer Roadmaps</a></h2>\n<p>Developer Roadmaps收集了各个开发方向的技能路线图</p>\n<h2><a href=\"https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo\">How we configured pnpm and Turborepo for our monorepo</a></h2>\n<p>一篇比较详细的介绍monorepo技术方案选择工具的文章，从多项目开发的问题开始说起，逐步介绍<a href=\"https://github.com/pnpm/pnpm\">pnpm</a>(monorepo管理工具)和<a href=\"https://github.com/vercel/turbo\">Turborepo</a>(打包构建工具)</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart\">js-code-to-svg-flowchart</a></h3>\n<p>一个将JavaScript代码转化成svg图片的库。</p>\n<h3><a href=\"https://console-ninja.com/\">CONSOLE NINJA</a></h3>\n<p>一款VSCode插件，可以直接在代码中查看输入的console调试信息</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/shuding/react-wrap-balancer\">react-wrap-balancer</a></h3>\n<p>react-wrap-balancer能使文案比较智能的适应容器，占据容器的空间，达到比较好的展示效果，下面从源码上看它是如何实现的:\r\n<img src=\"/blog/9336733f998bb911bd52006bac3dd61b/blancer.gif\" alt=\"react-wrap-balancer\">\r\n通过简单的demo使用可以发现balancer在页面中注入了一段脚本并且为包裹的文本内容绑定的属性标识\r\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.399999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsElEQVQI1y2JQW6DMBQFuf/NWlGEDbaA2NDSUAL4QxopQFdTgbIYvRm9yMQFnS9xtsGVEzL/McsDmSYk3BFZmWUhjHf6YaUfnoRl5zaudP2TYVoZw3b24VESW8qiJlMarSw68+SmQClFqnIqf8UYi1KG96QkzRu0rflIKxLt0KYhzRxvsaXyHVGuf7h4wX0uVC5Qfy34/hd/e9DKxrdstLK/fKVb9nMPrvN2cnj7+v4B3u7bRFMr7ugAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"balancer-show\"\n        title=\"balancer-show\"\n        src=\"/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png\"\n        srcset=\"/blog/static/209d5af74aebd83c377943dd2258a96b/63868/blancerShow.png 250w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/0b533/blancerShow.png 500w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png 1000w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png 1088w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>    // react-wrap-balancer的主体代码逻辑\r\n    const Balancer: React.FC&#x3C;BalancerProps> = ({\r\n        as: Wrapper = 'span',\r\n        ratio = 1,\r\n        children,\r\n        ...props\r\n    }) => {\r\n        // 利用useId为组件生成唯一标识，useId可以根据组件的层级结构生成唯一标识\r\n        const id = React.useId()\r\n        const wrapperRef = React.useRef&#x3C;WrapperElement>()\r\n        const hasProvider = React.useContext(BalancerContext)\r\n\r\n        // 监听函数执行\r\n        // useIsomorphicLayoutEffect这里对服务端和客户端做了区分 在服务端调用useEffect,在客户端调用useLayoutEffect 解决客户端的闪动问题\r\n        useIsomorphicLayoutEffect(() => {\r\n            if (wrapperRef.current) {\r\n            // 调用绑定self上绑定的动态调整函数 并传入当前的入参执行\r\n            // self可以指代全局的window https://developer.mozilla.org/en-US/docs/Web/API/Window/self\r\n            // 主要计算逻辑都在relayout函数中\r\n            ;(self[SYMBOL_KEY] = relayout)(0, ratio, wrapperRef.current)\r\n            }\r\n        }, [children, ratio])\r\n\r\n        // 自己卸载的时候 终止监听函数\r\n        useIsomorphicLayoutEffect(() => {\r\n            return () => {\r\n                if (!wrapperRef.current) return\r\n\r\n                const resizeObserver = wrapperRef.current[SYMBOL_OBSERVER_KEY]\r\n                if (!resizeObserver) return\r\n\r\n                resizeObserver.disconnect()\r\n                delete wrapperRef.current[SYMBOL_OBSERVER_KEY]\r\n            }\r\n        }, [])\r\n\r\n        return (\r\n            &#x3C;>\r\n                &#x3C;Wrapper\r\n                    {...props}\r\n                    // 绑定的唯一标识\r\n                    data-br={id}\r\n                    data-brr={ratio}\r\n                    ref={wrapperRef}\r\n                    style={{\r\n                    display: 'inline-block',\r\n                    verticalAlign: 'top',\r\n                    textDecoration: 'inherit',\r\n                    }}\r\n                    suppressHydrationWarning\r\n                >\r\n                    {children}\r\n                &#x3C;/Wrapper>\r\n                {createScriptElement(hasProvider, `self.${SYMBOL_KEY}(\"${id}\",${ratio})`)}\r\n            &#x3C;/>\r\n        )\r\n    }\n</code></pre>\n<p>通过上面的源码分析，主要的动态计算逻辑都在relayout函数中</p>\n<pre><code>    const relayout: RelayoutFn = (id, ratio, wrapper) => {\r\n        // 根据id获取包裹的wrapper组件\r\n        wrapper =\r\n            wrapper || document.querySelector&#x3C;WrapperElement>(`[data-br=\"${id}\"]`)\r\n        // wrapper的父容器\r\n        const container = wrapper.parentElement\r\n        // 更新wrapper的最大宽度\r\n        const update = (width: number) => (wrapper.style.maxWidth = width + 'px')\r\n\r\n        // 重置wrapper的最大宽度\r\n        wrapper.style.maxWidth = ''\r\n\r\n        // 获取wrapper的父容器的宽高\r\n        const width = container.clientWidth\r\n        const height = container.clientHeight\r\n\r\n        // 二分查找的方式计算wrapper的宽度\r\n        let left: number = width / 2\r\n        let right: number = width\r\n        let middle: number\r\n\r\n        if (width) {\r\n            while (left + 1 &#x3C; right) {\r\n                middle = ~~((left + right) / 2)\r\n                update(middle)\r\n                if (container.clientHeight === height) {\r\n                    // 缩放后 高度没有变 那么right= middle\r\n                    right = middle\r\n                } else {\r\n                    // 否则right = middle\r\n                    left = middle\r\n                }\r\n            }\r\n\r\n            // 更新wrapper的宽度\r\n            update(right * ratio + width * (1 - ratio))\r\n        }\r\n\r\n        // 通过ResizeObserver去监听wrapper父容器的变化 执行relayout函数\r\n        if (!wrapper['__wrap_o']) {\r\n            ;(wrapper['__wrap_o'] = new ResizeObserver(() => {\r\n            self.__wrap_b(0, +wrapper.dataset.brr, wrapper)\r\n            })).observe(container)\r\n        }\r\n    }\n</code></pre>","frontmatter":{"date":"2023-01-04","path":"/2023-1-1","title":"2023-1-1-前端快报"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}