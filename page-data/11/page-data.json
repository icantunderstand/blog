{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/11",
    "result": {"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"1afb6c25-089f-57eb-9a85-e631e71ad1cd","html":"<p>javascript的执行是单线程的,React老的架构是利用栈(递归)来完成组件的更新渲染,这样当组件层级较深更新任务较多的时候,js线程会阻塞UI线程导致表现上页面卡顿的现象.React新的架构Fiber中将更新任务进行了<a href=\"https://github.com/facebook/react/blob/f227e7f26b81cb1eba0c837ab2acd7fa7f91404f/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1472\">细粒度的划分</a>并且实现了新的任务调度系统.这样保证了React页面更新的流畅和响应的速度.本文主要从调度React更新任务的Scheduler包入手从宏观的角度了解React中的任务调度机制.</p>\n<h2>前置知识</h2>\n<h3>事件循环</h3>\n<p>javascript中的事件循环可以参考<a href=\"https://icantunderstand.github.io/blog/event-loop\">事件循环</a></p>\n<h3>isInputPenging</h3>\n<p>isInputPending是Facebook实现的一个浏览器的新的api标准,现在只在最新的chrome版本上有对应的实现.通过调用navigator.scheduling.isInputPending方法来获取当前是否有高优先级的用户输入需要处理,从而实现打断js执行响应用户输入的目的.</p>\n<h2>任务调度的演进过程</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 943px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQFB/9oACAEBAAE/Id4qv//aAAwDAQACAAMAAAAQc8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAADAQEAAAAAAAAAAAAAAAAAASERYf/aAAgBAQABPxB24lpLzGLhn//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"长时间执行任务\"\n        title=\"长时间执行任务\"\n        src=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg\"\n        srcset=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/0479a/scheduler_long_task.jpg 250w,\n/blog/static/08a926bcf0d7610b88cd024eff38d4ba/41099/scheduler_long_task.jpg 500w,\n/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg 943w\"\n        sizes=\"(max-width: 943px) 100vw, 943px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n当js线程执行一个比较长时间的js任务的时候,会导致UI线程无法快速的响应用户的输入,造成体验卡顿等问题.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/71f0d49fe6d23486141918239a4604af/faa66/scheduler_split_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3AUH/8QAFhAAAwAAAAAAAAAAAAAAAAAAABAR/9oACAEBAAEFAir/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQEAAT8huqV//9oADAMBAAIAAwAAABBwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAgMAAAAAAAAAAAAAAAEAESExQVGR/9oACAEBAAE/EAlxd53DoPYN4J//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务分片\"\n        title=\"任务分片\"\n        src=\"/blog/static/71f0d49fe6d23486141918239a4604af/a2510/scheduler_split_task.jpg\"\n        srcset=\"/blog/static/71f0d49fe6d23486141918239a4604af/0479a/scheduler_split_task.jpg 250w,\n/blog/static/71f0d49fe6d23486141918239a4604af/41099/scheduler_split_task.jpg 500w,\n/blog/static/71f0d49fe6d23486141918239a4604af/a2510/scheduler_split_task.jpg 1000w,\n/blog/static/71f0d49fe6d23486141918239a4604af/faa66/scheduler_split_task.jpg 1056w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n将长时间执行的任务划分成多个短时间执行的任务,能有效的降低js执行线程卡死的状态,这样就引入另一个问题就是如何划分任务切片才能产生更好的UI体验.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe4g0o//xAAYEAACAwAAAAAAAAAAAAAAAAAAAQIQIf/aAAgBAQABBQK5CeH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAEBAQACAwAAAAAAAAAAAAABABEhMUFhgf/aAAgBAQABPyHfTfGHfDJ6LLDscl//2gAMAwEAAgADAAAAEIMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBUXH/2gAIAQEAAT8QU31Z1sLKHX5kQcH2UGzTklACfYqEvfZ//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务调度\"\n        title=\"任务调度\"\n        src=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg\"\n        srcset=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/0479a/scheduler_continuous_task.jpg 250w,\n/blog/static/150e0b4d08aa0861f4343a41e1c4da61/41099/scheduler_continuous_task.jpg 500w,\n/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n基于以上两种模式的思路,js如果能在执行过程中主动的获取用户的输入(执行的deadline),主动的暂停当前js的执行并通过事件循环在下一次的事件循环中再次唤起js任务的执行，这样就能充分的利用起所有的执行时间来执行任务并且保证用户输入(高优先级任务)的响应，以上就是Scheduler在调度任务执行的实现方式，下面从源码的角度来看下Scheduler是如何实现任务调度的.</p>\n<h2>Scheduler的实现思路</h2>\n<p>以下源码分析基于React master分支的<a href=\"https://github.com/facebook/react/blob/master/packages/src/forks/SchedulerDOM.js\">最新代码</a></p>\n<p>在React进行渲染任务调度的时候,是通过调用Scheduler暴露出来的unstable_scheduleCallback将任务函数作为callback传入等待Scheduler调度执行.<a href=\"https://github.com/facebook/react/blob/00d4f95c2ad000f40ea0c774cc1ced3a0ceb6f23/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js#L131\">源码位置</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/84f4d/scheduler_call.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQY022QW0vDQBSE8/9/jPiqeMEnpX0QrGCtF6zdjZu0qdlks0n39kmKikgHhuEc5gyHyWLdELuOoEe1GO3RW0dbe5rtgPeBESmlX/7Mh5B1WvMhc6pyTVUoSrXGbkqGYsXwWRGaithWxBR/j/6G/2dWa83j8wvVWuHkAzv5gFcLvJgRqndi3+BNi7c9ZhfxYQw+/N24z0xr6bsBFyBG8CHt7WGcXdqr6yOuC3Q9DEMiffu8j4SQcD7iXGBsIYs6x6k3xP0ly5sjxPSY4u6UfHpGPjmhmF2jhEStBKUUfI61SEEun5BigVwtKNUr9XZFcFsyZ9dEW2HFLXp+jn2+Qs8vaBaXNPMzmuWEzhTYrsC0it2w2as1Jb3dYJqC6GvAQNR8AbVpy5r5USwPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler调用\"\n        title=\"Scheduler调用\"\n        src=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/00d43/scheduler_call.png\"\n        srcset=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/63868/scheduler_call.png 250w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/0b533/scheduler_call.png 500w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/00d43/scheduler_call.png 1000w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/84f4d/scheduler_call.png 1208w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在使用Concurrent Mode的时候此处传入的callback是performConcurrentWorkOnRoot函数，这个函数是React内部调度更新的起始函数.</p>\n<p>以下是Scheduler_scheduleCallback的代码逻辑\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/67a79/schedule_callback.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 112.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIklEQVQ4y42V6W7cOBCE/RrJSBRJiaduaaSxxxd8rBf7/g/0LUQldgLbcX4UmoDIQnd1detC6BLlA815ZXw806wz7XnCtoH+YSXOA7qy+GFGV4Y8zxBCfIoLISXKOFw/Uq+X1OOIa2qklAhxIM8OZFlG9v0bebaT5Xn+OWEhBJUPDHfPjPcvhGnF1i1lWZHn7x/8iWwnLAoq64nLFe3lbSLbMsmy7DeSv8VFUWwZRrrrB/qbR9r1jIsxlSrEn7P5MENZCJquw3cTflywIWKso1AapaukZZ7lCSIXr/HzkpXGVQYTA7ZtqILH1AE/DYRpxDiLMpIy6D16jSzlh/omwlwqSmsY725pr8501zd012fqZaK/vaVZFqpQoZ1AlgJlJUIKssNhR3Z4bVQuci62gzWG4zwwrgvd1T3Nck3sJ+JwRBtPZSxV6Ci3c1kSg8PEBtP0SSKt9U6a/+hyUUhi9IynkfZ8ot+yPR3prhfCcaadGvzUYZtAPXiayeOGmjD3+KHBxBLtVJIlEW7CK6kwbSRMHWHsCFNPOI6EsU0PXg2eZRxSfF/yqw83OGs4nyamOdL3nmmuca4iFwcK9bVdfvHhTmitZ1xu8f0R9wN+XKlcQJqYbLTN8dbdjwz9k3QvuZDoSqOcQjuNNpoqlCluF7c7YsMXGf5WctM51nPP8dQyLw3Hq555aRnHmmmqccHj+gnfT5TWYdutIcfkBlkUb4SiENjKEkxMM3z49n0XfouHjDxlUHw502/rK8/xMXLz9MJ498Rw/0J3dUd3umG6e04ZxWnXcn9Y/FKmeKfphRIFqpS4psQPIS1WU1eY1uM6iyxzhMrQvkjnQmUJyhRor9BW7dGrNJpJQ6UUvvHEdcTPA2GZqC+PxHWmPk3UU5O+2bbDdWNaxpWpkGprlkgo5B73LouC/rhyevqX5eGZ9fGF0/N/LA//MJ4u6Y6XlNanzV66QOljSuIjXfcuS4l1JdFrvFUEv81rhbeaprG7wX+djsPhXTPe9qEQBBuwpUP7mtLX6WKW5WQ/Y5Z/6b9XQiUlRlcJpQ9pexefmPir/8lG+D+6pI2XBDmakQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler调用callback\"\n        title=\"Scheduler调用callback\"\n        src=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/00d43/schedule_callback.png\"\n        srcset=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/63868/schedule_callback.png 250w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/0b533/schedule_callback.png 500w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/00d43/schedule_callback.png 1000w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/67a79/schedule_callback.png 1408w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在unstable_scheduleCallback中主要做了如下几件事:</p>\n<ol>\n<li>根据传入的执行函数和优先级创建执行任务，加入异步执行队列或者同步执行队列</li>\n<li>调度任务更新</li>\n</ol>\n<p>以下先只关注同步taskQueue的执行流程,requestHostCallback通过Message channel发起宏任务来执行flushWork,最终走入到workLoop整个调度的<a href=\"https://github.com/facebook/react/blob/00d4f95c2ad000f40ea0c774cc1ced3a0ceb6f23/packages/src/forks/SchedulerDOM.js#L200\">实现逻辑</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 733px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 131.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAD9UlEQVRIx42Vy27dNhCGz1sEjSXxTlGi7jo+Olc79zRANl0UfYsWBYp20V374F8hyY6dxEG6+DEUIQ5n5p/5udFGYIKnOjTEqUfnAWUcNpTYvEBKSZokK9KELMsQQnyF+/2NNorpuOP46sR02jJOI/3xTHfzhtiPn37O7u13sFFS0bcT/e6CawaqqiBUNaHp8UW5/HQf3QPSb2IjhcDmOf76jN/dYPsJ2U648YirOvKiIHQjoe3J24G8atdL0vTpCKWShDygrScVklQqshnGIYxHSIXQdoE0FmXMGs23Up6LrpWm3R3pLm/ozi9pTi+J447heKS/HuinHdc3F8ZpjzWGJEm+cnQf8RKhMQYXAjZGfF3jmxrjHc4oiuDIvV2s0Zo0SZ/EvdPN3DZSKnxpCYPFd5py5/CdRVqB0ALp5GqtRFmJ9gqdK5STmKCWvYcI5RphWzTkzpOJFCEzhJydSTK5OhVKIB/ZT2uz2kcOBcYHhI+koUFWA9oHXGwp24EQK6phh/WB5OrqIc00u8O6/owUqy31/pb69gPx9Ip4+57hdENdN2zHLVUV0cYuzT2zPh9Mrp6TJFdLj84XLZctfSglUmuK6xP15S3V5R3V5S3x/Aa7PROmW6rdifb0kub4gvbyiridcLHBlxXW57hY46sWqRQbpQVKKeq2ZNw39IcR148U0558vMb3PXGaqHYTWmvUDGPR1i3npNJoly9lm8ldWVYa1/aUhx3l+UA8TFSnifK4p51adueG7alDVANp0SKKBhl7ZL3FOH9X2+QhZaU0sdsRj69x44nmsKI9X+jPN8S6pfSOGHLKEDA+J1NmnSApybKHMdxoK5BCorTCthWuqzFtjR86TF0g65rMBuQsaXO9vEeK7JGkPTT1EuFcB5EJuqHn8uqW/WXP9jDRnF5Q78/4cb8IR3F6Tdi/QIaK7ItZfiwUGy0lQkmaENkOW8qZkG4kL0qapqRqW0K/pahb7DJ6V3fO0icVZ9FDIeQyp23fUm6PVLsz1nqMlhhrUS5fmJ3FNn0iqs8dKrnQb/06u/MoKTfPbUaaJQ8MflGvbyu2EYt89dtqaY9hKmkOHdXxmri7Rt/pX/adyD45nNO11jD1A1XTkccapRxpki2lWNNM/9d7srA8H/Ah0I4jxfawCGtVx0UgbIgobR4JwiObfr13l7LF5gETI7Yssd5QtYHQtYRhiyvmHpRIo5B6tbOszZ2x7qnFrq+imEkROJMSWkveePLa4aPC1RofEqT6AVem2JCg3dWyNvm6nvfMbIuE7OoZ6fNnbOyPvxE//kX/8z/EX/6l/Olv8o9/4D7+if/wO+bdr+i3v6LffQ7z5ff7Ff8BGwXxHBeZuTwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"workLoop调用\"\n        title=\"workLoop调用\"\n        src=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png\"\n        srcset=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/63868/workloop.png 250w,\n/blog/static/698bc99b2ece9e667db04ba2c3e361f0/0b533/workloop.png 500w,\n/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png 733w\"\n        sizes=\"(max-width: 733px) 100vw, 733px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0f586/yieldTimeout.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACs0lEQVQ4y4WU2W4cNxBF9RlG1NybO3ubGY2txWNY8Ev+/4NO0GxFseEkergokkAfXNYt9l2KEeUiqS2cHzY+P125XM+cdz1slJJxsWLdiBQC8YHuaq1IqQjTRn7+Rry9Mt5+UL488fT9kfOXE+enK/M6oaxCGoXUCm0USu+Sh+yxvvMxEoRg0gNTFMxRMgfBmgRbVX2/BMGSFFuznKthqhZbLb45xl3V4rJFGXUA0yAoKZJOE3GOjEvGLg3tPWOI+FIYU0Jbi5OCogSDlCgl312+XznXShzuyW3DXV4Qp0c+Xb/z6fINOV+IywO+rbiYkcaih4F0PzAI+VtPpZTcpZzx+5XVwDTuV9OsWbMEyZo00yhpZqDZgeYkq1dkr7HZYoPpMl53WHe4p7xvzKgPuaNab7pkd/KmQSCGN0fD7wl3hznnA+gUYzWMVffqksZlg58cLpmj+c3h57GfhWVkrK4H09fNHQ5LKQfQj5TrzHw7Ux4afor4OeFnh02mw8Ps8Hu6k+va0x2LwTeLtuoAxv3KQhBCJc0n/LQyxoIdPS5ErNGYNwltGbRFKIOQGiHVsdf2px6mhJSCGBOnyzPTdu2wWgLzlFmWQq2R1jKyLPzRTtzXE0OaECFzv9eyYIx5eymldvpoHcu0sT5/pTxcia0grUQogTT7S5Boc/S6y2u0U+j93Kq+7qEcT28fUtWbX7ZAOyema2b5XChrJFVPrB47mgPyNgkHUL3X7jCEcIRiDGub2OZGDI6SAyV78l5LIMWA0YZhGI6R+Rf9MjZaKebrC+fXP1luP5hfXpkeb4x1wbbzL7P2X/rpbyMZnUM7h/Wxp2t6ygltLMq6fz76H2B3uI+N1ppWZlIsB8AYlNbHx3pPb3h395HLA6gUPlfydiGtZ+JyIrSluzWxIJX6EPQ38C/i5f+uoA5LswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务过期处理逻辑\"\n        title=\"任务过期处理逻辑\"\n        src=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/00d43/yieldTimeout.png\"\n        srcset=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/63868/yieldTimeout.png 250w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0b533/yieldTimeout.png 500w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/00d43/yieldTimeout.png 1000w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0f586/yieldTimeout.png 1498w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nwookLoop是实现任务调用的核心逻辑,它主要实现了如下几件事:</p>\n<ol>\n<li>对可执行时间进行了切片(yieldInterval == 5ms)</li>\n<li>当超时可执行时间后,进行任务队列的调整在下个事件循环中唤起任务调度逻辑.这里有区分的是同步任务队列是直接通过postMessage发起调用,延迟任务队列是通过timer(setTimeout)发起调用.</li>\n</ol>\n<p>抛开源码可以简单的理解Scheduler的调度任务实现思路如下图,它正好实现了任务调度切片,优先级,高优任务插入等逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 984px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9INAQKD//EABcQAAMBAAAAAAAAAAAAAAAAAAABIDH/2gAIAQEAAQUCFl//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAACAwEBAAAAAAAAAAAAAAABIQAQETFR/9oACAEBAAE/ITyelNuDcVGDlf/aAAwDAQACAAMAAAAQMwc8/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHBABAAICAwEAAAAAAAAAAAAAAQARITEQUWGB/9oACAEBAAE/EN1dRqHbhBk0fNTqPsLrNQYmPD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler整体的思路\"\n        title=\"Scheduler整体的思路\"\n        src=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg\"\n        srcset=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/0479a/how_scheduler_work.jpg 250w,\n/blog/static/d056dfc402ef23dd6cb937078e3b9073/41099/how_scheduler_work.jpg 500w,\n/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg 984w\"\n        sizes=\"(max-width: 984px) 100vw, 984px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考链接</h2>\n<p><a href=\"https://engineering.fb.com/2019/04/22/developer-tools/isinputpending-api/\">isInputPending的实现背景</a><br>\n<a href=\"https://web.dev/isinputpending/\">isInputPending的使用思路</a><br>\n<a href=\"https://someu.github.io/2020-11-10/react-scheduler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\">react scheduler源码解析</a><br>\n<a href=\"https://react.iamkasong.com/concurrent/scheduler.html#%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%E5%8E%9F%E7%90%86\">React技术解密</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"从Scheduler包来看React的任务调度","date":"2021-03-15","tags":"React","path":"/react-scheduler","top":null,"summary":null}}},{"node":{"id":"76e654f7-5c52-5b12-8d13-55f5aa101acc","html":"<p>最近公司组织架构调整，来字节的一年多时间难得有这样一段清闲的时光来思考下自己这段时间做的事，坐在电脑旁想用一句简短的话来总结下这一年，想了半个小时愣是没想出来。所以还是以片段的方式来思考下2020一些做的不好点的，希望2021这个新年能做的更好。</p>\n<h3>技术能力</h3>\n<ol>\n<li>从原来的B端业务场景比较快速的熟悉了C端Hybrid项目的开发流程。对于跨端开发的知识的深入度不够。</li>\n<li>快速处理问题的能力有提升</li>\n<li>业务实现设计思考比较欠缺，在忙于业务的时候并没有思考好业务代码的组织形式和方案。</li>\n</ol>\n<h3>业务理解</h3>\n<ol>\n<li>低头看的时间比较多，没有看的更宽或者从业务的视角看的更远。</li>\n<li>没有更好的从业务的视角去思考技术，导致从开发视角看一直在实现PM的各种业务，没有一个长期的技术路径视角。</li>\n</ol>\n<h3>管理协作</h3>\n<ol>\n<li>没有把握好自身的精力。有时候会压缩自己在短时间内做更多相对简单重复的事，而不是压缩自己做超出自己能力的事。</li>\n<li>原则性不够  需要意识到良好的规则能更好的让事情发展，应该与协作方一起建立规则，否则会导致自己疲于奔命得到的事情的结果不一定是正向的。举个例子：需求排期的时候会估算需求的测试时间，如果一味的为了赶时间点，去压缩这个测试时间，就可能导致下个需求跟这个需求同时出现问题。保证一件事做好有可能真的不比两件事做完差(自身成长+ 业务价值)</li>\n</ol>\n<h3>2021的一些小目标</h3>\n<ul>\n<li>在技术和业务上希望自己能小步慢走，踏踏实实，走几步回头看看。不是一味的低头快走。</li>\n<li>自身学习上多看一些书，给自己的笨脑瓜充电点。体重上要控制住自己的嘴，减重年度okr: 10KG。</li>\n</ul>\n<p>结尾附录一段看到的话，共勉</p>\n<p>当我们提，技术驱动业务的时候，我们说的是：“我们已经想清楚业务的目标是什么，知道技术能在其中起到什么作用，目前现状是什么，我们可以怎么做，并且每个双月都定期复盘和回顾。”\n当我们提，我们这个方向好缺人，里面隐含着：“我们知道长期这个方向要解决哪些问题，目标是什么，需要招什么样的人，招来做什么？”\n当我们问，如何才能在技术上走到下一个阶段？除了执行力和自驱力之外，想清楚规划和执行路径，也是很关键的一步。</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2020年总结","date":"2021-02-01","tags":"年度总结","path":"/2020-summary","top":null,"summary":null}}},{"node":{"id":"a75da308-1935-501a-8291-43665a2911c1","html":"<h2>概要</h2>\n<p>本文主要梳理前端路由的实现方案，按照如下的逻辑进行梳理：\n前置知识 => 路由方案现状 => 从源码的解读理解前端路由的实现过程</p>\n<h2>前置知识</h2>\n<h3>history</h3>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>history.length</td>\n<td>只读, 代表当前会话历史的长度</td>\n</tr>\n<tr>\n<td>history.state</td>\n<td>只读, 代表当前会话栈顶的state</td>\n</tr>\n<tr>\n<td>history.go(number) history.forward() history.back()</td>\n<td>从当前会话加载特定的页面,会触发popstate事件</td>\n</tr>\n<tr>\n<td>pushState(state, title, url)</td>\n<td>在当前会话的添加一个新的记录(关联state) url参数需要保证同源策略</td>\n</tr>\n<tr>\n<td>replaceState(state, title, url)</td>\n<td>替换当前会话栈顶的记录(不会增加history长度,关联state) url参数需要保证同源策略</td>\n</tr>\n</tbody>\n</table>\n<h4>history相关事件</h4>\n<p>当用户触发浏览器动作或者js调用history.back/history.forward/history.go方法时,会触发popstate事件。</p>\n<h3>hash相关事件</h3>\n<ol>\n<li>当url片段标识符改变(#xxx), 会触发hashchange事件。</li>\n<li>当设置与当前不同的hash片段的时候，会在当前会话中添加一个新的记录。</li>\n</ol>\n<h2>路由方案现状</h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>原理</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于history实现的路由方案</td>\n<td>使用history相关事件和方法完成路由的切换</td>\n<td>history可以设置同源下的任意url，需要注意与服务端结合的场景，防止出现404</td>\n</tr>\n<tr>\n<td>基于hash实现的路由方案</td>\n<td>使用hash相关事件完成路由的切换</td>\n<td>hash只能改变当前url的#，有局限性</td>\n</tr>\n</tbody>\n</table>\n<h2>从源码的了解路由的实现过程</h2>\n<p>以下源码分析了history路由的实现过程,源码涉及<a href=\"https://github.com/ReactTraining/history\">history</a>, <a href=\"https://github.com/ReactTraining/react-router\">react-router</a>.整体的实现逻辑如下</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 424px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 172%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC8UlEQVRIx62W6U5yMRCGuf/rIPzgF3dgQgCDyCIoyL7JjrKobAo1zyRz0gOFD83XZNKeLtN3+r6dnsB2uzVfX19ms9mY9XottRrfjO92O6/+lwW+v7/NaDQytVrNtFot02w2PeP7+fnZfHx8yKbXOA3s93tZDCJX6ff7ZjabGTa+2mG73ZbwDoeDmc/n4uDz8/P/OHx5eZHwB4PB3x0SMpNdBcdvb28+h9TnyBJShsOhoAJpo9Ew8XhcCOl2u6ZcLgspbGw7OEdSQDtXq5UQ8/r6akKhkHl/f5dQF4uFtDHGmUvNJk6Ex53s3Ov15OwymYxJp9MmkUhI/fT0ZKrVqle7ztVDyCBhsXsul/NNBg2hwzzkEQ31WYQMTqdTCZFzDAaD0qYPQpiDs+PFzjNU2UDAeDwWgyQMh6VSSbTJPGX3IstMhFHOzlW4lsc6vKRHcdjpdIRdkNIGGdoENUIH4Z9uihqLNSG4EF51U1iIE3QHImqIqFQqv3MICkSL7tTQn/19TiJOh5pgSQygpXButLXvVwnWztjUkBOJRLw+W3O2MeaSkCSHyWTisUpyuLm5Ebb55opxtsxT00g0CjsCIQUny+XSm0BhIQUFQBJO2RgjpdXrdakZhzzNPp5s9AmAXe4qpvmQzbhBJAXu9MPDg7m/v5c2NeOqAp8OtQ1iwqWQediEq8g1BBnJ4/HxUdr0oQQfQs4Ph+cyNmFyPdmIVzCVSokVCgVxWiwW/aSwyH5G2Z0atExGp4pAVcE6zZ929g643gmQqCyOZeOSkE829hNAm8MPh8PShj3VosuJaxPvz4GzIETqWCwm4fPNmWnImtlVixq2D+E1zyjJAX1qZkcmEEU0RGAnjpOHnpSPA4RsP/QswBGIIQrpZLNZkZX9Ap44BBGkoDt1yCZcRdhHdzjN5/MmGo2a29tbEfhJyJd+lrh6jPMDcHd3JxrkWU0mk/LEcgzeTTn+nQOdGshBZOvw+NWz5eXJ5rc/nK7cqKT8ABAkKsYiO95UAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"route\"\n        title=\"route\"\n        src=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n        srcset=\"/blog/static/b70462c5399fc0b238df6097205f72be/63868/route.png 250w,\n/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png 424w\"\n        sizes=\"(max-width: 424px) 100vw, 424px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>下面代码是在react项目中使用history路由实现的一个例子，它能实现根据特定的path来渲染对应的组件。</p>\n<pre><code>import './App.css';\nimport React from 'react'\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nfunction App() {\n  return (\n    &#x3C;Router >\n      &#x3C;Switch>\n        &#x3C;Route exact path=\"/\">\n            &#x3C;div>home&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/about\">\n            &#x3C;div>about&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/dashboard\">\n            &#x3C;div>dashboard&#x3C;/div>\n          &#x3C;/Route>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  );\n}\nexport default App;\n</code></pre>\n<p>react-router/packages/react-router-dom/modules/BrowserRouter.js</p>\n<pre><code>import React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    // 初始化browser history 可以推断出路由的切换逻辑是history与Router结合的实现\n    return &#x3C;Router history={this.history} children={this.props.children} />;\n  }\n}\nexport default BrowserRouter;\n</code></pre>\n<p>packages/index.ts</p>\n<pre><code>// 在最后执行跳转的时候 会执行所有的listen函数\nfunction applyTx(nextAction: Action) {\n  action = nextAction;\n  [index, location] = getIndexAndLocation();\n  listeners.call({ action, location });\n}\nlet history: BrowserHistory = {\n  // 以下为主要的跳转函数，在实现跳转逻辑的时候都调用了applyT方法。\n  push,\n  replace,\n  go,\n  back() {\n    go(-1);\n  },\n  forward() {\n    go(1);\n  },\n  // listion方法用于增加路由切换的监听函数\n  listen(listener) {\n    return listeners.push(listener);\n  },\n  // block方法允许传入一个block函数,在路由跳转的时候会执行所有的blocker函数\n  block(blocker) {\n    let unblock = blockers.push(blocker);\n    if (blockers.length === 1) {\n      window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n    }\n    return function() {\n      unblock();\n      if (!blockers.length) {\n        window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n    };\n  }\n};\nreturn history;\n</code></pre>\n<p>从上面history源码看出，history这个库主要是维护history的相关状态(state, location, hash)并且增加路由跳转的告知能力.</p>\n<p>react-router/packages/react-router/modules/Router.js</p>\n<pre><code>import React from \"react\";\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.history.location\n    };\n    this._isMounted = false;\n    this._pendingLocation = null;\n    if (!props.staticContext) {\n      // 这里订阅了history的变化并且在变化的之后更新location\n      this.unlisten = props.history.listen(location => {\n        if (this._isMounted) {\n          this.setState({ location });\n        } else {\n          this._pendingLocation = location;\n        }\n      });\n    }\n  }\n  componentDidMount() {\n    this._isMounted = true;\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n  render() {\n    return (\n      // 将location作为context 在需要订阅的位置获取   Route消费location完成特定children的渲染。\n      &#x3C;RouterContext.Provider\n        value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      >\n        &#x3C;HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      &#x3C;/RouterContext.Provider>\n    );\n  }\n}\nexport default Router;\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊前端的路由方案","date":"2020-12-15","tags":"JavaScript","path":"/history","top":null,"summary":null}}},{"node":{"id":"be69e5b2-aefc-53f5-a712-d24f2d40c7ba","html":"<h2>为什么开启设计模式系列</h2>\n<p>在业务压力下，仓库的代码量是快速增长的。最近在思考如何能让代码有灵活性和扩展性。随着产品的迭代，一部分业务逻辑需要重新实现，那一种良好的设计是否能在重构代码中帮助我们呢？答案是确定的。开启这个系列主要有这两方面的原因:</p>\n<ol>\n<li>在翻译业务的时候更高效和优雅</li>\n<li>通过对模式的学习能加强思考</li>\n</ol>\n<p>设计模式是解决一类问题的通用的方案，希望通过对设计模式的学习能完善解决问题的能力，本系列会结合《设计模式-可复用面向对象软件的基础》来对设计模式进行比较全面的梳理。</p>\n<h2>创建型模式</h2>\n<p>创建型模式通过对实例化过程进行抽象，隐藏了底层的具体实现，从而实现更多的灵活性。创建型模式有以下几种:</p>\n<ol>\n<li>Abstract Factory(抽象工厂)</li>\n<li>Builder(生成器)</li>\n<li>Factory Method(工厂方法)</li>\n<li>Prototype(原型)</li>\n<li>Singleton(单例)</li>\n</ol>\n<p>本文会结合一个创建迷宫的示例来介绍以上几种设计模式.通常实现一个迷宫会定义以下基类:</p>\n<pre><code>// 方向枚举\nenum Direction { North, South, East, West };\n// 迷宫组件的公用抽象类\nclass MapSite {\n  public: virtual void Enter() = 0;\n}  \n// 房间  保存其他MapSite的引用\nclass Room: public MapSite {\n  public: \n    Room(int roomNo);\n    MapSite* GetSide(Direction) const;\n    void SetSide(Direction, MapSite*)\n  private:\n    MapSite* _sides[4];\n    int _roomNumber;\n}  \n// 墙 \nclass Wall : public MapSite {\n  public: \n    Wall();\n    virtual void Enter();\n}\n// 门\nclass Door : public MapSite {\n  public: \n    Door(Room* = 0, Room*  = 0);\n    virtual void Enter();\n    Room* OthersSideFrom(Room*);\n  private: \n    Room* _room1;\n    Room* _room2;\n    bool _isOpen;\n}\n// 迷宫类\nclass Maze {\n  public: \n    Maze();\n    // 在迷宫中添加Room\n    voidb AddRoom(Room *);\n    // 根据RoomNo查找Room\n    Room* RoomNo(int) const;\n  private:\n}\n// 一个可能的迷宫生成代码\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room* r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n</code></pre>\n<p>上面代码在定义迷宫布局的时候对布局过程进行了硬编码，在未来需要对迷宫布局进行修改的时候就需要修改硬编码逻辑。通过创建型模式可以实现将实现的细节封装起来，给予代码一定的可变化性。</p>\n<h3>Abstract Factory(抽象工厂) - 对象创建型模式</h3>\n<p>抽象工厂提供一个创建一系列相关或相互依赖对象的接口而无需指定他们具体的类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 891px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABK0lEQVQoz41S147DMAzL//9gkYHMZu80O01UkAcd0ocDToBgW5ZpkrYhInJdl7zfb9n3XZZlkW3buP5v4LyGoYWqqsT3fXk8HuK6rqRpKl3XyXEcvACX6fh6vbjfNA3376CGTnA4CAI2Pp9P5rqu3APb8zyZiGmaSKBt2y8lwCJDNCoT3cAazfcDd1t0Pc8ze/UyoyxLSjVNkwyLoqCUMAzFsixxHEeSJKHMKIq4hiUIMLRtm7W6rn8AIc3zPAIAGIcAeq9hDkAo6Puec2U4jiNrYP77KGhUc++ButoAmQCHd/A5jmPOcRkIQB1Y8lHQjFTP9BHgDx5Ae/I8p0wkQIZhkCzLOOqagGr0PcEMLw8/AYzUOkZcBFUq9UvyXwGmCoIvpKk1BVRr8G0+DjIE5/TLV5AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"抽象工厂结构\"\n        title=\"抽象工厂结构\"\n        src=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n        srcset=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/63868/abstractFactory.png 250w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/0b533/abstractFactory.png 500w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png 891w\"\n        sizes=\"(max-width: 891px) 100vw, 891px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>AbstractFactory</li>\n</ul>\n<p>声明一个创建抽象产品对象的操作接口</p>\n<ul>\n<li>ConcreteFactory</li>\n</ul>\n<p>实现创建具体产品对象的操作</p>\n<ul>\n<li>AbstractProduct</li>\n</ul>\n<p>为一类产品对象声明接口</p>\n<ul>\n<li>ConcreteProduct</li>\n</ul>\n<p>定义一个将被相应具体工厂创建的产品对象，实现AbstractProduct接口</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>仅使用由AbstractFactory和AbstractProduct类声明的接口</p>\n<h4>适用性</h4>\n<p>抽象工厂通过将具体的对象创建延迟到ConcreteFactory中，能提供丰富的灵活性，适用于以下场景:</p>\n<ol>\n<li>一个系统要独立于它的产品的创建，组合和表示时</li>\n<li>一个系统要由多个产品系列中的一个来配置时</li>\n<li>需要对一系列相关产品对象设计进行联合使用时</li>\n<li>对外提供产品类库，提供统一的接口</li>\n</ol>\n<h4>优点&#x26;缺点</h4>\n<ul>\n<li>分离了具体类的实现，通过具体工厂封装对具体产品实现的细节。</li>\n<li>通过具体工厂的实现，将具体产品的实现逻辑封装在一起，增加了整体的一致性。但是在增加新的种类的产品的时候需要实现新的具体工厂。</li>\n</ul>\n<h4>代码示例</h4>\n<p>下面的代码使用Abstract Factory模式来创建一个迷宫。</p>\n<pre><code>// 定义抽象方法类\nclass MazeFactory {\n  public: \n    MazeFactory()\n  \n  virtual Maze* MakeMaze() const { return new Maze; }\n  virtual Wall* MakeWall() const { return new Wall; }\n  virtual Room* MakeRoom(int n) const { return new Room(n); }\n  virtual Door* MakeDoor(Room* r1, Room* r2) { return new Door(r1, r2); }\n}\n// 通过传递具体的工厂实现迷宫的创建\nMaze* MazeGame::CreateMaze(MazeFactory&#x26; factory) {\n  Maze* aMaze = factory.MakeMaze();\n  Room* r1 = factory.MakeRoom(1);\n  Room* r2 = factory.MakeRoom(2);\n  Door* aDoor = factory.MakeDoor(r1, r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  \n  r1.SetSide(North, factory.MakeWall())\n  r2.SetSide(North, factory.MakeWall());\n  // 省略很多的SetSide操作\n  return aMaze;\n} \n\n// 创建过程\nMazeGame game;\nMazeFactory factory\ngame.CreateMaze(factory)\n</code></pre>\n<p>通过传递ConcreteFactory,上面的代码将创建逻辑都封装在具体工厂中，这样通过传递不同的工厂就能完成不同类型对象的创建。</p>\n<h3>Builder(生成器) - 对象创建型模式</h3>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Builder模式能更好的封装产品的内部表示。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 871px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuTSRRX//EABcQAQADAAAAAAAAAAAAAAAAAAEAICH/2gAIAQEAAQUCBg7T/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABUQAQEAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Aqv/xAAYEAEBAQEBAAAAAAAAAAAAAAABABEhEP/aAAgBAQABPyED3cSusO+EX//aAAwDAQACAAMAAAAQpA//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCn/8QAFhEAAwAAAAAAAAAAAAAAAAAAECEx/9oACAECAQE/EEg//8QAGxAAAwACAwAAAAAAAAAAAAAAAAERMVEQIYH/2gAIAQEAAT8QqGJomDZtdCEqvvGTMD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"生成器结构\"\n        title=\"生成器结构\"\n        src=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n        srcset=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/0479a/builder.jpg 250w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/41099/builder.jpg 500w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg 871w\"\n        sizes=\"(max-width: 871px) 100vw, 871px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Builder</li>\n</ul>\n<p>为创建一个Product对象的各个部件指定抽象接口</p>\n<ul>\n<li>ConcreteBuilder</li>\n</ul>\n<p>实现Builder的接口来完成对象的创建\n定义并明确它所创建的表示\n提供一个检索产品的接口</p>\n<ul>\n<li>Director</li>\n</ul>\n<p>构建一个使用Builder的接口对象</p>\n<ul>\n<li>Product</li>\n</ul>\n<p>被构造的复杂对象</p>\n<p>抽象的Builder类为Director要创建的对象定义操作。ConcreteBuilder实现Builder定义的方法</p>\n<h4>适用性</h4>\n<p>通过生成器可以把复杂的对象创建过程隐藏，通过不同的Builder来完成系统的创建, 适用于以下场景：</p>\n<ol>\n<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li>\n<li>当构造过程必须允许被构造的对象有不同的表示时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeBuilder {\n  public:\n    virtual void BuildMaze() {};\n    virtual void BuildRoom(int room) {};\n    virtual void BuildDoor(int roomFrom, int roomTo) {};\n    virtual Maze* GetMaze() { return 0  };\n  protected: \n    MazeBuilder();\n}\n// 在具体调用的时候 可以传递一个实现了抽象类builder的ConcreteBuilder\nMaze* MazeGame::CreateMaze(MazeBuilder&#x26; builder) {\n  builder.BuildMaze();\n  builder.BuildRoom(1);\n  builder.BuildRoom(2);\n  builder.BuildDoor(1,2);\n  return builder.GetMaze();\n}\n\n// 创建过程\nMaze* maze\nMazeGame game\nMazeBuilder builder\nmaze = game.CreateMaze(builder)\n</code></pre>\n<p>对比抽象工厂,Builder模式封装了创建过程的细节，通过不同的builder实现可以创建出不同的对象。</p>\n<h3>Factory Method(工厂方法) - 对象创建型模式</h3>\n<p>工厂方法定义一个用于创建对象的接口，让子类来实现对应的接口来创建对象。Factory Method使一个类的实例化延迟到其子类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 818px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABdUlEQVQoz5XRwY6DIBAG4L7/g/XQSisJcTSgoIK12GqtgDXadlPd3Zi97XeawPwBhs00TcYYa61zbhgG55yZTdP0/tH3fdd1fd8/Hg9rbdd1y+6mKAohhNaac04IWWo5m6bpMWOMaa0ZY0EQFEWRpmlZlp8w5/x0Oo3jqJTCGOd5boxpmoZS2vf9/X5vmuZ4PDZNQwjxPE8pJYSI4/g7jDEmhPi+DwBKqSzLktly59frxRiL45hzDgBZlgFAVVWf8HKg7/sIoe12myRJnudJkiilluTvy8dxbNt2vbh5rxhj1t1/PJ9P59x6ZWOt1VrXs/P5vBRa63Xf9Xqt67qqKinl7XbTWltrP2EhhJQSAA6HA0Jot9uFYXi5XBhjbduWZVnXte/7QRAghPb7ved5GGMp5ffAOOdpmgJAGIZxHAsh8jynlI4zYwxCiFK6NERRhDEWQnzCZVkCQBRFABAEAWOMUkoIWX5yYX+4Wdd1wzD8Hdh/fQFNImIPdtdAXwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"工厂方法\"\n        title=\"工厂方法\"\n        src=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n        srcset=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/63868/factoryMethod.png 250w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/0b533/factoryMethod.png 500w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png 818w\"\n        sizes=\"(max-width: 818px) 100vw, 818px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Product</li>\n</ul>\n<p>定义工厂方法所创建对象的接口(抽象产品)</p>\n<ul>\n<li>ConcreateProduct</li>\n</ul>\n<p>实现Product的接口(具体产品)</p>\n<ul>\n<li>Creator</li>\n</ul>\n<p>声明工厂方法(抽象工厂)</p>\n<ul>\n<li>ConcreteCreator</li>\n</ul>\n<p>实现工厂方法，返回ConcreateProduct实例</p>\n<p>工厂方法依赖它的子类来实现工厂方法来完成对象的创建。</p>\n<h4>适用性</h4>\n<p>工厂方法适用于以下场景:</p>\n<ol>\n<li>父类不知道它需要创建的对象的类的时候</li>\n<li>当一个类希望它的子类来指定创建对象的时候</li>\n<li>当类将创建对象的职责委托给多个帮助子类中的某一个并且希望某一个帮助子类代理这个创建过程</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeGame {\n  public: \n    Maze* CreateMaze();\n\n    // factory method;\n    virtual Maze* MakeMaze() const { return new Maze(); };\n    virtual Room* MakeRoom(int n ) const { return new Room(n); };\n    virtual Wall* MakeWall() const { return new Wall; };\n    virtual Door* MakeDoor(Room* r1, Room* r2) const { return new Door(r1,r2);  };  \n}\n\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room&#x26; r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n// 子类实现工厂方法来完成对象的创建\nclass BombedMazeGame : public MazeGame {\n  public:\n    BombedMazeGame()\n    virtual Room* MakeRoom(int n) const  { return new RoomWithBomb(n); };\n}\n</code></pre>\n<h3>PROTOTYPE（原型) - 对象创建型模式</h3>\n<p>原型模式通过原型实例指定创建对象的种类，通过拷贝原型来创建新的对象</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 747px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY03XQ224EIQiA4Xn/x5wLKzr1iA6guG3cbA9p+l0S/pBw1FpjjABQSqm1Pl7GGMwsGxGFEGKMPyeqepznaYwJIVzXZa3tvRMRM8cYvfcppbC9bYhYa0XElNIY40gplVJ67601Zv66rKrMXEpBRGaem6q21u77VtW11vFcXWs9fltriQgiEpGIrI2Z28bM3/FfRAQA1loAcM6NMUTEGOOcs9uc89+Ymb33Oef3bc4pIgCQc34+6DP+AFoUWqjoiPwWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"原型方法\"\n        title=\"原型方法\"\n        src=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n        srcset=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/63868/prototype.png 250w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/0b533/prototype.png 500w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png 747w\"\n        sizes=\"(max-width: 747px) 100vw, 747px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Prototype</li>\n</ul>\n<p>声明一个克隆自身的接口</p>\n<ul>\n<li>ConcretePrototype</li>\n</ul>\n<p>实现一个克隆自身的操作</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>让一个原型克隆自身从而创建一个新的对象</p>\n<h4>适用性</h4>\n<p>原型模式适用于以下场景:</p>\n<ol>\n<li>实例化的类需要在运行时刻指定</li>\n<li>类的实例状态是相似的，通过原型的克隆能减少类的创建</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazePrototypeFactory : public MazeFactory {\n  public :\n    MazePrototypeFactory(Maze* , Wall*, Room*, Door*);\n\n    virtual Maze* MakeMaze() const;\n    virtual Room* MakeRoom(int) const;\n    virtual Wall* MakeWall() const;\n    virtual Door* MakeDoor(Room*, Room*) const;\n\n  private:\n    Maze* _prototypeMaze;\n    Room* _prototypeRoom;\n    Wall* _prototypeWall;\n    Door* _prototypeDoor;\n}\n\nMazePrototypeFactory::MazePrototypeFactory (\n  Maze* m, Wall* w, Room* r,Door* d\n) {\n  _prototypeMaze = m;\n  _prototypeRoom = r;\n  _prototypeWall = w;\n  _prototypeDoor = d;\n}\n\nWall* MazePrototypeFactory::MakeWall() const {\n  return _prototypeWall->Clone();\n}\nMazeGame game;\n// 需要初始化传入的实例支持clone操作，可以通过传递不同的实例完成不同的对象创建\nMazePrototypeFactory simpleMazeFactory(new Maze, new Wall, new Room, new Door);\nMaze* maze = game.CreateMaze(simpleMazeFactory)\n</code></pre>\n<h3>SINGLETON（单例）- 对象创建型模式</h3>\n<p>保证一个类仅有一个实例，并提供一个访问他的全局访问点</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu6QD//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARIUFR/9oACAEBAAE/IVnbLE7KXJ//2gAMAwEAAgADAAAAENDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECExkf/aAAgBAQABPxB7NzXBiTW+QRKuDzP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"单例模式\"\n        title=\"单例模式\"\n        src=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n        srcset=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/0479a/singleton.jpg 250w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/41099/singleton.jpg 500w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg 750w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Singleton</li>\n</ul>\n<p>定义一个Instance操作，允许客户访问它的唯一实例</p>\n<h4>适用性</h4>\n<p>单例模式适用于以下场景:</p>\n<ol>\n<li>唯一的实例需要全局访问时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class Singleton {\n  public: \n    static Singleton* Instance();\n  protected:\n    Singleton();\n  private:\n    static Singleton* _instance;\n}\n\nSingleton* Singleton::_instance = 0;\n// 对成员初始化未空，第一次访问的时候创建成员，再次访问直接范返回成员\nSingleton* Singleton::Instance() {\n  if(_instance == 0) {\n    _instance = new Singleton();\n  }\n  return _instance;\n}\n</code></pre>\n<p>在单例模式中，想要实现动态的确定单例的类型方式，可以通过维护单例注册表的方式来实现。</p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"编程拾遗系列设计模式-创建型模式","date":"2020-07-06","tags":"设计模式","path":"/build-pattern","top":null,"summary":null}}},{"node":{"id":"dbb428a4-60cc-51c9-bbb6-74a94c623175","html":"<h2>前言</h2>\n<p>在react native开发中通常会使用Touchable<em>组件来实现对用户手势的处理.本篇文章从Touchable</em>组件的基本使用出发,逐步深入到react native中手势处理的原理.</p>\n<h2>Touchable*组件</h2>\n<h3>基本使用</h3>\n<p>在react native中通常使用一下几种组件来实现点击的处理</p>\n<ol>\n<li>TouchableOpacity</li>\n<li>TouchableHighlight</li>\n<li>TouchableWithoutFeedback</li>\n</ol>\n<p>对于TouchableOpacity的基本使用如下,通过绑定onPress事件就能获取到用户的点击行为进行处理</p>\n<pre><code>    &#x3C;TouchableOpacity\n      style={styles.button}\n      onPress={(evt => { this.onPressEvt(evt)  })}\n    >\n      &#x3C;Text>Press Here&#x3C;/Text>\n    &#x3C;/TouchableOpacity>\n</code></pre>\n<p>在开发中不禁会有这样的疑问,为什么TouchableOpacity能响应用户的手势点击而普通的View组件却不行.这就引出了React Native中的手势处理流程</p>\n<h2>手势处理流程</h2>\n<p>React Native中组件对手势的响应是通过如下的阶段来实现:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 862px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAEWH/2gAIAQEAAT8hVFRU/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAABEAASFR/9oACAEBAAE/EH3VNXZv1f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 手势\"\n        title=\"react native 手势\"\n        src=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n        srcset=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/0479a/gesturelifecycle.jpg 250w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/41099/gesturelifecycle.jpg 500w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg 862w\"\n        sizes=\"(max-width: 862px) 100vw, 862px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在每个阶段会有相应的处理函数来处理当前阶段的行为</p>\n<h3>手势响应的阶段</h3>\n<h4>申请阶段</h4>\n<ol>\n<li>View.props.onStartShouldSetResponder: (evt) => bool(返回true 代表当前组件申请在触摸手势的时候成为响应者)</li>\n<li>View.props.onMoveShouldSetResponder: (evt) => true(返回true 代表当前组件申请在移动手势的时候成为响应者)</li>\n</ol>\n<h4>通知阶段</h4>\n<ol>\n<li>View.props.onResponderGrant: (evt) => {}(获取手势处理回调)</li>\n<li>View.props.onResponderReject: (evt) => {}(获取手势处理失败回调)</li>\n</ol>\n<h4>响应阶段</h4>\n<ol>\n<li>View.props.onResponderMove: (evt) => { }(手势移动回调)</li>\n<li>View.props.onResponderRelease: (evt) => { }(手势行为结束(touchUp)回调)</li>\n</ol>\n<h4>释放阶段</h4>\n<ol>\n<li>View.props.onResponderTerminationRequest: (evt) => bool (当其他组件想成为当前手势的处理者时会触发,返回true表示释放)</li>\n<li>View.props.onResponderTerminate: (evt) => {} (当前组件失去响应者身份触发）</li>\n</ol>\n<h3>手势拦截</h3>\n<p>手势的响应是冒泡的,父元素可以使用如下的方法来实现对手势的拦截处理.</p>\n<ol>\n<li>View.props.onStartShouldSetResponderCapture: (evt)=> bool (返回true成为手势的处理者, 子元素不响应)</li>\n<li>View.props.onMoveShouldSetResponderCapture: (evt)=> bool ((返回true成为手势的处理者, 子元素不响应))</li>\n</ol>\n<h3>自定义响应组件实现</h3>\n<p>通过对手势处理阶段的了解,在定义响应组件的时候可以通过添加相应的函数来实现,react native定义了PanResponder.create()方法来快速的实现组件的定义.PanResponder响应回调函数中封装了事件和手势的状态信息,能更细致的实现对手势的处理.</p>\n<pre><code>class App extends Component {\n  constructor(props) {\n    super(props)\n    this.PanResponder = PanResponder.create({\n      onStartShouldSetPanResponder: (evt, gestureState) => true, // 触摸的时候成为手势响应者\n      onPanResponderStart: (evt, gestureState) => { console.log('someone touch me') }, // 触摸时间回调\n    })\n  }\n  render() {\n    return (\n      &#x3C;View style={styles.container} {...this.PanResponder.panHandlers} >&#x3C;/View>\n    )\n  }\n}\n</code></pre>\n<h2>后记</h2>\n<p>后面会按照下面的思路逐步的梳理下React Native相关入门与实践的一些知识.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/098f83ac1e178157d52feb66022c929c/5c263/reactNativeBasic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABmklEQVQ4y5VTW0rDQBTtOlyAPyJuxA24C/8E0TX46ToEERTRUv8UaUMihUKCsa9kkraTJs17cmSupLZNH3Tg5P5Mzj3n3Ds1bDhFUczrIsqT5zmyLK/cre0iWj1CCAyHFrrdHjzPq9ytbVK3SJxlGSmSiKII36YJXTcwnkwwm82WFcqPEAXyNQijmFQYhgFFUaBpGhhjcEcjIuv1+5hwviSitilDiATIE2oWxzEpkwjDkEg598i6zRjyXCxn+G5wPCgMT5qDR1WC4e6ji6Y5rfSRtoMgIOI0TcmBtD0nFEWB05sPHF7UcXTZwMn1G46vGjg4f8HZbfOPRIjKpC3bhmXZlWGSwqbp4fnLRb09wmvbJdx/dqH2/LVpyCExx0G/PwBjzva1+W+ZoMjieYZljrJKu3IYvu9Tjo7jUBNSuGvKnHPouo5OpwNVVdFqtTAYDGDbDJZlEXkYRpTtXntYQv4oVbruCH4QYDqdwvcDpKXCfV9KOWlJNB5PqMoll/Y3Ktz2lktEUUzrIolM8wdJkmwn3NVoNZ5ybX4B7cM55EqQKNkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 入门\"\n        title=\"react native 入门\"\n        src=\"/blog/static/098f83ac1e178157d52feb66022c929c/00d43/reactNativeBasic.png\"\n        srcset=\"/blog/static/098f83ac1e178157d52feb66022c929c/63868/reactNativeBasic.png 250w,\n/blog/static/098f83ac1e178157d52feb66022c929c/0b533/reactNativeBasic.png 500w,\n/blog/static/098f83ac1e178157d52feb66022c929c/00d43/reactNativeBasic.png 1000w,\n/blog/static/098f83ac1e178157d52feb66022c929c/aa440/reactNativeBasic.png 1500w,\n/blog/static/098f83ac1e178157d52feb66022c929c/5c263/reactNativeBasic.png 1636w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"react-native中的手势处理","date":"2020-04-15","tags":"跨端技术","path":"/rn-gesture","top":null,"summary":null}}},{"node":{"id":"8376f00f-727a-5a04-bb7e-2e8e1c1c9067","html":"<h2>前言</h2>\n<p>长列表优化是一个老生常谈问题,优化的方案也是相似的(减少内存占用,复用渲染结果,可视区域渲染,预渲染),在跨端开发的React Native中列表主要有FlatList和SectionList两种,以下主要通过对FlatList的介绍来了解React Native中的长列表.</p>\n<h2>FlatList</h2>\n<p>FlatList通过预渲染和可视区域渲染的方案,来降低列表渲染时候的内存占用从而提升页面的性能.下面从FlatList的基础使用来逐渐展开.</p>\n<h3>基本使用</h3>\n<pre><code>renderItem = ({ item, index }) => {\n  return &#x3C;View>&#x3C;Text style={{ color: 'white' }}>{item.name}&#x3C;/Text>&#x3C;/View>\n}\nrender() {\n  return (\n    &#x3C;FlatList\n      data={[{ name: 'a' }, { name: 'b' }, { name: 'c' }, { name: 'd' }]}\n      renderItem={this.renderItem}\n      keyExtractor={item => `${item.name}`}\n    />\n  )\n}\n</code></pre>\n<p>在上面的例子中通过设置data, renderItem(条目渲染函数)就完成了列表的渲染功能</p>\n<h3>结构</h3>\n<p>FlatList数据渲染的原理是通过数据项和底层容器ScrollView的布局事件计算出需要渲染的条目,在滚动过程中动态的更新渲染条目来完成列表的绘制.FlatList渲染的内部结构如下:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/flatList.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 157.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsTAAALEwEAmpwYAAADeElEQVRIx6VWS4/TZhS1xKhQsUfqhkUXlUCCUhYUqZVaCQmVAv+jSEjdTIuEkKpu2k2X7T9ohbqoVAQbEBKLMu9h3knITDJ24vgR5+XxK4kd56BzwenAamJs3Xyfbfn43nPPd74ocRwjDEP0ej0cHBxIuK4r1/1+H3w+HA5lPEoofEnXdTQaDezt7WF/fx+1Wg31eh22bWM0Gk0HGAQBLMtCs9nE7u6uAJZKJZimKfdyATITZrm1tSVZbmxsCHir1UKSJNMBkj+WR2BmtrCwIOUzO8Mwps8wiiIpk80gCMHZEM7JZZqm+UrmwRdZImMwGAi3uThkNr7vo1gsolqtTjLOBUgOydV4PJaXGZyTitwcMivKJJMKM9M0TficmkNmSKBMLmzE+vr6pNPTlxyEMEwDcRqj8LKA+aV56JaOcBCiYTQmgEcJAfQDHx2zg9iJ4Rs+AjOA1/AQ2REcy0E6TpHEiZTO7mc8Z0GQTBkEVRABv1f+wJf2V7hu3cQ31re4Zt/AFfUqnqnPkIQJ3AMX7XZblECNZkZCE6G8OOczgioIgNv2d1AOn66Cr9cv4f7cX3ix+AJaTRN+V1ZWsLS0hLW1NSwvL2N1dVWkVigUZJkyY8nwzv5vUNyzONn9Ase7l3HCvYwZ+yIe1Z8iDRMM4oFkUC6XJ86kqqoogWBUyqGSQ/xY0aH4wAc+MOMBygBQemM81HRZQYM3HPKgRhnZnAcz+x8wDDGra1AwwgzIQYqPWgY+L23iz+f/QS3vouk42N7eFmnRQFgm3YjBe1y6XAT8qIIwwA81C8oYmEkh4ykPuGCGeLBdhKPr8IJAyqM+yeHc3JzwSF4XFxdRqVTE9UU26AN3yn9DMWdx0vwJH5r3cKz1M5TGXTzSVl6bRvJatFz35JJdJQCvOSeHmV6ly983b73dZZ4jBf9a/wAjIBpGb+nt3Ti870iXf1F/xengY3zqXcTZ3jmcDz7DJ60zeFx/AqRAf9g/0iqRDMMoRF2rQ91ToVZUtO02quUqtIoG0zDzb1JOy8Hm1iZ2Cjsoloroub332/W4nbJb7BxNwfM9caHcewplQfXTAzkSnKtiaj8kIMEycrnY+YAGkAuQJTuOg2w7pasw+KFcewqFSkACEJBzOkduQL5I26fiPc+bjLR/usrUJfOHWXY6nUl0u10Jfmzaf1+vACaDAH8XnMbBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listSection\"\n        title=\"listSection\"\n        src=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/flatList.png\"\n        srcset=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/63868/flatList.png 250w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/0b533/flatList.png 500w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/flatList.png 523w\"\n        sizes=\"(max-width: 523px) 100vw, 523px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>FlatList性能优化</h3>\n<h4>减少更新时列表项总体数目和条目的重渲染,</h4>\n<ol>\n<li>列表条目使用PureComponent或者shouldComponentUpdate来减少条目的更新.</li>\n<li>调整windowSize大小(默认是21)</li>\n<li>调整maxToRenderPerBatch的大小,控制每次更新的最大条目</li>\n</ol>\n<h4>减少内存的占用</h4>\n<ol>\n<li>减少匿名函数的使用</li>\n<li>列表条目的渲染逻辑尽量简单</li>\n</ol>\n<h4>减少渲染过程中的计算</h4>\n<ol>\n<li>使用getItemLayout减少列表条目的计算过程</li>\n<li>调整滚动事件的触发频次(scrollEventThrottle)</li>\n<li>在列表项中合理的使用缓存</li>\n<li>渲染过程中减少与Native通信过程,可以使用InteractionManager优化</li>\n</ol>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"聊聊React Native中的长列表","date":"2020-03-22","tags":"跨端技术","path":"/rn-list","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":11,"pageCount":15,"additionalContext":{"pageAllCount":87}}},
    "staticQueryHashes": []}