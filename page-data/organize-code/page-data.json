{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/organize-code",
    "result": {"data":{"markdownRemark":{"html":"<p>这篇文章对之前的内容进行了一次重写，过去内容关注的点更小或者说对维护项目这个话题并没有更加系统和深入的思考\n代码的维护并不是一蹴而就的,在业务的维护阶段如果不能对项目代码进行有效的治理,就会导致业务代码逐渐臃肿可维护性降低.</p>\n<h2>功能分离&#x26;整合</h2>\n<p>在业务发展的过程中最初单一的功能衍生出不同的业务模式和逻辑.通过对代码有序的梳理能更好的帮助后续的迭代降低维护成本.</p>\n<h3>功能(逻辑)聚合</h3>\n<ol>\n<li>相同功能提取至上层(工具包)减少逻辑的分散，增加封装性</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f4744724c2714f096071420341056b8c/1dbe8/pull.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAklEQVQoz41RzUrGMBDM+1/Fi76F+AgePHvooeCl/Uox0KT/zSYtI7MSCIL4HYZNujOzs42JMeJeiEhRBSIXUuoAvClEGph7jbLZuq5YlgXzPCGEC+dZw/snWPuIGN9hMvkvlKYpJczzDGstrP1CjFDDYXhG0zz8GJJ8nqeSeWYt7+Wq27bBOaeGzg3wfoHIJ4BXAC+4rg+Y4zgwjqNODiGoiHeuVaZkpVnXddqbpgm3W4dx9IhxV4gcMGxWVaVEmvV9j7qutVJEeO811b7vakwNkX9BCByaIBJhmIpmFJBMQtu2mvL349CY36nhZkxMY754huEUNoksZNJy1Xz+j8f6DV72aRUmZVkFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"提取\"\n        title=\"提取\"\n        src=\"/blog/static/f4744724c2714f096071420341056b8c/00d43/pull.png\"\n        srcset=\"/blog/static/f4744724c2714f096071420341056b8c/63868/pull.png 250w,\n/blog/static/f4744724c2714f096071420341056b8c/0b533/pull.png 500w,\n/blog/static/f4744724c2714f096071420341056b8c/00d43/pull.png 1000w,\n/blog/static/f4744724c2714f096071420341056b8c/1dbe8/pull.png 1374w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>功能隔离(边界划分)</h3>\n<ol>\n<li>代码仓库(功能)要进行合理的划分(划分维度 业务相关性/技术栈形式),防止不同业务间的互相干扰.</li>\n<li>在提供业务功能的时候，内部逻辑可以减少对外层逻辑的解释，在边界统一封装外层的解释逻辑。举个简单的例子比如前端在处理日期在处理Date对象构造函数new Date(year, month,day)的时候，month是0-11区间的,但是在对外提供的时候需要转化成1-12区间，那么在内部处理时可以尽量减少month的转化，保持一致的含义，在暴露出对外的接口中统一提供转化</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/68cfb0b896d568e04141bb15d229a8e4/ce92a/innersame.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY032R2wqEMAxE+//fqOiLqKj1fq9mOYEWwd0thJmmM0nTmnEcZZqmV/j8cRyy77si+2EYXtp5ngMaxH455wKnAObzPJWDNHlq7vsOvr7vpes6MWVZirVW6rqWqqo04Hmea8Ft22RdV8W2bTXHHlyWRZvgL4pCvcYbScLp0jSNZFmmHAPncExJkgiXiKJI9XEcS5qmyrUg4/h1XVfgjEghxkEDUtzr0TIywe39ZObbI//7lF+fyBuCH2tszmG+rwtAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"内部一致性\"\n        title=\"内部一致性\"\n        src=\"/blog/static/68cfb0b896d568e04141bb15d229a8e4/00d43/innersame.png\"\n        srcset=\"/blog/static/68cfb0b896d568e04141bb15d229a8e4/63868/innersame.png 250w,\n/blog/static/68cfb0b896d568e04141bb15d229a8e4/0b533/innersame.png 500w,\n/blog/static/68cfb0b896d568e04141bb15d229a8e4/00d43/innersame.png 1000w,\n/blog/static/68cfb0b896d568e04141bb15d229a8e4/ce92a/innersame.png 1459w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>规范建立</h2>\n<ol>\n<li>编码规范(lint commit rule)</li>\n<li>分支规范(上线规范)</li>\n<li>review机制</li>\n<li>语义化(可读性)、注释(文件、核心代码片段注释)</li>\n<li>目录规范化-约定俗成</li>\n</ol>\n<h2>基于业务的框架(功能复用)</h2>\n<p>造轮子是在技术/业务发展都一定阶段的诉求.通过将开发能力、线上能力、业务通用逻辑下沉到框架层,让框架去约束业务并给业务赋能.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/21724b1a09b327be152374878d99f949/3dde1/frameWork.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQ4y6WS6arEIAxG+/4vWVq67/sOGY6Q4pUp3DI/gjGa4xcT7zgO+cW2bZNlWWTfd7P3COAQwHdtXdc/qx0nbxgGyfNclOMVRSFBEEgURVKWpdR1baxpGsmyzPh930vbtsJd9l3XmbvTNBkQ8VthVVUSx7G5gJEMjERNGsdR5nm+YfogMe77vm/i53mKRwLQNE3NIYYyTOE8iArdJ0liFFM2UHw4RiFUPlVfJ4kH2GuJKCWJc1Zi13XdjcGHQ9me1k5AL+BTZhiG94e75+S5ZhRqh+0gpagSVGHfknW17SsQRZRJyZTPaKgqG/QIVHNVAEIpUL7gCfIIdKF0nm6jFvhroF0y46HdZSTskl8DaQrjA4iRAur+8ysgK52lTFYd2v8AP11ePBIQ9s29AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"框架能力\"\n        title=\"框架能力\"\n        src=\"/blog/static/21724b1a09b327be152374878d99f949/00d43/frameWork.png\"\n        srcset=\"/blog/static/21724b1a09b327be152374878d99f949/63868/frameWork.png 250w,\n/blog/static/21724b1a09b327be152374878d99f949/0b533/frameWork.png 500w,\n/blog/static/21724b1a09b327be152374878d99f949/00d43/frameWork.png 1000w,\n/blog/static/21724b1a09b327be152374878d99f949/3dde1/frameWork.png 1018w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>渐进的变化</h2>\n<h3>延迟抽象</h3>\n<p>延迟对代码进行抽象逻辑的封装，过度的提前封装会导致封装模块不利于维护，后续不同模块功能产生分歧大的时候，进行功能的拆分也是很痛苦的。在下面的例子中初期可以只封装最底层的模块，后期在进行业务逻辑的向上封装提取\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/11db52875dd41a085919d8c2506ae7ec/2dab4/slow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABBUlEQVQoz3WSCQrFMAhEc/9zttB93xf8PMFgS39BNEbHmdRwHIfs+y74ZVlkmiY5zzPmzN7nf7lA0qxpGimKQtZ1fTR4v22bxvM8S1VVsZc8XgGv61KQYRik6zotvu87gngFbdsqEMOJ8fSgjH4F5KLve8myTJIk0ZicyQcMD+A4jgqI5x4iEOCecwA1z/M4Gcnk6rrW6RQjBwOEO+pgRQ5ASKFIAWmyAmLMGsnBlrMx41yWpdbBnA8wGKpkkrCiEKZpmuoka/aSYUITRg0qUIYKBuKD/W57cCZT7P+sN4DNGOjfOa4NAW9hsu2Rv9bGYmqoBdSv2WMPbZe+gPwy2x9F8hvwB6/OBkODx0lQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"延迟抽象\"\n        title=\"延迟抽象\"\n        src=\"/blog/static/11db52875dd41a085919d8c2506ae7ec/00d43/slow.png\"\n        srcset=\"/blog/static/11db52875dd41a085919d8c2506ae7ec/63868/slow.png 250w,\n/blog/static/11db52875dd41a085919d8c2506ae7ec/0b533/slow.png 500w,\n/blog/static/11db52875dd41a085919d8c2506ae7ec/00d43/slow.png 1000w,\n/blog/static/11db52875dd41a085919d8c2506ae7ec/2dab4/slow.png 1461w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>技术方案设计的思考</h2>\n<ol>\n<li>(宏观)上层技术框架方案的设计\n<ul>\n<li>层次设计-分层</li>\n<li>面向未来的实现方式</li>\n</ul>\n</li>\n<li>(微观)功能的封装\n<ul>\n<li>组件、工具函数</li>\n<li>组合</li>\n<li>适度的抽象</li>\n</ul>\n</li>\n</ol>\n<p>代码是与机器交互的语言,也是开发者之间\b交流的\b一种方式.之所以要提倡编写可维护的代码是希望在同一个团队中形成统一的方言.这种独特的方言要在一定程度上提高开发的效率(不好的方言有可能降低开发效率).也许团队这段时间会使用这种方言,过段时间会换另一种方言.自己的建议是多思考,多想想方言之间的不同,为什么这种模式会适应现在的场景,慢慢的你就会建立一种你自己的方言或者思考问题的方式.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.im/post/5b3ae175f265da63252c2f21\">代码质量与规范，那些年你欠下的技术债</a><br>\n<a href=\"https://www.zhihu.com/question/20017545\">好的提高代码质量的方法有哪些</a><br>\n<a href=\"https://overreacted.io/zh-hans/goodbye-clean-code/\">Goodbye, Clean Code</a></p>","frontmatter":{"date":"2022-01-05","path":"/organize-code","title":"维护项目的一些想法(持续更新)"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}