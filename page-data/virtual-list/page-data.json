{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/virtual-list",
    "result": {"data":{"markdownRemark":{"html":"<h2>前言</h2>\n<p>在开发公司内部web版聊天工具的时候,用户联系人数目是100+的.最近在思考如果每次都把100+的联系人进行渲染并且更新,这种实现是过度的.用户可能只操作20个联系人,浏览器却要为此付出多余的渲染性能.因此考虑通过虚拟列表来实现这个功能.虚拟列表只渲染可视区域,这样一定程度上降低了性能的消耗.本文主要通过react代码来描述如何实现一个简单的虚拟列表,在实际的生产环境还是推荐使用比较成熟的包,例如react-virtualized.在最后分享下自己在工作中的一点想法.</p>\n<h2>虚拟列表的简单实现</h2>\n<p>使用虚拟列表的前提是容器的高度是固定的,渲染的每个条目的高度也是相对固定的,这样就能计算出容器能渲染出的条目.下面是页面的结构:</p>\n<pre><code>import React, { Component } from 'react';\nconst allData = Array(1000).fill({ title: 'sss' }); //所有的渲染条目\nconst styles = {\n  container: {   // 外层容器样式\n    height: '400px',\n    border: '1px solid black',\n    position: 'relative',\n    overflow: 'auto',\n  },\n  openContainer: {  // 容器内通过定义一个空元素 高度为所有条目的高度,撑起父元素显示滚动条\n    position: 'absolute',\n    height: allData.length * 40 + 'px',\n    left: 0,\n    right: 0,\n    top: 0,\n    zIndex: -1,  //显示在列表条目下面\n  },\n  listContainer: {  // 列表容器\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    top: 0,\n  },\n  listItem: {  // 列表条目\n    height: '40px',\n    lineHeight: '40px',\n  },\n}\nclass VirtualList extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      visibleData : [],  // 实际显示的条目\n      visibleCount: 0,   // 显示的数据\n      start: 0,  // 显示条目的起始位置\n      end: 0,  //   \b显示\b条目的末位置\n      itemHeight: 40, // 条目的高度\n    };\n  }\n  render() {\n    return (\n    &#x3C;div>\n      &#x3C;div\n        ref={container => this.container = container} // 外层容器\n        onScroll={(e) => {this.scrollHandle(e)}}\n        style={styles.container}\n      >\n        &#x3C;div style={styles.openContainer}>&#x3C;/div> // 撑起父容器,父元素展示滚动条\n        &#x3C;div\n          style={styles.listContainer}   // 列表容器\n          ref={listContainer => this.listContainer = listContainer}>\n            {this.state.visibleData &#x26;&#x26; this.state.visibleData.map((item, index) => (\n            &#x3C;div \n              key={index}\n              style={styles.listItem}\n            >\n              {item.title}\n            &#x3C;/div>))}\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>);\n  }\n}; \n</code></pre>\n<p>接下来在组件挂载的时候,\b计算出\b\b\b容器可以显示的列表条目和初始显示的数据</p>\n<pre><code>componentDidMount() {\n    const visibleCount = Math.ceil(this.container.clientHeight / this.state.itemHeight); // 计算实际应该显示的条目数\n    const end = this.state.start + visibleCount; // 计算位置\n    const visibleData = allData.slice(this.state.start, end);  // 计算应该展示的条目\n    this.setState({ end, visibleCount, visibleData }); // 更新状态\n  }  \n</code></pre>\n<p>在父容器绑定滚动事件,在滚动列表的时候,计算实际需要渲染的条目并且列表的位置.</p>\n<pre><code>scrollHandle(e) {\n    const scrollTop = this.container.scrollTop;\n    const fixedScrollTop = scrollTop - scrollTop % this.state.itemHeight;  // 计算到父容器顶部的距离\n    this.listContainer.style.webkitTransform = `translate3d(0, ${fixedScrollTop}px, 0)`;  // 移动列表\n    const start = Math.floor(scrollTop / this.state.itemHeight);\n    const end = start + this.state.visibleCount;  \n    const visibleData = allData.slice(start, end); // 重新计算需要显示的元素\n    this.setState({ start, end, visibleData }); // 更新状态\n}\n</code></pre>\n<h2>一些想法</h2>\n<p>在最近学习和工作的思考中,产生了几个想法:</p>\n<ol>\n<li>学习是一个需要渐进坡度的过程.在我刚开始工作的时候,自己还没有接触react并且对MVVM等概念也不是很明确.\b在对一些类库的\b使用之后比自己之前直接去看相应的文章更加能理解文章的意图.学习的\b\b坡度\b最好是渐进的.</li>\n<li>在工作上,在完成业务要求的时候的同时个人应该有更多的思考.让自己有一个正向的工作模式.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/14b5013e441a414126d7d5ce364726a9/20785/work.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHElEQVQoz02S246DMAxE+f+/6xNIfaiAUhAtlHArd6/OSFkFyXKYjO2M7eg4DjvP04ZhMOecfNd1Bt62rdV1be/32/q+t3EcxcHg7Ptu3+9XMXCnabKIZAR/Ph9dQCA4z3NL09Sez6eScn48HkoEt6oqYa5z4oNRMKLKPM8iQCahr9o0jbwvRBCe13AmERxejIppnCzioixLkXjpuq6Scl2X/Lqswnxrtm2TcRf+Y8d+WETmoihUkQ8iwT6hN4LP4/xPFhYNMUn+/X7q2f1+tyRJ1LOhHyQDiXjagbxQMkPAc+dlaygYsuM4ttvtZlVZWZZlGgi9fb1eOoOREIyi4L4ofQaPwrWBhNFs8HBVlmXR8MC0Yp2TZL9qfnB/0aNjqAd6ymQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"how to work\"\n        title=\"how to work\"\n        src=\"/blog/static/14b5013e441a414126d7d5ce364726a9/00d43/work.png\"\n        srcset=\"/blog/static/14b5013e441a414126d7d5ce364726a9/63868/work.png 250w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/0b533/work.png 500w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/00d43/work.png 1000w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/20785/work.png 1307w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","frontmatter":{"date":"2019-02-24","path":"/virtual-list","title":"虚拟列表的简单实现"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}