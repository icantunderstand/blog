{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2024-4-1",
    "result": {"data":{"markdownRemark":{"html":"<h2><a href=\"https://github.com/tc39/proposal-iterator-helpers\">proposal-iterator-helpers</a></h2>\n<p>tc39增加了迭代器helpers函数的proposal.已经到了Stage 3阶段。通过这些迭代函数可以很方便的对迭代器进行处理。比如</p>\n<pre><code>    function* naturals() {\n        let i = 0;\n        while (true) {\n            yield i;\n            i += 1;\n        }\n    }\n\n    const result = naturals()\n    .map(value => {\n        return value * value;\n    });\n    result.next(); //  {value: 0, done: false};\n    result.next(); //  {value: 1, done: false};\n    result.next(); //  {value: 4, done: false};\n</code></pre>\n<h2><a href=\"https://github.com/proposal-signals/proposal-signals\">proposal-signals</a></h2>\n<p>tc39增加了signals的proposal。现在是Stage 0阶段。在<a href=\"https://www.solidjs.com/\">solidjs</a>中就有对signals的封装和使用。通过signals可以一定程度上简化在业务逻辑中的依赖关系覆盖和监听逻辑。</p>\n<h2><a href=\"https://itnext.io/frontend-development-beyond-react-svelte-1-3-f47eda22cba5\">Frontend Development Beyond React: Svelte</a></h2>\n<p>这篇文章介绍Svelte的基本原理和相关使用。对比react，Svelte的没有虚拟dom、有编译时优化、响应式更加高效。React也在编译时优化做尝试，React Compiler已经在instagram有使用</p>\n<h2><a href=\"https://www.lydiahallie.com/blog/promise-execution\">JavaScript Visualized: Promise Execution</a></h2>\n<p>这篇文章通过动图的方式介绍JavaScript中Promise的执行过程</p>\n<h2><a href=\"https://romgrk.com/posts/react-functional-components/\">The problem with functional components</a></h2>\n<p>在之前的文章中<a href=\"https://icantunderstand.github.io/blog/thinking-in-react\">聊聊我对React Hooks的理解</a>中,梳理了对react引入hooks的理解</p>\n<ul>\n<li>通过的代码复用方式</li>\n<li>解决老的问题 比如生命周期函数可能存在多次调用、组件内监听解绑逻辑分离</li>\n<li>规范使用范式</li>\n</ul>\n<p>这篇文章的作者通过例子说明在使用函数组件的一些问题，比如hooks很多缺少治理，hooks的依赖问题，代码可读性问题等。对于这个问题的确在react中没有强制的一些限制解法。自己在开发中也遇到一个组件多个useState声明造成代码可读性下降的问题。对于函数组件的hooks它更应该是可插拔的复用能力或者偏向于与组件结合的业务逻辑，一些数据或者非视图层逻辑应该做到更好的拆分.</p>\n<h2><a href=\"https://miaomiaozhenren.com/index.php/2023/01/20/dynamic-form/\">动态表单的设计思想及实现策略</a></h2>\n<p>这篇文章主要介绍动态表单的设计思想，在中后台系统的一些表单项是可以通过动态表单来实现的。</p>\n<h2><a href=\"https://web.dev/articles/bfcache?ref=sabatino.dev&#x26;hl=zh-cn\">bfcache</a></h2>\n<p>浏览器的往返缓存，在一些特定场景需要针对bfcache做处理逻辑</p>\n<h2>工具</h2>\n<h3><a href=\"https://bun.sh/blog/bun-v1.1\">Bun</a></h3>\n<p>Bun现在支持windows了，Bun选择的JavaScript执行引擎和实现语言使得Bun有一定的性能优势，值得尝试</p>\n<h3><a href=\"https://github.com/yocontra/react-responsive\">react-responsive</a></h3>\n<p>一个用于在react代码中做媒体查询实现动态逻辑的库。在阅读源码的过程中发现它使用了css-mediaquery实现静态查询的匹配</p>\n<pre><code>    var mediaQuery = require('css-mediaquery');\n    \n    var isMatch = mediaQuery.match('screen and (min-width: 40em)', {\n        type : 'screen',\n        width: '1024px'\n    });\n</code></pre>\n<p>使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia\">window.matchMedia</a>做动态的查询变更通知能力</p>\n<h3><a href=\"https://previewjs.com/\">Preview.js</a></h3>\n<p>Previerw.js可以实现一些UI组件的预览，可以实现动态属性修改的预览、控制台的console输出、不同设备下查看样式等</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/astoilkov/use-local-storage-state\">use-local-storage-state</a></h3>\n<pre><code>    import useLocalStorageState from 'use-local-storage-state'\n\n    export default function Todos() {\n        const [todos, setTodos] = useLocalStorageState('todos', {\n            defaultValue: ['buy avocado', 'do 50 push-ups']\n        })\n    }\n</code></pre>\n<p>在之前的<a href=\"https://icantunderstand.github.io/blog/window-message\">聊聊页面间的通信机制</a>中有介绍到localStorage可以实现跨Tab的消息通信，在前端的数据存储中localStorage是一种常用的前端存储方案，use-local-storage-state这个库实现了数据的存储和数据的变更通知，下面分别从这两个点看下具体实现</p>\n<h3>数据存储</h3>\n<pre><code>try {\n    // 支持localStorage的时候使用localStorage存储\n    localStorage.setItem(key, stringify(value))\n    inMemoryData.delete(key)\n} catch {\n    // 不支持localStorage的时候使用内存对数据存储\n    inMemoryData.set(key, value)\n}\n</code></pre>\n<h3>数据变更通知</h3>\n<pre><code>   const value = useSyncExternalStore(\n    useCallback(\n        (onStoreChange) => {\n            const onChange = (localKey: string): void => {\n                if (key === localKey) {\n                    onStoreChange()\n                }\n            }\n            // callback注入，当onStoreChange执行 会触发页面更新\n            callbacks.add(onChange)\n            return (): void => {\n                callbacks.delete(onChange)\n            }\n        },\n        [key],\n    ),\n    () => {\n        // 通过ref存储当前的值 返回\n    },\n    () => defaultValue,\n)\n\nuseEffect(() => {\n    // 当不需要通知同步的时候直接返回\n    if (!storageSync) {\n        return undefined\n    }\n    const onStorage = (e: StorageEvent): void => {\n        if (e.storageArea === goodTry(() => localStorage) &#x26;&#x26; e.key === key) {\n            triggerCallbacks(key)\n        }\n    }\n    // 订阅storage 触发更新回调\n    window.addEventListener('storage', onStorage)\n\n    return (): void => window.removeEventListener('storage', onStorage)\n}, [key, storageSync])\n</code></pre>","frontmatter":{"date":"2024-04-15","path":"/2024-4-1","title":"2024-4-第一期"}}},"pageContext":{"readingTime":"6 min read"}},
    "staticQueryHashes": []}