{"componentChunkName":"component---src-templates-index-js","path":"/2","result":{"pageContext":{"pageAllCount":90,"allPage":[{"id":"6b14bd4d-1cc8-57ef-b81a-bdbe405e6d96","html":"<h2>1.0 - 2017-02-25</h2>\n<blockquote>\n<p>在这里记录下学习前端的过程。最近在博客园写自己之前的博客的时候，发现自己不是很善于描述东西，也发现博客园的书写体验没那么好，之前一直想弄一个这样的博客，这就算成型了。<br>\n希望通过这个博客来锻炼自己表达的能力同时起到督促自己目的。</p>\n</blockquote>\n<h2>2.0 - 2021-04-08</h2>\n<p>看到这个文档上次的修改记录已经是三年之前了,个人的博客在三年中有一直保持更新(虽然频率上😢不高).应该在去年建了一个公众号-前端小板凳和掘金账号.\n小板凳的初衷是我能跟大家一起坐在板凳上一起学习进步(我要是在胖下去 小板凳要变成大板凳了➳♥゛扎心),最近重新理了下思路以后小板凳和这个博客会主要以如下的内容进行更新(虽然搞不好哪天就不更了).\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVQ4y4WTW27bMBBFvfkC/elG0gL96Bby0zU0sRtbUiQ/JFKkxJfEU4iObSmNWwIEyBnO697LFW8rxpj2tNpWUdc1LoDqHFVVkRcFzrnr2/cxl/vqYjw7IsbB/nAiz3M6C6I1PK/XlGVFCOFuosv9lvDNaf3s4dStNuz3e6x1DMNACMMiwbIhWL2v0jvIipL1ek3bR6qjZrPZIISkrhuU1peARZezkWEYIQyRYTwn9D7gncMH6I1HqXYRNHU6xsg4jmnPu12dB7tVcn5ZWXeGXZahdYcNUJZ7mkYyRJCtQgix7FCbyLfHyMNj5MfPiOwhL0q2ux2diXQmIKXAOo/1E2EHXssDjdDkecHLy5bT6cQwjmcMawWfHuDz18iX75FGwzAEvPcJiq63STbWj3Q2opRCa40xPcbYhOkks/GSkAWnERfmcoBWTSwfkmTOmC2J+ICUmACegqfzpL3itSLLdigDeSkTy00jrlqdS+Uv2dwM5yrGRYx1WGsSZrXoF8D/V9hz45R1+inGWpzzyS6k4tfTE1LKNLa19orX3a83d04jZ3nJ8+Y3ou2RsuV4PNI0TQK/ESIRdjfh0hETs3Uj2G53lFX1TwI+GvkP6qVFIVq+nLwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"技术路线\"\n        title=\"技术路线\"\n        src=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png\"\n        srcset=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/63868/road.png 250w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/0b533/road.png 500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png 1000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/aa440/road.png 1500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/e8950/road.png 2000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png 2270w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>前端基础</h3>\n<ol>\n<li><a href=\"https://html.spec.whatwg.org/#toc-browsers\">HTML Standard</a> html标准</li>\n<li><a href=\"https://tc39.es/ecma262/\">javascript标准</a></li>\n<li>网络基础知识</li>\n</ol>\n<h3>前端框架</h3>\n<ol>\n<li>react</li>\n<li>前端状态管理(redux, hook, Mobx)</li>\n<li>next.js</li>\n<li>webpack</li>\n</ol>\n<h3>横向技术</h3>\n<ol>\n<li>跨端(端)技术</li>\n</ol>\n<ul>\n<li>跨端技术 flutter taro</li>\n<li>端技术 Android/ IOS</li>\n</ul>\n<ol start=\"2\">\n<li>服务端技术</li>\n</ol>\n<ul>\n<li>node.js egg.js(如何构建一个高可用的服务端系统)</li>\n<li>go</li>\n</ul>\n<h3>解决方案</h3>\n<ol>\n<li>微前端方案</li>\n<li>离线化(预加载)</li>\n<li>拆包</li>\n<li>骨架</li>\n<li>服务端渲染</li>\n</ol>\n<h3>工程化</h3>\n<ol>\n<li>服务部署运维(docker Kubernetes)</li>\n</ol>\n<h3>思考(做事方式)</h3>\n<p>这里会记录一些思考,会随着自己的认知定期修改这部分内容.一些内容会沉淀成记录\n要从把事做完到做好到做广.</p>\n<ol>\n<li>数据 => 业务</li>\n<li>做好监控(用户行为 异常监控)</li>\n<li>如何能做到业务技术两手抓</li>\n<li>探索推进业务的方式(往前看 多聊, 视角的切换(长期短期 用户视角))</li>\n<li>先想好在做 别急 这点不容易</li>\n</ol>\n<p>希望2.0版本能把我们的知识串成一个网,一起把事做好.希望事情会因你不同.</p>\n<h2>3.0-2022-04-12</h2>\n<p>距离上次更新这个文档差不多刚好一年的时间，博客的内容也大致按照之前2.0版本的内容在更新(万幸没有断更)。3.0版本的内容会在2.0的基础上更加<strong>系统化</strong>。这里对3.0版本的内容做下diff:</p>\n<ul>\n<li>形式上会结合做过的事或者看过的内容，结合自己的想法总结和输出(虽然有些想法比较基础和简单)，也是想在自己这边能把一些东西揉碎想明白的一种尝试，现在主要有以下两种方式:\n<ol>\n<li><a href=\"https://icantunderstand.cn/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\"><strong>前端快报</strong></a>收录近期阅读的前端技术类文章，月维度更新</li>\n<li><a href=\"https://icantunderstand.cn/%E8%AF%BB%E4%B9%A6%E7%9B%AE%E5%BD%95/\"><strong>读书目录</strong></a>收录自己读过的书和阅读过程中的一些想法，采取了打分推荐的方式(有个人喜好)，根据读书进度实时更新。</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"初心","date":"2019-07-10","tags":"思考","path":"/my-heart","top":true,"summary":null},"title":"初心","date":"2019-07-10","tags":"思考","path":"/my-heart","top":true,"summary":null},{"id":"01f5df8e-fe02-530b-b203-a191cd46eebf","html":"<ul>\n<li>要有刨根问底的精神</li>\n<li>多思考这件事为什么是这样</li>\n<li>提取事物相同的模式 从更上层或者多角度去看相似的问题</li>\n<li>有深度的刻意练习才能产生提高</li>\n<li>做技术 可以从技术角度去产生技术方案也可以从用户产品视角去思考技术 不要把这两个孤立开来</li>\n</ul>\n<h2>跨端的本质</h2>\n<p>一句话概括: 如何技术手段以较低成本和较高的稳定性实现端业务的快速发展\n在讨论具体的跨端方案时，先看几个在选择跨端方案的场景</p>\n<table>\n<thead>\n<tr>\n<th>目标</th>\n<th>考量点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>动态化</td>\n<td>1. 包体积问题是一个app发展到一定阶段必定要考量的问题，也是一些大厂在内部推动跨端方案的一个核心诉求 2. 业务动态化诉求(快速迭代/动态更新)</td>\n</tr>\n<tr>\n<td>人效</td>\n<td>跨端方案可以实现一次开发多端使用，提升人效 1. 原生能力需要端接入或者端技术能力，长期需要多端技术能力 2. 多端展现存在差异，需要开发中磨平 3. 通常说跨端都从h5(动态化技术)的视角切入，h5和native不是非此即彼的关系，事是大家的</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>技术方案存在性能瓶颈，通过其他技术方案可以解决性能问题，优化业务体验</td>\n</tr>\n<tr>\n<td>技术基建能力</td>\n<td>1. 技术储备 2. 业务在不同技术方案下探索(小程序)</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"想法片段总结","date":"2020-12-21","tags":"思考","path":"/idea","top":true,"summary":null},"title":"想法片段总结","date":"2020-12-21","tags":"思考","path":"/idea","top":true,"summary":null},{"id":"b291531c-f09d-5949-920b-5523a387a6ab","html":"<h2><a href=\"https://frontendmastery.com/posts/rethinking-react-best-practices/\">Rethinking React best practices</a></h2>\n<p>这篇文章介绍React发展的过程，从SPA的方式开始，讲述SPA存在的一些问题，然后React在服务端有一些尝试为了解决SPA的问题，引入Suspense、流式渲染、React Server Component等。在文章开头对软件开发中的问题的描述很有意思: 人的问题&#x26;技术的问题。非常不错的文章</p>\n<h2><a href=\"https://www.jvandemo.com/a-10-minute-primer-to-javascript-modules-module-formats-module-loaders-and-module-bundlers/\">A 10 minute primer to JavaScript modules, module formats, module loaders and module bundlers</a></h2>\n<p>这篇文章简要的介绍了JavaScript中模块的发展历史，包括IIFE、AMD、CMD、UMD、System.register、ES6模块等</p>\n<h2><a href=\"https://www.honeybadger.io/blog/javascript-regular-expressions/\">Regular expressions in JavaScript</a></h2>\n<p>这篇文章介绍JavaScript中的正则表法式，详细的介绍了正则表达式的创建、使用、匹配等</p>\n<h2><a href=\"https://www.bbss.dev/posts/eventloop/\">Practical Guide To Not Blocking The Event Loop</a></h2>\n<p>文章通过在node服务器中一个长时间执行任务阻断后续请求的例子来讲解如何防止阻塞时间循环，文中的配图通俗易懂\nwoqu</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/FormidableLabs/react-live\">react-live</a></h3>\n<p>一个实现预览react组件代码的库</p>\n<h3><a href=\"https://webcontainers.io/\">Dev environments.In your web app</a></h3>\n<p>可以在浏览器环境中运行node的工具</p>\n<h3><a href=\"https://shoelace.style/\">Shoelace</a></h3>\n<p>web components组件库</p>\n<h3><a href=\"https://github.com/typicode/lowdb\">lowdb</a></h3>\n<p>一个JSON存储数据库，支持在node/浏览器环境中使用</p>\n<h2><a href=\"https://github.com/hakimel/reveal.js\">reveal.js</a></h2>\n<p>一个实现网页演示文稿的工具</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2023-5-1-前端快报","date":"2023-05-01","tags":"前端快报","path":"/2023-5-1","top":null,"summary":null},"title":"2023-5-1-前端快报","date":"2023-05-01","tags":"前端快报","path":"/2023-5-1","top":null,"summary":null},{"id":"8e4245f7-613c-56fe-ba85-affb461a47c2","html":"<p>h5性能优化可以总结为如下的几个方向:</p>\n<ul>\n<li>将请求时间线上的行为提前执行</li>\n<li>将请求时间线上不紧急的后置</li>\n<li>将资源从最近的位置提供给页面</li>\n</ul>\n<p>在讨论h5加载性能的时候主要有以下角色:</p>\n<ul>\n<li>Native容器</li>\n<li>用户(开发的视角)</li>\n<li>服务端(数据 页面)</li>\n<li>h5页面</li>\n</ul>\n<p>本文会结合优化的方向从不同角色的角度总结h5优化的一些通用方案。</p>\n<h2>Native容器优化</h2>\n<ul>\n<li>Webview池 通过提前初始Webview和Webview复用降低Webview初始化时间</li>\n<li><a href=\"https://icantunderstand.cn/cross-platform-prefetch\">数据预取</a> 容器侧提供数据预取能力，提前数据加载</li>\n<li>DNS连接 容器提前建立与h5页面相同域名的DNS链接</li>\n<li><a href=\"https://icantunderstand.cn/cross-platform-offline\">离线包</a> 通过离线包可以直接加载提前下载好的本地资源展示</li>\n</ul>\n<h2>h5页面内优化</h2>\n<ul>\n<li>预连接 dns-prefetch, preconnect</li>\n<li>资源包拆分 框架和业务代码进行拆包，框架层使用更长的缓存策略来减少框架代码的请求</li>\n<li>页面资源加载 图片懒加载、路由懒加载、小图内联、模块动态加载</li>\n<li>js执行优化 缓存计算结果、WebWorker、GPU渲染、长列表优化</li>\n</ul>\n<h2>服务端优化</h2>\n<ul>\n<li>api聚合服务 前端侧可以通过一个请求聚合多个后端请求，后端在内网完成数据的聚合</li>\n<li>CDN容灾策略</li>\n<li>预渲染技术\n<ol>\n<li><a href=\"https://www.patterns.dev/posts/server-side-rendering\">SSR</a>(server-side rendering)服务端渲染,在服务端完成数据请求和html内容的生成返回给用户</li>\n<li><a href=\"https://www.patterns.dev/posts/static-rendering\">SSG</a>(static site generation)静态页面生成，SSG主要用于生成静态的网站比如博客等</li>\n<li><a href=\"https://www.patterns.dev/posts/incremental-static-rendering\">ISR</a>（Incremental Static Generation)渐进式静态内容生成，可以增量的方式在服务端生成新的内容和替换已有内容，对SSG的一种补充</li>\n<li><a href=\"https://www.patterns.dev/posts/react-selective-hydration\">Selective Hydration</a> 可选的注水 通过Suspense和pipeToNodeStream流式输入实现可选注水</li>\n<li><a href=\"https://www.patterns.dev/posts/islands-architecture\">Islands Architecture</a> 孤岛架构,可以实现静态和动态内容的分离渲染，可以对组件渲染更细粒度的控制</li>\n</ol>\n</li>\n</ul>\n<h2>用户</h2>\n<ul>\n<li>功能取舍 低端机放弃一些功能保证页面更流畅</li>\n<li>骨架屏 使用骨架屏在数据未返回时给用户更好的体验</li>\n<li><a href=\"https://blog.ihanai.com/2020/12/comparison-of-solution-for-same-layer-render.html\">同层渲染</a></li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://tech.meituan.com/2017/06/09/webviewperf.html\">WebView性能、体验分析与优化</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work\">渲染页面：浏览器的工作原理</a>\n<a href=\"https://blog.ihanai.com/2020/12/comparison-of-solution-for-same-layer-render.html\">同层渲染方案比较</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"web性能优化总结","date":"2023-03-15","tags":"跨端技术","path":"/h5-performance","top":null,"summary":null},"title":"web性能优化总结","date":"2023-03-15","tags":"跨端技术","path":"/h5-performance","top":null,"summary":null},{"id":"88a9e68d-ade0-51a0-ab18-73032ff76cd5","html":"<p>在维护大型项目的时候，随着项目功能的迭代会出现委会的一些痛点，比如</p>\n<ul>\n<li>页面打包、开发启动过程慢，模块间逻辑冗余，模块间功能依赖导致牵一发而动全身</li>\n<li>项目规范难以实行，不同模块同学开发的代码理解成本大</li>\n<li>功能和逻辑共享问题</li>\n</ul>\n<p>本文在以上问题的基础上，梳理自己对项目维护的一点思考</p>\n<h2>重新认识项目</h2>\n<p>不同的项目类型决定了项目不同的技术方案和业务发展模式，当前对项目维护上的一些决策是可以结合到当前的现状和未来的业务发展做提前规划的。比如在C端项目中会侧重于用户侧的性能和体验的探索，那么在技术方案上就会比较激进，要考虑好方案的回退等。在B端项目侧重于稳定性、功能流程的完善性，单个项目周期较长。长期项目和短期项目的思考点又有些不同。如果项目是作为服务模块提供给使用者，这个使用者可以是我们自身或者业务同事，那么就需要思考如何在不影响原有的架构模式上提供服务。</p>\n<h3>项目的组织方式</h3>\n<p>这里谈的是项目的拆分和聚合。可以通过monorepo的方式把依赖项目管理起来或者把不长维护的模块拆分出去。通用的模块拆出来进行维护，这里的拆可以是渐进的，先在项目维度进行拆分，防止过度拆分引起的后续维护问题.模块可以通过框架层面进行共享和注入。</p>\n<h3>模块之间的解耦(分层、共享)</h3>\n<p>代码不好维护有一定程度上跟模块的治理有关，模块间没有更好的做好分层，功能的拆分，就会导致业务逻辑分散，功能不聚合。\n在前端应用中，要思考业务、数据逻辑与视图逻辑的拆分</p>\n<h2>项目的规范(项目中的人)</h2>\n<p>项目中的规范是比较难实行的，比如设计到代码书写方式上的问题，不同人的理解真的很大不同，对于这部分应该要认可人之间的不同，在项目中建工具化的规范，通过工具去限制人的行为。比如lint 规范、大文件拆分、核心代码注释，尽可能通过框架去限制不合理的代码操作,这里举个例子比如项目中涉及到静态图片的展示，大图对用户的代码和体验都有损失，那么就可以通过编译时脚本来检查图片资源目录，当出现大图文件时中断编译或者通知。</p>\n<p>代码是与机器交互的语言,也是开发者之间交流的一种方式.之所以要提倡编写可维护的代码是希望在同一个团队中形成统一的方言.这种独特的方言要在一定程度上提高开发的效率(不好的方言有可能降低开发效率).也许团队这段时间会使用这种方言,过段时间会换另一种方言.自己的建议是多思考,多想想方言之间的不同,为什么这种模式会适应现在的场景,慢慢的你就会建立一种你自己的方言或者思考问题的方式.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.im/post/5b3ae175f265da63252c2f21\">代码质量与规范，那些年你欠下的技术债</a><br>\n<a href=\"https://www.zhihu.com/question/20017545\">好的提高代码质量的方法有哪些</a><br>\n<a href=\"https://overreacted.io/zh-hans/goodbye-clean-code/\">Goodbye, Clean Code</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"在聊维护项目的时候我们在聊什么","date":"2023-03-08","tags":"工程化","path":"/organize-code","top":null,"summary":null},"title":"在聊维护项目的时候我们在聊什么","date":"2023-03-08","tags":"工程化","path":"/organize-code","top":null,"summary":null},{"id":"1a5c275d-51a1-5b48-a911-e35eefd0ce40","html":"<h2><a href=\"https://dev.to/codux/experiments-with-the-javascript-garbage-collector-2ae3\">Experiments with the JavaScript Garbage Collector</a></h2>\n<p>这篇文章通过一些demo例子来理解JavaScript的垃圾回收</p>\n<h2><a href=\"https://martinfowler.com/articles/modularizing-react-apps.html\">Modularizing React Applications with Established UI Patterns</a></h2>\n<p>模块化、业务逻辑与视图分离是构建可维护性强应用的一些基础方式，这篇文章通过例子来说明模块化、抽象化的过程。仔细阅读有收获</p>\n<h2><a href=\"https://deno.com/blog/you-dont-need-a-build-step\">You Don't Need a Build Step</a></h2>\n<p>这篇文章通过前端代码的编译引出<a href=\"https://fresh.deno.dev/\">fresh</a>这个框架，fresh支持实时的编译和转换，现在已经有10k+的star,值得关注</p>\n<h2><a href=\"https://betterprogramming.pub/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42\">All JavaScript and TypeScript Features of the last 3 years</a></h2>\n<p>这篇文章介绍JavaScript和TypeScript最近三年的一些features,这里主要整理下avaScript的一些新features.\nES2020: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">可选链</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">空值合并运算符</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\">Promise.allSettled()</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\">globalThis</a><br>\nES2021: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\">String.replaceAll()</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\">Promise.any</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment\">逻辑空赋值</a><br>\nES2022: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await#%E5%9C%A8%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8_await\">Top level await</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn\">hasOwn</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-starter/\">How to start a React Project in 2023</a></h2>\n<p>之前关于react项目的starter工具引发了一波讨论，这篇文章介绍了(Vite)[<a href=\"https://vitejs.dev/%5D%E3%80%81(Next)%5Bhttps://nextjs.org/%5D%E3%80%81\">https://vitejs.dev/]、(Next)[https://nextjs.org/]、</a><a href=\"https://astro.build/\">Astro</a>作为React项目初始化的优点和缺点</p>\n<h2><a href=\"https://react.dev/\">React</a></h2>\n<p>react最新的文档站点，文档在入门的介绍上和api的查看上相对之前的文档站都有一定的提升</p>\n<h2>工具</h2>\n<h2><a href=\"https://github.com/vadimdemedes/ink\">ink</a></h2>\n<p>一个可以在命令行中写React代码的工具库</p>\n<h2><a href=\"https://github.com/lucaong/minisearch\">MiniSearch</a></h2>\n<p>MiniSearch是一个实现搜索功能的库,他运行在内存中，有模糊搜索等能力，在博客的站点上试用了一下感觉还不错</p>\n<h2><a href=\"https://github.com/rogchap/v8go\">v8go</a></h2>\n<p>用Go语言执行javascript</p>\n<h2><a href=\"https://github.com/microsoft/playwright\">playwright</a></h2>\n<p>Playwright是一个微软出品的web测试和自动化工具，github上的star已经49k</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2023-3-1-前端快报","date":"2023-03-01","tags":"前端快报","path":"/2023-3-1","top":null,"summary":null},"title":"2023-3-1-前端快报","date":"2023-03-01","tags":"前端快报","path":"/2023-3-1","top":null,"summary":null},{"id":"e3ace596-3e3b-503f-9749-e050e7ba90aa","html":"<p>在聊关于价值的一点想法之前，请让我介绍一部我喜欢的电影作为引子-Once upon a time in America(美国往事)。我微信的昵称是noodles，也是因为这部电影。</p>\n<p>美国往事是一部讲述美国20世纪60年代生活的犯罪电影，主角noodles(面条)在街区中结识了一群小伙伴，最开始过着调皮捣蛋的快乐生活，随着新搬来的邻居Max(麦克斯)的到来，大家逐渐去做一些犯罪和帮派的活动，在剧情不断发展中，跟随noodles经历了童年的欢乐、青涩的爱情、友情、遗憾、无奈。在'生意'逐渐做大的时候，他们一伙人想要铤而走险，noodles为了挽救他们的生命，选择了举报他们的行动，结果行动被破坏但是伙伴们都死于那次举报。noodles抱着悔恨远走他乡。多年以后，一封信把noodles叫回了故乡，此时的noodles已经头发发白，岁月在他身上有了明显的痕迹。这次他遇到了之前痛而不得的爱人，也遇到了自己的老友-Max.原来Max在之前的行动中做了个局，在那次行动中，Max并没有死而noodles被迫远走之后，Max占据了大家一起打拼的事业，‘一帆风顺’当上了部长。Max此时已经无法自保，他想向noodles坦白自己之前做的事，让noodles了结他的生命。印象中深刻的台词就这里发生了，当Max坦白，noodles却不愿意拿枪杀死他，画面切回了之前他们一起经历的快乐时光。noodles说: it`s just the way i see things(这是我对人生的看法)，I hava a story alse(我也有一个关于你说的故事)。在noodles讲述的故事中他因为自己的举报导致挚友去世感到悔恨一生，但是他们之间有真挚的友谊。最后nodles走之间对Max说希望调查的结果没有问题，否则一生的忙碌到最后没有结果很遗憾。最后Max自杀，电影闪回了noodles去烟管吸烟的场景，最后电影定格在noodles的笑容中。</p>\n<p>最近看了好几遍电影的后面部分，还是有些理解不好nooldes最后的笑容，不过渐渐地理解noodles的: I hava a story alse(我也有一个关于你说的故事).也许人生的价值或者意义就在于我们的看法。同样的人生也会因为看法不同导致感受。</p>\n<p>----一个长的引子的分割线----</p>\n<h2>什么是价值</h2>\n<p>亚里士多德将生活分为三类：动物式的生活，政治的生活和沉思的生活。</p>\n<ul>\n<li>动物式的生活指受到动物本能的指引，在缺少理智的参与下，过着无节制的生活</li>\n<li>政治的生活指人具有社会属性，可以放弃一些动物的本能去追求荣誉、善</li>\n<li>沉思的生活指通过思考达到精神的愉悦状态</li>\n</ul>\n<p>我理解在对这三种生活划分的时候，是没有贬义的，因为我们都或多或少的因为生活的阶段、能力的限制在间插似的体验不同的生活。在这个过程中不可避免的会对我们做的事，过的生活进行思考。这里其实就引入了价值的思考。如果生活的最终目的是幸福，当然这个幸福是相对的主观的。也许一个人的幸福是到老了回忆起年轻的一个蠢事或者儿孙满堂或者家缠万贯，幸福的定义虽有不同却大致相似。那价值就是那些拓宽我们关于幸福定义的事。</p>\n<h2>追求价值的方式</h2>\n<p>在去年开始相对集中的阅读，因为觉得自己在好像还看不明白一些事也想不明白。最近在看张维迎《经济学原理》一书中引发了我对价值这个问题的思考。在经济学中有个概念叫-生产可能性边界，用来表示经济社会在既定资源和技术条件下所能生产的各种商品最大数量的组合。这里可以用这个边界来类比幸福的范围.那我们生活的目标就集中在如何扩大幸福的边界和范围了。<br>\n我想年龄的焦虑一个主要的原因可能是在可见的未来能预测到幸福的边界会收缩，比如职场的35岁年龄焦虑，认为在未来年龄不在具有竞争力，那幸福的面积就可预测的缩小了。所以我理解追求幸福其实就是个逐步的拓宽边界的行为。这个行为可以很简单，比如早起、多运动、多陪伴家人。也可以相对复杂，比如创办一个家乡企业、写一本有意思的书。也可以比较抽象，比如在夏天的时候做个清凉的白日梦、在冬天的时候听听雪。</p>\n<h2>价值的相对性</h2>\n<p>说到底人生经历的事情还是自己和最亲密的人一起经历的，那价值就有很强的主观性，如果一直想让自己适应社会的价值想法会一直处于比较较劲的状态。不过关于价值这个问题自己也没有想的特别明白，也希望自己能一直想想这个问题。也希望跟看到这里的你一起想好这个问题，也许当有天有人带着鄙夷的语气问你生活的价值和意义的时候，你会告诉他: I hava a story alse(我对人生有不同的看法)</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"关于价值的一点想法","date":"2023-02-26","tags":"思考","path":"/thought-about-value","top":null,"summary":null},"title":"关于价值的一点想法","date":"2023-02-26","tags":"思考","path":"/thought-about-value","top":null,"summary":null},{"id":"4aeddc08-5bbe-5228-a3e4-90e1eae191bd","html":"<h2><a href=\"https://www.builder.io/blog/structured-clone\">Deep Cloning Objects in JavaScript, the Modern Way</a></h2>\n<p>structured-clone是在结构化克隆算法的基础上实现的克隆方案。结构化克隆算法会有一些限制:</p>\n<ul>\n<li>Function对象和DOM节点是不能被结构化克隆算法复制,会抛出DATA_CLONE_ERR</li>\n<li>对象的某些特定参数也不会被保留,比如RegExp 对象的 lastIndex 字段不会被保留、属性描述符、原型链上的属性等</li>\n</ul>\n<p>对比几种clone方案:</p>\n<ul>\n<li>对象扩展符和Object.assign不能实现深克隆</li>\n<li>JSON.parse(JSON.stringify(x))  JSON.stringify无法处理循环引用数据、丢失内置类型(Map/Set/Date/Symbol等)、无法复制函数</li>\n<li>cloneDeep是一个比较成熟的方案，但是它的包体积有点大材小用(在平时的使用中其实很少用到那么复杂结构的数据)</li>\n</ul>\n<h2><a href=\"https://jakearchibald.com/2023/unhandled-rejections/#unhandled-rejections-are-problematic\">The gotcha of unhandled promise rejections</a></h2>\n<p>这篇文章介绍for wait中unhandled promise的处理方式</p>\n<h2><a href=\"https://blog.codeminer42.com/everything-you-need-to-know-about-concurrent-react-with-a-little-bit-of-suspense/\">Everything you need to know about Concurrent React (with a little bit of Suspense)</a></h2>\n<p>这篇文章介绍React Concurrent mode.通过例子引入Concurrent mode中高优先级和低优先级任务的处理，比较生动。</p>\n<h2><a href=\"https://www.macarthur.me/posts/options-for-removing-event-listeners\">You’ve Got Options for Removing Event Listeners</a></h2>\n<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/axios-cancel\">axios的cancel功能源码解读</a>中axios已经AbortController来实现请求的终止，这篇文章中介绍了使用AbortController实现网页中元素绑定事件的移除</p>\n<h2><a href=\"https://deno.com/blog/the-future-of-web-is-on-the-edge\">The Future of the Web is on the Edge</a></h2>\n<p>这篇文章简单介绍Serverless的概念，可以结合<a href=\"https://juejin.cn/post/6996271746898722830\">为什么我不使用Serverless</a>，<a href=\"https://www.zhihu.com/question/506704568\">如何评价无服务器计算（serverless）的未来前景？你认为 serverless 有未来吗？</a>进一步了解Serverless</p>\n<h2>工具</h2>\n<h3><a href=\"https://mafs.dev/\">Mafs</a></h3>\n<p>实现可交互的数学视图的React库</p>\n<h3><a href=\"https://github.com/mswjs/msw\">msw</a></h3>\n<p>一个支持在浏览器和node环境中实现Mock Server的库，在浏览器中它通过Service Worker或者通过拦截原生的fetch实现mock，在node中通过拦截器封装原生的http模块实现mock.</p>\n<h3><a href=\"https://github.com/nolimits4web/swiper\">swiper</a></h3>\n<p>移动端的swiper组件，有比较多的动效支持</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/7044934738431180830\">最新HTML规范——structuredClone深拷贝函数，能取代JSON或者lodash吗？</a>\n<a href=\"https://stackoverflow.com/questions/59694309/for-await-of-vs-promise-all\">for await of VS Promise.all</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2023-2-1-前端快报","date":"2023-02-13","tags":"前端快报","path":"/2023-2-1","top":null,"summary":null},"title":"2023-2-1-前端快报","date":"2023-02-13","tags":"前端快报","path":"/2023-2-1","top":null,"summary":null},{"id":"240f03c5-3aa3-5133-a076-80d06778e48d","html":"<p>这里记录下2023读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2023年已阅读: 14本</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>张维迎寓言经济学 岑科 傅小永 邓新华</h2>\n<h3>推荐指数 4</h3>\n<p>通过寓言比喻的方式阐述了经济学,自由市场,国企等相关观点 一些观点难免有些激进 不过需要不同的观点来冲撞才有不同的视角来看世界,推动改革.张老师对于自由市场和国企改革的想法很多,也让我对大国企和自由市场有了一些简单的思考.改革是大题,需要慢慢答,特别是在人口超规模的中国,无论如何希望还是拥有改革开放时候的魄力,能积极改进</p>\n<h2>美丽新世界 4.5 奥尔德斯·赫胥黎</h2>\n<h3>推荐指数 4.5</h3>\n<p>读过《1984》里面塑造了一个可怕和压抑的社会,但这个社会还有一些美好就是有主人公一样的角色在思考,在试图反抗\n《动物农场》则是用童话故事去反映团体中成员的无助和统治者的行为\n《美丽新世界》里面塑界了一个高度塑造的社会,有些毛骨悚然.通过作者后面的论证和文中的一些场景,似乎这样社会的某些方面已经在现实生活中发生</p>\n<h2>叫魂: 1768年中国妖术大恐慌 孔飞力</h2>\n<h3>推荐指数 4.5</h3>\n<p>作者从叫魂的一个小案件开始叙述,从社会背景多方面讲述了那段历史.其中看到了官僚制度与帝王制度的抵抗、百姓对于未知恐惧、权力的恐慌与无助</p>\n<h2>约翰·克里斯多夫 罗曼·罗兰 许渊冲译</h2>\n<h3>推荐指数 5</h3>\n<p>在初高中有段时间比较喜欢看书，在书店总能看到这本《约翰·克里斯多夫》，印象中在书架上摆放了上中下三本，深灰色的包装。当时觉得这么长的书肯定不好看。这次鼓足了气翻开了这本书，一下子就被吸引住了。罗曼罗兰对于细腻情感的把握真的很好，比较能打动人。喜欢文中对自然景色，人物性格的描写都扣人心弦。在书中跟随着克里斯多夫走完了他的一生，从最开始莽莽撞撞的小伙子到最后老年的平静，在他身上似乎总有一种火在燃烧，那朵火并没有因为年龄或者阅历而熄灭。最开始喜欢克里斯多夫不断碰壁的莽撞的性格，从德国到巴黎，中间夹杂了很多对艺术的描写。现在的我也许还不能对这些艺术的描写有那么深的领悟，只能体会到艺术或者音乐在磨难中一直陪伴着克里斯多夫。克里斯多夫还有真诚的性格，他与奥利维的友谊一直延续到他人生的终点，从现实的生活中很难发现这样的友谊当然也很羡慕这种友谊。在爱情上似乎一直都有暗线在行进，后面与葛拉齐亚的故事是有克制的爱情，那种相知多年的爱人的感觉，读起来也很温馨，推荐这本书，也许等到在成长一些在看一遍这本书会有不同的感悟</p>\n<h2>经济学原理 张维迎</h2>\n<h3>推荐指数 4.5</h3>\n<p>一直没有仔细阅读过经济学原理方面的书籍都是相对概括介绍的读物。本书系统的介绍了微观经济学和宏观经济学中的相关概念，有些知识点自己之前只是简单了解或者理解的不对都在阅读的过程中得到了深化，特别是宏观经济学中观于经济周期与经济波动的部份读起来兴趣昂然。推荐</p>\n<h2>好好告别 凯瑟琳·曼尼克斯</h2>\n<h3>推荐指数 4</h3>\n<p>本书从临终的模式开始说起，讲到对待死亡的告别方式、态度、谈论死亡的时机、对生命的预期、对生命的看法。书中的故事很有趣也很感人，作者的叙事方式感觉就像在你身边跟你讲一件熟悉的事一样。推荐这本书，能激发一些思考，对死亡的准备和人生的意义</p>\n<h2>你是你吃出来的: 吃对少生病，病了这样吃 夏萌</h2>\n<h3>推荐指数 3.5</h3>\n<p>对饮食跟身体的关系有了全新的认识，书的内容不错从营养素的介绍到缺乏对应营养素身体的反应都讲解的通俗易懂。适合快速翻阅</p>\n<h2>理想国 柏拉图</h2>\n<h3>推荐指数 4</h3>\n<p>理想国是论证一个理想的城邦或者国家应有的样子，包括教育、统治者、人的行为等。通过对话辩论的方式阐释观点，其中会有些晦涩难懂或者绕的方式。不过并没有掩盖书中的一些重要的观点。</p>\n<ul>\n<li>要注重身体各部分的感受，感受身体和灵魂</li>\n<li>感受事物的真实，对观察思考</li>\n<li>要有求知欲，去看更广阔的世界</li>\n<li>精力有限，要追求更‘好’的欲望</li>\n</ul>\n<h2>芯片战争 余盛</h2>\n<h3>推荐指数 4</h3>\n<p>因为在A股有投资半导体企业所以通过这本书来了解半导体整个行业的背景和现状。书中详细的介绍全球半导体的发展过程。日本半导体的崛起和衰落、韩国半导体的崛起、荷兰的阿斯麦尔的发展过程读起来都饶有兴致。书中对于中国半导体行业的发展介绍的也很详细。让我了解到了一些中国半导体的至暗时刻，也看到国内半导体行业为突破技术封锁的尝试。作为一本介绍半导体行业的书本书通俗易懂，故事性强，推荐阅读。</p>\n<h2>农民笔记 候永禄</h2>\n<h3>推荐指数 3.5</h3>\n<p>跟着书读完作者的一生,经历了那些只在书本中的年代,书的名字是农民笔记。但是作者是一个有知识、思考、坚持的人,在那些年代很不容易.很感谢这本书让那些年代的记忆鲜活了，也让我意识到在自己的内心中有坚持也能过好一生</p>\n<h2>一个无政府主义者的意外的意外死亡 达里奥·福</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过剧本的方式呈现生动有趣的故事，描述的细节很精彩感觉人物栩栩如生，推荐</p>\n<h2>蛤蟆先生去看心理医生  罗伯特·戴博德</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过这本书跟着蛤蟆先生一起成长。成长的过程在于认识自己的内心，去理解自己的情绪，摆脱过去消极的思维模式。很有意思的故事。推荐</p>\n<h2>疯人说: 精神病院医生手记 穆戈</h2>\n<h3>推荐指数 4</h3>\n<p>书的内容是讲述在精神病院中病人的故事，精神病人的故事很有意思，通过对故事了解了精神病相关的背景知识。感受最深的一点就是家庭的因素对精神病人病情影响很大。比如索引病人，其实就是这个家庭成员状态的索引，需要调整好家庭的状态病人回归家庭才能好。小说有意思的是把几个精神病人的故事连成了一个故事，这个故事的命题</p>\n<ul>\n<li>你是相信世界是不好的但怀着热情生活</li>\n<li>你知道世界不好选择无视他或者逃避它生活下去</li>\n</ul>\n<p>很有意思的小说，虽然部分剧情比较牵强，但是不影响整体，推荐</p>\n<h2>百年孤独 加西亚·马尔克斯</h2>\n<h3>推荐指数 5</h3>\n<p>记不清是第几次准备看这本书了，每次都是被开头的人物名字弄迷糊然后就放下了。这次耐下心来一周就看完了。百年孤独有故事的魔幻性、历史的厚重和轮回。在书中见证了一家人从最开始的兴旺到没落。结尾中破解了羊皮卷发现内容就是预言整个家族的事的时候很震撼。</p>\n<ul>\n<li>似乎并没有理解好文中孤独的概念。孤独是不是就是上校重复制作的小金鱼(对生活失去了理想只是让自己有事可做)或者是不想织不完的寿衣(不想面对老去的现实)。</li>\n<li>有种空虚感，文中人物故事的轮回，我们自己的人生也是否是空欢喜一场，上校会被人忘记，事实也会被篡改</li>\n</ul>\n<p>推荐，是本值得反复品味的书</p>","fields":{"readingTime":{"text":"12 min read"}},"frontmatter":{"title":"读书目录-2023","date":"2023-01-28","tags":"读书目录","path":"/book-list-2023","top":null,"summary":null},"title":"读书目录-2023","date":"2023-01-28","tags":"读书目录","path":"/book-list-2023","top":null,"summary":null},{"id":"b554705e-f1cc-52f6-ab7b-0159784362a1","html":"<h2><a href=\"https://github.com/reactwg/react-18/discussions/37\">New Suspense SSR Architecture in React 18</a></h2>\n<p>这篇文章介绍react 18中流式渲染和Suspense的结合，实现更好的服务端渲染功能。相关文章还有<a href=\"https://juejin.cn/post/7064759195710521381\">浅析React 18 Streaming SSR</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍2022年热度比较高的React库</p>\n<h2><a href=\"https://developer.aliyun.com/article/781882\">一文详解 CSS-in-JS</a></h2>\n<p>这篇文章从CSS规范、CSS的设计模式说起，逐步覆盖到CSS-in-JS的细节，涉及的相关背景比较多，值得仔细阅读。</p>\n<h2><a href=\"https://weizman.github.io/page-what-is-a-realm-in-js/#identity-discontinuity\">What is a realm in JavaScript?</a></h2>\n<p>这篇文章介绍JavaScript中Realm的定义。也可以结合这篇<a href=\"https://2ality.com/2022/04/shadow-realms.html\">ShadowRealms – an ECMAScript proposal for a better eval()</a>介绍ShadowRealms API提议的文章一起了解。</p>\n<h2><a href=\"https://roadmap.sh/roadmaps/\">Developer Roadmaps</a></h2>\n<p>Developer Roadmaps收集了各个开发方向的技能路线图</p>\n<h2><a href=\"https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo\">How we configured pnpm and Turborepo for our monorepo</a></h2>\n<p>一篇比较详细的介绍monorepo技术方案选择工具的文章，从多项目开发的问题开始说起，逐步介绍<a href=\"https://github.com/pnpm/pnpm\">pnpm</a>(monorepo管理工具)和<a href=\"https://github.com/vercel/turbo\">Turborepo</a>(打包构建工具)</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart\">js-code-to-svg-flowchart</a></h3>\n<p>一个将JavaScript代码转化成svg图片的库。</p>\n<h3><a href=\"https://console-ninja.com/\">CONSOLE NINJA</a></h3>\n<p>一款VSCode插件，可以直接在代码中查看输入的console调试信息</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/shuding/react-wrap-balancer\">react-wrap-balancer</a></h3>\n<p>react-wrap-balancer能使文案比较智能的适应容器，占据容器的空间，达到比较好的展示效果，下面从源码上看它是如何实现的:\n<img src=\"/blog/9336733f998bb911bd52006bac3dd61b/blancer.gif\" alt=\"react-wrap-balancer\">\n通过简单的demo使用可以发现balancer在页面中注入了一段脚本并且为包裹的文本内容绑定的属性标识\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.399999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsklEQVQI1y3J3Y6CMBRFYd7/ySbjDx6BIkiZOjFWhFPUGAtXa6LOxUr2zpeYRYVvSqxpsbseDTNB72jfo/0V1cioAb2M+C5y6p4M44S/RI7+STdEumHi3Md3yXpZUpUtmQhbMUjWkhc7RIR0k1PbI3lh2EjB97omzR1iWpayZ7W1iHGkmeVrVVLZE0kunroJ1O5G1QSaw5Xa39mfH/zoxCFMOJ3/d+R3nHEa373s45//sj/d/dswZf2NSQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"balancer-show\"\n        title=\"balancer-show\"\n        src=\"/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png\"\n        srcset=\"/blog/static/209d5af74aebd83c377943dd2258a96b/63868/blancerShow.png 250w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/0b533/blancerShow.png 500w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png 1000w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png 1088w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>    // react-wrap-balancer的主体代码逻辑\n    const Balancer: React.FC&#x3C;BalancerProps> = ({\n        as: Wrapper = 'span',\n        ratio = 1,\n        children,\n        ...props\n    }) => {\n        // 利用useId为组件生成唯一标识，useId可以根据组件的层级结构生成唯一标识\n        const id = React.useId()\n        const wrapperRef = React.useRef&#x3C;WrapperElement>()\n        const hasProvider = React.useContext(BalancerContext)\n\n        // 监听函数执行\n        // useIsomorphicLayoutEffect这里对服务端和客户端做了区分 在服务端调用useEffect,在客户端调用useLayoutEffect 解决客户端的闪动问题\n        useIsomorphicLayoutEffect(() => {\n            if (wrapperRef.current) {\n            // 调用绑定self上绑定的动态调整函数 并传入当前的入参执行\n            // self可以指代全局的window https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n            // 主要计算逻辑都在relayout函数中\n            ;(self[SYMBOL_KEY] = relayout)(0, ratio, wrapperRef.current)\n            }\n        }, [children, ratio])\n\n        // 自己卸载的时候 终止监听函数\n        useIsomorphicLayoutEffect(() => {\n            return () => {\n                if (!wrapperRef.current) return\n\n                const resizeObserver = wrapperRef.current[SYMBOL_OBSERVER_KEY]\n                if (!resizeObserver) return\n\n                resizeObserver.disconnect()\n                delete wrapperRef.current[SYMBOL_OBSERVER_KEY]\n            }\n        }, [])\n\n        return (\n            &#x3C;>\n                &#x3C;Wrapper\n                    {...props}\n                    // 绑定的唯一标识\n                    data-br={id}\n                    data-brr={ratio}\n                    ref={wrapperRef}\n                    style={{\n                    display: 'inline-block',\n                    verticalAlign: 'top',\n                    textDecoration: 'inherit',\n                    }}\n                    suppressHydrationWarning\n                >\n                    {children}\n                &#x3C;/Wrapper>\n                {createScriptElement(hasProvider, `self.${SYMBOL_KEY}(\"${id}\",${ratio})`)}\n            &#x3C;/>\n        )\n    }\n</code></pre>\n<p>通过上面的源码分析，主要的动态计算逻辑都在relayout函数中</p>\n<pre><code>    const relayout: RelayoutFn = (id, ratio, wrapper) => {\n        // 根据id获取包裹的wrapper组件\n        wrapper =\n            wrapper || document.querySelector&#x3C;WrapperElement>(`[data-br=\"${id}\"]`)\n        // wrapper的父容器\n        const container = wrapper.parentElement\n        // 更新wrapper的最大宽度\n        const update = (width: number) => (wrapper.style.maxWidth = width + 'px')\n\n        // 重置wrapper的最大宽度\n        wrapper.style.maxWidth = ''\n\n        // 获取wrapper的父容器的宽高\n        const width = container.clientWidth\n        const height = container.clientHeight\n\n        // 二分查找的方式计算wrapper的宽度\n        let left: number = width / 2\n        let right: number = width\n        let middle: number\n\n        if (width) {\n            while (left + 1 &#x3C; right) {\n                middle = ~~((left + right) / 2)\n                update(middle)\n                if (container.clientHeight === height) {\n                    // 缩放后 高度没有变 那么right= middle\n                    right = middle\n                } else {\n                    // 否则right = middle\n                    left = middle\n                }\n            }\n\n            // 更新wrapper的宽度\n            update(right * ratio + width * (1 - ratio))\n        }\n\n        // 通过ResizeObserver去监听wrapper父容器的变化 执行relayout函数\n        if (!wrapper['__wrap_o']) {\n            ;(wrapper['__wrap_o'] = new ResizeObserver(() => {\n            self.__wrap_b(0, +wrapper.dataset.brr, wrapper)\n            })).observe(container)\n        }\n    }\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null},"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null},{"id":"284f1e7f-d1ea-5347-a1de-ee281477dfef","html":"<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/react-hooks\">React Hooks源码解读</a>中有对React hooks的实现原理进行分析，本文主要结合React hooks的发展过程聊下对hooks的理解。hooks的提出主要解决了以下的问题:</p>\n<ul>\n<li>为react带来通用的代码逻辑复用的方式。相对于render props/高阶组件(HOC)等，hooks在代码复杂度上都有一定降低。声明式的hooks使用方式也符合函数式编程的思想。</li>\n<li>解决类组件生命周期函数复杂度和在新的react架构中的一些问题</li>\n<li>规范react使用范式，通过hooks的接口能更好的组织组件与组件/组件与渲染的原生DOM/组件与外部依赖之间的关系</li>\n</ul>\n<h2>通用的代码复用方式</h2>\n<p>react中可以通过render props/高阶组件(HOC)实现代码的能力的复用(组合)。</p>\n<pre><code>// render props通过传入渲染函数的方式复用逻辑\nclass Cat extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = { name: 111 }\n        // 可复用的逻辑\n    }\n    render() {\n        // 通过调用渲染函数的方式实现共享\n        return this.props.render(this.state)\n    }\n}\nclass App extends Component {\n    render() {\n        return (\n            &#x3C;Cat render={params => (&#x3C;div>{params.name}&#x3C;/div>)} />\n        )\n    }\n}\n// 高阶组件\nfunction HOC(WrappedComponent) {\n  return class extends Component {\n    componentDidMount() {\n      // 通用的业务逻辑\n    }\n    render() {\n      return (&#x3C;WrappedComponent {...this.props} />)\n    }\n  }\n}\n</code></pre>\n<p>从render props和高阶组件的实现方式上看，两者都引入了新的组件结构来实现复用，增加了理解成本从而导致一些问题。笔者在最开始对高阶组件不熟悉的时候就遇到过一次bug。包裹的高阶组件没有将外层传递的属性透传给被包裹的组件从而导致子组件渲染异常。<br>\nhooks通过函数声明式的方式实现代码复用，理解上更符合可见可得的思想，减少了理解成本。</p>\n<h2>解决老的问题</h2>\n<p>类组件的生命周期问题导致代码逻辑的分离，比如事件的监听与解绑</p>\n<pre><code>// 类组件示例\nclass Test extends Component {\n    componentDidMount() {\n        // 监听\n        document.addEventListener()\n    }\n    componentWillUnmount() {\n        // 解绑\n        document.removeEventListener()\n    }\n    render() {}\n}\n// 函数式组件示例\nfunction Test(props) {\n    useEffect(() => {\n        // 监听\n        document.addEventListener()\n        return () => {\n            // 解绑\n            document.removeEventListener()\n        }\n    }, [])\n    return xxx;\n}\n</code></pre>\n<p>在Concurrent Mode中会导致生命周期函数的多次执行，hooks的提出在结构上是与Fiber结构绑定的，服务于新的架构的</p>\n<h2>规范使用范式</h2>\n<p>react开发者都需要用一些库(redux等)来组合应用，react通过hooks为react增加了状态管理、操作DOM的入口、父子组件调用方式等，丰富且规范了React开发者的开发模式。通过这种规范可以让React更好的与社区结合，比如相关的库<a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>、<a href=\"https://github.com/streamich/react-use\">react-use</a>。</p>\n<h2>hooks使用注意</h2>\n<ul>\n<li>避免hooks依赖，比如useMemo/useCallback等是否需要使用。使用多个useState的时候是否引入其他的管理库来解</li>\n<li>UI逻辑与业务逻辑合理拆分。hooks做过多的业务逻辑会导致业务逻辑不明晰，需要进行适当的拆分。</li>\n<li>hooks的依赖问题会导致业务中存在隐藏逻辑，需要控制代码中隐藏逻辑</li>\n<li>hooks更适合组件级别的代码复用和逻辑,跨组件逻辑需要仔细设计(比如是否需要useRef)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null},"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null},{"id":"fa80434f-17f1-5530-a3b5-0070b8a2482d","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\n    logMessage(user, message) {\n        const sender = user.getName();\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\n    }\n}\nclass User {\n    constructor(name, chatroom) {\n        this.name = name;\n        this.chatroom = chatroom;\n    }\n\n    getName() {\n        return this.name;\n    }\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\n    send(message) {\n        this.chatroom.logMessage(this, message);\n    }\n}\nconst chatroom = new ChatRoom();\nconst user1 = new User(\"John Doe\", chatroom);\nconst user2 = new User(\"Jane Doe\", chatroom);\nuser1.send(\"Hi there!\");\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\nconst books = new Map();\nconst createBook = (title, author, isbn) => {\n    const existingBook = books.has(isbn);\n    if (existingBook) {\n        // 已存在就查找返回\n        return books.get(isbn);\n    }\n    // 不存在新建返回\n    const book = new Book(title, author, isbn);\n    books.set(isbn, book);\n    return book;\n};\n//  存储书的列表\nconst bookList = [];\nconst addBook = (title, author, isbn, availability, sales) => {\n    const book = {\n        // 利用之前的共享对象创建新的实力\n        ...createBook(title, author, isbn),\n        sales,\n        availability,\n        isbn\n    };\n    bookList.push(book);\n    return book;\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\n    class OrderManager {\n        constructor() {\n            // 指令处理的对象\n            this.orders = [];\n        }\n\n        execute(command, ...args) {\n            // 匹配指令和指令处理的对象\n            return command.execute(this.orders, ...args);\n        }\n    }\n    // 指令创建类\n    class Command {\n        constructor(execute) {\n            this.execute = execute;\n        }\n    }\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\n    function PlaceOrderCommand(order, id) {\n        return new Command(orders => {\n            orders.push(id);\n            return `You have successfully ordered ${order} (${id})`;\n        });\n    }\n    const manager = new OrderManager();\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null},"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null},{"id":"7aa1bea5-0d00-517f-af8c-5522602188fe","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>观察者模式</h2>\n<p>观察者模式(发布订阅模式)是定义对象间一种一对多的依赖关系，使得当每一个被观察方改变状态，则所有依赖于它的观察者都会得到通知并自动更新。</p>\n<pre><code>// 被观察者提供观察者通知逻辑、订阅逻辑\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    // 观察者订阅入口\n    subscribe(func) {\n        this.observers.push(func);\n    }\n\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    // 通知观察者\n    notify(data) {\n        this.observers.forEach(observer => observer(data));\n    }\n}\nfunction logger(data) {\n    console.log(data)\n}\nconst observable = new Observable() \n// 订阅操作\nobservable.subscribe(logger);\n// 通知操作\nobservable.notify('this is a test!')\n</code></pre>\n<p>观察者模式的优点是可以做到逻辑的分离，做到单一职责。缺点是当观察者数目较多的时候会有性能的问题</p>\n<h2>Mixin模式</h2>\n<p>Mixin模式可以在不通过继承的方式实现为类(对象)增加复用的能力。当你需要将一个特定的feature添加到不同的类或者为类提供可插拔能力的时候可以考虑Mixin模式。</p>\n<pre><code>// 基础类 只有name能力\nclass Dog {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// mixin方法 可以为基础类提供复用的能力\nconst dogFunctionality = {\n    bark: () => console.log(\"Woof!\"),\n    wagTail: () => console.log(\"Wagging my tail!\"),\n    play: () => console.log(\"Playing!\")\n};\n// 通过方法的拷贝 在Dog的原型上就有了对象的方法\nObject.assign(Dog.prototype, dogFunctionality);\nconst pet1 = new Dog(\"Daisy\");\npet1.bark(); // Woof!\n</code></pre>\n<p>可以在mixin函数中通过指定__proto__实现mixin的继承能力</p>\n<pre><code>const sayMixin = {\n    say(phrase) {\n        alert(phrase);\n    }\n};\nconst sayHiMixin = {\n    // 设置原型 实现mixin的继承\n    __proto__: sayMixin, // (可以在这儿使用 Object.setPrototypeOf 来设置原型)\n    sayHi() {\n        // 调用父类方法\n        super.say(`Hello ${this.name}`); // (*)\n    },\n    sayBye() {\n        super.say(`Bye ${this.name}`); // (*)\n    }\n};\nclass User {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// 拷贝方法\nObject.assign(User.prototype, sayHiMixin);\n\n// 现在 User 可以打招呼了\nnew User(\"Dude\").sayHi(); // Hello Dude!\n</code></pre>\n<p>mixin模式会存在覆盖功能和增加项目代码复杂度的问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"5分钟速读系列-观察者模式/Mixin模式","date":"2022-11-03","tags":"设计模式","path":"/2022-11-observable","top":null,"summary":null},"title":"5分钟速读系列-观察者模式/Mixin模式","date":"2022-11-03","tags":"设计模式","path":"/2022-11-observable","top":null,"summary":null},{"id":"0d7eb1a7-5d60-5e0b-9b6a-2c558a43344b","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>提供者模式</h2>\n<p>提供者模式通过封装方法给予应用订阅不同数据源的能力。react中通过外层的Provider来提供全局的store，在组件内部通过useContext来获取相关的Context值。</p>\n<pre><code>    // 根组件通过Provider的value绑定全局store\n    export const ThemeContext = React.createContext();\n    const themes = {\n        light: {\n            background: \"#fff\",\n            color: \"#000\"\n        },\n        dark: {\n            background: \"#171717\",\n            color: \"#fff\"\n        }\n    };\n    export default function App() {\n        const [theme, setTheme] = useState(\"dark\");\n        function toggleTheme() {\n            setTheme(theme === \"light\" ? \"dark\" : \"light\");\n        }\n        const providerValue = {\n            theme: themes[theme],\n            toggleTheme\n        };\n        return (\n            &#x3C;div className={`App theme-${theme}`}>\n                &#x3C;ThemeContext.Provider value={providerValue}>\n                    &#x3C;Toggle />\n                &#x3C;/ThemeContext.Provider>\n            &#x3C;/div>\n        );\n    }\n    // Toggle组件\n    import React, { useContext } from \"react\";\n    import { ThemeContext } from \"./App\";\n\n    export default function Toggle() {\n        const theme = useContext(ThemeContext);\n        return (\n            &#x3C;label className=\"switch\">\n                &#x3C;input type=\"checkbox\" onClick={theme.toggleTheme} />\n            &#x3C;/label>\n        );\n    }\n</code></pre>\n<p>在React应用中通过全局的context可以解决组件属性的传递问题，便于组件的设计。但是全局Context的更新会导致消费对应Context组件的更新，造成需要不必要的渲染。这里就需要对全局Context进行更细粒度的拆分。</p>\n<h2>原型模式</h2>\n<p>JavaScript通过原型完成对象间属性的共享。通过原型能减少相同属性或者方法的创建，相同类型的实例可以共享实例原型上的属性和方法。对于原型模式需要理解几下的几点:</p>\n<ul>\n<li>\n<p>实例对象的__proto__指向构造函数的prototype(实例与原型的关系).构造函数的prototype的constructor(构造函数与原型的关系).</p>\n<pre><code>  class Dog {\n      constructor(name) {\n          this.name = name;\n      }\n      bark() {\n          return `Woof!`;\n      }\n  }\n  const dog1 = new Dog(\"Daisy\");\n  dog1.__proto__ === Dog.prototype // true\n  Dog.prototype.constructor === Dog // true\n</code></pre>\n</li>\n<li>\n<p>对象属性的获取是顺着对象__proto__沿着原型链查找，会一直查找到Object.prototype(Object.prototype.__proto__是null)</p>\n</li>\n<li>\n<p>理解new关键字中原型的处理方式，new操作符主要做了如下的操作:</p>\n<ol>\n<li>\n<p>以构造器的原型为属性创建新对象</p>\n</li>\n<li>\n<p>将新对象作为this调用构造器</p>\n</li>\n<li>\n<p>如果构造器返回的是对象则返回否则返回第一步创建的对象</p>\n<pre><code> function myNew(Con, ...args) {\n     const obj = Object.create(Con.prototype);\n     const ret = Con.call(obj, args);\n     if(ret instanceof Object &#x26;&#x26; ret !== null) {\n         return ret;\n     }\n     return obj;\n }\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"5分钟速读系列-提供者模式/原型模式","date":"2022-11-02","tags":"设计模式","path":"/2022-11-provider","top":null,"summary":null},"title":"5分钟速读系列-提供者模式/原型模式","date":"2022-11-02","tags":"设计模式","path":"/2022-11-provider","top":null,"summary":null},{"id":"25508f8f-26d3-51b4-b8a9-a50cfd7f2c5f","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>单例模式</h2>\n<p>单例模式通过全局维护一个实例的方式来达到全局属性的共享和减少内存的占用。单例的简单实现如下:</p>\n<pre><code>    let instance;\n    let counter = 0;\n    class Counter {\n        constructor() {\n            if (instance) {\n                throw new Error(\"You can only create one instance!\");\n            }\n            instance = this;\n        }\n        getInstance() {\n            return this;\n        }\n        getCount() {\n            return counter;\n        }\n        increment() {\n            return ++counter;\n        }\n        decrement() {\n            return --counter;\n        }\n    }\n    const singletonCounter = Object.freeze(new Counter());\n    // 暴露给外部的单一实例\n    export default singletonCounter;\n</code></pre>\n<p>单例模式的优点也恰恰是他的缺点，由于全局属性的共享导致改动的全局污染问题、测试用例写法问题等。在react中全局的redux\\context store就是应用中的单例，store通过单向的数据流来规避单例的一些问题。</p>\n<h2>Proxy(代理)模式</h2>\n<p>代理模式通过为对象提供占位符来控制对象的访问。代理对象相当于中间人角色，可以在不改变被代理对象的接口的情况下扩展功能。在JavaScript中可以使用Proxy来实现代理的功能。</p>\n<pre><code>    const person = {\n        name: \"John Doe\",\n        age: 42,\n        nationality: \"American\"\n    };\n    const personProxy = new Proxy(person, {\n        // handler的get/set方法代理了被代理对象属性的访问方法\n        get: (obj, prop) => {\n            console.log(`The value of ${prop} is ${obj[prop]}`);\n            // 可以用Reflect修改代理对象的属性\n            Reflect.set(obj, prop);\n        },\n        set: (obj, prop, value) => {\n            console.log(`Changed ${prop} from ${obj[prop]} to ${value}`);\n            obj[prop] = value;\n            return true;\n        }\n    });\n    personProxy.name;\n    personProxy.age = 43;\n</code></pre>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"5分钟速读系列-单例模式/代理模式","date":"2022-11-01","tags":"设计模式","path":"/2022-11-singleton","top":null,"summary":null},"title":"5分钟速读系列-单例模式/代理模式","date":"2022-11-01","tags":"设计模式","path":"/2022-11-singleton","top":null,"summary":null},{"id":"7a195122-2575-5d8d-af5a-826176974d22","html":"<p>偶然间想起2021竟然没有过来总结，恍然间发现时间过的好快。这次提前来总结下，希望年终总结能成为每年的一个思考和沉淀的习惯。</p>\n<h2>工作</h2>\n<p>近两年经历了两次工作的变动，从字节离开 => 短暂的教育行业经历(3个月) => 现在的公司(也经历过一次内部的部门调整)。仔细回想自己应该有半年多的迷茫期或者比较空闲的状态，那段时间感觉十分地缺少自信，也是循环播放Unstoppable的一段时间。</p>\n<ul>\n<li>从字节离开的时候，leader有对工作去向和内心的想法疏解，记忆最深的一句话就是不要跟系统内改变不了的东西对抗，比如架构调整之类. 现在再回头看当时自己的确没有想明白当时的问题或者自己想要什么。在离开字节之前没有好好跟合作的伙伴都打个招呼，现在想起来很不成熟。总是觉得要走就要一个人偷摸的走。如果有机会可以改之前飞书的签名，我会写: 有缘再见，不如加个V 哈哈。</li>\n<li>短暂的教育行业经历略过</li>\n<li>在当前的公司经历过一次内部的调整，有过一小段时间的“空闲”。这段时间想明白了一件事就是要让自己的状态跟环境匹配，从小事中逐步的找到做事的状态，甚至整理xlsx表格这种小事也相当认真。自己在这段\"空闲\"的时候做了一个组内前端报警的工具，自己从想法到功能设计完善了整个工具的功能，是这段时间比较有意思的事情。</li>\n</ul>\n<h3>技术能力</h3>\n<ol>\n<li>回归到B端业务的开发 自己从B端到C端又回到了B端感觉经历了一个圈。想起之前面试字节面试官问我B端业务和C端业务的区别是啥。我当时很懵(没有准备/思考过这个问题)，现在在重新尝试回答下这个问题，有可能还是比较浅显的认知，后续有新的认知在回来check</li>\n</ol>\n<ul>\n<li>面向的用户不同， 决定着同一个业务形式的在B端和C端是两套不同的技术架构和业务发展模式。在进行技术储备和规划上就需要做更多的考虑。比如广告业务，在C端侧业务是如何将广告与人结合，转化。从产品上会考虑如何原生化、样式多样性、结合转化流程的简单性、趣味性、品牌价值(平台如何给广告主带来价值)、平台价值等，业务形态上流程短、迭代节奏快。在B端上就需要为C端的业务提供完成的配套流程，业务形态上要简单好用（减轻用户的理解成本/操作成本）、功能完善等。</li>\n<li>业务形态决定技术方案的选择思考点不同。C端薄的业务可以快速的试错。新技术方案的尝试(跨端)或者欠考虑的技术实现后期都有比较大的空间可以进行业务迭代。B端由于系统是一以贯之的，需要前期相对于C端业务要更加充分的进行技术方案的对比，当然在B端和C端都会产生技术宅问题。</li>\n<li>B端和C端是可以进行良性互补。比如广告中的建站平台，就是客户侧对快，开发对效率有要求才产生的平台。</li>\n</ul>\n<ol start=\"2\">\n<li><a href=\"https://icantunderstand.cn/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\">前端快报</a> 月维度收录一些阅读的比较好的前端文章，算是对自己的一个督促。仔细考虑这一年对技术方面的学习是落后的。</li>\n</ol>\n<h3>工作心态</h3>\n<p>工作上慢慢的变的不那么急躁。从最开始的被UI支配的控制到现在改UI的时候心态很相对平静(改UI真的容易心态炸裂)。学会注意到工作中双方的认知差异。比如在UI实现上设计师是领域专家，那在实现上基于成本的考虑就可以以设计师的想法为主。</p>\n<h2>生活</h2>\n<h3>读书</h3>\n<p>在2020的年终总结上说要多读书，今年才开始系统的读书了<a href=\"https://icantunderstand.cn/book-list-2022\">读书目录2022</a>。有一次突然觉得好多事好像还看不懂，不明白，就不管三七二十一的读起来了。希望能一直读下去。</p>\n<h3>投资</h3>\n<p>尝试进行投资理财。发现只有上交到家庭的固定工资部分是真的“理财”，其他都是负理财。后续规划上会进行一些系统知识的学习。</p>\n<h3>家庭</h3>\n<p>貌似懂得了陪伴，但是这些方面做的还远不够。国庆老妈来北京逛了一圈。我作为一个在北京10多年的老北漂家人第一次来北京溜达实属惭愧。</p>\n<h2>思考</h2>\n<p>转眼已经30出了个小头了。距离不惑虽然还有些年龄的距离，但是距离不惑的状态还是有些差距。有好多事还没想明白，有好多事甚至都没曾想过。不过一个简单的想法就是要注重自己的价值和心里状态。持续的读书是想保证内心的富足。这个博客也希望能坚持下去，后续会做其他别的分享带来其他的价值</p>\n<h2>番外</h2>\n<p>写到中间的时候，发现<a href=\"https://mp.weixin.qq.com/s?__biz=MzUwOTk5NDI3OA==&#x26;mid=2247484174&#x26;idx=1&#x26;sn=123f7a9b633c3c786519e24f3f4b0072&#x26;chksm=f908f747ce7f7e51785450e91d9aa8c68f411f63935b162d9f19b4fea1cb9184ef10b30f3e7f#rd\">2021的流水账</a>记录在微信的公众号上了，这个博客没有同步。看了下比上次或许有一点进步就算是安慰了。</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"2022年终总结","date":"2022-10-20","tags":"年度总结","path":"/2022-summary","top":null,"summary":"2022年总结-回顾了工作、生活和自身的一些思考"},"title":"2022年终总结","date":"2022-10-20","tags":"年度总结","path":"/2022-summary","top":null,"summary":"2022年总结-回顾了工作、生活和自身的一些思考"},{"id":"9867eee0-87d3-5eb8-901e-4886bc0cd7cd","html":"<h2><a href=\"https://legendapp.com/open-source/legend-state/\">Making React fast by default and truly reactive</a></h2>\n<p>这篇文章通过介绍React中组件渲染优化的问题引出类mobx的状态库方案<a href=\"https://github.com/LegendApp/legend-state\">legend-state</a>,在底层的技术方案上跟mobx是相似的，通过监听observable值的变化来运行渲染函数。</p>\n<h2><a href=\"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/\">A (Mostly) Complete Guide to React Rendering Behavior</a></h2>\n<p>这篇文章比较详细的介绍了React组件渲染的细节，包括渲染的阶段、Fiber、渲染优化等。</p>\n<h2><a href=\"https://prateeksurana.me/blog/future-of-rendering-in-react/\">The future of rendering in React</a></h2>\n<p>这篇文章主要介绍基于react的页面渲染流程和渲染方式的优缺点。</p>\n<ol>\n<li>CSR(Client-side rendering)- 客户端渲染。这种渲染方式通过在客户侧的浏览器执行脚本来完成整个页面内容的生成和数据的加载。 这种方式可以通过CDN去优化JS脚本的加载，能有效的提交TTFB(Time To First Byte),但是由于页面和数据都是在客户端组装和渲染会影响用户的首次可交互时间和不方便做SEO优化。</li>\n<li>SSR(Server-side rendering)- 服务端渲染。这种渲染方式通过react提供的api在服务端组装数据和渲染页面内容。服务端渲染的优势在于有利于SEO优化，能有效的提供FCP(First Contentful Paint)和LCP(Largest Contentful Paint),劣势是服务端渲染会降低TTFB,但是可以通过一些手段去优化，比如\n<ul>\n<li>SSG(Static site generation)- 静态页面生成  将不依赖数据的页面提前进行预编译，在访问的时候直接将已编译好的页面内容返回</li>\n<li>ISR (Incremental static site generation)- 增量式页面生层 ISR为了解决SSG的对动态数据依赖和构建规模问题，可以在运行时动态的生成页面内容并存储</li>\n<li>Streaming SSR- 流式服务端渲染 主要使用node中的stream实现流式的返回服务端渲染的内容，能有效的提高TTFB</li>\n</ul>\n</li>\n</ol>\n<h2><a href=\"https://alexkondov.com/half-hour-to-learn-js/\">A Half-Hour to Learn JavaScript</a></h2>\n<p>这篇文章介绍JavaScript中的基础知识点，包括变量声明、闭包、this、new关键字、原型链、继承、异步调用(async await,Promise)、事件循环等，适合复习基础的时候浏览查缺补漏。</p>\n<h2><a href=\"https://2ality.com/2022/10/javascript-decorators.html\">JavaScript metaprogramming with the 2022-03 decorators API</a></h2>\n<p>这篇文章详细的介绍了JavaScript中装饰器的细节</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/google/zx\">zx</a></h3>\n<p>google的一个脚本工具，可以在脚本中写javascript，值得一试</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/SortableJS/Sortable\">Sortable</a>源码解读</h3>\n<p>Sortable是一个实现可拖拽列表的库，它提供了丰富的功能比如共享列表的拖拽、多条目的拖拽等。以下主要从两方面对Sortable的源码进行简单的分析，希望对功能库的设计有所思考</p>\n<ol>\n<li>插件机制</li>\n<li>拖拽功能实现</li>\n</ol>\n<h4>插件机制</h4>\n<ul>\n<li>插件能很好的实现功能的隔离。插件内功能逻辑自治，</li>\n<li>通过统一的接口提供接入和调用能力。便于后续功能的扩展</li>\n<li>通过组合插件，可以提供多版本的库</li>\n</ul>\n<h5>插件注册</h5>\n<pre><code>    //  通过mount方法调用PluginManager的mount来注册插件\n    Sortable.mount = function(...plugins) {\n        if (plugins[0].constructor === Array) plugins = plugins[0];\n\n        plugins.forEach((plugin) => {\n            if (!plugin.prototype || !plugin.prototype.constructor) {\n                throw `Sortable: Mounted plugin must be a constructor function, not ${ {}.toString.call(plugin) }`;\n            }\n            if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n            PluginManager.mount(plugin);\n        });\n    };\n</code></pre>\n<h5>触发插件</h5>\n<p>通过调用pluginEvent来触发插件执行的逻辑</p>\n<pre><code>    pluginEvent(eventName, sortable, evt) {\n        this.eventCanceled = false;\n        evt.cancel = () => {\n            this.eventCanceled = true;\n        };\n        const eventNameGlobal = eventName + 'Global';\n        plugins.forEach(plugin => {\n            if (!sortable[plugin.pluginName]) return;\n            // Fire global events if it exists in this sortable\n            if (\n                sortable[plugin.pluginName][eventNameGlobal]\n            ) {\n                sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n            }\n\n            // 触发对应插件上对应eventName的处理函数\n            // 比如MultiDrag plugin的drop方法就是通过pluginEvent('drop', this, { evt })触发\n            if (\n                sortable.options[plugin.pluginName] &#x26;&#x26;\n                sortable[plugin.pluginName][eventName]\n            ) {\n                sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n            }\n        });\n    },\n</code></pre>\n<h4>拖拽能力实现</h4>\n<p>拖拽能力主要实现是:</p>\n<ul>\n<li>初始化绑定根元素拖拽的dom事件监听函数</li>\n<li>根据事件触发顺序添加动画处理逻辑、插件调用逻辑、元素替换逻辑、配置的回调函数触发逻辑等</li>\n</ul>\n<h4>绑定事件监听函数</h4>\n<p>在<a href=\"https://lotabout.me/2018/HTML-5-Drag-and-Drop/\">HTML 5 Drag and Drop 入门教程</a>中有对html5中拖拽函数介绍。</p>\n<pre><code>    // 事件监听\n    if (!this.nativeDraggable || touch) {\n\t\tif (this.options.supportPointer) {\n\t\t\ton(document, 'pointermove', this._onTouchMove);\n\t\t} else if (touch) {\n\t\t\ton(document, 'touchmove', this._onTouchMove);\n\t\t} else {\n\t\t\ton(document, 'mousemove', this._onTouchMove);\n\t\t}\n\t} else {\n        // 注意这里传入的是this\n\t\ton(dragEl, 'dragend', this);\n\t\ton(rootEl, 'dragstart', this._onDragStart);\n\t}\n</code></pre>\n<h4>事件触发</h4>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\">addEventListener</a>的第二个参数listener可以是一个函数或者是一个带handleEvent函数的对象。在绑定监听函数的时候listener传入的是this,在触发回调的时候就会走入到handleEvent处理拖拽结束的函数逻辑</p>\n<pre><code>    handleEvent: function (/**Event*/evt) {\n        switch (evt.type) {\n            case 'drop':\n            case 'dragend':\n                // 拖拽结束的时候 执行逻辑\n                this._onDrop(evt);\n                break;\n\n            case 'dragenter':\n            case 'dragover':\n                if (dragEl) {\n                    this._onDragOver(evt);\n                    _globalDragOver(evt);\n                }\n                break;\n\n            case 'selectstart':\n                evt.preventDefault();\n                break;\n        }\n    },\n</code></pre>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"2022-10-1-前端快报","date":"2022-10-08","tags":"前端快报","path":"/2022-10-1","top":null,"summary":null},"title":"2022-10-1-前端快报","date":"2022-10-08","tags":"前端快报","path":"/2022-10-1","top":null,"summary":null},{"id":"5138f9c7-1e45-5332-b7f5-477d54a56248","html":"<h2><a href=\"https://www.joshwcomeau.com/react/usememo-and-usecallback/\">Understanding useMemo and useCallback</a></h2>\n<p>这篇文章介绍useMemo和useCallback</p>\n<ul>\n<li>useMemo可以实现组件内计算逻辑的拆分缓存能力，减少页面渲染时的计算和子组件重复渲染.需要考虑的是是否可以通过组件拆分或者计算逻辑的拆分来实现计算逻辑的优化.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/eef642c6e58030017ad568bf488a4430/d14c1/useMemo.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAARD/2gAIAQEAAT8hHP/aAAwDAQACAAMAAAAQAA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAADAQEAAAAAAAAAAAAAAAAAAREhcf/aAAgBAQABPxDKJZrOH//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"useMemo\"\n        title=\"useMemo\"\n        src=\"/blog/static/eef642c6e58030017ad568bf488a4430/a2510/useMemo.jpg\"\n        srcset=\"/blog/static/eef642c6e58030017ad568bf488a4430/0479a/useMemo.jpg 250w,\n/blog/static/eef642c6e58030017ad568bf488a4430/41099/useMemo.jpg 500w,\n/blog/static/eef642c6e58030017ad568bf488a4430/a2510/useMemo.jpg 1000w,\n/blog/static/eef642c6e58030017ad568bf488a4430/d14c1/useMemo.jpg 1234w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>useCallback用于保存函数的引用，保证在依赖不变的情况下复用之前的函数</li>\n</ul>\n<p>需要注意的是在开发中不要对hook过度使用，在关键的位置做好优化比如:</p>\n<ol>\n<li>使用useState定制的hook，返回的setter函数通过useCallback缓存</li>\n<li>全局context使用useMemo缓存减少渲染</li>\n</ol>\n<h2><a href=\"https://thisweekinreact.com/articles/useSyncExternalStore-the-underrated-react-api\">useSyncExternalStore - The underrated React API</a></h2>\n<p>这篇文章介绍react useSyncExternalStore的使用场景</p>\n<h2><a href=\"https://github.com/pubkey/broadcast-channel\">broadcast-channel</a></h2>\n<p>在<a href=\"https://www.smashingmagazine.com/2022/09/javascript-api-guide/\">JavaScript APIs You Don’t Know About</a>中提及到BroadcastChannel来实现跨页面间的通信。<a href=\"https://github.com/pubkey/broadcast-channel\">broadcast-channel</a>这个库通过封装BroadcastChannel、localStorage、indexedDB、node的socket来实现跨运行时的通信。</p>\n<h2><a href=\"https://2ality.com/2022/09/nodejs-overview.html\">An overview of Node.js: architecture, APIs, event loop, concurrency</a></h2>\n<p>这篇文章介绍node的架构、同步异步的api风格、通过例子介绍node中事件循环的模型。</p>\n<h2><a href=\"https://marmelab.com/blog/2022/09/20/react-i-love-you.html\">React I Love You, But You're Bringing Me Down</a></h2>\n<p>这篇文章介绍作者长期使用react的一些感受和痛点，有点观点很有共鸣。比如：</p>\n<ul>\n<li>context的渲染问题 是否能像redux的useSelector一样来优化渲染</li>\n<li>react引入的一些规则倒是代码写起来比较‘别扭’，不支持条件effect、forwardRef、hook的依赖等</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/AykutSarac/jsoncrack.com\">JSON Crack</a></h3>\n<p>JSON校验和结构可视化工具</p>\n<h3><a href=\"https://pemistahl.github.io/grex-js/\">grex-js</a></h3>\n<p>在线生成正则表达式的工具</p>\n<h2><a href=\"https://engineering.fb.com/2022/09/12/open-source/memlab/\">MemLab: An open source framework for finding JavaScript memory leaks</a></h2>\n<p><a href=\"https://github.com/facebookincubator/memlab\">MemLab</a>是一个分析前端脚本内存泄露的工具，使用puppeteer来执行页面操作进而分析页面的内存状态。</p>\n<h2><a href=\"https://github.com/naptha/tesseract.js#tesseractjs\">tesseract.js</a></h2>\n<p>tesseracts是一个视频图片中文字的前端库，可以支持node和浏览器场景</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-9-1-前端快报","date":"2022-09-21","tags":"前端快报","path":"/2022-9-1","top":null,"summary":null},"title":"2022-9-1-前端快报","date":"2022-09-21","tags":"前端快报","path":"/2022-9-1","top":null,"summary":null},{"id":"fd92a9b2-6634-513c-b581-0c6d7a60cd38","html":"<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-0-61fea500b180\">Frontend Web Performance: The Essentials [0]</a></h2>\n<p>这篇文章介绍前端页面渲染的过程，包括渲染的流程，优化的手段等。通过例子结合chrome的开发者工具给出优化的过程。</p>\n<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-1-cb6513e1c3a1\">Frontend Web Performance: The Essentials [1]</a></h2>\n<p>这篇文章介绍浏览器的事件循环，包括宏任务，微任务等，通过将微任务与宏任务结合的方式可以实现宏任务的拆分。</p>\n<h2><a href=\"https://www.toptal.com/javascript/10-most-common-javascript-mistakes\">The 10 Most Common JavaScript Issues Developers Face</a></h2>\n<p>这篇文章介绍了javascript中几个常见的问题点。比如this的确定、内存泄露、原型链等.</p>\n<h2><a href=\"https://www.robinwieruch.de/typescript-react-useref/\">TypeScript: React useRef Hook</a></h2>\n<p>介绍React useRef Hook的文章.\nReact提供了useCallback, useMemo来实现memoization能力，减少重复的计算。应该避免对应hook的滥用，在缓存大量计算逻辑的时候使用<br>\nuseImperativeHandle可以实现父组件对子组件的方法调用。在使用useImperativeHandle的时候思考是否可以将逻辑抽离到store层处理<br>\nuseRef可以用于存储值，改变useRef的值不需要重新渲染组件</p>\n<h2>工具</h2>\n<h3><a href=\"https://react-svgr.com/docs/what-is-svgr/\">SVGR</a></h3>\n<p>SVGR通过svgo优化，svg内容解析将svg转化成React组件使用</p>\n<h3><a href=\"https://github.com/thebuilder/react-intersection-observer\">react-intersection-observer</a></h3>\n<p>react-intersection-observer通过对IntersectionObserver的封装提供了react hook的方式来监听元素在视口中的位置</p>\n<h3><a href=\"https://github.com/pmndrs/react-spring\">react-spring</a></h3>\n<p>react实现spring动画的库</p>\n<h2>想法</h2>\n<h3>关于前端store设计</h3>\n<p>在<a href=\"https://icantunderstand.cn/2022-7-1\">上期前端快报</a>中聊到了前端的页面设计，要从数据逻辑去思考页面，实现数据逻辑和渲染逻辑的分离。\n在对前端store(View-Model)的设计上，可以从页面的角度，去拆分通用模块，页面级别模块实现更好的数据逻辑与渲染逻辑的隔离.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpElEQVQ4y51Ty07DMBDM/wvxAUj8CwckxBmpouJE2zRJ82iSPvxMB80GN6EBVDiMvLuxx7MTb2StxRjGGAHj4/GIpmkEVVWdY6XUZG9ANCYab3LO4XA4YLfbCUmSJBITrPP7QEhoiaNLdVy5WWstB7fbrWC9Xp9j1vszTsiM8TDmJPlEIdsk4jhGURSiLqhs21bWzWaDPM+htYIxDl2XoeveoPUe0bhVrnVdiwoeoFfMWffeS04v+Y1o2wZFUaNpHpCmt1Bq3isMZDxEFSQJnjEPXVA5VQeFVVUiz2nBE5S6h3PzQSE94+3L5VIU8iBJCRKNvabHQYhzHt638D6DtZ8tcwO9IVFZlqKMJLyAOTF+AQNCjX+8kzUKN7JNqsqyDPv9/qw44HvCnrR/Nj0iGp2mqYBKQkzSy/Yuh+A7RGx1sViId1TJdTabYbVaTabhGtKIftG7uu7fW1FUSJJMaj+N16+EXwsOzvERrybTczXhYK6GtYDWz8jzOyj1DmtPUv+HwjHhI8ryBs69whjI0Pd/8I+EYci9jwG8wNpC8uFJXEf4ASte1qZJXzjwAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"store设计\"\n        title=\"store设计\"\n        src=\"/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png\"\n        srcset=\"/blog/static/e6385772916f35fe16003bf9eb93be77/63868/storeDesign.png 250w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/0b533/storeDesign.png 500w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png 1000w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/187fa/storeDesign.png 1194w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-8-1-前端快报","date":"2022-08-05","tags":"前端快报","path":"/2022-8-1","top":null,"summary":null},"title":"2022-8-1-前端快报","date":"2022-08-05","tags":"前端快报","path":"/2022-8-1","top":null,"summary":null},{"id":"bf1c7d29-cf60-5ac9-b56f-e0daabe2565e","html":"<h2><a href=\"https://h3manth.com/ES2022/\">ES2022 Features!</a></h2>\n<p>这篇文章介绍ES2022的Features。</p>\n<h2><a href=\"https://mikevdv.dev/blog/2022-06-23-stop-the-screen-going-to-sleep-with-javascript\">Stop The Screen Going To Sleep With JavaScript</a></h2>\n<p>这篇文章介绍WakeLock api的使用方法。WakeLock用于防止用户屏幕变暗或者锁屏。<a href=\"https://github.com/richtr/NoSleep.js/\">NoSleep.js</a>就是封装了WakeLock的能力来实现对应的功能.</p>\n<p>NoSleep功能实现:</p>\n<ul>\n<li>在支持wakeLock的设备上使用wakeLock</li>\n<li>在老的ios设备上  通过设置当前href和window.stop的定时器来激活页面</li>\n<li>其他情况通过设置一个循环播放的video标签来实现</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/wbkd/react-flow\">react-flow</a></h3>\n<p>react绘制图表和流程图的工具库</p>\n<h2>想法</h2>\n<h3>关于前端页面设计</h3>\n<ul>\n<li>作为前端开发似乎很容易直接从页面的角度去考虑实现，因为接触的UI就是最直观的图形输入。但是页面不光是简单的UI展示，后面还承载着数据的流动。从数据流去思考业务的逻辑和设计实现页面和业务逻辑的分离。数据承接逻辑，页面承接UI渲染组合能更好的服务于页面的扩展。</li>\n</ul>\n<h3>react hooks的理解</h3>\n<p>hooks是react暴露给外部的接口。这个是react增加hooks提供的一个比较重要的能力。比如react query通过hooks的能力桥接了queryClient.</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/pierpo/react-archer\">react-archer</a>源码分析</h3>\n<p>react-archer通过箭头线绘制React节点之间的关联关系。它的实现主要:</p>\n<ul>\n<li>维护全局的节点关联关系(逻辑抽象 封装)</li>\n<li>解耦节点渲染和箭头线渲染(解耦)</li>\n</ul>\n<h4>节点关系处理逻辑</h4>\n<pre><code>    // 子节点注册逻辑\n    const registerTransitions = (newRelations: Array&#x3C;RelationType>) => {\n        // 格式化节点配置\n        const newSourceToTarget = generateSourceToTarget(id, newRelations);\n        assertContextExists(context);\n        // 更新全局节点配置\n        context.registerTransitions(id, newSourceToTarget);\n    }\n\n    // 根节点更新逻辑\n    const _registerTransitions = useCallback(\n        (elementId: string, newSourceToTargets: SourceToTargetType[]): void => {\n            // 节点关系在根节点中通过useState进行更新维护 触发组件更新\n            setSourceToTargetsMap((previousValue) => ({\n                ...previousValue,\n                [elementId]: newSourceToTargets,\n            }));\n        },\n        [],\n    );\n</code></pre>\n<h4>箭头渲染逻辑</h4>\n<p>在根组件中通过SvgArrows渲染节点连接逻辑</p>\n<pre><code>// 遍历节点关系数据 依次渲染\n{getSourceToTargets(props.sourceToTargetsMap).map((currentRelation) => (\n    &#x3C;AdaptedArrow\n      key={JSON.stringify({\n        source: currentRelation.source,\n        target: currentRelation.target,\n      })}\n      source={currentRelation.source}\n      target={currentRelation.target}\n      label={currentRelation.label}\n      style={currentRelation.style || {}}\n      startMarker={props.startMarker}\n      endMarker={props.endMarker}\n      endShape={props.endShape}\n      strokeColor={props.strokeColor}\n      strokeWidth={props.strokeWidth}\n      strokeDasharray={props.strokeDasharray}\n      noCurves={props.noCurves}\n      lineStyle={props.lineStyle}\n      offset={props.offset}\n      parentCoordinates={parentCoordinates}\n      refs={props.refs}\n      uniqueId={props.uniqueId}\n    />\n))}\n\n// 使用getBoundingClientRect和配置项计算绘制箭头的位置 最后使用svg进行关联线的绘制\nexport const getPointCoordinatesFromAnchorPosition = (\n    position: AnchorPositionType,\n    index: string,\n    parentCoordinates: Vector2,\n    refs: Record&#x3C;string, HTMLElement>,\n): Vector2 => {\n    const rect = getRectFromElement(refs[index]);\n\n    if (!rect) {\n        return new Vector2(0, 0);\n    }\n\n    const absolutePosition = computeCoordinatesFromAnchorPosition(position, rect);\n    return absolutePosition.substract(parentCoordinates);\n};\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null},"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null},{"id":"d61957d7-be29-53c8-abf3-4974dbb8a1b8","html":"<p>本文梳理axios中使用CancelToken来实现中断请求的源码实现.\n(CancelToken已经是deprecated, axios已支持AbortController实现相应的功能)</p>\n<h2>简单使用</h2>\n<pre><code>    const CancelToken = axios.CancelToken;\n    // 创建cancelToken\n    const source = CancelToken.source();\n\n    axios.get('/user/12345', {\n        // 请求的时候 传入创建的cancelToken\n        cancelToken: source.token\n    }).catch(function (thrown) {\n        if (axios.isCancel(thrown)) {\n            console.log('Request canceled', thrown.message);\n        } else {\n            // handle error\n        }\n    });\n\n\n    // 调用cancelToken的cancel方法 取消请求\n    source.cancel('Operation canceled by the user.');\n</code></pre>\n<p>上面是axios官网的上使用CancelToken的例子，可以看到通过将创建的cancelToken传入对应的请求对象，就实现了请求控制能力暴露给外部的能力。</p>\n<h2>源码分析</h2>\n<p>XMLHttpRequest支持使用abort方法实现请求的终止，axios底层封装了XMLHttpRequest来实现请求的处理，通过将调用abort方法的能力暴露给外部就实现了请求中断的控制。axios引入了cancelToken来实现这个过程的解耦。下面从具体的源码来看实现的过程</p>\n<h3>创建cancelToken对象</h3>\n<pre><code>// 调用source方法 生成CancelToken 导出token和取消请求的cancel方法\nCancelToken.source = function source() {\n    var cancel;\n    var token = new CancelToken(function executor(c) {\n        cancel = c;\n    });\n    return {\n        token: token,\n        cancel: cancel\n    };\n};\n\nfunction CancelToken(executor) {\n    if (typeof executor !== 'function') {\n        throw new TypeError('executor must be a function.');\n    }\n\n    var resolvePromise;\n    // 设置CancelToken的promise函数\n    this.promise = new Promise(function promiseExecutor(resolve) {\n        resolvePromise = resolve;\n    });\n\n    var token = this;\n    // cancel函数的执行逻辑 在调用cancel接口的时候 执行下面的逻辑\n    executor(function cancel(message) {\n        if (token.reason) {\n            // Cancellation has already been requested\n            return;\n        }\n\n        token.reason = new Cancel(message);\n        resolvePromise(token.reason);\n    });\n}\n</code></pre>\n<h3>cancelToken与XMLHttpRequest绑定</h3>\n<pre><code>    // 代码是axios封装XMLHttpRequest的部分逻辑\n    if (config.cancelToken) {\n        // 如果传入的配置有cancelToken 就调用cancelToken的promise方法 \n        // 通过promise实现控制流的流转 调用cancelToken方法的时候 将resolve时机暴露给cancelToken\n        // 调用cancelToken的cancel方法时,resolve了当前的promise，控制流程回到当前的后续流程，执行request.abort()从而完成请求的终止\n        config.cancelToken.promise.then(function onCanceled(cancel) {\n            if (!request) {\n                return;\n            }\n\n            request.abort();\n            reject(cancel);\n            // Clean up request\n            request = null;\n        });\n    }\n\n    if (!requestData) {\n        requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n</code></pre>\n<p>通过对实现流程的源码梳理，在类似的功能中可以利用promise来完成流程的控制。</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"axios的cancel功能源码解读","date":"2022-06-22","tags":"JavaScript","path":"/axios-cancel","top":null,"summary":null},"title":"axios的cancel功能源码解读","date":"2022-06-22","tags":"JavaScript","path":"/axios-cancel","top":null,"summary":null},{"id":"bdbed110-909c-577e-9652-4e22fb148271","html":"<h2><a href=\"https://michel.codes/blogs/ui-as-an-afterthought\">UI AS AN AFTERTHOUGHT</a></h2>\n<p>这篇文章介绍作者对UI框架和状态管理的思考。在React中开发者通常会在组件中处理业务逻辑，这样导致UI和数据无法解耦。文章中的方式是让React做比较纯粹的渲染框架，业务逻辑组织在全局store中.</p>\n<h2><a href=\"https://mmazzarolo.com/blog/2022-02-16-track-down-the-javascript-code-responsible-for-polluting-the-global-scope/\">Track down the JavaScript code responsible for polluting the global scope</a></h2>\n<p>文章提供了基于ES6 proxy查找全局变量污染的方案</p>\n<h2><a href=\"https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md\">useEvent RFC</a></h2>\n<p>相关文章\n<a href=\"https://typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/\">What the useEvent React hook is (and isn't)</a><br>\nreact增加了useEvent提案，使用场景能帮我们缓存一个函数的回调。主要用于解决如下的问题:</p>\n<ol>\n<li>通常的场景在组件中声明中的函数会因为依赖项的问题导致在渲染的时候函数会新生成引用，这样在使用该函数的子组件就会触发重新渲染。</li>\n<li>react hooks的依赖解耦 比如在一个effect hook中有两段业务逻辑，这样就需要把两段业务逻辑的依赖都加入到effect hook的依赖中，导致effect执行不符合预期。</li>\n</ol>\n<p>useEvent简化实现如下:</p>\n<pre><code>    function useEvent(handler) {\n        const handlerRef = useRef(null);\n\n        // In a real implementation, this would run before layout effects\n        useLayoutEffect(() => {\n            handlerRef.current = handler;\n        });\n\n        return useCallback((...args) => {\n            // In a real implementation, this would throw if called during render\n            const fn = handlerRef.current;\n            return fn(...args);\n        }, []);\n    }\n</code></pre>\n<p>useEvent可以看出是官方的解决前面提到问题的方案，在往前走一会，有如下的一些思考:</p>\n<ol>\n<li>是否需要一个不变的callback => 性能 vs 代码复杂度</li>\n<li>组件是否做了组件该做的事 => 渲染和业务逻辑的设计</li>\n</ol>\n<h2><a href=\"https://www.youtube.com/watch?v=NZoRlVi3MjQ\">The Story of Concurrent React </a></h2>\n<p>视频介绍react Concurrent发展的过程</p>\n<h2><a href=\"https://www.developerway.com/posts/react-key-attribute\">React key attribute: best practices for performant lists</a></h2>\n<p>文章介绍React组件中key使用的注意事项</p>\n<h2><a href=\"https://www.robinwieruch.de/react-hook-detect-click-outside-component/\">React Hook: Detect Click outside of Component</a></h2>\n<p>文章介绍如何实现一个自定义的hook来监听组件外的点击</p>\n<h2><a href=\"https://www.robinwieruch.de/web-applications/\">Web Applications 101</a></h2>\n<p>文章介绍web应用前端技术的发展过程，从最开始的web1.0到web2.0娓娓道来。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/timc1/kbar\">kbar</a></h3>\n<p>kbar是一个给站点提供快捷操作的工具</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null},"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null},{"id":"e9263203-28a6-5ebd-9a58-365666024052","html":"<p>本文整体记录自己在优化项目代码的思路和实现过程，主要从以下的方面展开:</p>\n<ul>\n<li>项目背景(技术方案，迭代上遇到的问题)</li>\n<li>使用的优化方式</li>\n<li>过程的总结思考</li>\n</ul>\n<h2>项目背景</h2>\n<p>页面的整体结构可以简化成如下的结构:</p>\n<ul>\n<li>顶部数据筛选区, 筛选数据变化触发表格数据更新</li>\n<li>数据表格渲染区域</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/5112c/pageStruct.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB7cTRoF//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQES/9oACAEBAAEFAusdYqJiP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/AYf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARMVFh/9oACAEBAAE/IYCrwU0chIf/2gAMAwEAAgADAAAAENcf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EC4//8QAGxABAAICAwAAAAAAAAAAAAAAAQAhETFBwfD/2gAIAQEAAT8Qw07IZnkha0i69p4MKUT/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"页面结构\"\n        title=\"页面结构\"\n        src=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/a2510/pageStruct.jpg\"\n        srcset=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/0479a/pageStruct.jpg 250w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/41099/pageStruct.jpg 500w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/a2510/pageStruct.jpg 1000w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/5112c/pageStruct.jpg 1149w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n数据渲染区域有比较复杂的渲染逻辑，需要根据顶部的筛选区域做数据条目的渲染，因此之前的方案通过useReducer引入全局的store做数据的存储和处理。useReducer的方案在当时看并没有问题，但是随着业务的发展遇到了如下的问题，对业务的迭代产生了一些限制:</p>\n<ol>\n<li>表格组件存在一对多问题，随着业务的发展顶部的筛选区域会产生更多业务类型的表格，导致单一组件中存在较多的\"非\"业务相关处理逻辑 => 页面渲染逻辑不清晰、组件渲染逻辑复用度低</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/aafa5a667beca13516314f38856d0a3d/5112c/tableProblem.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAduFlB//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQES/9oACAEBAAEFAq6xURH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPwGH/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBABAQEBAQAAAAAAAAAAAAAAEQABITH/2gAIAQEAAT8hKQb2O+QYbZi//9oADAMBAAIAAwAAABBPH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAQEBAAAAAAAAAAAAAAAAAAARIf/aAAgBAgEBPxCGP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESExQf/aAAgBAQABPxBzLXmHsaxJ5Sew1cRBIVfdj1F1hsKYT//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"表格组件渲染问题\"\n        title=\"表格组件渲染问题\"\n        src=\"/blog/static/aafa5a667beca13516314f38856d0a3d/a2510/tableProblem.jpg\"\n        srcset=\"/blog/static/aafa5a667beca13516314f38856d0a3d/0479a/tableProblem.jpg 250w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/41099/tableProblem.jpg 500w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/a2510/tableProblem.jpg 1000w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/5112c/tableProblem.jpg 1149w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n2. 在业务迭代中引入了新的概念去实现业务功能，这些概念在业务迭代过程中变得不再适用或者很难维护 => 提前封装\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/61d5f/concept.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB7VTRpBf/xAAYEAADAQEAAAAAAAAAAAAAAAAAARESEP/aAAgBAQABBQKmlyGUQ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/AYf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAEBAQADAAAAAAAAAAAAAAABABEQITH/2gAIAQEAAT8hTEaPlnvgAX//2gAMAwEAAgADAAAAEITf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAECAQE/EIbH/8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFhcZH/2gAIAQEAAT8QO1ZfE0KnjDaiuptp3nZ7fYbRc//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"渲染逻辑问题\"\n        title=\"渲染逻辑问题\"\n        src=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/a2510/concept.jpg\"\n        srcset=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/0479a/concept.jpg 250w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/41099/concept.jpg 500w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/a2510/concept.jpg 1000w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/61d5f/concept.jpg 1162w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上图中引入了一个统一的渲染处理逻辑,这个逻辑可以演化成字段、函数等，在业务的迭代中该业务逻辑可维护性差<br>\n3. 代码组织结构混乱。部分文件超过千行难以维护。useReducer相当于低配版的redux，新功能的增加需要添加更多的模板代码 => 功能&#x26;代码组织缺少梳理</p>\n<h2>优化思路&#x26;思考</h2>\n<h3>功能模块化&#x26;组件化</h3>\n<h4>组件化</h4>\n<p>在部分渲染逻辑上，依赖useReducer返回的全局store和dispatch方法触发action。这样有个问题是无法解耦业务组件与表格组件，表格组件和业务组件的逻辑不能有效地分离。代码缺少组件化，页面渲染逻辑不清晰\n对这部分的思考是引入useContext，通过组件内部获取到全局的store对象从而解耦了组件渲染和表格组件的绑定关系。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/82b8c/component.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB3IJQP//EABYQAAMAAAAAAAAAAAAAAAAAAAAQIf/aAAgBAQABBQIq/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAABAx/9oACAEBAAY/Air/xAAZEAABBQAAAAAAAAAAAAAAAAARAAEQMfH/2gAIAQEAAT8hYm0MI//aAAwDAQACAAMAAAAQh8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAGhAAAgIDAAAAAAAAAAAAAAAAABEBIUFRcf/aAAgBAQABPxDKguEspRez/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组件化\"\n        title=\"组件化\"\n        src=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/a2510/component.jpg\"\n        srcset=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/0479a/component.jpg 250w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/41099/component.jpg 500w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/a2510/component.jpg 1000w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/c58a3/component.jpg 1500w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/82b8c/component.jpg 1960w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>功能模块化</h4>\n<p>useReducer函数因为模板代码的问题导致代码行数逐渐增多，这样就在修改代码和熟悉业务增加了成本，降低的维护性。这里引入了combineReducers的概念，在实现新业务的时候，将对应的useReducer处理逻辑封装成独立的模块，在主useRefucer函数中引入从而使实现逻辑模块化。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/01ab0/reducer.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuzUAT/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAQABPyHR1z//2gAMAwEAAgADAAAAEOg//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQETFx/9oACAEBAAE/ENYNd6KEt9Ej/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reducer逻辑分离\"\n        title=\"reducer逻辑分离\"\n        src=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/a2510/reducer.jpg\"\n        srcset=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/0479a/reducer.jpg 250w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/41099/reducer.jpg 500w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/a2510/reducer.jpg 1000w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/01ab0/reducer.jpg 1300w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n随着业务迭代，应该适当地对组件进行隔离维持好组件单一职责的本心，如果多个模块都有类似的能力但是业务逻辑不一致就不要在一个组件中维护过多的能力。可以在上层收口再实现层分离。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/01ab0/single.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7NQA//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAABEBEg/9oACAEBAAE/Ibgr/9oADAMBAAIAAwAAABDoL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAICAwAAAAAAAAAAAAAAAAABEXEQITH/2gAIAQEAAT8QoNzPcpuxI//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组件逻辑拆分\"\n        title=\"组件逻辑拆分\"\n        src=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/a2510/single.jpg\"\n        srcset=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/0479a/single.jpg 250w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/41099/single.jpg 500w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/a2510/single.jpg 1000w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/01ab0/single.jpg 1300w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>引入新的技术方案降低模板代码</h3>\n<p>useReducer可以通过action的合理设计来减少模板代码，但是在增加新功能的时候，需要声明action、reducer处理逻辑，随着业务的迭代这些模板类代码会越来越重，这里引入的mobx方案去解决这个问题</p>\n<h3>对封装的思考</h3>\n<p>在业务迭代比较频繁的模块，可以通过封装简单的util函数来达到代码的复用能力。随着业务迭代，直接对整体业务模块的封装会导致代码的可理解性、可维护性下降。（这里讨论的问题并不是降低封装而是延迟封装）<br>\n在下图中，有多个业务处理模块都有使用A处理逻辑，但是在后续的模块中对A逻辑的能力都有限制和修改。如果在初期就抽离出A逻辑就会导致A逻辑中引入了后续模块的特定逻辑进而降低该模块的可维护性。在进行业务修改的时候覆盖的范围也是扩大的。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 612px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 128%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt2E0FikKX/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQABBQJP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwJP/8QAGhAAAwADAQAAAAAAAAAAAAAAAAEREFFhcf/aAAgBAQABPyG9PcVlfgil4Ii0Rax//9oADAMBAAIAAwAAABC8I8D/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAeEAEAAgEFAQEAAAAAAAAAAAABABEhMUFRYXGRof/aAAgBAQABPxB1YeXBc2OqYPcbnO/M5P1dxXebzFW4fYK3I9qJz0zepfks1HyAGgE//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"封装\"\n        title=\"封装\"\n        src=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg\"\n        srcset=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/0479a/module.jpg 250w,\n/blog/static/bd72f3db3c4c906ece570c5b72b785c1/41099/module.jpg 500w,\n/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg 612w\"\n        sizes=\"(max-width: 612px) 100vw, 612px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n比较好的思路是在业务比较稳定的时候再对A逻辑进行区分，在组织逻辑上通过入口划分不同的业务细节。</p>\n<p>以上就是自己在业务代码优化上的一些实践和思考。代码的优化并不是一蹴而就的，是渐进式的。最开始的设计相当于建筑的地基，这个地基的好坏能一定程度上为项目保驾护航。代码的优化则是自身对业务理解梳理，对功能实现的总结思考，相当于对建筑的添砖加瓦，是个有意思的过程。</p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"记一次项目代码优化","date":"2022-04-06","tags":"工程化","path":"/code-refactor","top":null,"summary":null},"title":"记一次项目代码优化","date":"2022-04-06","tags":"工程化","path":"/code-refactor","top":null,"summary":null},{"id":"b1129eb4-7e02-5c11-a5be-9651c06a747d","html":"<h2><a href=\"https://timothygu.me/es-howto/\">How to Read the ECMAScript Specification</a></h2>\n<p>这篇文章介绍如何阅读ECMAScript规范的一些思路，文章中有对规范章节内容的整体划分和规范写法的例子解读.规范比较难啃，可以通过例子熟悉规范的写法，在自己需要了解相关内容的时候去阅读规范</p>\n<h2><a href=\"https://dev.to/this-is-learning/conquering-javascript-hydration-a9f\">Conquering JavaScript Hydration</a></h2>\n<p>前端框架的服务端渲染可以在服务端输出组件的内容(html, data-fetch)，一定程度上加快FCP(First Contentful Paint).在用户侧浏览器根据服务端提供的内容执行前端脚本完成事件的绑定和组件相关逻辑的执行，这个过程称为Hydration(注水)。在Hydration过程中页面仍然是不可交互的，造成了页面可交互的假象。所以尽量减少在Hydration中执行的逻辑是优化性能的一个方向。这篇文章给出了这个方面的一些思考。</p>\n<h2><a href=\"https://www.chakshunyu.com/blog/a-fundamental-guide-to-react-suspense/\">A Fundamental Guide To React Suspense</a></h2>\n<p>这篇文章详细地介绍的React中使用Suspense解决问题的背景和优点。</p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍列举了React中一些通用的解决方案和工具库，包括状态管理、项目结构、代码规范等。</p>\n<h2><a href=\"https://uniqname.medium.com/why-i-avoid-async-await-7be98014b73e\">Why I avoid async/await</a></h2>\n<p>这篇文章介绍了作者对使用async/await的一些思考，主要的观点心智的转换和写法上的比较。async/await表面上将异步代码转换成同步代码的写法一定程度上改变了代码的运转模式。</p>\n<h2>ECMAScript规范</h2>\n<h3><a href=\"https://2ality.com/2022/03/properties-of-primitives.html\">How do primitive values get their properties?</a></h3>\n<p>这篇文章介绍ECMAScript语法层面上对初值的封装逻辑、属性的获取逻辑、方法的调用逻辑。</p>\n<h3><a href=\"https://github.com/tc39/proposal-type-annotations\">proposal-type-annotations</a></h3>\n<p>tc39新增Type Annotations的proposal,现在处于stage 1阶段。未来有可能javascript直接支持类型定义，可以理解ECMAScript在吸收javascript超集的优点。</p>\n<h3><a href=\"https://2ality.com/2022/04/shadow-realms.html#shadowrealm.evaluate()\">ShadowRealms – an ECMAScript proposal for a better eval()</a></h3>\n<p>这篇文章对ShadowRealms proposal进行了详细的介绍，现在处于stage 3阶段。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/nolimits4web/atropos\">atropos</a></h3>\n<p>atropos是一个做3D触摸特效的动画库</p>\n<h3><a href=\"https://stuk.github.io/jszip/\">JSZip</a></h3>\n<p>JSZip是一个JavaScript操作zip文件的库</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null},"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null},{"id":"4c1cd05d-9c62-5dd4-ab31-4f1ca0a7aee3","html":"<h2><a href=\"https://monorepo.tools/\">Understanding Monorepos</a></h2>\n<p>这篇文章通过对Monorepo/Polyrepo(多仓库模式)、实现Monorepo的工具进行对比，对使用Monorepo模式进行开发有参考价值。</p>\n<ol>\n<li>Monorepo是什么: Monorepo在主体仓库中组合了多个子仓库并且这些子仓库的功能是相关联的,对应的例子可以参考<a href=\"https://github.com/facebook/react\">react</a>项目的仓库</li>\n<li>为什么使用Monorepo: Monorepo在组织关联业务代码上有优势，能减少代码复用、技术统一、开发调试中的问题</li>\n</ol>\n<p>关于Monorepos和Polyrepo的思考可以参考这篇文章<a href=\"https://earthly.dev/blog/monorepo-vs-polyrepo/\">Monorepo vs Polyrepo</a></p>\n<h2><a href=\"https://www.modularmanagement.com/blog/what-is-a-good-modular-system\">What is a Good Modular System?</a></h2>\n<p>这篇文章介绍了系统设计的思考点</p>\n<ul>\n<li>模块的功能界定  通过引入模块系统可以降低系统的复杂性，提高系统的灵活性,但是对于引入的模块功能的界定划分需要考量。如果功能没有界限好会导致功能代码从一个位置移动到另一个位置增加了模块维护的复杂度。比如之前的中台概念，需要划分好中台的功能才能更好的实现中台的能力，拆分出模块系统一方面做得更多去帮助系统更好，一方面也要思考如果做得更少去实现最初的目标</li>\n<li>生命周期 功能的稳定和灵活性能提高模块的生命周期</li>\n<li>模块收益的衡量标准</li>\n</ul>\n<p><img src=\"weeklyReport22/modular-value.png\" alt=\"模块收益衡量标准\"></p>\n<p>通过模块衡量的公式，在进行模块系统设计的时候可以有以下的考虑:</p>\n<ol>\n<li>平台的功能边界考量\n<ol>\n<li>不是越少越好，前期的投入能力后期带来收益</li>\n<li>前期的忽视需要后续弥补，要仔细思考</li>\n<li>用小范围的能力边界限制实现整体的灵活扩展</li>\n</ol>\n</li>\n<li>整体和部分的考量\n<ol>\n<li>不用一步到位，部分功能提升到独立的系统也能产生比较大的价值，后期再进行统一</li>\n<li>在资源可能的情况下，相关的依赖系统要统一升级</li>\n</ol>\n</li>\n<li>从长期的视角去看系统的模块设计 从现在的能力出发结合系统未来的发展诉求去做系统设计(能力建设)，这个角度的考虑也是在为未来打地基</li>\n</ol>\n<p>对于模块系统的介绍可以参考这篇文章<a href=\"https://www.modularmanagement.com/blog/all-you-need-to-know-about-modularization\">All You Need to Know About Modularization</a>,模块的实现应该在部分能力抽象的情况下实现系统整体的灵活性</p>\n<p><img src=\"weeklyReport22/modular-define.png\" alt=\"模块化系统的定义\"><br>\n模块化系统能带来效率、灵活度、敏捷的特点。</p>\n<ol>\n<li>效率 模块的复用/功能的组装  这里可以通过比喻装配式建筑来理解,通过对预制模块在工地快速的组装就快速完成了建筑的装配。</li>\n<li>灵活性 基础模块能快速的组装出新的功能模块/通过统一的接口设计能快速的实现模块的功能替换</li>\n<li>敏捷性 由于基础模块的拆分，通过基础模块的改变就可以快速地影响整个系统</li>\n</ol>\n<h2><a href=\"https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd\">Deep dive into React Native’s New Architecture</a></h2>\n<p>这篇文章通过React Native前后架构的对比对新旧架构进行了介绍</p>\n<h2><a href=\"https://kentcdodds.com/blog/javascript-to-know-for-react\">JavaScript to Know for React</a></h2>\n<p>这篇文章介绍了React中JavaScript的一些常用的语法，比如模板字符串、可选链、空值合并预算符等</p>\n<h2><a href=\"https://blog.bitsrc.io/some-reasons-for-disliking-react-hooks-80f1e18eb9b3\">Some reasons for disliking React hooks</a></h2>\n<p>这篇文章作者介绍了使用react hooks的优缺点</p>\n<ul>\n<li>优点 hooks可以更好实现代码的复用组合/逻辑集中</li>\n<li>缺点 hooks的写法上有上手成本和调试成本，容易引发一些bug，还有不要过于过度使用hooks.hooks的调用方式是通过数组的方式调用函数，过多或者依赖关系复杂的hooks会降低页面的性能</li>\n</ul>\n<h2><a href=\"https://blog.bitsrc.io/inversion-of-control-with-react-584533e49245\">Build Decoupled React Components with Inversion of Control</a></h2>\n<p>这篇通过例子的方式介绍通过反转控制的方式解耦组件的实现来应对未来逻辑的变更</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"2022-3-1-前端快报","date":"2022-03-07","tags":"前端快报","path":"/2022-3-7","top":null,"summary":null},"title":"2022-3-1-前端快报","date":"2022-03-07","tags":"前端快报","path":"/2022-3-7","top":null,"summary":null},{"id":"983124c1-808b-5e13-bea1-17907d6cd08f","html":"<p>这里记录下2022读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2022年已阅读: 40本</p>\n<p>2022读书感悟:\n最开始以为读书能看懂世界，觉得能增加所谓的阅历，其实发现多个看世界的视角就好</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>《半小时漫画历史系列》- 陈磊</h2>\n<h3>推荐指数 5</h3>\n<p>原来发现历史是这么有趣，原来晦涩的朝代故事在笔者轻松的表达下竟然那么引人入胜，非常适合在闲暇的时候当历史简版读物来看。</p>\n<h2>《动物农场》- 乔治·奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>经典之作。这本书描写了动物农场的一场反抗活动，对现实社会有影射意义，思考我们是不是也在一个农场中，只是压迫的程度大小，要跳出来看自己的生活。</p>\n<h2>《1984》- 乔治.奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>是看完动物农场才看的《1984》. 书中塑造了一种恐怖绝望的氛围会跟着主人公体验到从拥有希望到绝望的过程，在小说的故事中文明、历史似乎都可以被改写。读完会有疑惑就是书中描绘的社会是否会在现实中呈现，如果生活在那样的社会应该是十分的压抑的。</p>\n<h2>《为什么是中国》- 金一南</h2>\n<h3>推荐指数 4</h3>\n<p>这本书主要介绍中国近代以来的发展历史，其实作为中国人会感觉到自豪，中国在社会实践上走的是一条充满实践的道路</p>\n<h2>《胜者思维》- 金一南</h2>\n<h3>推荐指数 4.5</h3>\n<p>本书中金一南通过对中国历史发展从军事的角度进行总结，一些思路在其他的领域也很有价值，比如领导者的领导作用、权力的下放与担责</p>\n<h2>《认知觉醒: 开启自我改变的原动力》- 周岭</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中的对思维方式表达改变了我之前对思维方式的思考，思维是可以训练，我们对自己也不应该固步自封，很推荐看这本。</p>\n<h2>《柳林风声》- 肯尼斯·格雷厄姆</h2>\n<h3>推荐指数 4.5</h3>\n<p>这是一本适合大人和孩子一起看的童话书，书中的小动物形象跃然纸上，有的时候你会为书中的蛤蟆扼腕叹息，认为它罪有应得，会喜欢上对人和善的鼹鼠。在阅读的过程中仿佛你就进入了这个童话的世界，跟着动物们一起探索，历险。</p>\n<h2>《时间的形状:相对论史话》- 汪洁</h2>\n<h3>推荐指数 5</h3>\n<p>非常通俗易懂的科普读物 作者通过讲故事的方式把比较硬核的理论通俗易懂地讲出来。了解到相对论等理论的发展过程,发现人类的探索欲也觉得人类很渺小.这是一本充满科学内核的科普“小说”。称它为小说是因为你会被一个个故事所吸引。非常推荐</p>\n<h2>《宇宙的琴弦》- 格林</h2>\n<h3>推荐指数 3.5</h3>\n<p>弦论的科普读物。书中的论证的过程和思考的方式有一定的启发作用</p>\n<h2>《中国新基建：未来布局与行动路线》</h2>\n<h3>推荐指数 3.5</h3>\n<p>这本书比较全面地介绍了新基建的方向、图谱、路径。需要意识到与别人的差距也要切实的看到中国的进度，建立中国自信</p>\n<h2>《花猫三丫上房了》 - 叶广岑</h2>\n<h2>《土狗老哥闯祸了》 - 叶广岑</h2>\n<h2>《耗子大爷起晚了》- 叶广岑</h2>\n<h3>推荐指数 4.5</h3>\n<p>非常生动的童年故事，读起来会有很多温馨的瞬间。不是童话却有童话的感觉</p>\n<h2>《这就是中国: 走向世界的力量》 - 张维为</h2>\n<h3>推荐指数 4.5</h3>\n<p>这本书的内容很多，值得反复阅读。主要包括我们是怎么崛起的、我们为什么会崛起、我们的制度优势、需要建立中国自信(有自己的视角看问题和解读问题，建立自己的话语体系)等。在开始阅读的时候会觉得鸡血貌似多了一点，在逐渐阅读大部分后发现自己之前的一些想法不够成熟。书中的视角是从国家的角度来阐释发展，其实映射到个人也有一定的价值。非常推荐。</p>\n<h2>《超越期待：松浦弥太郎的人生经营原则》- 松浦弥太郎</h2>\n<h3>推荐指数 2</h3>\n<p>书的内容围绕着作者的人生态度和处事原则的细致总结，读起来相对来说缺少面的陈述，不推荐</p>\n<h2>《献给阿尔吉侬的花束》 - 丹尼尔·凯斯</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完有些伤感，小说通过日记的方式叙述查理从不聪明到聪明又回归到愚钝的状态，作者对心理变化的描述入微，读起来感觉在跟查理经历着这一切。这本书有许多的现实反射，比如</p>\n<ul>\n<li>查理的妈妈小时候对查理的不认同，导致查理性格上的讨好和迫切的希望获得别人的认可，可见在孩子幼年的时候塑造一个健全的人格的重要性</li>\n<li>如何接受和认识自身的问题 在没变聪明之前查理过得很开心，在经历了变聪明又变不聪明之后查理的心态无法回到之前的状态，这里也情有可原。文中有两个查理体现在聪明程度的差异，在我们自身上是否在其他方面也有另一个查理呢，在暗处观察着自己。</li>\n</ul>\n<h2>《西方哲学史:从古希腊到当下》- 奎纳尔·希尔贝克 尼尔斯·吉列尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>整本书比较详细的描写了人类历史发展阶段的哲学思考过程.我们现在的社会发展成当前的模式是在前人的思考基础上的,从这个角度去阅读和理解本书是一个不错的角度</p>\n<h2>哪有没时间这回事(白金版) - 纪元</h2>\n<h3>推荐指数 3</h3>\n<p>对时间的管理上有一定的启发</p>\n<h2>聪明的投资者(第四版) - 本杰明·格雷格姆 贾森·兹威格</h2>\n<h3>推荐指数 4.5</h3>\n<p>价值投资的观点并不过时。书中主要介绍格雷厄姆对价值，对投资的一些思考。</p>\n<h2>股票大作手回忆录 埃德温·勒菲弗</h2>\n<h3>推荐指数 3.5</h3>\n<p>作为利弗莫尔一生在”投机“生涯的回忆录，记录视角上会感觉一个经历了大起大落的人在你耳边叙述他的一生。</p>\n<h2>时间尽头的咖啡馆 约翰·史崔勒基</h2>\n<h3>推荐指数 4</h3>\n<p>一本简短的小说，通过故事的方式引领你的思考-关于生命的意义。找到问题的答案仍然需要自己的积极思考</p>\n<h2>斯坦福极简经济学 蒂莫西·泰勒</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中通过简单的例子阐述宏观和微观经济学的基本概念，读起来兴趣盎然。经济学有助于我们改变对世界的认识，推荐这本。</p>\n<h2>养育你内心的小孩 丛非从</h2>\n<h3>推荐指数 4</h3>\n<p>这本书从心理学的角度上介绍了安全、自由、价值、意义、亲密等对行为产生的影响。我们对于外界的行为起因是我们的内心有一定的冲突，要不停的认识自己。</p>\n<h2>火星编年史 雷·布拉德伯里</h2>\n<h3>推荐指数 4.5</h3>\n<p>很喜欢作者对人类文明发展的克制表达，是一本有诗意却有些悲凉色彩的科幻小说</p>\n<h2>邓小平时代 傅高义</h2>\n<h3>推荐指数 4.5</h3>\n<p>对历史的细节有了更多的了解。邓爷爷一辈子起起伏伏，一直在为中国发展贡献着力量，阅读过程中会感觉一个亲切而坚定的人跃然纸上，作者在写作本书的时候对历史的细节有足够的求证力图还原真实的历史。阅读本书了解到了什么是中国特色社会主义制度，为什么会有经济特区，发展才是硬道理等等，祖国的今天得来不易，以史为鉴才能走得更好，感恩前人。</p>\n<h2>法治的细节</h2>\n<h2>圆圈正义: 作为自由前提的信念  罗翔</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完这两边书让我对法治的概念有了基本的思考，也了解到要接受自己的局限性，多思考。</p>\n<h2>李光耀观天下 李光耀</h2>\n<h3>推荐指数 4</h3>\n<p>跟随李光耀先生的视角看了一次世界.在看待中国问题上还是存在一些西方的视角不过也的确看到了发展中出现的问题。在其他区域的发展上从政治经济上看的很广,有全局的视野</p>\n<h2>鼠疫 加缪</h2>\n<h3>推荐指数 4.5</h3>\n<p>在新冠疫情的背景下看这本书更加有感触。书中散发着作者对于生活坚定的力量。</p>\n<h2>用经济思维看懂世界格局·亚欧大陆经济整合--新体系伟大力量的源泉 徐伯赢</h2>\n<h3>推荐指数 5</h3>\n<p>本书从经济学的角度来探讨世界格局，覆盖了美、欧、中东、东南亚、日本、中国在经济领域的历史，读起来兴趣盎然。在探讨的视角是也比较宏观。</p>\n<ul>\n<li>日本和东南亚就像今天中国发展的镜子，如何解决房地产泡沫问题、如何寻找经济发展替换地产经济的问题，发展方式的选择问题(合作共赢还是胜者通吃)、金融领域的开放问题等，有不错的借鉴意义</li>\n<li>欧债危机暴露了很多问题，看似表面团结的欧盟(英国与欧洲大陆国家，欧洲大陆核心国与非核心国)由于国家经济政策不同和整个欧盟产业结问题容易产生一些隐藏的问题。欧盟似乎应该在更加统一的财政政策和独立于美国的政策上发力</li>\n<li>对比其他国家和区域，我们的发展路线是在全球化背景下实践一条合作发展，互利共赢的道路，虽然我们现在也面临很多的问题(法制的建设等)，希望这些问题会越来越好，附上这本书结尾的话: 士不可以不弘毅，任总而道远</li>\n</ul>\n<h2>PDCA循环工作法 冈村拓郎</h2>\n<h3>推荐指数 3.5</h3>\n<p>PDCA循环工作法的实践书籍，对于一些细节和思考上有收获。适合快读</p>\n<h2>纳闷集 匡扶</h2>\n<h3>推荐指数 3</h3>\n<p>漫画集，通过漫画和搞笑的表达方式叙述了温暖的故事</p>\n<h2>战胜华尔街 彼得·林奇 约翰·罗瑟查尔德</h2>\n<h3>推荐指数 4</h3>\n<p>之前读过股票大作手回忆录-利弗莫尔的回忆录，是第三方视角记录的有些内容就会存在失真，收获有限。这本书是彼得·林奇个人写的自传，本书从头到尾都在基于他投资选股的内容进行阐述，在对周期股的概念、长期价值投资的坚定、选股思考的逻辑都有不错的收获</p>\n<h2>自洽: 在不确定的日子里向内看 史欣悦</h2>\n<h3>推荐指数 3.5</h3>\n<p>自洽是一个向内沟通的过程，自己之前有段时间工作相对忙碌，在那段时间里很少的考虑到自己本身的一些想法，被一件一件推着往前走。比较缺少对做的事情的一些思考。最近时常会蹦出来一些想法当时如果这么做会更好。在快的节奏里面如果保持自己的节奏(内心)很重要，需要不断的跟自己沟通，丰富自己的认知。</p>\n<h2>看懂世界格局的第一本书 王伟</h2>\n<h3>推荐指数 4</h3>\n<p>通过本书了解到了很多历史的细节和全面的视角,对了解世界格局和经济很有帮助.比如日本、苏联、东南亚国家的发展都对现在有借鉴价值</p>\n<h2>认知世界的经济学 珍大户</h2>\n<h3>推荐指数 4</h3>\n<p>作为入门读物,在需求供给、弹性、利率等方面通过例子讲解的很清晰.书中有些例子有些刻意为之但是瑕不掩瑜</p>\n<h2>随风去野 白关</h2>\n<h3>推荐指数 4</h3>\n<p>跟随生动的插画与作者一起经历了骑行过程中的人、事、景色，是一次不错的体验</p>\n<h2>海龟交易法则 柯蒂斯·费思</h2>\n<h3>推荐指数 3</h3>\n<p>本书是作者个人的经历介绍.海龟交易法阐述了在市场中交易的基本原则,控制风险、控制仓位、止损、止盈等.从书中的收获是在市场中要掌握自己的优势，发挥自己的优势。 建议关键章节详细看</p>\n<h2>中国近代通史(全10册) - 中国社会科学院近代史研究所</h2>\n<h3>推荐指数 5</h3>\n<p>从鸦片战争到中华人民共和国成立，这本书详细的介绍了中国近代史的细节。在阅读的过程中会有历史在眼前重演的错觉，会有遗憾、不解、叹息等情绪。历史仿佛能启发人的思考，以史为鉴可以正衣冠应该说的就是这个道理，对近代史感兴趣的话推荐这本书</p>\n<h2>荒原狼 赫尔曼·黑塞/涂媛媛译</h2>\n<h3>推荐指数 3.5</h3>\n<p>书中的荒原狼可以理解是黑塞本人或者自我抗争的一种表现，书中有很多光怪陆离的表达手法读起来还不错</p>\n<h2>局外人 加缪</h2>\n<h3>推荐指数 4</h3>\n<p>加缪的小说很像有人在你身边讲故事，通过平淡且扎实的叙事方式推进故事的演进</p>","fields":{"readingTime":{"text":"19 min read"}},"frontmatter":{"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null},"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null},{"id":"e88dde7e-fd25-5606-b4a9-8cd74b7e55be","html":"<h2><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/\">JavaScript. The Core: 2nd Edition</a></h2>\n<p>这篇文章介绍JavaScript的一些核心概念，包括对象、原型链、闭包、this、执行上下文等，适合温故知新</p>\n<h2><a href=\"http://www.ayqy.net/blog/%E7%90%86%E8%A7%A3git-submodules/\">理解Git Submodules</a></h2>\n<p>这篇文章介绍了包管理通用的几种方式: npm packages/monorepo/git submodules.\nnpm packages的管理方式基于npm的版本控制方式实现子模块更新，更适合管理底层库、基础依赖。这类代码的变更相对较少，主repo更多使用的是子repo编译后的代码产物<br>\nmonorepo 适用于服务于同一功能的多个模块的组合方式，模块之间功能划分清晰，依赖清晰。解决方案有<a href=\"https://github.com/lerna/lerna\">lerna</a>和yarn的<a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">workspaces</a>.monorepo的优势是可以在一个仓库内完成不同包模块功能的测试，不需要关注子repo的版本问题。劣势是需要解决node_module的依赖问题、编译流程、主repo体积问题等。业务不相关的模块建议直接拆仓维护，自治的成本反而更低。<br>\ngit submodules跟monorepo的理念相近，都直接依赖子repo的源码进行开发。git submodules优势是可以实现子repo的共享源码能力(相对于编译后产物的优势)，可以实现功能的复用(npm packages/微前端)。</p>\n<h2><a href=\"https://blog.plasmic.app/posts/how-react-server-components-work/\">How React server components work: an in-depth guide</a></h2>\n<p>这篇文章详细的介绍了React Server Components的实现机制，通过React Server Components可以更好的实现bundle体积的减少，渲染时间的加快,值得后续的关注</p>\n<h2><a href=\"https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/\">Improving JavaScript Bundle Performance With Code-Splitting</a></h2>\n<p>这篇文章详细的介绍了使用Code Split的细节和关注点</p>\n<h2><a href=\"https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html\">Use Streams to Build High-Performing Node.js Applications</a></h2>\n<p>这篇文章详细的介绍了node中stream流的使用细节，通过例子的方式讲解了流的状态，背压等概念。</p>\n<h2><a href=\"https://www.developerway.com/posts/how-to-write-performant-react-code\">How to write performant React code: rules, patterns, do's and don'ts</a></h2>\n<p>这篇文章通过例子的方式介绍react代码的优化方式，阅读过后能发现出平时一些不注意的点</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null},"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null},{"id":"f93c19b6-9fb0-5f4d-84d1-c3e05c285d4e","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#single-spa\">single-spa简单用法</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#\">子应用配置</a></li>\n<li>1.2. <a href=\"#-1\">主应用配置</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#single-spa-1\">single-spa源码分析</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">启动</a></li>\n<li>2.2. <a href=\"#-1\">子应用挂载/切换</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">关于微前端的一些总结思考</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>微前端是应用组装的一种模式,本文从single-spa的使用方式入手逐步深入到single-spa的源码实现了解微前端的实现方式</p>\n<h2>1. <a name='single-spa'></a>single-spa简单用法</h2>\n<p>single-spa通过子应用与主应用约定交互协议实现微前端应用,在具体的交互中:</p>\n<ul>\n<li>子应用需要暴露应用生命周期方法,例如bootstrap、mount、unmount</li>\n<li>主应用与子应用约定激活规则</li>\n<li>主应用根据挂载规则动态的切换应用状态并且执行对应子应用的生命周期方法</li>\n</ul>\n<p>下面的例子分别从子/主应用的角度梳理下single-spa实现微前端方案的配置方式,在例子中定义了一个主应用(baseapp), 两个子应用(app1, app2).</p>\n<h3>1.1. <a name=''></a>子应用配置</h3>\n<p>single-spa基于js Entry的方式实现微前端方案,在子应用导出的js模块中需要包含子应用的生命周期函数方法，这里的两个子应用都以create-react-app创建的react应用举例,实例代码已上传到<a href=\"https://github.com/icantunderstand/microappdemo\">微前端demo</a></p>\n<ol>\n<li>使用create-react-app创建子应用 npx create-react-app app1</li>\n<li>进入到对应的目录\nnpm run eject // 将创建项目的配置弹出\nnpm install single-spa-react -S</li>\n<li>修改项目的webpack配置,修改输出文件(这里仅为测试使用)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAADEUlEQVQ4y32U647bNhSE/RqpLV51sShS94stW7K3mwDdogX6/i/zFdJuNkh+5MeAJETMGZ3hmUNd1wghUFKQlTXl/YHrO4oqR5kIqU4oc0LqiCiK9ru/w6Gqqn2jtUZrRVYGsqog7yqKqSNva8p1prj0aBtzOkVEJ7GTR5Eg2s8fiASHT4VKYa2lGCfyvsL1LUXXU15H2peVom9J8wSbChJvMalGJ4rYWWxuiJ3BJJpDWZafhMYaimGivN/w44g6nzmOM9F9JeonjuOCfHwlLh1KC5RRmGwj1nsBZSSHpml+Uph4R9YUnLuA9Sm6dNjGY+qC5FJjm4I0pJhU7cqS8K42Lt7X/ZellO8KjcGPV9r1T+rLTP94pb3eMaFCTStivCOmB2JcUO2EkRHGaJSSe/+lkhxCCD8RGq1J0pSmrmi6jqqu2Yybhp6hqehCwb0JzLVnrgoupWMMOUvtaV3GwTmHEN8JLanzZMMd8/wX8/IP+vqKff0PtbxRNR1j8Fx9zmMjLQsmn/M2NgzuzL0sOHjvfyi0lnxTtdxonnfCNOKHjjBNlPOFNLf0bU4VMlqfMTSOpj5z6QuCT+ma/FfCzXpJ7CRZpUnDBoPZn4oiqxPSJib2BlsYTGGIgyUu32GD/ZlQG4PMDNpZjI9JugxTxpgyQTlL3CTYKtm/ZcMZnW0FLWmIsWez45NQKkVuLev1xnpfea4v3IaBZZx4Lg9uXc9jWblfLizzzMvzhbafUPbd3Q1Cih8uC6WZE8M8Tiyv33j+9Ubnc/6eKr72gbUOBGvxRlNoTakkV6uJpEJ+zPHGcxi3idgqaM010SQuIxsDbi5w45lm8fg5J68dUhsipVDW7k9sjjUmjkmSZD9vg7ErVB8KL1YRmoZyvuGGlrKw3PyZxBj+OB53JVsqbasRgl6eOP2aNt97KJTiEivSEEjHHncbcesVWZRIqQjnlJOQfDlFfIkEp0jQRkeOxwixJc3xPXH2cNh7oDQ3K3nUnnVqWfqadehYx5q1ivlWp9y8ZTxL+lRySQSLk9jN4Ux/JtD/HNz2qyS1fusAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wepack修改配置\"\n        title=\"wepack修改配置\"\n        src=\"/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png\"\n        srcset=\"/blog/static/0b818be146d1f3df7220cfad8a318320/63868/webpackConfig.png 250w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/0b533/webpackConfig.png 500w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png 1000w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png 1186w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n4. 修改子应用代码</p>\n<pre><code>    import React from 'react';\n    import ReactDOM from 'react-dom';\n    import './index.css';\n    import singleSpaReact from 'single-spa-react'\n    import App from './App'; // App是子应用的入口 \n\n    // 使用single-spa-react产生子应用的生命周期方法\n    const reactLifecycles = singleSpaReact({\n        React,\n        ReactDOM,\n        rootComponent: App,\n        errorBoundary(err, info, props) {\n            // https://reactjs.org/docs/error-boundaries.html\n            return (\n            &#x3C;div>This renders when a catastrophic error occurs&#x3C;/div>\n            );\n        },\n    });\n\n    export const bootstrap = reactLifecycles.bootstrap;\n    export const mount = reactLifecycles.mount;\n    export const unmount = reactLifecycles.unmount;  \n</code></pre>\n<ol start=\"4\">\n<li>\n<p>构建子应用,生成入口文件，这里通过serve提供静态服务的方式提供入口js Entry的访问，在实际中可以使用nginx或者cdn的形式提供访问</p>\n<pre><code> npm run build\n serve -s -l 3001 build // 指定端口 \n</code></pre>\n</li>\n</ol>\n<h3>1.2. <a name='-1'></a>主应用配置</h3>\n<ol>\n<li>\n<p>使用create-react-app创建主应用 npx create-react-app baseapp</p>\n</li>\n<li>\n<p>安装微前端依赖</p>\n<p>npm install single-spa react-router-dom -S</p>\n</li>\n<li>\n<p>主应用增加与子应用配置代码</p>\n<pre><code> import React from 'react';\n import ReactDOM from 'react-dom';\n import { BrowserRouter as Router, Link } from 'react-router-dom'\n import history from 'history/browser';\n import './index.css';\n import { registerApplication, start } from 'single-spa'\n\n async function loadApp(libraryUrl, libraryName) {\n     // 打包的webpack配置是umd模式 直接挂载在window上\n     if(window[libraryName]) {\n         return window[libraryName]\n     }\n     // 加载并且等待js执行\n     await new Promise((resolve, reject) => {\n         const script = document.createElement('script')\n         script.src = libraryUrl\n         script.onload = resolve\n         script.onerror = reject\n         document.body.appendChild(script)\n     })\n     return window[libraryName]\n }\n\n // 子应用可以通过走服务端下发配置 \n const apps = [\n     {\n         name: 'app1',\n         // 子应用加载方法，加载对应的js Entry\n         app: () => loadApp('http://localhost:3001/app1.js', 'app1'),\n         // 子应用激活方法\n         activeWhen: location => location.pathname.startsWith('/app1'),\n         // 共享属性\n         customProps: {}\n     },\n     {\n         name: 'app2',\n         app: () => loadApp('http://localhost:3002/app2.js', 'app2'),\n         activeWhen: location => location.pathname.startsWith('/app2'),\n         customProps: {}\n     }\n ]\n // 注册子应用\n for(let i = 0; i &#x3C; apps.length; i++) {\n     registerApplication(apps[i])\n }\n // 启动single-spa提供微服务能力\n start()\n // 渲染主应用\n ReactDOM.render(\n     &#x3C;div>\n         this is base app\n         &#x3C;Router history={history}>\n         // 子应用入口\n         &#x3C;div>&#x3C;Link to=\"app2\"  >app2&#x3C;/Link>&#x3C;/div>\n         &#x3C;div>&#x3C;Link to=\"app1\" >app1&#x3C;/Link>&#x3C;/div>\n     &#x3C;/Router>\n     &#x3C;/div>,\n     document.getElementById('root')\n );\n</code></pre>\n</li>\n<li>\n<p>启动主应用，就能看到两个子应用聚合成一个应用，点击对应的调整也能正常切换</p>\n</li>\n</ol>\n<p><img src=\"/blog/35257e241336dfb4aa08e94db8b4aec4/run.gif\" alt=\"引用切换\"></p>\n<h2>2. <a name='single-spa-1'></a>single-spa源码分析</h2>\n<p>single-spa的源码可以分成两个阶段来看: 启动阶段和子应用挂载(切换)阶段.下面就分别从这两个阶段看single-spa的执行过程</p>\n<h3>2.1. <a name='-1'></a>启动</h3>\n<p>在启动主应用的时候，通过registerApplication注册子应用和start方法启动微前端\n在registerApplication中主要对子应用的入参进行了格式化处理然后将子应用推入全局的数据保存，然后执行应用切换的主函数reroute做首次应用的加载逻辑</p>\n<pre><code>export function registerApplication(\n    appNameOrConfig,\n    /** 子应用异步加载函数 需要返回带有生命周期的模块导出 */\n    appOrLoadApp,\n    /** 应用激活函数 */\n    activeWhen,\n    /** 共享属性 */\n    customProps\n    ) {\n    // 子应用入参格式化处理\n    const registration = sanitizeArguments(\n        appNameOrConfig,\n        appOrLoadApp,\n        activeWhen,\n        customProps\n    );\n    /** 推入全局的子应用数组 */\n    apps.push(\n        assign(\n        {\n            loadErrorTime: null,\n            /** 应用状态 */\n            status: NOT_LOADED,\n            parcels: {},\n            devtools: {\n            overlays: {\n                options: {},\n                selectors: [],\n            },\n            },\n        },\n        registration\n        )\n    );\n    if (isInBrowser) {\n        ensureJQuerySupport();\n        /** 执行应用切换的主函数 */\n        reroute();\n    }\n}\n</code></pre>\n<p>在reroute中会对子应用加载状态进行分类(appsToUnload\\appsToUnmount\\appsToLoad\\appsToMount)然后根据是否运行过start函数走不同触发逻辑:</p>\n<ol>\n<li>\n<p>未运行过start函数,走app初始化加载逻辑(js Entry下载)</p>\n</li>\n<li>\n<p>运行过start函数,走app挂载/切换逻辑</p>\n<pre><code> export function start(opts) {\n     // start控住通过全局变量控住整个应用挂载状态\n     // 二次调用start 触发对应的子应用挂载\n     started = true;\n     if (opts &#x26;&#x26; opts.urlRerouteOnly) {\n         setUrlRerouteOnly(opts.urlRerouteOnly);\n     }\n     if (isInBrowser) {\n         reroute();\n     }\n }\n /** 执行应用切换的主函数 */\n export function reroute(pendingPromises = [], eventArguments) { \n     /** 应用处于切换状态中,推入到待处理的peopleWaitingOnAppChange 等待后续统一处理 */\n     if (appChangeUnderway) {\n         return new Promise((resolve, reject) => {\n         peopleWaitingOnAppChange.push({\n             resolve,\n             reject,\n             eventArguments,\n         });\n         });\n     }\n     /** 获取当前子应用的状态数组 */\n     /** 在getAppChanges中根据传入的activeWhen进行判断 首次应用应该处于appsToLoad数组中 */\n     const {\n         /** 移除状态 */\n         appsToUnload,\n         /** 卸载状态 */\n         appsToUnmount,\n         /** 加载状态 */\n         appsToLoad,\n         /** 即将挂载状态 */\n         appsToMount,\n     } = getAppChanges();\n     let appsThatChanged,\n         navigationIsCanceled = false,\n         oldUrl = currentUrl,\n         newUrl = (currentUrl = window.location.href);\n     // 是否运行过start函数 走应用切换逻辑\n     if (isStarted()) {\n         appChangeUnderway = true;\n         appsThatChanged = appsToUnload.concat(\n         appsToLoad,\n         appsToUnmount,\n         appsToMount\n         );\n         return performAppChanges();\n     } else {\n         // 未运行过start函数走app初始化加载逻辑\n         appsThatChanged = appsToLoad;\n         return loadApps();\n     }\n     /** 省略若干代码 */\n }\n</code></pre>\n</li>\n</ol>\n<p>loadApps通过微任务的方式加载js Entry然后在对应的app对象设置子应用的生命周期函数</p>\n<pre><code>/** 加载子应用js Entry */\nfunction loadApps() {\n    return Promise.resolve().then(() => {\n        /** 通过微任务的方式加载appsToLoad 在加载完毕后在\n        * 对应的app对象上设置暴露的生命周期方法\n        */\n        const loadPromises = appsToLoad.map(toLoadPromise);\n\n        return (\n        Promise.all(loadPromises)\n        /** 触发路由事件 首次加载可忽略这里 */\n            .then(callAllEventListeners)\n            // there are no mounted apps, before start() is called, so we always return []\n            .then(() => [])\n            .catch((err) => {\n            callAllEventListeners();\n            throw err;\n            })\n        );\n    });\n}\n</code></pre>\n<h3>2.2. <a name='-1'></a>子应用挂载/切换</h3>\n<p>在single-spa启动的时候,会监听路由事件然后再触发路由事件和执行reroute方法</p>\n<pre><code>/** 路由事件监听 */\nwindow.addEventListener(\"hashchange\", urlReroute);\nwindow.addEventListener(\"popstate\", urlReroute);\n/** patchedUpdateState也会触发urlReroute */patchedUpdateState\nwindow.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    \"pushState\"\n);\nwindow.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    \"replaceState\"\n);\n\nfunction urlReroute() {\n    reroute([], arguments);\n}\n</code></pre>\n<p>所以app挂载切换的主逻辑都在reroute的performAppChanges中,主要做了:</p>\n<ul>\n<li>\n<p>派发single-spa自定义事件</p>\n</li>\n<li>\n<p>执行移除/卸载状态应用的生命周期函数</p>\n</li>\n<li>\n<p>执行挂载应用的生命周期函数(依赖卸载/移除的执行tryToBootstrapAndMount)</p>\n<p>function performAppChanges() {</p>\n<pre><code>  return Promise.resolve().then(() => {\n      /** 派发single-spa自定义事件 */\n      /** 省略若干代码 */\n      // 执行需要移除/卸载状态应用的生命周期函数并且删除对应的生命周期函数\n      // 重置应用状态\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      const unmountUnloadPromises = appsToUnmount\n          .map(toUnmountPromise)\n          .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n      unmountAllPromise.then(() => {\n      window.dispatchEvent(\n          new CustomEvent(\n          \"single-spa:before-mount-routing-event\",\n          getCustomEventDetail(true)\n          )\n      );\n      });\n\n      // 子应用的加载和bootstrap生命周期函数执行\n      const loadThenMountPromises = appsToLoad.map((app) => {\n          return toLoadPromise(app).then((app) =>\n              tryToBootstrapAndMount(app, unmountAllPromise)\n          );\n      });\n      // 子应用挂载和mount生命周期函数的执行\n      const mountPromises = appsToMount\n          .filter((appToMount) => appsToLoad.indexOf(appToMount) &#x3C; 0)\n          .map((appToMount) => {\n              return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n      });\n      /** 省略若干代码 */\n  });\n  }\n  // tryToBootstrapAndMount依赖之前需要unLoad和unMount的应用周期函数执行完毕\n  function tryToBootstrapAndMount(app, unmountAllPromise) {\n      if (shouldBeActive(app)) {\n          return toBootstrapPromise(app).then((app) =>\n          unmountAllPromise.then(() =>\n              shouldBeActive(app) ? toMountPromise(app) : app\n          )\n          );\n      } else {\n          return unmountAllPromise.then(() => app);\n      }\n  }\n</code></pre>\n</li>\n</ul>\n<p>以上梳理了single-spa实现微前端的主体流程</p>\n<h2>3. <a name='-1'></a>关于微前端的一些总结思考</h2>\n<p>在讨论使用一个技术方案的时候,主要考虑点这项技术方案是否能解决当前或者未来项目中遇到的问题,微前端的优势在于项目的组合(新老项目平滑过渡\\项目功能共享\\应用拆分\\流程解耦)等但同时也增加了项目维护的一些成本,需要结合项目和业务发展方向进行探索使用</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://juejin.cn/post/6862661545592111111\">微前端框架 之 single-spa 从入门到精通</a><br>\n<a href=\"https://blog.yuanziwen.cn/2019/12/18/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E8%90%BD%E5%9C%B0%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF\">微前端时代思考与实践</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/fy3qri\">你可能并不需要微前端</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/rhduwc\">微前端的核心价值</a></p>","fields":{"readingTime":{"text":"11 min read"}},"frontmatter":{"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null},"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null},{"id":"6364b3fd-5475-525c-b92d-3a8dbc96d96d","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#\">前置概念</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#-1\">沙盒</a></li>\n<li>1.2. <a href=\"#Proxy\">Proxy</a></li>\n<li>1.3. <a href=\"#with\">with</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#-1\">沙盒的实现方式</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#ProxySandbox\">ProxySandbox(单实例沙盒)</a></li>\n<li>2.2. <a href=\"#snapshotSandbox\">snapshotSandbox(单实例沙盒)</a></li>\n<li>2.3. <a href=\"#-1\">多实例沙盒</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">附录</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>不同的微前端框架会提供沙盒环境来实现不同微前端应用的隔离.本文梳理JavaScript中沙盒的实现方式，有助于学习微前端方案的技术细节.</p>\n<h2>1. <a name=''></a>前置概念</h2>\n<h3>1.1. <a name='-1'></a>沙盒</h3>\n<p>沙盒是一种安全机制可以为程序提供隔离的执行环境，沙盒中提供用后即回收的磁盘及内存空间，在沙盒中对网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是被严格限制的.JavaScript沙盒是通过语法层面的限制来实现代码执行的隔离.</p>\n<h3>1.2. <a name='Proxy'></a>Proxy</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>可以实现对对象属性访问的代理，通过Proxy的使用可以实现JavaScript代码执行的沙盒模式</p>\n<h3>1.3. <a name='with'></a>with</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with\">with</a>语句可以扩展当前的执行上下文</p>\n<pre><code>const a = { name: 1111 }\nwith(a) {\n    console.log(name) // 1111\n}\n</code></pre>\n<h2>2. <a name='-1'></a>沙盒的实现方式</h2>\n<p>沙盒的实现方式上主要分为:</p>\n<ul>\n<li>单实例沙盒: 同一个时刻只有一个微应用实例存在，当前资源被这个应用独占，需要解决的主要问题是应用切换的时候变量污染清理和再次启动时的变量恢复</li>\n<li>多实例沙盒: 资源不是应用独占，需要解决资源共享、通信等问题</li>\n</ul>\n<h3>2.1. <a name='ProxySandbox'></a>ProxySandbox(单实例沙盒)</h3>\n<p>基于Proxy的拦截和设置功能，通过Proxy拦截对全局对象的修改记录，在应用切换的时候还原全局对象</p>\n<pre><code>    /** 设置全局对象属性 */\n    const setWindowProp = (prop, value) => {\n        window[prop] = value\n    }\n\n    class SandBox {\n        name;\n        /** 代理对象 需要通过该对象操作沙盒 */\n        proxy = null;\n        /** 新增的修改 */\n        addedPropsMap = new Map();\n        /** 沙盒期间更新的修改 */\n        modifiedOriginValueProps = new Map();\n        /** 当前沙盒所做的修改 用于还原当前的沙盒 */\n        currentUpdatedProps = new Map();\n        /** 激活沙盒 */\n        active() {  \n            this.currentUpdatedProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n        }\n        /** 沙箱卸载 */\n        inactive() {\n            /** 修改的属性还原 */\n            this.modifiedOriginValueProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n            /** 增加的属性清空 */\n            this.addedPropsMap.forEach((_, p) => {\n                setWindowProp(p, undefined)\n            })\n        }\n        constructor(name) {\n            this.name = name;\n            const fakeWindow = Object.create(null)\n            const {\n                addedPropsMap,\n                modifiedOriginValueProps,\n                currentUpdatedProps,\n            } = this\n            const proxy = new Proxy(fakeWindow, {\n                get(target, prop) {\n                    return window[prop]\n                },\n                set(_, prop, value) {\n                    if(!window.hasOwnProperty(prop)) {\n                        /** window上没有该属性 新增 */\n                        addedPropsMap.set(prop, value)\n                    } else if(!modifiedOriginValueProps.hasOwnProperty(prop)) {\n                        /** window上有该属性且未更新,记录 */\n                        const originValue = window[prop] \n                        modifiedOriginValueProps(prop, originValue)\n                    }\n                    /** 记录当前沙盒的更新 */\n                    currentUpdatedProps.set(prop, value)\n                    /** 更新全局属性 */\n                    setWindowProp(prop, value)\n                    return true\n                }\n            })\n            this.proxy = proxy\n        }\n    }\n\n    const newSandBox = new SandBox('app')\n    const proxyWindow = newSandBox.proxy\n    proxyWindow.appName = 'app'\n    console.log(window.appName, proxyWindow.appName) // app app\n    newSandBox.inactive()\n    console.log(window.appName, proxyWindow.appName) // undefined undefined\n    newSandBox.active()\n    console.log(window.appName, proxyWindow.appName) // app app\n</code></pre>\n<h3>2.2. <a name='snapshotSandbox'></a>snapshotSandbox(单实例沙盒)</h3>\n<p>快照沙盒是在不支持Proxy的环境下，通过将window对象属性都复制到快照对象上然后再激活和卸载的时候对激活期间的diff进行添加或者回退.这个方案的对比方案较复杂，比如考虑到原型链的修改与还原问题，一般不作为沙盒方案的首选.</p>\n<pre><code>class SnapshotSandbox {\n    constructor(name) {\n        this.name = name;\n        this.proxy = window;\n        this.type = 'Snapshot';\n        this.sandboxRunning = true;\n        this.windowSnapshot = {};\n        this.modifyPropsMap = {};\n        this.active();\n    }\n    //激活\n    active() {\n        // 记录当前快照\n        this.windowSnapshot = {};\n        iter(window, (prop) => {\n            this.windowSnapshot[prop] = window[prop];\n        });\n\n        // 恢复之前的变更\n        Object.keys(this.modifyPropsMap).forEach((p) => {\n            window[p] = this.modifyPropsMap[p];\n        });\n\n        this.sandboxRunning = true;\n    }\n    //还原\n    inactive() {\n        iter(window, (prop) => {\n            if (window[prop] !== this.windowSnapshot[prop]) {\n                // 记录变更，恢复环境\n                this.modifyPropsMap[prop] = window[prop];\n            \n                window[prop] = this.windowSnapshot[prop];\n            }\n        });\n        this.sandboxRunning = false;\n    }\n}\n\nconst sandbox = new SnapshotSandbox();\nconst proxyWindow = sandbox.proxy\nsandbox.active();\nproxyWindow.appName = 'app'\nconsole.log(proxyWindow.appName, window.appName) // app app\nsandbox.inactive();\nconsole.log(proxyWindow.appName, window.appName) // undefined undefined\n</code></pre>\n<h3>2.3. <a name='-1'></a>多实例沙盒</h3>\n<p>多实例沙盒是Proxy实现的单实例的变种版，在Proxy实现的单实例沙盒中，Proxy的handler的get/set是直接操作的全局对象,多实例版本在handler的get/set中操作沙盒自己维护的对象，从而实现多实例模式</p>\n<pre><code>class MultiProxySandbox {\n    name;\n    proxy = null;\n    /** context 传入多实例沙盒共享数据 */\n    constructor(name, context={}){\n        this.name = name;\n        const fakeWindow = Object.create({});\n        const proxy =  new Proxy(fakeWindow,{\n        set(target, name, value){\n            /** 返回共享属性  */\n            if(Object.keys(context).includes(name)){\n                context[name] = value;\n            }\n            target[name] = value;\n        },\n        get(target,name){\n            // 优先使用共享对象\n            if(Object.keys(context).includes(name)){\n                return context[name];\n            }\n            if( typeof target[ name ] === 'function' &#x26;&#x26; /^[a-z]/.test(name)){\n            return target[ name ].bind &#x26;&#x26; target[ name ].bind( target );\n            } else {\n            return target[ name ];\n            }\n        }\n        })\n        this.proxy = proxy\n        return proxy\n    }\n}\n\nconst context = { document: window.document, globalData:'abc'};\nconst newSandBox1 = new MultiProxySandbox('app1',context);\nconst newSandBox2 = new MultiProxySandbox('app2',context);\nnewSandBox1.appName = 'app1'\nnewSandBox2.appName = 'app2'\nconsole.log(newSandBox1.appName, newSandBox2.appName, window.appName) // app1 app2 undefined\nconsole.log(newSandBox1.globalData, newSandBox2.globalData) // abc abc\n</code></pre>\n<h2>3. <a name='-1'></a>附录</h2>\n<p><a href=\"https://juejin.cn/post/6844904066225537037\">字节跳动的微前端沙盒实践</a><br>\n<a href=\"https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg\">前端微服务在字节跳动的打磨与应用</a><br>\n<a href=\"https://cloud.tencent.com/developer/article/1748172\">谈谈微前端领域的js沙箱实现机制</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null},"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null},{"id":"323785b4-f7d7-591d-a250-aee7abdc366b","html":"<h3><a href=\"https://alexkondov.com/tao-of-react/\">Tao of React - Software Design, Architecture &#x26; Best Practices</a></h3>\n<p>这篇文章介绍了React开发中的一些‘最佳’实践,比如组件逻辑拆分、项目的目录设计、react常见的写法等，可以将其中的一些点作为code review时候的一些参考点</p>\n<h3><a href=\"https://blog.tericcabrel.com/implement-server-sent-event-in-node-js/\">Implement Server-Sent Events in Node.js and React</a></h3>\n<p>这篇文章介绍nodejs中server-sent events的实现服务端推送，看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventSource#browser_compatibility\">兼容性</a>上还可以。在有node中间层的服务可以尝试这种方案</p>\n<h3><a href=\"https://blog.molecule.dev/the-only-custom-react-hooks-we-use/\">The only two custom React hooks we ever really use</a></h3>\n<p>这篇文章介绍了两个自定义的hooks,可以在项目中尝试下</p>\n<ul>\n<li>useAsyncExtendedState  实现state的部分更新，更新state的时候只需要传入需要更新的属性即可.</li>\n<li>userPromise 异步事件的管理(cancal, reset)</li>\n</ul>\n<h3><a href=\"https://thoughtspile.github.io/2021/11/15/unintentional-layout-effect/\">useEffect sometimes fires before paint</a></h3>\n<p>这篇文章介绍了react hook-useEffect和useLayoutEffect触发时机和结合使用的一些注意事项</p>\n<h3><a href=\"https://thoughtspile.github.io/2022/01/17/jsx-conditionals/\">Good advice on JSX conditionals</a></h3>\n<p>这篇文章介绍在React中写JSX的一些建议写法，有利于规范的形成，比如禁止嵌套三元运算符也能防止代码出现不可预知的错误</p>\n<h3><a href=\"https://blog.saeloun.com/2022/01/13/react-18-usedefferedvalue-hook\">Sneak peek into React 18 useDeferredValue hook</a></h3>\n<p>这篇文章介绍React 18中useDeferredValue hook.通过useDeferredValue可以实现指定优先级的渲染任务.</p>\n<h3><a href=\"https://www.robinwieruch.de/react-event-bubbling-capturing/\">React: Event Bubbling and Capturing</a></h3>\n<p>这篇文章通过图解和例子的方式比较生动的介绍了React中事件的处理机制，可以作为温习</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null},"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null},{"id":"cc4079ca-b1c7-595d-8587-228c1e489fd6","html":"<h2><a href=\"https://web.dev/aspect-ratio/\">aspect-ratio CSS property</a></h2>\n<p>通过aspect-ratio可以直接为容器设置宽高比</p>\n<h2>React</h2>\n<h3><a href=\"https://www.joshfinnie.com/blog/using-webassembly-created-in-rust-for-fast-react-components/\">Using WebAssembly (created in Rust) for Fast React Components</a></h3>\n<p>一篇React结合WebAssembly的介绍文章</p>\n<h3><a href=\"https://alexsidorenko.com/\">A Visual Guide to React Rendering -xxx</a></h3>\n<p>很不错的介绍react相关api和基本概念的文档</p>\n<h3><a href=\"https://joshcollinsworth.com/blog/introducing-svelte-comparing-with-react-vue\">Introducing Svelte, and Comparing Svelte with React and Vue</a></h3>\n<p>一篇介绍Svelte与react和vue的对比文章，通过这篇文章发现Svelte的确在某些情况较react/vue有一定优势，可以保持关注度</p>\n<h3><a href=\"https://devtrium.com/posts/react-typescript-using-generics-in-react\">React &#x26; TypeScript: use generics to improve your types</a></h3>\n<p>这篇文章结合useState的例子介绍react中泛型的使用</p>\n<h2>项目设计</h2>\n<h3><a href=\"https://dev.to/mbarzeev/creating-a-react-component-with-tdd-2jn8\">Creating a React component with TDD</a></h3>\n<p>在react项目中引入TDD的案例文章</p>\n<h3><a href=\"https://engineering.udacity.com/react-folder-structure-for-enterprise-level-applications-f8384eff162b\">React folder structure for enterprise level applications</a></h3>\n<p>React项目文件组织的推荐方式，文件的组织、文档、技术方案都是项目整体架构的一部分，需要给予关注</p>\n<h2>前端库</h2>\n<h3><a href=\"https://github.com/breejs/bree\">Bree</a></h3>\n<p>Bree is the best job scheduler for Node.js and JavaScript with cron, dates, ms, later, and human-friendly support</p>\n<h3><a href=\"https://github.com/DominicTobias/react-image-crop\">React Image Crop</a></h3>\n<p>An image cropping tool for React with no dependencies</p>\n<h3><a href=\"https://github.com/pubkey/rxdb\">RxDB</a></h3>\n<p>RxDB是基于PouchDB的一套响应式数据库存储方案</p>\n<h3><a href=\"https://github.com/dexie/Dexie.js\">Dexie.js</a></h3>\n<p>在IndexedDB基础上进行封装，提供更好用的查询api和降低IndexedDB的使用成本</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null},"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null},{"id":"78fb9a8d-a295-5d20-8c43-9a4a98d296ef","html":"<h2>1. <a name=''></a>跨端相关</h2>\n<h3>1.1. <a name='Flipperhttps:fbflipper.com'></a><a href=\"https://fbflipper.com/\">Flipper</a></h3>\n<p>Flipper是调试react native的桌面工具，相对于之前的远程调试(模拟JS运行在本地浏览器)，Flipper的调试都基于当前react native的运行环境，使用体验上也比远程调试的方式好一些.</p>\n<h3>1.2. <a name='Elecruehttps:github.comRajvirSingh1313Elecrue'></a><a href=\"https://github.com/RajvirSingh1313/Elecrue\">Elecrue</a></h3>\n<p>Elecrue是一个生成Electron模板应用的工具，做一些辅助的Electron应用可以尝试使用这个工具</p>\n<h2>2. <a name='React'></a>React相关</h2>\n<h3>2.1. <a name='whatsnewinreact18https:yagmurcetintas.comjournalwhats-new-in-react-18'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-react-18\">what's new in react 18?</a></h3>\n<p>这篇文章介绍了React 18的新特性，其中<a href=\"https://github.com/reactwg/react-18/discussions/21\">Automatic batching</a>值得关注</p>\n<h3>2.2. <a name='react-usehttps:github.comstreamichreact-use'></a><a href=\"https://github.com/streamich/react-use\">react-use</a></h3>\n<p>react-use是一个hooks的工具函数库，需要对应的hooks实现的时候可以参考</p>\n<h3>2.3. <a name='react-loadablehttps:github.comjamiebuildsreact-loadable'></a><a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a></h3>\n<p>react-loadable是基于webpack dynamic import实现的动态加载组件的库，看它的实现其实不难，感悟是要到通用的问题要学会抽象的提取并且设计解决方案，比如loadable的loading设置时间，超时时间等，都是在解决开发中的问题。webpack还有splitChunk实现chunk的拆分。</p>\n<h3>2.4. <a name='react-queryhttps:react-query.tanstack.comoverview'></a><a href=\"https://react-query.tanstack.com/overview\">react-query</a></h3>\n<p>相对于Redux，react-query减少了很多模板代码的编写，减少了代码的理解成本。能让你falling into the pit of success.<a href=\"https://tkdodo.eu/blog/react-query-as-a-state-manager\">React Query as a State Manager</a>这篇是在官网上看到的react-query做状态管理的例子。</p>\n<h2>3. <a name='Javascript'></a>Javascript相关</h2>\n<h3>3.1. <a name='whatsnewines2022https:yagmurcetintas.comjournalwhats-new-in-es2022'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-es2022\">what's new in es2022?</a></h3>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null},"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null},{"id":"7175f7aa-a470-5777-9d30-b1181240a447","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#\">背景知识</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#RN\">RN项目初始化</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">依赖安装</a></li>\n<li>2.2. <a href=\"#cli\">cli初始项目</a></li>\n<li>2.3. <a href=\"#typescript\">使用typescript模板初始项目</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#RN-1\">RN项目启动&#x26;调试</a></li>\n</ol>\n<ul>\n<li>3.1. <a href=\"#metro\">启动metro</a></li>\n<li>3.2. <a href=\"#-1\">启动项目</a>\n<ul>\n<li>3.2.1. <a href=\"#-1\">正常模式启动项目</a></li>\n<li>3.2.2. <a href=\"#debug\">debug模式启动项目</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>在<a href=\"https://icantunderstand.cn/2021-11-03\">11月的前端快报</a>中有系列文章介绍了React Native新架构的相关概念，笔者也有一定的React Native开发经验，但是总感觉没有深入到React Native的细节实现停留到用的层面偏多，这个深入浅出React Native系列注重从源码的角度梳理RN的实现细节，希望通过这个系列能熟悉RN的细节拓展端知识，希望能跟你一起有所收获。</p>\n<h2>1. <a name=''></a>背景知识</h2>\n<p>本系列基于Android代码的基础上进行源码分析，涉及到Android相关的基础知识，可以参考之前的笔记<a href=\"https://icantunderstand.cn/android-basic\">第一行代码-Android读书笔记</a>和<a href=\"https://icantunderstand.cn/%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/\">跨端技术</a></p>\n<p>在系列文章中使用RN来指代React Native</p>\n<h2>2. <a name='RN'></a>RN项目初始化</h2>\n<h3>2.1. <a name='-1'></a>依赖安装</h3>\n<ul>\n<li>\n<p>Android Studio</p>\n</li>\n<li>\n<p><a href=\"https://developer.android.com/studio/run/emulator\">创建Android虚拟机</a></p>\n</li>\n<li>\n<p>JDK 这里推荐自己手动<a href=\"https://www.oracle.com/java/technologies/java8.html\">下载JDK</a>进行安装并且在控制台的启动配置上配置Android和JDK配置</p>\n<pre><code>  // Android\n  export ANDROID_HOME=$HOME/Library/Android/sdk\n  export PATH=$PATH:$ANDROID_HOME/emulator\n  export PATH=$PATH:$ANDROID_HOME/tools\n  export PATH=$PATH:$ANDROID_HOME/tools/bin\n  export PATH=$PATH:$ANDROID_HOME/platform-tools\n  // Java\n  export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home\n  export PATH=$JAVA_HOME/bin:$PATH\n  export CLASS_PATH=$JAVA_HOME/lib  \n</code></pre>\n</li>\n<li>\n<p>node watchman\nnode推荐使用<a href=\"https://github.com/nvm-sh/nvm\">nvm</a>进行安装\nwatchman使用<a href=\"https://brew.sh/\">Homebrew</a></p>\n</li>\n</ul>\n<h3>2.2. <a name='cli'></a>cli初始项目</h3>\n<p>按照<a href=\"https://reactnative.dev/docs/environment-setup\">官方文档</a>的步骤选择配置条件，这里使用Cli初始项目<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5UlEQVQoz62Q22rEMAxE/f9/WHp72Gazvmrt2Epjh0yRQqH0dVcwyB7BGSFDdEeMEaUx3meL12nG23TDy+UK7gPHcWDs+6kxsGs/3/8lM2OdQyKCdR4uJtxChA1nvzkP7z1yLmBesSwLWmO01pBz1r+o1qb+UitMiFGHKSWEEHRbgdyJ1PM+oJSCWquCRAJh5tNj1rmGMcNYa+GcAxEpTEASIkrp9H7P8teTMOkxyiIR1jqs6wrzOc2YrcO2bRgHUPuOR8p8BULrO1ju8t1xzQ39eAD4Mc1Y+8CzykxUdLO+bU8B/gA2hG4JYWmz4wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cli配置\"\n        title=\"cli配置\"\n        src=\"/blog/static/34c810777b55c962d15e1c6a1593e3af/00d43/cliConfig.png\"\n        srcset=\"/blog/static/34c810777b55c962d15e1c6a1593e3af/63868/cliConfig.png 250w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/0b533/cliConfig.png 500w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/00d43/cliConfig.png 1000w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/aa440/cliConfig.png 1500w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/e8950/cliConfig.png 2000w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/b75f8/cliConfig.png 2124w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>2.3. <a name='typescript'></a>使用typescript模板初始项目</h3>\n<p>使用typescript初始化项目</p>\n<pre><code>npx react-native init AwesomeTSProject --template react-native-template-typescript  \n</code></pre>\n<p>项目目录如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 736px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ef5f8a4e4b272b12658513416b29ba6e/f941f/projectCategory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 244.79999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAxCAYAAADa6ImIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAE20lEQVRIx51X6W7bZhD0W/RHEVkHKV7iLfEmJUqyZFmSryRFEyRtUfT9X2GKWZpOgqAW2R+LTyE/b2Z3Zg9e+b4Pw7BgWTYcx0MSZwjDBTTNkOd97Wo+XyBNVyjLLY7HJ3z58jc+f/4Lnz79gSyrkSTLXnYVBAFs24fnzTGfx8iyEmW5wnK5lme27cn7rnbleR7G4wkMw4CuG6iqCofDAff3D3BdF6PRCIqiYDLpZuJQUVSYJnNgIklS1PUaljWTC6qqQVWnne3VIZ3RoijG7e0Bvh8I8j7OfnI4m9lYLlfI8wKj0bi3s58RmpY4K8tK8snn/z9k3YBjzbDZbHE+3+Ph4VEuDIejl1x2duhDmSjQbRdWVCCOY8RxgiAIwXfMKVPBy9Op1sGh70MdDqFWO6jHj6iyDLeHOyFmv78V+dD5u3cDjIZjKMoFh77n4VpRsdZMfFZNBFEsxFTVUpCmaSZ5Xa1qZFkuf/SWU3E4UlTkmomTbqOqa2zWGyGGjne7PW5uduKQxrAbst4ghUk3ZzMs0gSrZS1OjsejiJyhXl8PhRzaW86+I2UCywsRFDWiRSShFUUpuTMNSyREZP1IWe0x/u0f7LeNbEgGQ316ekYYzjEYXHeTTZvDjDk0HURphjiKRS60lhj+/ib2SyyrU2xUDV8VA3FZYl2vhRg2CUqH5Gy3N7Bt56LIm5BZt2mF4faMLE6w3mxFNswl0bF6yHqXihGHyngMI8phZDWyJBFElAhRrV+Q5kUBpU8tm5qOPKaoawxepEIixN4NXiVzya44pDTDhGU7cP0AcZrB8Xz5t8d6DkJ5blgzuXfJrvwggGE7sP0ASVHi8cMH3J3vsdntcf/0jNPjEz7+/glhnECzZjAdV+7/lzWkqBrC+QJ+ECLLCyEkL0pUy5UIfKKomGr6q7jfstfSo3hZGSSDjNIRTxLSjoJOOXRdD5puYF6UcBwXx+PpVSY8T6cTbMft3GQFIaH6PhupI8ha/bE6ePJ5Z4eu50LXTLwv/0QUJrg9HHA6nUWLDJeX+gwsQcgfumnLbsKWtVhEUsM8mVfuOZdq+EeHZMhyhBgOp91uh/1+L2ezQXidZ/QLQg36zIHjejgc7iRUhsz8Mdyu6H4IWdVngqSua3FGYriZ9Rmh37E8RVUNEAQuttsd7u6O0rY4nNgcdM3oF7KmTeH7Y+l3JKWVDUlp5zLfNQPqkmxcD4ahIs+HYKNo0O2x2WxEPhxYPN+//9BpgRKHuj5FOB+DaImMbBNpu9JNJqqg0zT98ghoHUaLgawhRNi2fL5rSWlrtRvLmoGhX2CRZNjd7IQIEtKX4W8dW9VgByaCMJCmQCIomfZSz+2rkc3N9lcURYLz+UG6DFGy8zw/P+N4d/xuRe4omyAYC8ur1VrqmCjphHnkdnFpp/kJYZIMEccLETSlwtA5mLjbcFD17IdTzOcjeJ6LZdWUHUVNthk+eyTF3QthFI3ku6RZ2nMJm47a+cyQifhyg5VKmSJNr191yCWJhNAhf/M/4XrHLtRJ2FLLwURIYbgkhMgoHYbOk8aZ0wGh39Ry9AvSJJG6JarHx0chiOHSGTeJbrJxXai6Ce3mHkGUIEkSJGkmLDdfqpl8tnUfAa6LqTnD9PARizSXD8dmfJ4ln+zgDHUy7iabfwGst+EamUEFEAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"项目目录\"\n        title=\"项目目录\"\n        src=\"/blog/static/ef5f8a4e4b272b12658513416b29ba6e/f941f/projectCategory.png\"\n        srcset=\"/blog/static/ef5f8a4e4b272b12658513416b29ba6e/63868/projectCategory.png 250w,\n/blog/static/ef5f8a4e4b272b12658513416b29ba6e/0b533/projectCategory.png 500w,\n/blog/static/ef5f8a4e4b272b12658513416b29ba6e/f941f/projectCategory.png 736w\"\n        sizes=\"(max-width: 736px) 100vw, 736px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>android目录对应当前项目安卓代码的位置</li>\n<li>index.js是项目RN的入口文件(在MainApplication的ReactNativeHost的getJSMainModuleName方法关联指定入口)</li>\n</ul>\n<h2>3. <a name='RN-1'></a>RN项目启动&#x26;调试</h2>\n<h3>3.1. <a name='metro'></a>启动metro</h3>\n<p><a href=\"https://developer.android.com/studio/run/emulator\">metro</a>是react native的打包,通过启动metro server才能在项目中访问对应打包好的入口文件</p>\n<pre><code>npx react-native start\n</code></pre>\n<h3>3.2. <a name='-1'></a>启动项目</h3>\n<p>在Android Studio导入刚才初始化项目的android目录，</p>\n<h4>3.2.1. <a name='-1'></a>正常模式启动项目</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/09ae1afd35f64c13097b4c4898839eef/f4281/normalStart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAb0lEQVQI12XDQQ6CMBBAUU5lTAQybdMpdDotrFBX3v8S37XxJW9aF+HnLKwiSAqEWjB3csqkmOk+qNW5lpmP3Hg97ogkZIvEEFlzY8q78bca2hrqnTpOijmld+w42fzg2grvXXkWRaujo6HWyDb4Aqk4SS61U1qpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"正常启动\"\n        title=\"正常启动\"\n        src=\"/blog/static/09ae1afd35f64c13097b4c4898839eef/00d43/normalStart.png\"\n        srcset=\"/blog/static/09ae1afd35f64c13097b4c4898839eef/63868/normalStart.png 250w,\n/blog/static/09ae1afd35f64c13097b4c4898839eef/0b533/normalStart.png 500w,\n/blog/static/09ae1afd35f64c13097b4c4898839eef/00d43/normalStart.png 1000w,\n/blog/static/09ae1afd35f64c13097b4c4898839eef/f4281/normalStart.png 1016w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>3.2.2. <a name='debug'></a>debug模式启动项目</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ca8ec696ea59c20a4013243dd038753f/ddb6a/debugStart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 6.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAN0lEQVQI14XDwQ3AIAwEwXSGhMFnwOEN/ReyKSEjzVPN+e2O9kuMJFayclMl1J3bCqcbmpOm4AOivyRtdwx38gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"debug启动\"\n        title=\"debug启动\"\n        src=\"/blog/static/ca8ec696ea59c20a4013243dd038753f/00d43/debugStart.png\"\n        srcset=\"/blog/static/ca8ec696ea59c20a4013243dd038753f/63868/debugStart.png 250w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/0b533/debugStart.png 500w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/00d43/debugStart.png 1000w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/aa440/debugStart.png 1500w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/ddb6a/debugStart.png 1592w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 812px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c44eb22046aa719f25cbd994e0300adf/63ec5/startPage.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 175.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAACU9ioYAAAACXBIWXMAABYlAAAWJQFJUiTwAAAFkUlEQVRIx62W228cVRLG5w3xtruPIXGcoH0HXmD/gYg3tA+8REICCZTYZmzP2Oa2gBASYmIrQIIgCFggCBI2Cw5RDIm8Hl+xPbZjJ2bjOOP4kvE1vva959I9/YM64551tIqU7KalUp2uOufrqvqqzkxkz+49/PEPf2Jf5X72VlSyb9/DPLz/z1RUVFKxZ2/JVrmfyr371LvInlB2V5RtDzzwIJW7dhN57JFHeTEapbaujpqaGmKxGE2NTTQ2NtLU1FReK2lqUlKyl/z19fXU1tby16eeYteuh4gcPHiQhvp6aqoO88LzzyvwhoYGBRyPx4jF4sTicRriMRrjO2zKH6euro5Dhw5RVV3NE4//hUhtXT1vH32PNxNHaGlu5uiRI7ybSJBIJJRu2Za3Egn+9u4R3kkkaN72h9Lc3ExLSwsHDjxJ5ESyl8F8QMemRbdmM2tYuKaJaZpKrxgWv2gOSc2hV3Po1BzWTAt7e4+IYRhk3SyHD1cR+bqrDz8IMEyTacshaWQZNV1c22bKcmk3skyYLrptk7NtxkyXS6ZL3raxbBtbtGWRz+eprqoh8nNXDxSL6is520K3LFK6Q1J36dFdViybvG2pQ1nLYsG06dVdbKtkE5Eoc7lcCfBiVw9BUEQ3DIztw2nDpnXLZUh3VNoSvW6a2KbBomHRozml9x2gCrC6hkhbZzcERWzDIG9ZZCyXvmwR2/cZcT0m80XwfYq+DwSsFXyG8gGe55XTLQNKhN919uAUA+Y0g0y2wMlfJ3mm8WU++uokb3/yGe+0tfPt+Ta+/aGV06dPc6a7l5ZT/6Cv418lMNu+PeUPheUCdG9aXHR8kpklPv7qJO/9/Us++PwLPm89xysnT/Fxeyevn/iUoxeTJM79zGetP2LZjqq7ae6I8P2OXvRiwKxmkMoFtLa2cnlkmPXVVZYX5pmanOSH0XG+aU8yl5nnRGcfP02kOTud4cKqxozl4lg7IjzR0U3ah+SGyVoRPjp2jGdjcZ577Q0OvfY6x44f55/ff88zL73KCy+/ytM1UY5/8D6vNDXS8+tVVe9RzcILSTmf7KKrACmtxPBN26VNczm/YXJ23WLccErM21la10zSuknOcVRXZC0Tw7bp0l0WswWiAtie7FSA45qJZ5n823A4q2f5Sc/xo56j33ApbPffOT3HouXghmSo3jRJ6TaTbp66qmoiXX2/sAEsuzn8QgErXyCT81jM+8znfbYKHkXPQyt4ZPI+esHD9zwKnqdaR/RS3iMP1L4YJZIaHOR+PbXROiJjo6NcT6dpa2tjbGyM/oEB+vv7cRxHbQruAigIQsBaIsNDQ2qwJyYmmJ+fZ3Nzk0wmQ6FQ+B8iVIDDOK6jQK5du8bU1BQ3b95keXlZyezsLDMzMywsLCgJbaIlgK2trdsBR4ZH2NjYUEAhqADKuxwUkHQ6zeLiovILiKZpCkBIKRaLtwOGpIgzCAK1QcSXC2Fbi4g/XAdBcOeUU4Mp9SIbpW7hF7PZrLLdcw1HR0eZnplRMyzEdHR0MDIygtgvXLhAMpnkzJkzDAwM3B3gUGoIz/dZX19X95vUR9a6rqtrSVgXAkRL1CLSUnIZhOswkzLLAiQkTE9PMzc3p9Y3btxgdXWVpaUlBSYEiU9IuXXrVpllsYctVu5DN+sqpxy+fv16uReF/Xuu4eDA/Rw9iXB4WF3lku7Kyor69SuNU1Buj536Ti3zH5YvXVLpyiwLw6lU6v+LMAQQRoU1mQiJVOooUyJsCwHCvmiZorW1NZWV67q3ZVBmWcAmJycVuzJ6V69eVeRcuXJFsXj58mUFND4+rvpR+lX8MuPSPv9VQwEUIGFZvioDLxGF/1ukL0VLtMK8rGWPtE9Yc3mipcYupSzO8A681ydMOXq/2yb6+0/Ab1SVgdzXLCJlAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"页面展示\"\n        title=\"页面展示\"\n        src=\"/blog/static/c44eb22046aa719f25cbd994e0300adf/63ec5/startPage.png\"\n        srcset=\"/blog/static/c44eb22046aa719f25cbd994e0300adf/63868/startPage.png 250w,\n/blog/static/c44eb22046aa719f25cbd994e0300adf/0b533/startPage.png 500w,\n/blog/static/c44eb22046aa719f25cbd994e0300adf/63ec5/startPage.png 812w\"\n        sizes=\"(max-width: 812px) 100vw, 812px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这样我们基于官方的教程就完成了RN项目的初始化和启动过程了，接下来就可以进入的源码来看RN的加载流程了！！！</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://reactnative.dev/docs/environment-setup\">Setting up the development environment</a>\n<a href=\"https://developer.android.com/studio/debug\">调试应用</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"深入浅出RN之项目初始化&调试","date":"2021-11-04","tags":"跨端技术","path":"/react-native-start","top":null,"summary":null},"title":"深入浅出RN之项目初始化&调试","date":"2021-11-04","tags":"跨端技术","path":"/react-native-start","top":null,"summary":null},{"id":"62a7a7d2-f5ec-51df-83b0-19a8a7911608","html":"<h2><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction</a></h2>\n<p>在项目中需要根据配置生成Async Function来保证配置的串行执行，Async Function在创建的时候只能访问到全局作用域的变量，需要注意。在node中可以通过<a href=\"https://github.com/nodejs/node/issues/9474\">vm.runInNewContext</a>来解决。</p>","fields":{"readingTime":{"text":"1 min read"}},"frontmatter":{"title":"前端小知识","date":"2021-11-03","tags":"JavaScript","path":"/know-little-more","top":null,"summary":null},"title":"前端小知识","date":"2021-11-03","tags":"JavaScript","path":"/know-little-more","top":null,"summary":null},{"id":"f8414df6-bcbe-5abe-af66-071c3b4aa351","html":"<h3>基础知识</h3>\n<h2><a href=\"https://jakearchibald.com/2021/cors/\">How to win at CORS</a></h2>\n<p>CROS看这篇就够了</p>\n<h2>React Native相关</h2>\n<p><a href=\"https://formidable.com/blog/2019/react-codegen-part-1/\">The New React Native Architecture Explained</a>这个系列文章介绍了React Native架构升级的一些核心概念，包括Turbo Modules,Fabric, JSI等，可以快速的了解架构升级背后的原理。可以结合<a href=\"https://www.cnblogs.com/ludashi/p/15381067.html\">React Native之新架构中的Turbo Module实现原理分析</a>来深入到原理部分。</p>\n<h2>项目管理&#x26;设计</h2>\n<h3><a href=\"https://blog.codinghorror.com/falling-into-the-pit-of-success/\">Falling Into The Pit of Success</a></h3>\n<p>一篇关于系统设计的文章，在进行系统设计的时候我们要思考在使用系统的时候如何让用户获得使用上的收益而不是通过一些手段去弥补系统的漏洞</p>\n<h3><a href=\"https://yonigoldberg.medium.com/fighting-javascript-tests-complexity-with-the-basic-principles-87b7622eac9a\">Writing clean JavaScript tests with the BASIC principles</a></h3>\n<p>在业务开发中，会因为业务的压力导致单测执行粒度不够，KPI式的单测覆盖率目标并不能保证有效的单测。比如前端做单测，在哪些维度做单测的尝试是值得考虑的(基础组件，核心api处理逻辑等)，这边文章讨论了单测执行过程中的一些问题并且给出了如何写单测的原则建议，很有意义。在附一个<a href=\"https://www.zhihu.com/question/27081528/answer/1872155062\">知乎关于单测的讨论</a></p>\n<h3><a href=\"https://mp.weixin.qq.com/s/g5ZjQt9F1UUryisEW1csSA\">这可能是大型复杂项目下数据流的最佳实践</a></h3>\n<p>这篇是关于项目治理的文档，数据流的设计与拆分，领域模块的隔离都有借鉴意义值得学习。项目的治理要早否则根深蒂固就积重难返了。</p>\n<h2>React</h2>\n<h3>hooks实践</h3>\n<p><a href=\"https://devtrium.com/posts/react-typescript-how-to-type-hooks\">React &#x26; TypeScript: how to type hooks (a complete guide)</a><br>\n<a href=\"https://thoughtspile.github.io/2021/10/18/non-react-state/\">How to replace useState with useRef and be a winner</a></p>\n<h3><a href=\"https://www.zhihu.com/question/468249924/answer/1968728853\">知乎上关于hooks的讨论</a></h3>\n<p>其中beeplin的回答有很多借鉴意义，思考到项目的设计问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-11-1-前端快报","date":"2021-11-03","tags":"前端快报","path":"/2021-11-03","top":null,"summary":null},"title":"2021-11-1-前端快报","date":"2021-11-03","tags":"前端快报","path":"/2021-11-03","top":null,"summary":null},{"id":"ea186f12-6741-57d1-9751-230edd265c28","html":"<h2><a href=\"https://blog.openreplay.com/using-recoil-instead-of-redux-for-state-management-in-react-applications\">Recoil</a></h2>\n<p><a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>是facebook出品的react状态管理库,这篇文章介绍了Recoil的简单使用。Recoil的特点是它通过写react的方式完成了状态管理，不像redux会在代码中引入更多的概念，值得一试</p>\n<h2><a href=\"http://www.ayqy.net/blog/cross-platform-pains/\">跨端方案的三大困境</a></h2>\n<p>跨端开发是主流app都会采用的方案，跨端的方式在短时间内可以尽快的试错跑通流程，相对于纯h5方案也有一定的性能优势，这篇文档主要介绍跨端开发中的一些思考点，对这些问题深入的思考能帮助更好的发展跨端技术。</p>\n<h2><a href=\"https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838\">React Native at Airbnb: The Technology</a></h2>\n<p>Airbnb关于React Native实践的系列文章，从中也能启发出很多跨端开发的思考点</p>\n<h2><a href=\"https://dev.to/adamdbradley/introducing-partytown-run-third-party-scripts-from-a-web-worker-2cnp\">Introducing Partytown 🎉: Run Third-Party Scripts From a Web Worker</a></h2>\n<p>现在的web开发通常需要引入很多第三方sdk来统计业务信息等，这些sdk的执行会增长用户的可交互时间，<a href=\"https://github.com/BuilderIO/partytown\">partytown</a>可以通过worker来运行第三方sdk来减少主页面js的执行时间，现阶段partytown还处于实验阶段，值得后续关注</p>\n<h2><a href=\"https://calibreapp.com/blog/bundle-size-optimization#lazy-load-third-party-resources-with-facades\">Small Bundles, Fast Pages: What To Do With Too Much JavaScript</a></h2>\n<p>这篇文章介绍系统的介绍了优化js包体积大小的方式，其实对momentjs使用的例子很有意思，优化其实不是一蹴而就的，废弃项目这个的momentjs可以从禁止momentjs使用的提示开始</p>\n<h2><a href=\"https://prateeksurana.me/blog/javascript-developer-guide-to-browser-cookies/\">A JavaScript developer’s guide to browser cookies</a></h2>\n<p>cookie拿来吧你</p>\n<h2><a href=\"https://github.com/mithi/react-philosophies\">https://github.com/mithi/react-philosophies</a></h2>\n<p>这篇文章介绍react中组件设计，性能优化的一些最佳实践方式，很有借鉴意义的文章。相关的文档还有<a href=\"https://kentcdodds.com/blog/dont-sync-state-derive-it\">Don't Sync State. Derive It!</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null},"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null},{"id":"b1d5f00b-e601-50c5-ae20-7db96b03404b","html":"<p>责任链模式将多个处理对象连成一条链并且沿着链传递该请求，直到有一个对象处理它为止。它实现了请求的发送者和接收者之间的解耦合。</p>\n<h2>结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVQ4y42TWauFMAyE/f+/0PMiiPu+70IPXyDi8Va4D0PbNB0nk+js+24U27Zd6xu4P89TwHmapp93zp3wTnochxXzPJskSUxZliZNU9M0zV/CuwIejeNoiqKQZBQAiPI8N1VVGd/3hTCOY1F6F+LoRoMQdl0nKiDt+14wDIMJw9BEUSSAjDj5PwqVgAf3SwUx9Y078rIsE7I7kbXkt8ZABkHbtrJSLiuWLMtyfcxa8vMD67qKh5RY17V4yR0+4ym2EPuXQiX0PE/guq4QaOzz+QjwVu2yEj7PkOAbjVLv6DYKAVZcCm0l24hts2qLvSp8DveT4C0uY0O3KEv3lKejAZg7yuXPwC9ytSlBEEguOayXQoxmz5zRTXyhe4A9MXzTkWFcyCXGHXHyvvBK7ODndxtOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"责任链结构\"\n        title=\"责任链结构\"\n        src=\"/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png\"\n        srcset=\"/blog/static/cd8a720c52b440ad2410037748a084bd/63868/chainstruct.png 250w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/0b533/chainstruct.png 500w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png 1000w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png 1225w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Handler</li>\n</ul>\n<p>定义一个处理请求的接口，实现后继链</p>\n<ul>\n<li>ConcreteHandler</li>\n</ul>\n<p>实现Handler接口，如果可以处理该请求就处理否则将该请求转发给它的后继者</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>向链上的具体ConcreteHandler提交请求</p>\n<h2>适用性</h2>\n<ul>\n<li>当多个对象都可以处理请求且哪个对象处理请求是运行时刻动态确定的</li>\n<li>在不想明确指定接收者的情况下，向多个对象的中的一个提交请求</li>\n<li>可处理一个请求的对象集合应是动态指定的</li>\n</ul>\n<h2>优缺点</h2>\n<ul>\n<li>降低耦合度 请求对象无需知道是其他哪个对象在处理其请求</li>\n<li>增强了给对象指派职责的灵活性  可以在运行中动态的对责任链中的对象进行添加或删除</li>\n<li>不保证被接受</li>\n</ul>\n<h2>实现</h2>\n<ul>\n<li>\n<p>实现后继者链</p>\n</li>\n<li>\n<p>连接后继者</p>\n</li>\n<li>\n<p>表示请求</p>\n<pre><code>  class Handler {\n  public:\n      virtual void handleRequest(Request* theRequest)\n      // _successor 实现后继链\n      Handler(Handler* s) : _successor(s) {}\n  private:\n      Handler*  _successor\n  }\n\n  class ConcreteHandler: public Handler {\n      public:\n      handleRequest(Request* theRequest) {\n          case:\n          /* 省略若干判断*/\n          default:\n          /*转发给后继处理*/    \n      }\n  }\n</code></pre>\n</li>\n</ul>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"10分钟设计模式-责任链","date":"2021-09-06","tags":"设计模式","path":"/chain-responsibility","top":null,"summary":null},"title":"10分钟设计模式-责任链","date":"2021-09-06","tags":"设计模式","path":"/chain-responsibility","top":null,"summary":null},{"id":"60b720c4-53b8-5d91-88c7-7ac6f0eb90d6","html":"<p>页面开发中数据在组件之间共享和同步是一个比较常见的问题，通过状态管理可以实现清晰的数据流和组件状态同步能一定程度上减少业务的复杂度。本文主要对比Redux和Mobx的实现细节来深入状态管理的技术实现，这样在做技术选型的时候能有一定的考量</p>\n<h2>1. <a name='reduxhttps:github.comreduxjsredux'></a><a href=\"https://github.com/reduxjs/redux\">redux</a></h2>\n<h3>1.1. <a name='redux'></a>redux的思路</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQ4y32U666CQAyEef9HxIAxBgLeuIqCQs3XZMjKufxolu2205l2l6jrOsPatrX7/W7P59Pqura+761pGpumyb85ZyUW3ziOvm4tqqrKbrebsRIM4OVycYDr9Wqv18v9fFOIuH8BYQUABiP2RVFYlmUOwB7wsiwdjH0IuAWOYIBT0gEF7Hg8OivA8COXBOKV/BvLSE4C3++3PR4PZwI7gCVfclnxhUxD4Ch0Yurh6XRaexqeU1ispe6L4Zb+PM9eHel8S6LOUUBB2qE2hAWjMBggXRekDcPgbGCptuhc/d7KXgEJBoQrxETp3/l8XpPFlCK0gxj5Zc4wRAcARkx4t9t5InuGwcCIow0Uwdjv93s7HA6WJIkTcoZIIgBASV2WxRloQJKOAvpHEXLCFqw9DK8KRjISSJZPzzHPcy8sUJhL8tc9hJVMPhgBgJw4jtenyPCIg8iPKf/1JvFTHWZpmnqv9GPYxoX38ANpAjjKavX2CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"redux实现思路\"\n        title=\"redux实现思路\"\n        src=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png\"\n        srcset=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/63868/redux.png 250w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/0b533/redux.png 500w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png 1000w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png 1189w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>redux通过全局的store来统一管理数据，通过订阅机制实现数据变更的通知</li>\n<li>redux引入函数式编程的概念，约定通过action来触发全局store的更新，单向数据流能一定程度上降低业务的复杂度</li>\n</ol>\n<h3>1.2. <a name='redux-1'></a>redux简单使用</h3>\n<pre><code>import { createStore } from 'redux';\nconst action_type = 'test';\nconst init = {\n  count : 1,\n}\nconst reducer = (state = init, action) => {\n  switch(action.type) {\n    case action_type: {\n      return { count: state.count + 1  }; \n    }\n    default: {\n      return state;\n    }\n  }\n}\nconst store = createStore(reducer);\nstore.subscribe(() => {\n  console.log(store.getState()); // { count: 2 }\n})\nstore.dispatch({\n  type: action_type,\n})\n</code></pre>\n<ul>\n<li>redux通过createStore(reducer, preloadState, storeEnhancer)函数来\b生成状态管理的store.</li>\n<li>store提供getState()来获取当前\b的状态</li>\n<li>dispath(action)更新应用的状态</li>\n<li>subscribe(listener)来订阅状态变更时触发的事件.</li>\n</ul>\n<p>通过上面的分析可以看出redux\b实现了一套发布订阅的机制来实现\b状态的变更和通知,下面将深入redux的源码来了解redux的具体实现</p>\n<h3>1.3. <a name='redux-1'></a>redux源码解析</h3>\n<p>以下源码部分基于<a href=\"mailto:redux@4.0.1\">redux@4.0.1</a>,为了整体介绍redux的整体流程,只保留了关键的部分并且进行了一部分修改.</p>\n<h4>1.3.1. <a name='createStore'></a>createStore</h4>\n<p>createStore(reducer, preloadedState, enhancer)\b接受reducer,状态初始值,store增强函数来生成应用的store</p>\n<pre><code>export default function createStore(reducer,preloadedState, enhancer) { \n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  // 如果存在enhancer函数,通过enhancer函数创建store\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  // 获取当前应用的状态\n  \bfunction getState() {\n    return currentState;\n  }\n  \n  // \b订阅当\b状态更新的监听函数.\n  // 返回取消当前监听函数的方法,用于取消订阅对应监听函数\n  function subscribe(listener) {\n    \bnextListeners.push(listener);\n    return () {\n      const index = \bnextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    }\n  }\n\n  // 执行action的变更并且执行监听函数\n  function dispatch(action) {\n    currentState = currentReducer(currenState, action);\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i &#x3C; listeners.length; i++) {\n      const listener = listeners[i]\n      listener();\n    }\n    return action;\n  }\n\n  return {\n    getState,\n    cubscribe,\n    dispatch,\n  }\n}\n</code></pre>\n<h4>1.3.2. <a name='combineReducer'></a>combineReducer</h4>\n<p>combineReucer(reducer)\b\b可以将多个reducer函数组合起来,接受action并改变状态.combineReducer\b解决了将所有的更新逻辑写到一个文件的问题</p>\n<pre><code>export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  // 生成finalReducers\n  for (let i = 0; i &#x3C; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  //  \b返回的函数是实际调用creaStore()的第一个入参,这样就能接受action来改变应用的状态了\n  return function combination(state = {}, action) {\n\n    let hasChanged = false;\n    const nextState = {};\n    // 对action执行所有的传入的reducer函数\n    for (let i = 0; i &#x3C; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]  // 对应reducer之前的state\n      const nextStateForKey = reducer(previousStateForKey, action) // 对应reducer接受\baction之后的状态\n      nextState[key] = nextStateForKey  // \b将\b\b处理过后的值存储\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 如果改变返回nextState, 否则返回之前的状态\n    return hasChanged ? nextState : state\n  }\n}\n</code></pre>\n<h4>1.3.3. <a name='applyMiddleware'></a>applyMiddleware</h4>\n<p>applyMiddleware是redux提供对外部进行扩展的\b途径,通常情况下\bdispacth只能接受一个对象来对状态进行修改,通过添加不同的中间件,对dispatch进行增强,可以使它接受更多的类型(function, promise)和实现更多的功能, 下面先从一个使用\b中间件的实例来\b了解appleMiddleware到底做了什么.</p>\n<pre><code>function thunkMiddleware({ dispatch, getState }) {\n  return  next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState);\n    }\n\n    return next(action);\n  };\n}\nconst store = createStore(reducer, { count: 1 }, applyMiddleware(thunkMiddleware))\nstore.subscribe(() => {\n  console.log(store.getState());\n})\nstore.dispatch(() => {\n  console.log(1);\n  return { type: action_type };\n});\n</code></pre>\n<p>通过上面的例子,dispatch就能接受函数类型\b并且执行对应的函数,下面来了解appleMiddleware的源码是怎样实现的.applyMiddleware返回的是store的enhancer,在createStore的代码部,在\b传入enhancer的时候,执行的是enhancer(createStore)(reducer, preloadedState).</p>\n<pre><code>function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    // ..args 是\b传入的reducer, proloadedState 来生成\bstore\n    const store = createStore(...args);\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n\n    // 将\bmiddlewareAPI注入到每个middleware\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    // next的注入,将多个中间件关联,返回的dispatch已经被增强\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre>\n<h4>1.3.4. <a name='reduxreact'></a>redux结合react</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 430px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 148%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTklEQVRIx6WVV4sCMRSF5///GNFnH0QRFLtYsVes2HvL8l24wyi6zuwGws1kkpNzy0msy+VivvXz+Sz2drt9XHO9XmWd5QZMAbvdrmm1WqbdbovVcbPZNJPJREAtt+yOx6MA0O73u9jH4yFjOqCs8wQIQwXUeW0wde2yAnY6Hdm82WxMpVKxWcH0T4DK8F0jHJ4AsY1Gw/R6PTMcDk2xWJTvwWAgBzHvOikKejgczHK5lPLx+/0mlUrJv9VqZa+x3NShkyksaLAjlsSPOV3jiSH2dDpJluv1ugBqQT8x1IlvXdfCigxvt1tbPbrG0oUqLU6k61itbtrtduJyIBAwpVJJwImtYtgM9/u9WSwW4gZBpjNmToNerVal3shoOp2Wb6cc7SwDxmQ0GpWF8XjcJJNJCXwikTD5fF7cc1WHuDSfz00oFBLAcDhsYrGYiUQiJpfLiSI4HUCY4fJsNrPZsxcgVGRnmRhQoADAKJPJCNNCoSAH4BrrAKQOYYodjUYyZj/WToomBiZszmazwhBXx+OxbEB6ZPZdo4wIjyRFAQmo0w3uN1zjH2HBavCRnh6IZzr3JD0FZTNd77lXlcCUFgwGJb40il1Ly3ot2t8KWjsHwZYEOWv0X9JTLb+VntvLQdnQyuWyZPpflwMu6vXl8/mkzPT6Uvl5umDRLlmlE0Pqst/vi63Vat5fPTZ+an9+U/jWax+XYUocsZ6fUYBo6/VaMowA9Dp70rIbQMqFhwklkRg6wFgURZF7fqSm06lIUq1zzEGe61Dl+K6r3n8A1lgA1sQPbKMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-redux\"\n        title=\"react-redux\"\n        src=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n        srcset=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/63868/reactRedux.png 250w,\n/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png 430w\"\n        sizes=\"(max-width: 430px) 100vw, 430px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact-Redux的作用是将React组件和Redux绑定，React组件可以通过react-reudx完成数据的获取和更新。其中connect函数就是这个功能，通过下面的代码可以看出connect主要是从redux或者context中获取属性通过高阶组件的方式返回包裹组件。</p>\n<pre><code>const Connect = _Connect as ConnectedComponent&#x3C;\n  typeof WrappedComponent,\n  WrappedComponentProps\n>\nConnect.WrappedComponent = WrappedComponent\nConnect.displayName = ConnectFunction.displayName = displayName\n\nif (forwardRef) {\n  const _forwarded = React.forwardRef(function forwardConnectRef(\n    props,\n    ref\n  ) {\n    // @ts-ignore\n    return &#x3C;Connect {...props} reactReduxForwardedRef={ref} />\n  })\n\n  const forwarded = _forwarded as ConnectedWrapperComponent\n  forwarded.displayName = displayName\n  forwarded.WrappedComponent = WrappedComponent\n  return hoistStatics(forwarded, WrappedComponent)\n}\n</code></pre>\n<h2>2. <a name='Mobx'></a>Mobx</h2>\n<p>mobx将响应式编程的概念引入到状态管理的实现上，通过观察者模式实现组件的更新。相比redux他的优势在于:</p>\n<ol>\n<li>在组件更新上性能更好 redux通过发布订阅的模式会在所有的组件上进行Prop的脏检查，mbox通过proxy依赖收集能更精确的控制组件的更新</li>\n<li>长期维护上存在一定优势 mbox基于proxy内部维护了更新的机制，redux需要通过mapStateTpProps来主动告知订阅的属性存在一定维护成本</li>\n</ol>\n<h3>mobx背景介绍</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQY00WQ3UrDQBSE8/6PIPgcuRItBqEgXpSQWqvGRpsfgrvFppvdPdl8ktTiwDA383M4Udu2KK05VVsOmwd+ioyyLFHqm7us4ermheW2pakrlFK8lk8ss5ha5RTFF9VuR54kpHFMk6ZE3ntOxtDtn9HZArNfIyI4a0k2Lde3bzy+K8Ig9H3PZ7sm/bhHH2tEBkzXcchz6tWKY10T8QcJI1prvARkGBjHERhhDEAghDPFD3gnZ/V+9joRhtkP0RS8hKdF5yzW2vkaYwzG9PTWMr1mHvQe59w/rZ310vMLZFMvcH+PNUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx\"\n        title=\"mobx\"\n        src=\"/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png\"\n        srcset=\"/blog/static/1f17685984e130f52da0a236b2dcae30/63868/mobx.png 250w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/0b533/mobx.png 500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png 1000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/aa440/mobx.png 1500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/e8950/mobx.png 2000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png 3445w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Observable  定义可观察的值，当observable值变化的时候会触发Derivations</li>\n<li>Derivations Derivations主要为Computed values和Reactions，可观察值的改变会触发对应的Derivations触发</li>\n<li>Actions actions触发Observable值的更改进而触发Derivations</li>\n</ul>\n<h3>mobx简单使用</h3>\n<pre><code>import { observable } from \"mobx\";\nimport { observer } from 'mobx-react'\n// 定义一个可观察的值\nvar timerData = observable({\n  secondsPassed: 0\n});\n// 定义了观察者 当secondsPassed发生变化的时候会触发组件更新\nconst Timer = observer(({ timerData }) =>\n    &#x3C;span>Seconds passed: { timerData.secondsPassed } &#x3C;/span>\n);\nsetTimeout(() => { timerData.secondsPassed = 33 }, 2000)\n\nfunction App() {\n  return &#x3C;Timer timerData={timerData} />\n}\n</code></pre>\n<h3>mobx源码解析</h3>\n<p>使用mobx实现组件更新的方式如下:</p>\n<ul>\n<li>mobx实现创建Observable值和触发Derivations</li>\n<li>mobx-react实现对react组件的封装，创建基于组件的Derivations从而在对应的Observable值修改的时候完成组件的更新</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 852px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVQ4y62Ta8uCQBCF/f9/rehD+EEysjAzKtO8ZdeJZ2CkZHkvkDDMMmf3nDM7q3e9XuWb4X2d8HK5iCtsw38xp0PX4b9gfcvn8/kjDLzdbtJ13QdGzTBI27bVOlkdNk0ju91O8jzXsDVEdV1LHMeSZZnW0jSV/X6vWFVVstlstH48HmW73ep+ryxLgfR+v6sySuv1Wk6nk+bFYtE7OBwOEgSBFEUhq9VKoiiS5/OpROxBxGOBA4IDZGoIPB4PVccFAmDU7cOMYXSGMc8uGjJaGk6N9tiIQw4ul0t1RiRJoqRgRP9sTA0VPtckGQKt+b4vk8lEptOphGGoRHZdOhRzhxoOyabmcouz+XyumaE43yEXPxqNZDwey2w20xaN8P39kc0Njt+d9e8QAEdMDWLaYqOL7Ke/yrI3vKchwW+kQ4cvCws6rZketdUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx原理\"\n        title=\"mobx原理\"\n        src=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n        srcset=\"/blog/static/28f13754dd42663bf2a3b517779e126f/63868/mobxlogic.png 250w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/0b533/mobxlogic.png 500w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png 852w\"\n        sizes=\"(max-width: 852px) 100vw, 852px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>mobx生成Observable</h4>\n<p>Observable会根据传入的值类型包装生成代理，在对观察值获取和设置的时候都是调用代理的方法</p>\n<pre><code>// mobx暴露的observable调用的入口函数 \nfunction createObservable(v: any, arg2?: any, arg3?: any) {\n  // @observable someProp;\n  if (isStringish(arg2)) {\n      storeAnnotation(v, arg2, observableAnnotation)\n      return\n  }\n  // 如果已经是可观察值忽略\n  if (isObservable(v)) return v\n  if (isPlainObject(v)) return observable.object(v, arg2, arg3)\n  // 这里省略了其他数据类型的包装 \n  // 调用工厂方法对不同类型的值包装成可观察值\n  if (typeof v === \"object\" &#x26;&#x26; v !== null) return v\n  // anything else\n  return observable.box(v, arg2)\n}\n// 观察值封装的工厂方法\n// 省略若干其他类型的封装\nobject&#x3C;T = any>(\n    props: T,\n    decorators?: AnnotationsMap&#x3C;T, never>,\n    options?: CreateObservableOptions\n): T {\n    return extendObservable(\n        globalState.useProxies === false || options?.proxy === false\n            ? asObservableObject({}, options)\n            : asDynamicObservableObject({}, options),\n        props,\n        decorators\n    )\n},\n//extendObservable通过创建一个代理(管家)来代理属性的访问和设置，这里关注在没有proxy设置的场景asObservableObject在内部创建了代理\nconst adm = new ObservableObjectAdministration(\n    target,\n    new Map(),\n    String(name),\n    getAnnotationFromOptions(options)\n)\n在ObservableObjectAdministration内部维护了维护了获取属性的get和set方法\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAChElEQVQ4y5WT3Y7bNhCF/RjdtSj+ir+iJEv22t6sHaQ3RZs0RVr0/R/lK6RNFynaAu3FhyGH4JkZ4nB3mArHy51yeSbeboT7jXK9ki4X6vkZF8tG5wMpBvo+4ENE2rjlrY8Yt+YSsm3ZiabFGktZFsbzvJEPI2ka6E8zaR7Jy0ide4Y5M86JXBN+6CnHiVDXWOnnni4ZdkopWiVpfaYOgToVQt/T7L9DiD1t29DKFYGQgkYIRCuQUmxnQjRIJbZzqVp2RhvGUAku0bpMGGbiMJOnhS5ERLNear8iaN/W7V/yf8adlBItFVoZpDJo614xFqnUq0jb/md2xmuEVAgpt9GFbDek1v9L6E3QlZ5uesEMI3oZ6E4Ldp7oco9Smv3DA83jI83+kaYRiK80e/G2X9dbfh25Gw7E60fc0wX7ciLf78TrFTMNmKkSDzN5edre1SWLdop1Kt9bXDLYqOnyGtfnUuxsrvjle8w4Y5+P6MtMvFwoL3fK+UQ6ROKU8H2gK5YwuE0gTo44uk14ZS2ktGTnS8KWBR16dM2Yw4CqBRU8Nlh0pzCdwiWH6V47McFgNxzWG1y22GwxnWZXa6AcJnQOtH3CTBlXI6FUQh2QqSPUcRu7zAu6JPRUMd6j/YDzaWtEDT3Gd+yUVNRauLxMPF0raZnpzwvjuyuhFsbriTJlfLa4aFBGbZ5r23+206sPlab0kTwVfC3EqRJKxjqP85m16P5hz+PDnmYzuvhXNsEVZzr8MDJcjkz3Zw6nnvPtyPzuiX6MxNqRJ4+xGrF2s937u/HfBNdN7xNDqsiQuX+48+W3j3z6/AM///Ijn7/8xK+/f+L24T1dGUjjQhqm7Wt+K/gHXJGxoBKDACIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setAndGet\"\n        title=\"setAndGet\"\n        src=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png\"\n        srcset=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/63868/setAndGet.png 250w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/0b533/setAndGet.png 500w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png 1000w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png 1322w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子对观察值进行修改的时候，会最终走入observablevalue的更新值并且触发Derivations</p>\n<pre><code>setNewValue_(newValue: T) {\n  const oldValue = this.value_\n  this.value_ = newValue\n  this.reportChanged()\n  if (hasListeners(this)) {\n      notifyListeners(this, {\n          type: UPDATE,\n          object: this,\n          newValue,\n          oldValue\n      })\n  }\n}\nexport function endBatch() {\n  if (--globalState.inBatch === 0) {\n      // 触发Derivations\n      runReactions()\n      // 省略若干逻辑\n      globalState.pendingUnobservations = []\n  }\n}\n</code></pre>\n<h4>mobx-react生成Derivations</h4>\n<p>这里主要从包装函数式组件来看Derivations的生成过程，函数式组件的封装方法主要做了:</p>\n<ul>\n<li>\n<p>定义更新逻辑并与生成的Reaction绑定</p>\n</li>\n<li>\n<p>通过运行函数 将observable值与Reaction绑定</p>\n<pre><code>export function useObserver&#x3C;T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    const [, setState] = React.useState()\n    // 定义刷新组件逻辑\n    const forceUpdate = () => setState([] as any)\n    const reactionTrackingRef = React.useRef&#x3C;IReactionTracking | null>(null)\n    if (!reactionTrackingRef.current) {\n        // 创建Derivations 在设置observable的时候会触发相应的newReaction\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n          if (trackingData.mounted) {\n            forceUpdate()\n          } else {\n              trackingData.changedBeforeMount = true\n          }\n        })\n    }\n    const { reaction } = reactionTrackingRef.current!\n    let rendering!: T\n    let exception\n    // track通过运行组件 走入组件的get方法 将reaction跟observable值关联起来\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n    return rendering\n}\n</code></pre>\n</li>\n</ul>\n<p>这样当observable更改的时候会触发对应的Reaction执行从而达到组件刷新的目的</p>\n<p>在业务开发中最开始引入状态管理是为了实现组件之间的状态共享，而使用Redux或者Mobx是引入不同的编程范式来实现这种共享的行为。不同的编程范式能给予项目一定的约束从而实现业务开发的规范。但是范式的引入也一定程度上增加了项目的复杂度，比如redux的依赖管理、中间件概念、mobx跟踪性较弱的更新逻辑等。在考虑引入具体方案的时候应该考虑整个项目的现状和成本，是不是有更轻量化的实现，比如React Hooks。</p>\n<h2>3. <a name=''></a>参考</h2>\n<p><a href=\"https://tech.youzan.com/mobx_vs_redux/\">我为什么从Redux迁移到了Mobx</a><br>\n<a href=\"https://github.com/reduxjs/react-redux\">react-redux</a><br>\n<a href=\"https://github.com/reduxjs/redux\">redux</a><br>\n<a href=\"https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\">Becoming fully reactive: an in-depth explanation of MobX</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/85720939\">mobx 源码解读（一）：从零到 observable 一个 object 如何</a></p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null},"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null},{"id":"9cf87650-c261-51d7-b150-77bfa90feef5","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#-\">深度思考-不断逼近问题的本质</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#12\">大败局(1 2)</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#--1\">增长黑客-如何低成本实现爆发式成长</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#\">看不见的心</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li><a href=\"#-1\">思考，快与慢</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li><a href=\"#--1\">结构性改革-中国经济的问题与对策</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>这里记录下自己读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>推荐指数0 - 5</p>\n<h2>1. <a name='-'></a>深度思考-不断逼近问题的本质</h2>\n<p>推荐指数 0.5<br>\n书名与内容严重不符的一本书，内容是作者的个人自传性质，在陈述的过程中并没有很好的结合书名进行深度解读，作为自传的话推荐指数很一般</p>\n<h2>2. <a name='12'></a>大败局(1 2)</h2>\n<p>推荐指数 4.5<br>\n大败局记录了多个企业的发展历史，从中能看到许多的无奈，作者的叙述也比较引人入胜，商业的发展历史很有意思，有机缘巧合也充满着时代的背景。</p>\n<h2>3. <a name='--1'></a>增长黑客-如何低成本实现爆发式成长</h2>\n<p>推荐指数 4<br>\n增长黑客主要介绍一个产品实现快速增长的方式，可以从多个角度去了解产品生命周期的一些行为，本书整体大纲如下:<br>\n<img src=\"./readBook/increase.png\" alt=\"增长黑客\"></p>\n<h2>4. <a name=''></a>看不见的心</h2>\n<p>推荐指数 4<br>\n通过两个人的爱情故事阐述了很多经济学的视角，很有意思的一本经济学读物</p>\n<h2>5. <a name='-1'></a>思考，快与慢</h2>\n<p>推荐指数 4<br>\n虽然有些中文翻译增加了阅读上的困难但整体上还是值得阅读的一本书，书中介绍了思维的快思考方式和慢思考方式、常见的思维误区等，阅读之后还是有一定的启发</p>\n<h2>6. <a name='--1'></a>结构性改革-中国经济的问题与对策</h2>\n<p>推荐指数 4.5<br>\n可以结合分析与思考一起阅读，这两本书总结了黄齐帆对中国经济问题的一些长远的思考，对于中国的一些问题通过结构性的方式去优化。黄奇帆通过结构性的梳理问题并且比较创造性的提出解决方案都体现出他对中国特色社会主义制度的深入思考，书读起来特别引人入胜</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null},"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null},{"id":"dc973b58-df85-506e-a262-d0a27a00f560","html":"<p>写这个主题是比较忐忑的，自己有一段时间会规划小组内下个阶段的工作目标，现在看当时做的阶段目标其实谈不上技术规划，本文主要结合自身的一些案例总结做技术规划上的一些思考。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQoz2VSQW6DMBD0/w+9VVXUa/qQ9AFRq36ghyRSMZhgSIzXJlONiYlpkUbgnfXsLLtKRBBCwDAM6LoOfd/De79gHMf0Zl4Z5zmj5NXlcsH1eoXWGlVVoWmaVTILlZdKYRb7yyu6MsbgdDolMZ6ZZK1Nbgl+szDjLE4451KMHOMZigQTKEpQMItmMX5P04QYA+pao+vOS1GC9/mwgKLNGGMi6rpeBCnetu0dBt4LnAvQ+gxjLIyZOXbFu9ShAZV7Z5Akk+h6DQ/nWoi8A9ghhF06Mz6Oc07+DctQOBAOhoLlUERYMCLGM/p+i8PhGU2zgUgFkdudf+Sr3OLxeExidFqux4yQBLV+w37/hO/vlyTo/fQvV+W22G6ecrkadOB9RAgthmELrTew9hUiP4vgymFebDorF/uxW7NDEU76C8AnbrcPiNh7fC34C+UwAiFBmhIuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png\"\n        srcset=\"/blog/static/19e59b526f6f15361b687635a5717660/63868/plan.png 250w,\n/blog/static/19e59b526f6f15361b687635a5717660/0b533/plan.png 500w,\n/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png 1000w,\n/blog/static/19e59b526f6f15361b687635a5717660/aa440/plan.png 1500w,\n/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png 1747w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>自身案例分析</h2>\n<p>在做下个阶段目标的时候经常会有如下的一些疑问:</p>\n<ol>\n<li>下个阶段做什么(来源)</li>\n<li>怎么做(过程)</li>\n<li>完成的总结</li>\n</ol>\n<p>在反思自己之前的制定目标的时候有以下的问题:</p>\n<ol>\n<li>多数在关注1阶段而弱化了2，3阶段的思考，这样会导致在下一次做规划的时候还是很挣扎跳不出这个圈。</li>\n<li>没有一个完整的全局视角 这个导致我的一个疑问是业务侧做这个为啥，看着很分散</li>\n<li>没有一个长期的视角，导致阶段性目标不明确</li>\n</ol>\n<h3>下个阶段做什么(来源)</h3>\n<p>在这个阶段我的思路是关注业务侧的规划文档，但是在看业务侧的文档会存在以下的\"问题\":</p>\n<ul>\n<li>某些目标比较泛并不能准确的落实到技术目标上 比如收入增加XXX</li>\n<li>可以收集到下个阶段的业务目标比如需求A，需求B，需求C，但是A，B，C有可能之间关联性不大，当然这可能跟当前的业务现状有关</li>\n</ul>\n<p>虽然通过看业务侧文档可以整理出下个阶段的业务目标，但是每次都感觉没有所谓的抓手，有种隔靴搔痒的感觉，其实从现在来看之前的我，可以看出很多思考上不足的点，才导致每次都很痛苦的想下个阶段要做啥。\n在思考上可以有两个思路:</p>\n<ol>\n<li>从上往下视角 从全局视角看不同模块的关系，建立联系和目标</li>\n<li>从下往上视角 为什么会有这样的关系，基于已有的关系是否会衍生出新的关系，在新的模块上能做什么</li>\n</ol>\n<h4>下个阶段业务目标</h4>\n<p>在梳理业务目标的时候可以从以下几点考虑:</p>\n<ol>\n<li>熟悉业务的现状  熟悉业务现状才能有目的性的查看业务侧的规划来反推出更多的思路来推动业务目标，比如\n<ul>\n<li>后续会发力营销但是现有的营销页面并不支持配置化那是否可以尝试推动业务侧一起建立配置平台</li>\n<li>业务侧要对存量的业务有一系列的优化，存量的业务还是老旧的技术栈，那么提前对技术栈进行迁移和统一</li>\n</ul>\n</li>\n<li>多与业务侧沟通，建立正向的连接  可以跟业务侧一起建立双向的规划分享，这样互相都比较了解对方做事的思路，团队每人也更有全局的意识</li>\n<li>数据思维 关注产品数据，业务数据促进对业务的反思，可以养成一个思维习惯就是产品的数据怎么能映射到我当前开发的具体业务上</li>\n</ol>\n<h4>下个阶段技术目标</h4>\n<p>在梳理技术目标可以从以下几点考虑:</p>\n<ol>\n<li>流程优化 梳理业务开发的流程针对性解决，比如:\n<ul>\n<li>规范 技术栈统一，代码规范，开发上线流程，Code Review(思考中，如何建立有效的Code Review)</li>\n<li>质量 性能，监控</li>\n<li>效率 通过工具、库来实现提效，已有业务的抽象组合</li>\n</ul>\n</li>\n<li>了解团队成员能力和诉求 可以针对不同阶段的团队成员制定不同的规划，比如工作年限相对短的可以多从一些复杂的业务中成长，年限久的赋予更多的自由度，实现自治</li>\n<li>技术储备(分享输出等) 技术储备可以为团队输入新的血液，分享和输出可以建立团队的整体意识和对外的口碑</li>\n</ol>\n<h3>怎么做(过程)</h3>\n<ul>\n<li>里程碑 每个目标阶段要有里程碑，比如做页面性能监控:\n<ol>\n<li>已有业务接入性能监控</li>\n<li>主要业务首屏优化达到XXX</li>\n<li>性能优化总结，推动上下游进行优化，新技术探索</li>\n</ol>\n</li>\n<li>可调整 在具体实现上因为优先级或者当前目标实现的结果不理想及时调整当前或者下个阶段目标</li>\n<li>多阶段完成 一个大的目标可以拆分成多个子目标在规划的多个阶段落实，需要建立多个目标之间的关系，保证规划的整体性</li>\n</ul>\n<h3>完成的总结</h3>\n<p>这个阶段可以结合上面的两个阶段来看:</p>\n<ul>\n<li>完成了哪些业务目标，技术目标，产生了哪些收益</li>\n<li>过程中产生了哪些问题，是否在下个阶段可以进行优化和避免(下个阶段目标)</li>\n<li>下个阶段目标调整</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844904201160491016\">技术管理- 怎样做好技术规划</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null},"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null},{"id":"b336e8ac-e502-5c89-83d4-431579baadac","html":"<p>使用<a href=\"https://icantunderstand.cn/webview-store\">缓存</a>和<a href=\"https://icantunderstand.cn/cross-platform-offline\">离线包</a>可以一定程度上提前页面展示的时间，但是页面的展示依赖具体的数据加载，Webview在加载h5的时间线可以做如下简化:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAa0lEQVQY05WPSwrAIAxEvf9RjSL4w7hJmcAUkW66eEw+JhmDqtrJ3tvGGJZztlqr03u3UoqTUvKaiFhrzXXO6XOYDwhu1lq+FA9O5bG7TiMgfDnEQrhCDmWOHlyhTmX/dUjb+OJJjPGXMn4AApw0UHe2ZIsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png\"\n        srcset=\"/blog/static/0ce30849a4870d72a825560fed237688/63868/timeLine.png 250w,\n/blog/static/0ce30849a4870d72a825560fed237688/0b533/timeLine.png 500w,\n/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png 1000w,\n/blog/static/0ce30849a4870d72a825560fed237688/aa440/timeLine.png 1500w,\n/blog/static/0ce30849a4870d72a825560fed237688/fd8a5/timeLine.png 1659w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Webview初始化 Webview在首次初始化会占用相对长的时间进行初始化(可以通过Webview池的方式来优化)</li>\n<li>DNS TCP TLS 建立与服务器的连接，可以通过html的预加载标签来优化(dns-prefetch, preconnect)</li>\n<li>数据请求响应阶段 在解析响应的html的时候会解析到js代码下载并执行发起数据请求(可以通过服务端渲染方案优化但是也增加了服务端成本需要考量)</li>\n</ul>\n<p>从上面的分析可以看出在发起数据请求之前通过Native并行提前完成数据的读取就能换取页面提前展示给用户的时间，下面介绍一种可能的预取方案。</p>\n<h2>实现方案</h2>\n<p>本方案通过配置维护了对应url下需要预取的配置，在初始Webview的时候客户端并行完成数据获取，最后通过jsbridge获取数据。</p>\n<h3>预取配置</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 775px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA60lEQVQoz3WRx6rFMAxE8/8/l1VIyCINQnrvVZcjMOQt3mKwNZJmBts6jkPAdV1ynqfeOQ1M/4v/eGAhtO+7FEUh8zzLfd9/lujDGXxNvzxzKrhtm4zjKHVdyzAMKvpNOE2TdF0nfd8rMIdnz3AADXiL4SiKJMsyieNYkiSRdV3VETGMlmVRIwzLstRE8OzCA3jmLNR93xfXdcXzPHEcR+8MB0Ggok3TSBiG8jyP2LYtaZqqMTV30hGCWattW8nzXIVIiBNNUuBcVZUKmkTU7/tq/eX5A01o3hARBHD5/qbhOJlj3rwhtembvR/OZxjL3yVM2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n        srcset=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/63868/config.png 250w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0b533/config.png 500w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png 775w\"\n        sizes=\"(max-width: 775px) 100vw, 775px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>配置侧 提供配置能力，需要对配置有准入审核，管理(下线，上线)</li>\n<li>服务侧 根据配置提供获取配置服务</li>\n<li>Native 动态拉取配置更新本地数据</li>\n</ul>\n<h3>加载流程</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 923px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 115.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y42VV47DMAxEff/T5Su9996c3hg8AmPIJWUBQo5EDodDShvdbjcL7Xq9Jutms7HdbudrHMd2v9+T808WZcEUcDqdbL1e236/dwM0m7AIPCpi9ng87HK5OBAMD4eDf79er5xvDrAoIyCLxcKGw6F1Oh3r9Xo2m81sPp/b+Xz+WnqUzcQfAJSr0o/Hoy2XS2s2mw4M20+gCUNK3G63zqrRaHgwbCifFQ1hiA/2E5AgAgaDgYPV63X/DSAsp9OpJ+r3+w7+FZBDhF+tVg4MS8oMk6EpySaTyW+GHNIIldRutxOtxJBvZhHD9y8NYQi7VqvloLASIAnYH41Gv0sOy6KbdBlgAkNAtO12uynArEXhzZCGBAHMHoHscYaGJPu7y4AgOkwomd9iCEi5XLbxeOw6sq84WYqhACm7Vqu5Xgy3mLAPczRkItQcpIC9GporGSfAYMI3TFgrlYpVq1VnSdn44ocMpVLJ9/BLdZnssIQZAWKoc5Jwzh6JYIoP7NhntCJ1Byc9Agx1eMWQg2B0pft86w0gEYBIkHscyBo+qhpggjSf2bEhBpYkLXy+cAxNDdPQMwXhTWEFkB7kGBYNavgSUTKPBJJobMQwBfjJwpECCK0wWOqd1A1LSv4HUBrSZZrGM4YEaAk7JCj8J/UNkJLpLivsns9nTmtuyhvVnukgKd1z8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载流程\"\n        title=\"加载流程\"\n        src=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n        srcset=\"/blog/static/b70892349e045d91bae6d4a918265e42/63868/prefetch.png 250w,\n/blog/static/b70892349e045d91bae6d4a918265e42/0b533/prefetch.png 500w,\n/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png 923w\"\n        sizes=\"(max-width: 923px) 100vw, 923px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在加载h5的时候</p>\n<ul>\n<li>Native会在初始化Webview的时候并行的根据配置加载数据(动态参数根据页面url和配置完成映射)</li>\n<li>Webview展示的时候触发jsbridge请求，普通请求jsb与prefetch jsb的区别在于prefetch有一层从本地获取数据的步骤和数据的重置操作。</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null},"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null},{"id":"95eed3a5-97d9-529a-8e3f-8b118507e82a","html":"<p>在<a href=\"https://icantunderstand.cn/webview-store\">一起学跨端技术-Webview缓存</a>中介绍了几种常用的缓存实现方案，几种方案都各有优缺点。其实h5的展示可以类比成CPU在运行的过程中动态获取数据，从寄存器中读取数据和从磁盘中读取数据的时间是相差极大的。那在h5展示的时候有没有一种方案可以绕过耗时较大的网络获取数据阶段直接加载内容展示呢？离线化就是这种解决方案。通过离线包的动态下发可以让用户在打开页面的时候直接加载已经在app中存储的离线化资源从而加速页面的展示。本文从以下两个方面介绍离线包的实现过程:</p>\n<ul>\n<li>离线包分发过程</li>\n<li>端内加载离线包过程</li>\n</ul>\n<h2>离线包分发过程</h2>\n<p>离线包的分发流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 907px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnElEQVQ4y4WS167CQAxE8/8/h0QEQfReQk0oSSjy1RnJuStA4sFa72Z9PONNVFWV3e93ez6fCvLj8Whpmtput7PtdluH71n3+319Tr7ZbOx8PlsEoCgKW6/XOjydTrqwWq2053w+n6sB++l0aqPRyLrdro3HY+v3+4rZbGaLxeIfyGWKALJOJhMVAGClgBUYZwBpxNlwOJQAzqNvlh36btWDbx4uBCey7MDH46Eoy1JFXAzDQRR6E/YoY0ScHw4Hi4DwCFhEMuoAYKXVaqmAvNPpyCb3yOM4ltVer2fNZlPfGEs9wzzPJfl6varbcrnUBeAMm2IaMjdyoP4YQJktdR+WyS+Xi2VZpias3ogcheS32033uOMrwqQQaBgOJl6vl2aGdVQnSSLV5ED8Ib0m8kKHkaMACwyZi1hpNBqyyYzb7bZs8yh8D8XUwBAc7ilA0WAwUBNy/xe9YVgTfYOFagms8Sfwe2CZWQJjZu8iPoAhlMGzAvJHAETOWH4qDLtRhD1UUMjwUQocGHvyn8AQ6i8HkOBBPIDxO71b/gMnvXNQcp6IjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"分发\"\n        title=\"分发\"\n        src=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n        srcset=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/63868/broadcast.png 250w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/0b533/broadcast.png 500w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png 907w\"\n        sizes=\"(max-width: 907px) 100vw, 907px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n分发流程中主要涉及4种角色:</p>\n<ul>\n<li>离线配置平台 配置平台可以提供离线配置能力、离线包管理(上传、禁用、清空)、离线包使用统计、离线包准入审核(自动(包大小限制)+人工(解决特殊case))</li>\n<li>离线配置服务 配置服务主要提供服务层能力，实现离线配置服务，离线包更新服务，离线资源长传下载服务、离线资源使用统计服务</li>\n<li>离线SDK 端内接入离线SDK，SDK主要与离线配置服务进行交互，完成离线资源的管理和接入配置能力</li>\n<li>Native侧  实现拦截请求在特定的协议下接入离线资源</li>\n</ul>\n<h2>离线包加载过程</h2>\n<p>离线包的加载流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQ4y32UWa+CQAyF5///Mx95IMYouKOouOKGS83XpDfDON6HpjDLOaenBdc0jRD3+/0vn89n8df9PTL7l8ultWbhwksc3G63crvdvojIrC+XS6mq6ouwBWiHZ7OZ5Hku4/G4BUY8Hg85HA6yXq8V1Fdp4XwGAKfTqSRJoqAxwLquZT6fa3CeNc5YdiaVBfOvKAo5Ho8S8/f1eklZlrLb7RQQxfv9Xm2CzAHACwAc4BJlxzyElPP9fl+yLFPi4XAok8lEA3AHOhssrFYr6fV6qgDQ0B/zEDsABJx3BKGYd3e9XlUdGZM3m40SLBYLXQtVvt9vbQpdhoA7NIjQks0/gjJRl6apmh5TCDkKKRWQ0WgknU5HgwpbXUYRyiiHHHaZZ5QNBgMFPJ1O2hDsYTrUQ78kACmZC7CHgDYFANgcovr5fGpEBxvmbrf7s9MoZA+facTXYIcKMZwL5BggJeIVwDarPz89AGFlhCg95iEkNhHhd94CtKFFgeXwjxL+Wf792xg7CukWOabQ9yum8AMub8+9QkzZbwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载\"\n        title=\"加载\"\n        src=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png\"\n        srcset=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/63868/load.png 250w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/0b533/load.png 500w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png 1000w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png 1113w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在端加载离线资源的过程中可以分为两个方面:</p>\n<ul>\n<li>离线SDK更新离线配置和离线资源 离线SDK通过与离线配置服务交互完成离线配置和离线包资源更新</li>\n<li>Web容器加载离线资源</li>\n</ul>\n<p>下面从代码层面简单介绍下加载离线资源的实现</p>\n<h3>离线配置</h3>\n<p>离线需要有一定的配置能力，比如禁用、特定的前缀支持离线化等。通过对离线配置的解析，Web容器就知道在打开对应页面是否的具体行为。这个过程是约定协议的过程。</p>\n<h3>加载离线资源</h3>\n<p>在<a href=\"https://icantunderstand.cn/jsbridge\">Hybrid开发-JSBridge原理</a>中通过拦截请求在特定的协议下可以实现javascript和Native的通信，那么在特定的协议下其实也可以实现离线包的加载能力。</p>\n<pre><code>// 定义请求资源类型映射\nprivate HashMap&#x3C;String, String > resourceMimeTypeMap  = new HashMap&#x3C;String, String>();\npublic CustomWebViewClient() {\n    super();\n    resourceMimeTypeMap.put(\"html\", \"text/html\");\n    resourceMimeTypeMap.put(\"js\", \"application/javascript\");\n}\n@Override\npublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n    Uri uri = request.getUrl();\n    String scheme = uri.getScheme();\n    String host = uri.getHost();\n    String path = uri.getPath();\n    // 处理资源加载离线包场景\n    // 协定 域名为www.test.com 且 path是local的走加载离线包逻辑\n    if(host.equals(new String(\"www.test.com\")) &#x26;&#x26; path.startsWith(\"/local\")) {\n        InputStream in = null;\n        String pageNamePath = path.split(\"/\")[2];\n        String type = pageNamePath.split(\"\\\\.\")[1];\n        String mimeType = \"text/plain\";\n        if(resourceMimeTypeMap.containsKey(type)) {\n            mimeType = resourceMimeTypeMap.get(type);\n        }\n        try {\n            // 加载本地离线资源\n            in = view.getContext().getAssets().open(pageNamePath);\n        } catch(IOException e) {\n          // 处理处理本地无离线资源 请求网络\n          return super.shouldInterceptRequest(view, request);\n        }\n        // 将本地读取的的内容进行类型映射后通过WebResourceResponse返回\n        WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", in);\n        return response;\n    }\n    return super.shouldInterceptRequest(view, request);\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADg0lEQVRIx+WWXUybZRTHn5WvQaFv2/ft2kIFRqgbHWbqHGGBTnEujdNIBpRBgjcmBo0yJ4lZskggfBhCsuxiiUYIXHJrwsW80HhhHBfTzGnQaLYJLZJsYx/EOIW29Geep5Z0fExJXhONJ/nl/J9zzvPvafopXnz5JH7/XoqLSzAMVwo9I+sGum6ovNbP6LndHnwlj1Bbe4ipqSmEXSvAphXgLXbj9rhw6DZ0w47T0NANDaeuUbbbh6c43fuzLrPLjlO3Y+xyICyCUCiE8Bi78Tqq8BkBfK4AXseeDfiMfRTrVZv2Sj1VlBgBnNZSGhqOIJ4ofIeOskuEfZ/S+eRFXj84zWFxgWd3fEyDSPGMuLCm08i+nOs88AVdh76iY/9HPBc8jjiaf54uEeNVscgbOXfp2nmPTnGH13b8TSy3ObXzPh1ihiO1xxEhyyhn98C5g79z7qkY5+tivC1W6BIrvKWIZeSNnBTLnBJJXhFRHq88jHjJMcpIBQwHYgxVxnjPn+BdI64441jhtO03TmsP4z5ntDhvFs2xr7wWcXbwfeau/MqXn8zy/fRNLn8WYWZ6gSufR7j+9V3u/JTk1rU4i9cTm3LrapylKHx7MUro6POID0c/4ObtBS5/c4kbiz/z47Xv+OGqZIZ7vyySiiRbR6q3cCNKuDWMmJiY4GGxmkiSXE2yugWJ+Kqam5uN0NbWhhgfH1eFeDxOMimHVlVOo3ZIbr2hnJcRiawzTCQSDxiZZrjd+EcNT5wwe0MzDaPRKOFw2FzDlpYWsw1N3rCpqen/Zmj6q9zc3PwvNzT9KZtqKD/LphrOz8/T2Nj4X3wfbpcN3zZjY2OqsLy8rH6otkssFlP3Z2dnU4aTk5OYEUtLS7S2tiLk8x4ZGaG/v5+hoSH6+vro7e1VenBwUNHT06P66bPUsib1wMAAw8PDdHd3p/4fCiHIpLCwkIqKigdqdXV1ZGdnr52lbm9vZ/3dmpoahNVqVQO5ublYLBYcDgcej0dpWcvKyqK8vJyioiKlJVJXV1erezk5OeTl5SnD+vp6hK7rOJ1OhdSapmGz2UjXZZZb2+12pSVSFxQUrN0zDIP8/HyCwSBCNwxcLpcqpvmr8/qa2+3Gai1MGe4ydOyatrZNJnJ4K515luTl5vLCsWOIygNPszdQTVlpqXqkzbZZb5S5pdfrxe9/FH9gPyWPBfkD9GZ9jWzUPEsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"成功加载离线资源\"\n        title=\"成功加载离线资源\"\n        src=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n        srcset=\"/blog/static/2a4c23295151170c16b9a53887eda09b/63868/loadsuccess.png 250w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/0b533/loadsuccess.png 500w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null},"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null},{"id":"def07bfd-8fd5-597b-9010-98ac2289a06c","html":"<p>跨端开发中h5加载性能优化是一个老生常谈的问题。h5在开发上有着迭代快、试错成本低的优势，但是h5的性能问题也是一个无法绕过的问题。加载慢、体验差是通常在考虑技术选型时候的一个顾虑点。本系列会以Webview性能优化为切入点尝试了解跨端开发中的技术方案来更好的辅助业务的开发。</p>\n<p>充分利用Webview的缓存(存储)机制能有效的提升h5的加载速度,通常有如下的方案可以实现缓存的过程:</p>\n<ul>\n<li>h5缓存机制</li>\n<li>Application Cache</li>\n<li>浏览器存储</li>\n</ul>\n<h2>h5缓存机制</h2>\n<p>h5缓存是指浏览器根据文件网络传输中的一些字段来确认是否使用已经缓存的文件，具体可以参考<a href=\"https://icantunderstand.cn/web-store\">缓存那些事</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVQoz22SzY6bMBSF8/zddNF1q64rtX2ESO2imheYdFPRhAwJJJAQfgwG+6uOgUwqjSXLNvfy3XOuvfIewGPtjnEscQ68t1h7wLkG5zxlWdL3HSHTt3i/A/Z4H4epPexwLmc1AR1dF2FMxvF4pq5PdN0T45hQ14YoiqjrKgCdE+wzxnwiit7z/PyOOP4AfMT7NSup8xOVYfAcj0eapp3PjtPpxO1243VcgSe8/8XttqYs1zTND+An8HtSOAFluw+ApmlmNY7z+UxVVfR9jzEtbWvIsoKyrJl1zK2Y1pVg3rsZaEmS5K5IMQHrusYYQ57nYf/ysqco8iBgGOyCDPmrBy/BooBStAyBlDgMA1mWhXMcx2GvAloVk5tZ4Y4k+UaSfMeYiDg+UFWvPZNVAbuu43A40LZtgFwul9AeQfVN8QB07i/7/RfS9CvW/iFJ0vuNqvLSAv2w2WyC5fv1XK8hplVFxnH837K1Y6isigswTdOgQla32214k+q1zuqvYppFUUzAx0sZxyEokM3HoRwVkUX1Vz8KqlVz6V+wLNDjW3yELHNRq+ek9a2x5P4Dh85Sl/bdd+YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"h5缓存机制\"\n        title=\"h5缓存机制\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/63868/cache.png 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/0b533/cache.png 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/0f529/cache.png 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Application Cache</h2>\n<p>Application Cache主要是做应用的离线化配置，它跟h5通过缓存头实现的缓存机制相对独立。通过在html中引入manifest属性开启Application Cache.</p>\n<pre><code>&#x3C;html manifest=\"example.appcache\">\n...\n&#x3C;/html>\n\nCACHE MANIFEST\n# Version 1\n// CACHE下声明的文件将在首次加载后进行缓存\nCACHE:\nscript/scriptfilename1.js\ncss/cssfilename.css\nimages/imagename1.png\nimages/imagename2.jpg\nimages/imagename3.png\n// FALLBACK定义离线状态下的规则 \nFALLBACK:\n// images下的资源都将使用images/imagename4.png替代\nimages/ images/imagename4.png\n// 缓存白名单 应用对Network下的请求都会绕过缓存请求服务器\nNETWORK:\nimages/imagename5.png\n\n// 端侧在初始化Webview的时候开启Application Cache \nWebSettings webSettings = webView.getSettings();\n// 允许执行JS\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n</code></pre>\n<p>在使用Application Cache需要注意以下几点:</p>\n<ul>\n<li>有同源限制，缓存大小限制(5MB)</li>\n<li>需要更新缓存文件的时候，需要同步更新manifest文件</li>\n<li>manifest声明中的文件无法下载时会导致无法更新到最新的缓存，浏览器将使用旧的缓存文件(推荐一些几乎不更新的文件使用Application Cache)</li>\n<li>可以在业务代码中通过window.applicationCache相关api实现缓存资源的手动触发更新</li>\n</ul>\n<h2>浏览器存储</h2>\n<p>通过浏览器提供的api实现数据的存储和缓存功能。</p>\n<h3>Dom Storage</h3>\n<p>Dom Storage指的是LocalStorage和SessionStorage。LocalStorage是持久存储，SessionStorage是会话存储。他们都通过key-value的方式来对简单的数据进行存储。Dom Storage存储空间为5MB有同源限制。</p>\n<pre><code>WebSettings webSettings = webView.getSettings();\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n// Webview初始化开启Dom Storage\nwebSettings.setDomStorageEnabled(true);\n\n// javascript\n// 设置键值\nwindow.localStorage.setItem('name', 'haha')\n// 读取键值\nwindow.localStorage.getItem('name')  // 返回\"haha\"\n</code></pre>\n<h3>IndexedDB</h3>\n<p>IndexedDB可以通过数据库的方式对数据进行存储，它的存储空间相对于Dom Storage大很多。通常可以基于封装IndexedDB的库来实现数据的存储。IndexedDB的使用方式可以参考<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<h2>参考</h2>\n<p><a href=\"https://webplatform.github.io/docs/apis/appcache/ApplicationCache/\">ApplicationCache</a><br>\n<a href=\"https://www.html5rocks.com/zh/tutorials/appcache/beginner/\">应用缓存初级使用指南</a><br>\n<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null},"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null},{"id":"c299ca54-40f9-5fa4-8614-d9513c8b13d1","html":"<p>Android中可以使用异步消息处理机制来完成主线程和子线程任务调度，本文主要介绍使用Handler实现消息通信的过程。</p>\n<h2>Handler</h2>\n<h3>基本概念</h3>\n<p>使用Handler实现异步消息需要以下的组件:</p>\n<ul>\n<li>Message\n发送消息传递的数据对象</li>\n<li>Handler\n负责消息的传递和处理</li>\n<li>MessageQueue\n负责保存当前线程中的发送的Message，每个线程只能有一个MessageQueue</li>\n<li>Looper\n负责管理线程中的MessageQueue，将MessageQueue中的Message不停的取出给Handler处理。每个线程只有一个Looper</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 814px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxzQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAQABBQJp/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQESExQf/aAAgBAQABPyG2301CwGUf/9oADAMBAAIAAwAAABAjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExcYGRsf/aAAgBAQABPxAoWhxEaUveYagcl+RXQfIANVP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Handler实现结构\"\n        title=\"Handler实现结构\"\n        src=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n        srcset=\"/blog/static/86b2a15f43db42534948074b87746b3e/0479a/Handler.jpg 250w,\n/blog/static/86b2a15f43db42534948074b87746b3e/41099/Handler.jpg 500w,\n/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg 814w\"\n        sizes=\"(max-width: 814px) 100vw, 814px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>例子实现</h3>\n<p>下面的例子中布局文件中定义了一个TextView和Button，在Button点击的时候通过发送Message来实现TextView内容的更新。 使用Handler处理异步消息主要有如下的步骤:</p>\n<ul>\n<li>\n<p>初始化Looper(Looper.prepare)和MessageQueue(Looper.loop)</p>\n</li>\n<li>\n<p>根据当前的Looper创建Handler并重写handleMessage方法</p>\n</li>\n<li>\n<p>在子线程中通过Handler发送Message传递数据</p>\n</li>\n<li>\n<p>主线程处理数据(UI显示)</p>\n</li>\n<li>\n<p>主线程退出后清除Handler的任务/关闭Looper</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n  // 定义更新按钮文旦的标识\n  public static  final  int UPDATE_TEXT = 1;\n  private TextView textView;\n  private Handler handler;\n  private Runnable runnable;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    textView = (TextView) findViewById(R.id.textView);\n    Button button = (Button) findViewById(R.id.button);\n    if(Looper.myLooper() == null) {\n      // 初始化当前线程的Looper 通过判断保证当前线程只有一个Looper\n      Looper.prepare();\n      // 开始线程中的MessageQueue\n      Looper.loop();\n    }\n    // 创建Handler  创建Handler必须执行Looper\n    handler = new Handler(Looper.myLooper()) {\n      @Override\n      public void handleMessage(@NonNull Message msg) {\n        // 重写消息处理方法\n        switch (msg.what) {\n          case UPDATE_TEXT:\n            // 获取传递的数据\n            String content = msg.getData().getString(\"content\");\n            textView.setText(content);\n            break;\n        }\n        super.handleMessage(msg);\n      }\n    };\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n          // 在子线程中通过Handler发送Message\n          runnable = new Runnable() {\n            @Override\n            public void run() {\n              // 这里可以做一些耗时操作\n              Message message = new Message();\n              Bundle bundle = new Bundle();\n              bundle.putString(\"content\", \"you click me!!!\");\n              message.setData(bundle);\n              message.what = UPDATE_TEXT;\n              handler.sendMessage(message);\n            }\n          };\n          runnable.run();\n        }\n    });\n  }\n  @Override\n  protected void onDestroy() {\n    // 可以在这里清除runnable/终止消息的处理\n    handler.removeCallbacks(runnable);\n    Looper.myLooper().quit();\n    super.onDestroy();\n  }\n}\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/blog/54c35e9eba49d7862bdca4f06c052160/showHandler.gif\" alt=\"使用Handler\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null},"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null},{"id":"840245e1-c990-5965-b1ee-b408fa76777c","html":"<p>Hybrid混合开发相对于单一的客户端开发有着开发周期短，迭代快的优势，但是Hybrid模式开发的页面存在着一定的缺陷，比如性能问题、缺乏客户端能力等。通过JSBridge这个桥梁可以实现客户端能力的打通，赋予了Hybrid应用更强的端能力。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 838px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcElEQVQ4y42U2Y7CMAxF+/8/SJ8qSksXukJXKNSjY8lVBmZEI0W249wb23HiDcMgZVlKVVVSFIX0fS+Px0Pn7XbT9bqudaKz3/xd121Y5DiO4qHgZCABLssi9/tdzuezbmY2TbPZz+dT/WDXdVUsNj7PNjAgAggxG06nk8zzLFEUSdu2moFLiG7DglFCiN4JIcqyTNI0VcnkAPxuhLsJAcRxLFZj6nm5XD5S/kpIagDQIbTakS4S+/V6bQT/ElJcZJ7neltERJqskT4AOgD/NE2qUw4G2A9CUiMy3/cVFIahBEGgAFKjRYjscDhs0aIzOByOj5St9wBatNfrVcuANNuyIf2vNWTRLuV4PCoZkZI+NSVaMqEMu2/Z6kZE2OyB2Ozdt8yi2zbUyYjQqes7ob2UX4TUjIF0Ce2FJEmipDQ2oL9eCmsbIRdBqwC2t2wp2+fAQdguoX0mdIhhPYAQ2qTH7DfhENoFEBP93e9i4foBsVCB7aDDCl4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"JS\"\n        title=\"JS\"\n        src=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n        srcset=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/63868/JSBridge.png 250w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/0b533/JSBridge.png 500w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png 838w\"\n        sizes=\"(max-width: 838px) 100vw, 838px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nJSBridge作为客户端和H5的通信的桥梁，可以承接如下的能力:</p>\n<ul>\n<li>鉴权能力 JSBridge调用能力鉴权，白名单，黑名单等</li>\n<li>胶水能力 JSBridge兼容代码，做版本控制等调用透明</li>\n<li>测试能力 提供测试方法，方便测试</li>\n<li>Scope(配置)能力 能基于配置产出精简版、目标版本JSBridge</li>\n</ul>\n<p>下面以Android代码为例，介绍JSBridge的实现方式。</p>\n<h2>Js调用Native</h2>\n<p>Js调用Native通常有如下的方案:</p>\n<ul>\n<li>拦截请求(shouldOverrideUrlLoading/shouldInterceptRequest)</li>\n<li>拦截特定方法(prompt/alert/confirm)</li>\n<li>客户端注入JSBridge(addJavascriptInterface)</li>\n</ul>\n<h3>拦截请求</h3>\n<p>在安卓初始化Wevview的时候可以设定WebViewClient，WebViewClient主要功能是处理Webview加载时的通知和请求事件等。通过重写WebViewClient的shouldOverrideUrlLoading/shouldInterceptRequest就可以实现拦截h5的请求从而实现端能力调用。\n实现思路如下:</p>\n<ul>\n<li>定义JSBridge实现Jsb方法</li>\n<li>定义JSBManager管理Jsb的调用</li>\n<li>实现拦截方法的重写</li>\n<li>H5侧调用</li>\n</ul>\n<h4>定义JSBridge方法类</h4>\n<pre><code>// 以下例子均省略import语句 \npublic class JSBridge {\n  // 需要考虑callback和入参一致性问题\n  public void showToast(JSONObject jsonObject) {\n      try {\n          Toast.makeText(MainActivity.context, jsonObject.getString(\"content\"), Toast.LENGTH_LONG).show();\n      } catch(Exception e) {\n      }\n  }\n}\n</code></pre>\n<h4>定义JSBManager管理Jsb的调用</h4>\n<pre><code>public class JsbManager {\n  // 通过HashMap获取JSBridge定义的所有方法\n  public static Map&#x3C;String, Method> methodMap = new HashMap&#x3C;>();\n  public void init() {\n      Method[] methods = JSBridge.class.getDeclaredMethods();\n      for(Method method : methods) {\n          methodMap.put(method.getName(), method);\n      }\n  }\n}\n</code></pre>\n<h4>实现拦截方法的重写</h4>\n<p>以下以shouldOverrideUrlLoading方法的重写为例子。在例子中定义的通信协议是myjsb://method?params。通过在拦截方法中对请求进行解析就可以实现调用对应客户端method的逻辑。</p>\n<pre><code>public class CustomWebViewClient extends WebViewClient {\n    private JsbManager jsbManager = new JsbManager();\n    private JSBridge jsBridge = new JSBridge();\n    public void initJsb() {\n        // 初始jsbManager和jsBridge实例\n        jsbManager.init();\n        jsBridge = new JSBridge();\n    }\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n        Uri uri = request.getUrl();\n        String scheme = uri.getScheme();\n        if(scheme.equals(new String(\"myjsb\"))) {\n            // 获取方法名 入参\n            String methodName = uri.getAuthority();\n            String query = uri.getQuery();\n            try {\n                JSONObject jsonObject = new JSONObject(query);\n                Method method = jsbManager.methodMap.get(methodName);\n                // 调用对应的客户端逻辑\n                method.invoke(jsBridge,jsonObject);\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n}\n// 主活动代码逻辑\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建WebViewClient\n        CustomWebViewClient webViewClient = new CustomWebViewClient();\n        // 调用JSBridge初始逻辑\n        webViewClient.initJsb();\n        WebView webView = (WebView) findViewById(R.id.webView);\n        // 设置WebViewClient处理webviewt通知，请求等\n        webView.setWebViewClient(webViewClient);\n        // 开启调试功能\n        webView.setWebContentsDebuggingEnabled(true);\n        WebSettings webSettings = webView.getSettings();\n        // 允许执行JS\n        webSettings.setJavaScriptEnabled(true);\n        // 这里加载项目本地的html文件方便调试\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n}\n</code></pre>\n<h4>H5侧调用</h4>\n<pre><code>    &#x3C;body>\n        &#x3C;div>this page test JSB&#x3C;/div>\n        &#x3C;script>\n          // 通过创建iframe发起JSBridge调用\n          function iframeCall(url) {\n            let iframe = document.createElement('iframe')\n            iframe.src = url\n            iframe.style.display = 'none'\n            document.documentElement.appendChild(iframe)\n            setTimeout(() => { document.documentElement.removeChild(iframe) })\n          }\n          function callJsb(method, params) {\n            let url = `myjsb://`\n            if(!method) {\n              return\n            }\n            url += `${method}`\n            if(!!params) {\n              url += `?${encodeURIComponent(JSON.stringify(params))}`\n            }\n            iframeCall(url)\n          }\n          callJsb('showToast', { content: 'xiaohong' })\n        &#x3C;/script>\n    &#x3C;/body>\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 196.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAnCAYAAAAPZ2gOAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+1US09TQRQeGwh90Pb29kFppQ9BVAghGjfqQorFaNyZCCt3CBSoMa6IhkRiDCYmBqMxRU34ObSEFlalYCIkbuTRCra29N62n5nR2/SF1IorPMmXc+Y7c89jZs4lOl4DTq+AoUmL5pNGaHRyaHkldAYleKOS+ZpbeLQ4TeAMCuiMyiLwRhXbr9UrwPFqEDN/Gm36PrTqXWhvuoZzVjfOWtxw6lywq3tg1/TAoXHBoXUxuxA2dQ/aDL3otLlxpqkPdlM3SLuqH/dsn3DXGoK3O8zwuPcj7nBB9BE/bpIAblQA5am/nwth4moEE5c+w+2YArmoHsQDkoOH7GCUfIW3fpfpMbKLcdkuxk/8QqFdwNF9w2QH94kIt3wG5Hz9MJ5bgVeXU3h5QcSHWxk84gSMkTS8VWKcJPGQANfr34JcMQ/hRTvwrCOO6c4UpjtSeNqaxJQjiSlndXjijGP6FHDb+gZkaNADiMDulzTi21nEd7JIRLP4Hqse37YFQABez/hARsdGQSVLo9YoOWSYfvd+FsTj8bCFIIjIZXM1QRR+FjPrKwgoiiJyuVxNFdJvWcDZ/wGPacBS5B/vb5JVDJjJZA6ehEMqrxgwlUpBEASk02kGuml/fz8frOoKR0ZGsLm5iXA4jOXlZaytrWF1dRXr6+uMq7llqSrp7LLZ7N+1LJGlZ/fHLf+zWz7mo1eoDzrXwuSHXkrpDR80OZKuusJq7aqejfTYY7EYtra2GKLRKJLJZFkHZaNHhc4t/UEUIpFIYGNjA0tLSwyRSAR7e3tl+2hiKj6fD8Tr9eKoZG5uDmRgYID9DBYWFhAMBrG4uAi/389silAoxHyBQIDZEjc/P5//huqVlRVMTk6CKJVKEEKKwHFc0Voul0Or1RZxFosFKpWqiKurqwNpbGwsIx0ORxFnMplgs9mYLZPJmO7q6oLZbC5LTHQ6HdRqdR40AXVIa41GA4VCwThqS1xDQwNodxJHwTozGAwwGo1FoBUdxlXaQ2MRvV6PowSx2+3geZ5Fp5Ac0rqUK/UX8rTKH4LefgGruMzUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"拦截请求实现调用\"\n        title=\"拦截请求实现调用\"\n        src=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n        srcset=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/63868/overrideUrlCall.png 250w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/0b533/overrideUrlCall.png 500w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>使用iframe发送消息的方式会存在消息丢失，参数限制等问题，可以通过消息队列和拦截shouldInterceptRequest方法来实现。</p>\n<h3>拦截特定方法</h3>\n<p>在初始化WebView的时候可以同步设置WebChromeClient，WebChromeClient主要是辅助WebView处理Js对话框，标题等操作，通过拦截WebChromeClient相应的方法同样可以实现调用端能力。</p>\n<h4>实现WebChromeClient</h4>\n<pre><code>public class CustomWebChromeClient extends WebChromeClient {\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 此处举例为主 直接弹端toast\n        // 实现上跟拦截url一致\n        Log.d(\"mesage\", message.startsWith(\"myjsb\")+ \"\");\n        if(message.startsWith(\"myjsb\")) {\n            Toast.makeText(MainActivity.context, \"PropmtCall\", Toast.LENGTH_LONG).show();\n            // 此时js调起了 需要JsPromptResult.confirm(result)\n            return true;\n        } else {\n            return super.onJsPrompt(view, url, message, defaultValue, result);\n        }\n    }\n}\n// 在初始化WebView的时候设置WebChromeClient\nCustomWebChromeClient webChromeClient = new CustomWebChromeClient();\nwebView.setWebChromeClient(webChromeClient);\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.prompt('myjsb://')\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 199.60000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+2U309bVRzAD9BCgdv23tt7ewsKq6nIBnWLcWYJ0RfjlLin6UzmHjQLyWYcbcfMKsZkPvrj0YRAoegMITz45xAShiYGWGIMIUQEWlrbjzmnu3jpHIPFx57kk/P9fs/3+znn9qGipydOxLSJOd040S5sK4ptOVgRBzviYJlRumLPKWSsah5kb9SOKceLiT6EbnYSMv3YsTCmrdEZ8qOFW9GtNoxogLDVSnevTlePrmLDDih0+9F5JIAWaqUz7Cesa4g+4xIX7HFes8d486XPuTj4BW+dGedccIyBtgzJ9tsMtKUVycBtBgMZhayf8acZev4ub788zjsDX5FwhhCva99yvf0PPgr+Sjr+kNHeh2STv3PV9wvviQdcESsHvO9B5pfFA64bv3E3uc6XyR1etUYQ77ZPcS8E48ZfZLVd7nXvkRK7jDXtcaelcDS+Ahmxx6fiT+4IuKDdQlwUOb4+Bd+d3eOb0/t8P7RPShS5KQp8cmx2yAg43zaKuPFGjoVrMPvBLvevFvnhSpGfrp2MHz/c4eeP4dK5UcT9uVlqqwxUH8XVE1JWU2OfZRD5fE1YKpWpVDg5f1cp7deE6XQGMTtbE5bLZarV6jMhZ+XKZOqEz7IawoawIWwIG8JjCt1/YW9cT/3ZU4Xe/Umv8kqf+snuQKVSOUDW3Lhe+kSh95Pk4NbWFqurq6ytral9fX2d7e3to184MzOjkmKxqA5KpZLaZb6xscHKygqLi4ssLS2xvLzM5ubmQY9LoVBQjlQqhVhYWOD/WtlsFjEyMsLc3BzT09Pk83lyuRyTk5MqlsifROZTU1MqdusTExOHZubn5xkeHkYIIahH07RDeTAYxOfzHaolEonH5lRPR0cHLS0tKmlublYyx3FoamrC7/erPRaLYZqmimWfpL+/X/XKGZlLh7xYyEZd1xWGYRAOh9WBjN2aHAyFQgc1iXyI7PXWpEtYto1t21iWpbDr8uPW3FiYeu2WSCRyJLL5v2IX5TANxOmz54mf6sWy/r3NHfLiFdWfSV6Ix+kbfIV/AHs5ocTNraY7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"重写Prompt方法调用\"\n        title=\"重写Prompt方法调用\"\n        src=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n        srcset=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/63868/overridePrompt.png 250w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/0b533/overridePrompt.png 500w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>客户端注入JSBridge</h3>\n<p>通过<a href=\"https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String)\">addJavascriptInterface</a>可以在初始化WebView的时候将客户端的调用逻辑暴露给H5。</p>\n<h4>实现JSInterface</h4>\n<pre><code>    public class JsInterface {\n        private Context context;\n        public JsInterface(Context context) {\n            this.context = context;\n        }\n        // JsInterface需要用@JavascriptInterface注解才可以被调用\n        @JavascriptInterface\n        public void showToast(String content) {\n            Toast.makeText(this.context, content, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    // 在初始WebView的时候注入interface\n    webView.addJavascriptInterface(new JsInterface(context), \"myjsb\");\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.myjsb.showToast(\"Interface\")  \n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 200.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADaklEQVRIx+2Vy09TQRTGB+jDK9D29j76UEyJIo9gfGCqJmowrtwQaMHIxoWJ8rJaCUaif4EL3oSFqAs3rliZCBFiXLKHiCECoRASiLzEtpT29jMz9dbyqoXgSif5Zc75euabczt3cslZ52UIvABZssJqOQJJlCGJFoYoUGTIkg1221EWx7Tf0DpZis1Wiw3EaMqEwawDL3Gw2HlkGjXIMupgEHTgZT2Mog6SPQs5uQJMkp7Bb5oPsfoskxYGEwdi54vhtD1AidyAi8fuo7TAi2uFXpRIDcjX16DocC0KuRoUHKpBIVcbp4irRYG+Bqf5elwv9uLq8Uacc1SBnDDcwF3Rh9vZX1F/bBqeXB+enJnDHWECZeQzXOTLrpSTMdzSj6Pp1AyeFH9DleMtyCmDC03aEJpNfjRxP/BM8sOr+YEHxI9GTQCPMnanMSMAb1oA9eQ7HpII3BnvQAp0LjRnRtB+IYTnRSF0X9nAUz6EeySIOhJEbQrUkQA8BKgg70Eu5bnwuiKMF2VBvCwPorcsiN7yIF651vGqIpgSvRUBvKkEHpe+B6m6WYnYUABE90mEOXz8NAhS6Y4ZKpEoFCWKqII9EwkrzOPDB2pY+cuQmkX3RyQS63BwMMFQ/XE/47/hP2uoKApjp/dM3XBPhsnGnzrfZri6uspYXFzE0tISVlZWWL6wsMC6TrXDvr4+ELfbjdnZWUxPT2NkZASTk5Ms9/l8GB8fjxenYtjf33+wjzw0NPQXD+X/TTlYw8Q52SGpcVLDVE51a82eOqTF6uukxls3/GOHanEoFML8/DympqbYDZqbm8Pa2lryjxS9elTc2NjYRDgcht/vx8zMDMbGxjA6OoqJiQksLy9vq11fX2eGAwMDINXV1TioMTw8DOJ0OtHd3Y2Ojg50dnayuaWlJZ53dXWhra2NaTSmGoXmra2tLG5vb0dPTw88Hg8Ix3EghGyC5/ltmiAIm3Kr1QqDwbCtjhiNRmg0mjharRYWiwV6vZ7l6enpbKHNZmOxTqdDWloacnJyWB2N6Rpay5qjO9OOEsnOzo7HZrMZdFOq0VjVaE43UjVVJ4IgQpIkiKIYZ2u+k0bzRI3FkgRilUWYTEaYzQL7n3aDLkqWsw55E0je+VLknczHEbt9x85UEo22IssyHA4HjucX4yfjfpxnxqZHBAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"interface调用\"\n        title=\"interface调用\"\n        src=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n        srcset=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/63868/callInterface.png 250w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/0b533/callInterface.png 500w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>Native调用Js</h2>\n<p>Nativa调用Js通常有如下的方案:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></li>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></li>\n</ul>\n<p>以下例子在H5中都定义了全局函数供Native调用</p>\n<pre><code>    function testNativeCall() {\n      console.log(\"nativeCallJs\")\n      return 'nativeCallJs'\n    }\n</code></pre>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></h3>\n<p>可以通过webView.loadUrl(\"javascript: testNativeCall()\")发起调用(需要等待Js执行完成)。loadUrl的方式会刷新页面且无法获取js的回调。</p>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></h3>\n<pre><code>webView.evaluateJavascript(\"javascript: testNativeCall()\", new ValueCallback&#x3C;String>() {\n    @Override\n    public void onReceiveValue(String value) {\n        return;\n    }\n});\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADPUlEQVRIx+1US08TURi9hSK0DG3n1SkEgRYlKAoGVoqPhZqwAF0pJi6MC9EIGoGFBlpRsRF5FAqJEH6AUXGlfwVIWFgKBASBYELaTqFwzL3N1PIqj7AwkZucfI97vnPPdOaW5OblQ+BF2JQs2GxZkCQrZFmBJFoZREFGVmY2A821vgbKtcoKREGC3e4AsQgcMiypkBQzRNkMznQMnCkNFskAQTayaMvmkXmcZzkvG2Ng+6KR8TlzGkxmDqSAv4GrOe9RrrSg4pQbVefaUFXchjLuJYpTnChJdbGo5fEoSmrGlew3uFn6DpVFnTiTUwFSzr1GLf8b9wx+1Np+4rF1Bs8Lf+Gu3o/bxIfqBLhFfuA+N4mG/Bm8OLmMi0oDyHWDBy1mwKkE4FJCeJsfwjNdEPW6EBr1KhqTE0Cvop6EUEeW0UCAS8YmkMvEg1YFaC8Jwn0ijPbiMJ6SEGpICA/3jADqCHBe3wRSc82Db0+Ajw8C+PxIxacaFUO1Kr7WqRiqi8ZEoJwvtUF8rwfulDeDfBjoRXRFcPAVnX3V6gLxeqOCK+EI1iLrB8JqOCrocrpAenujgpFIBOvr6wcCnWWCrm0E97uOBP9rwdXV1W2/MW1op8O2CPb19e3qYF8OOzs7EQwGsbi4iLm5ORaXlpawsLDAsG+HHR0dbHB8fBzDw8OYmprC9PQ0/H4/Jicn/4FHPvSXcnRTDl9w84vYCfGcXR3uxWk8d88ON39Ka2trsd6eHWrkcDiM+fl5+Hy+GCYmJtjVXFlZ2Vmwp6eHFaqqstMpKCEQCGB2dhajo6MMIyMjGBsbY/ed3n3K0fj0cLqcTifI4OAgDmu53W6Q6upqDAwMoLu7G16vl8Wuri7Qn4LWNNLa4/HEehT0T0WboU/Z39+PyspKEEIINsNisWyozWYzDAbDhl5hYeGWueTkZJD09HSW6PV6JCUlwWg0wmq1spz2dDodZFmGIAgsT0lJYXsOhwMZGRkxHtXgOA6EEnmej4G6o0Stpvu0NplMiOdSI9R5/CzdJ5IkMweSJMWwXb1bT8uJKFBXPERRTAhKTrRHn4xqkdOlF2DPy91wmkaKx3a9v3sSHHY7Cs6W4Q880qCTlgwo4gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"evaluate调用js\"\n        title=\"evaluate调用js\"\n        src=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n        srcset=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/63868/evaluateJS.png 250w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/0b533/evaluateJS.png 500w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a>\n<a href=\"https://juejin.cn/post/6844903840588759048\">跨端技能必备之JSBridge</a>\n<a href=\"https://juejin.cn/post/6844903856418062350\">从零开始写一个 JSBridge</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null},"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null},{"id":"a13a2570-fa88-5f20-a625-6102f0ddd286","html":"<p>在前端页面开发中，通常会将数据层和UI层进行隔离，这样能更好的做到职责的分离。在安卓开发中ViewModel可以实现UI的数据管理能力，结合LiveData的观察通知能力可以做到页面与数据视图的更新绑定，更有效的组织页面逻辑。</p>\n<h2>ViewModel</h2>\n<p>View能有效的做到视图和数据的分离，数据共享能力。\n<img src=\"./AndroidViewModel/viewmodel.png\" alt=\"ViewModel作用\"></p>\n<h3>ViewModel生命周期</h3>\n<p>ViewModel对象存在的时间范围是获取ViewModel时传递给ViewModelProvider的生命周期。ViewModel将一直留在内存中，直到限定其存在时间范围的Lifecycle永久消失：对于Activity，是在Activity完成时；而对于 Fragment，是在 Fragment 分离时。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkklEQVQ4y6WU208TQRTG+a99Uh/UGH3VaIgvPvkEGMGAPICXekVDsS3UloJZe9n7dtu9X2Z+ZhdbDdZC4yYnZ2Zy5ttz+b5ZklLmUkpx3sTECymyXIg8F6UXM2J/WREcLxUL/vObYEgpkylglmXSNE05GAxK3x8M5Nh1ZK3ry+WXinz86kQ+evVDtvVIQi6jNJJxFslc5MX9EkMI8RuwKGY8HmPbNqPRCMuyiUOfphpy53mH26tVbm8c0xhEuJHGoXZAU//KKBpOk5wCTjKeVY6XCHYbGk8rh2wf9NDHOXagcjQPsDhJ01SqqoqiKPT7/dLrukaYZHTtgO+qg2J6xBmY/iUAix5aloWmaZimia7r2I6DzGIyt8ew3yZ1FMhjDF+jeRHgv0qWgU3QfEF/b41RbQM8DSMwOFKrNLU5gJNeTk2Isz+MFKLXdxls3sTfuQFGHSOyaZk12lZjAUApygx9R+Pd+iN2Vh7yZu0BTu8Yw9fZa1f4cvIeN3QuByjEWQdOrIRr6wpXV5pcWTlhv5cyDAZsfVjn5f4249hdjDa2n/HsS48nO3VWP/2g56Q4oUbLrM8vuZhyEAQU5HZdF8/ziMKAIBE0ui4fDxWqpxZeDNaENvOGkiSJHA6HdLtd2u12SZ+h65LGIalnEboGiWeCyDB89WLa/Hot/hQ85S4ZE3QqnH7awP22C6GN7uscadVFpXe2laMe4cdltN37jCv3QKtjRQ4tvUbbaODFo9kZFo9DlmVF6aWlSUImQA4VzO1bKBs3MDavk7W2UH2davc9tf4eTmD+W8vFIIredTqdUnq+75PneRFeBE+5+fn0LVv7a2ztr9LS6otJ7y8pznlgL1DKbGP2+WKAk6mfX88C/AlUyUhxrEpdmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ViewModel生命周期\"\n        title=\"ViewModel生命周期\"\n        src=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n        srcset=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/63868/cycle.png 250w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/0b533/cycle.png 500w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>LiveData</h2>\n<p>LiveData是一种可观察的数据存储类，它具有生命周期感知能力，可以遵循其他应用组件(如Activity、Fragment、Service)的生命周期进行数据的更新通知。使用LiveData有通常有以下的三个步骤:</p>\n<ul>\n<li>在ViewModel中创建LiveData实例保存数据</li>\n<li>创建可以定义OnChange()方法的<a href=\"https://developer.android.com/reference/androidx/lifecycle/Observer?hl=zh-cn\">Observer</a>对象</li>\n<li>在界面控制器中使用<a href=\"https://developer.android.com/reference/androidx/lifecycle/LiveData?hl=zh-cn#observe(android.arch.lifecycle.LifecycleOwner,%0Aandroid.arch.lifecycle.Observer%3CT%3E)\">observe()</a>方法将创建的Observer对象附加到LiveData对象</li>\n</ul>\n<h3>添加依赖</h3>\n<p>使用LiveData需要引入ViewModel</p>\n<pre><code>dependencies {\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.lifecycle:lifecycle-viewmodel:2.3.1\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>在ViewModel中创建LiveData对象</h3>\n<pre><code>public class MyViewModel extends ViewModel {\n    private MutableLiveData&#x3C;String> title;\n    public MutableLiveData&#x3C;String> getTitle() {\n        if (title == null) {\n            // 网络请求、读取文件etc\n            title = new MutableLiveData&#x3C;String>(\"哈哈\");\n        }\n        return title;\n    }\n} \n</code></pre>\n<h3>在界面中使用LiveData数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyViewModel myViewModel;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        TextView textView = (TextView) findViewById(R.id.textView);\n        // 获取ViewModel\n        myViewModel = new ViewModelProvider(this).get(MyViewModel.class);\n        // 创建Observer\n        final Observer&#x3C;String> titleObserver = new Observer&#x3C;String>() {\n            @Override\n            public void onChanged(String s) {\n                textView.setText(s);\n            }\n        };\n        myViewModel.getTitle().observe(this, titleObserver);\n        Button button = (Button) findViewById(R.id.button);\n        // 定义button的点击事件 更改ViewModel的数据\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                myViewModel.getTitle().setValue(\"我变了\");\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/d9632f4d22fc8dd9b600386ab2ade7dc/showLiveData.gif\" alt=\"使用LiveData\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-页面数据管理(ViewModel&LiveData)","date":"2021-07-02","tags":"跨端技术","path":"/android-view-model","top":null,"summary":null},"title":"一起学Android-页面数据管理(ViewModel&LiveData)","date":"2021-07-02","tags":"跨端技术","path":"/android-view-model","top":null,"summary":null},{"id":"94b4b3b7-46cb-5f27-b003-34911da0a665","html":"<p>应用程序在运行时需要占用系统的存储空间来实现加载代码运行、存储运行时数据等功能。理解内存空间的管理策略能让我们更好的理解代码在系统中运行的机制。本文从代码运行时存储开始逐步介绍V8的垃圾回收机制。</p>\n<h2>运行时存储</h2>\n<h3>堆存储</h3>\n<ul>\n<li>主要存储全局变量,引用类型</li>\n<li>动态分配，可分配动态空间，有垃圾回收机制参与空间管理</li>\n<li>总存储空间大(通常分配给应用的空间有限制)，查找效率低</li>\n<li>堆空间被应用的线程间共享</li>\n</ul>\n<h3>栈存储</h3>\n<ul>\n<li>主要存储局部变量(基础数据类型)、指针、函数执行片段(function frames)</li>\n<li>由系统分配，通常存储限定大小的数据，栈片段弹出后空间释放</li>\n<li>栈结构后进先出(LIFO),访问效率高</li>\n<li>多线程应用每个线程都有一个栈存储空间</li>\n</ul>\n<h2>内存管理</h2>\n<p>通常说的内存管理都是指对堆内存空间的管理，以下介绍V8中的内存管理方式。<br>\n在V8中运行的程序会被分配如下的内存空间(Resident Set)\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACd0lEQVQoz23LX0wSARwH8HvoqYde22o91kubbj20zH8Tpw+ZpjMn1ioLzywljAORSRqKcIIgJ3hcd7RQ1OafkNWdoilq2siMXeLBwTEOway57EXsvaHV1tb22Xe/73f7AYEoH5lf5qa93ExaxLN4dHAzXnbOS8+s0qSPpj7Q076N2VXm0KZnNbiwshmNAdEQS7UZJI80cjncItV2NmpkkE4mg6HmLnejqRPSK4wPlYYmlRYSVdvzq7ECoS2rHBuV2mMhBoiHwg51X5bGXGLGi7qRcjks6LGUIHie1mhvtLZo2qQLZTJPlWysJrccO37DdlJEHKtEUYkjHg4CXDgyK9XratRIQw8CwqgINoM6MwjrhWoX2Ce+7RTVD4gluESMP7jzWnhrqvrmq+KrEy+kozzLACE2wnYY/A3tAah747EmAHUzrYZgh4GGoI12pVuud0mNnnaUUo0Mgl3D9RonqEUqlHNyPceyQJDldp6oEuC9xKOmhLhpq+7udotyF1d8s2bsolk/iJzvaMYemr2D6KyZpy0Xztjzz/eeO/G2tjLK8ennpLqLF0u2FMotRSvf3JxQdX61Pd02F3+xlG2j15PIlR1rVbyv11F02XmtcKSiiBBcnL9fy0ViQIhh9wkshVn3bWkpzJrC0RSOHjxHDwafHTiwFDHw047u9RuHLp0dFWROlmbjmafe1wljXAxYD/PU1DLpWiJdR/kb5V6hKB9F+kj3O9K19GbSO0yMO/ExJzE+hL2cGCY/hXnAE4gLetfzej7m6/+RA6+VWfyl/f5ceC29GNYFJvpIgYkuNPmpzzzg55OLTPz/gof+VO9m7K9FhvfzyV+uIZYSosOVRgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"V8内存结构\"\n        title=\"V8内存结构\"\n        src=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n        srcset=\"/blog/static/51d594675e95270d44f2ba31e0459f30/63868/V8.png 250w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/0b533/V8.png 500w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png 960w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>V8堆内存结构</h3>\n<ul>\n<li>(New Space)新生区</li>\n</ul>\n<p>新分配对象或者存活期较短的对象都会存储到新生区</p>\n<ul>\n<li>(Old Space)老生区</li>\n</ul>\n<p>新生区经过垃圾回收会晋升到老生区</p>\n<ul>\n<li>Old pointer space 保存有指向其他对象的对象</li>\n<li>Old data space 存放只包含原始数据对象(无指向其他对象指针)、字符串、封箱的数字以及未封箱的双精度数字数组</li>\n<li>(Large object space)大对象区</li>\n</ul>\n<p>存储超过超过1MB大小的对象，垃圾回收不会处理大对象区。</p>\n<ul>\n<li>(Code-space)代码区</li>\n</ul>\n<p>存储代码，唯一有运行权限的存储空间</p>\n<ul>\n<li>Cell space, property cell space, and map space</li>\n</ul>\n<p>这些空间保存大小一致的对象</p>\n<h3>V8垃圾回收</h3>\n<p>V8的垃圾回收机制只作用于内存空间的新生区和老生区，由于在新生区和老生区存储数据的类型(大小，存活时间)等不同，垃圾回收在新生区和老生区使用不同的策略实现。</p>\n<h3>新生区垃圾回收</h3>\n<p>新生使用Scavenger算法</p>\n<ul>\n<li>新生区内存一分为二,每部分空间称为semispace. 在运行时只有一个semispace处于使用中,使用状态的semispace称为From空间,空闲状态的semispace称为To空间</li>\n<li>在分配对象的时候会先从From空间分配对象，当From空间无法存储没有足够的空间存储新对象的时候触发垃圾回收</li>\n<li>在进行垃圾回收的时候会检查From空间的存活对象将存活对象复制到To空间,完成复制后From空间和To空间会进行角色互换</li>\n</ul>\n<h4>新生区晋升到老生区</h4>\n<p>在新生区的垃圾回收中满足以下两个条件，可以移动到老生区存储。</p>\n<ul>\n<li>当对象从From空间复制到To空间的时候,如果它经历过一次Scavenge回收会把该对象从From空间复制到老生区</li>\n<li>当对象从From空间复制到To空间的时候如果To空间使用超过25%则这个对象直接复制到老生区</li>\n</ul>\n<h3>老生区垃圾回收</h3>\n<p>老生区由于存活占比较大,使用Scavenge算法并不科学。在老生区使用Mark-Sweep-Compact来实现垃圾回收。</p>\n<ul>\n<li>Mark</li>\n</ul>\n<p>只标记存活的对象，如果循环引用但是无法被标也会被清除(解决循环引用问题)</p>\n<ul>\n<li>垃圾回收器会在内部创建一个根列表(全局对象,本地函数的局部变量和参数,当前嵌套调用链上的其他函数的变量和参数),用于从根节点出发去寻找可以被访问的变量</li>\n<li>垃圾回收器从所有根节点出发遍历其可以访问到的子节点标记为活动节点,不能到达的节点为非活动节点</li>\n<li>Sweep 释放非活动节点空间</li>\n<li>Compact 整理内存空间，将存活对象占用的空间移动到一起，减少内存间隙</li>\n</ul>\n<p>由于垃圾回收会暂停应用的执行，V8的垃圾回收机制又通过增量回收(incremental GC)、并行标记(Concurrent marking)、并行清除整理(Concurrent sweeping/compacting)、(懒整理)Lazy sweeping等手段结合优化回收效率。</p>\n<h2>参考</h2>\n<p><a href=\"https://deepu.tech/memory-management-in-programming/\">Demystifying memory management in modern programming languages</a><br>\n<a href=\"https://deepu.tech/memory-management-in-v8/\">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a><br>\n<a href=\"https://juejin.cn/post/6844904016325902344\">一文搞懂V8引擎的垃圾回收</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"聊聊Node的内存管理","date":"2021-07-01","tags":"Node","path":"/node-memory","top":null,"summary":null},"title":"聊聊Node的内存管理","date":"2021-07-01","tags":"Node","path":"/node-memory","top":null,"summary":null},{"id":"faf195c1-4597-5185-a794-521bff83c69b","html":"<p>Android使用的文件系统提供了以下几种保存应用数据的选项:</p>\n<ul>\n<li>应用专属存储空间 存储仅供应用使用的文件 存储在/data/data/package_name目录</li>\n<li>共享存储 存储应用打算与其他应用共享的文件</li>\n<li>偏好设置 以键值对的形式存储私有原始数据</li>\n<li>数据库 将结构化数据存储到专用数据库中</li>\n</ul>\n<p>下面介绍几种常用的存储方式:</p>\n<ol>\n<li>文件存储</li>\n<li>键值存储(SharedPreferences)</li>\n<li>数据库存储(ROOM)</li>\n</ol>\n<h2>文件存储</h2>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileOutput(java.lang.String,%20int)\">openFileOutput(String name, int mode)</a></td>\n<td>用于文件写入，返回FileOutputStream。mode有MODE_PRIVATE/MODE_APPEND,MODE_APPEND模式会在已有文件的尾部追加内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileInput(java.lang.String)\">openFileInput(String name)</a></td>\n<td>用于文件的读取，返回FileInputStream</td>\n</tr>\n</tbody>\n</table>\n<p>以下通过一个输入框存储和读取输入内容的例子来梳理文件存储的实现方式。</p>\n<h3>存储文件</h3>\n<pre><code>// 布局文件 定义一个居中显示的EditText \n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n    &#x3C;EditText\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:width=\"200dp\"\n        android:id=\"@+id/editText\"\n        android:lines=\"2\"\n    />\n&#x3C;/androidx.constraintlayout.widget.ConstraintLayout>\n// 活动文件\npublic class MainActivity extends AppCompatActivity {\n    private EditText editText;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 读取对应id EditText中的输入\n        editText = (EditText) findViewById(R.id.editText);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        String  inputText = editText.getText().toString();\n        // 在活动destroy时候 获取editText的内容写入文件\n        save(inputText);\n    }\n    public void save(String inputText) {\n        FileOutputStream out = null;\n        BufferedWriter writer = null;\n        try {\n          // 写入data文件 返回FileOutputStream\n          out = openFileOutput(\"data\", Context.MODE_PRIVATE);\n          // 转换成字符输入流\n          writer = new BufferedWriter(new OutputStreamWriter(out));\n          // 写入文件\n          writer.write(inputText);\n        } catch(IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if(writer != null) {\n                  // 关闭写入流 \n                  writer.close();\n                }\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}  \n</code></pre>\n<p>在模拟器中启动程序，在输入框中输入内容test save file然后退出应用。通过Android Studio提供的Device File Explorer查下对应app下的目录文件内容已经正常写入。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/acd79/saveData.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAu0lEQVQY032OSU7DQBBFfRx6gDhBgILBdnf1YHcmR8n9r/KQexGJBSyeVE/6VfWbNBdciMRproQ8V69IxIf08JAnfM6MEhgk0Ivw7T3Orx6ZT2ea17d32naLtRZjDMbaOv/mGW00gxPK8UIuB3zMOEmENCFpYpTI6APNy6ZFKYXW+k/WR0o90fUDy+3O9Xav7ddj5XjivFxre4mZZtNuH0v/sWZ2Hx1SFvZDYLfv+XSJPs7Ew4Uvn+lc5Ae/ZIZnhB7+6gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"保存数据\"\n        title=\"保存数据\"\n        src=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/00d43/saveData.png\"\n        srcset=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/63868/saveData.png 250w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/0b533/saveData.png 500w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/00d43/saveData.png 1000w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/aa440/saveData.png 1500w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/acd79/saveData.png 1543w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>读取文件</h3>\n<p>在存储文件的基础上，在Activiy创建的时候读取存储文件，实现填写恢复功能。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText editText;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        editText = (EditText) findViewById(R.id.editText);\n        // 读取文件内容 在存在内容的情况下直接设置内容\n        String existText = load();\n        editText.setText(existText);\n        if(!TextUtils.isEmpty(existText)) {\n            editText.setText(existText);\n            editText.setSelection(existText.length());\n        }\n    }\n    public String load() {\n        FileInputStream in = null;\n        BufferedReader reader = null;\n        StringBuilder content = new StringBuilder();\n        try {\n            // 获取FileInputStream\n            in = openFileInput(\"data\");\n            // 转换成读取流\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            // 分行读取文件内容写入\n            while((line = reader.readLine()) != null) {\n                content.append(line);\n            }\n        } catch(IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if(reader != null) {\n                try {\n                  reader.close();\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        // 返回读取内容\n        return content.toString();\n    }\n}\n</code></pre>\n<p>再次重启应用，输入框内已经默认填写的内容。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 670px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 170.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAABYlAAAWJQFJUiTwAAACD0lEQVRIx+2Vy2sTURSHL4rNo5ImJn1IrUWFKjYp6kKxgWzFRbsVFzWNBNGosU0ibUwQhEB01YX9s1zYgiQQyCoLIQkkwcwk6WQ+mcmjtdg0DnXVHvg4c8699zdnLvfcEXanGZtjhOmrE9hdFhzjJuzjZhxd7C4TM9dcTF6xMeYy7ef7cyyMOc1ctI/gcNoQbucKdyeD3JsKcGfiOXNmP7dGV7lp9feZszzrPq8e8n48jgALrgDeGyGuTz1APHV+I3g5x4vZHCuXsjwW31kWuyyLHZbEju478a4eL/XznfjJ6A+CM1k+LpZ4OP0G8fr8T6ImmajlFxu2Ou+tEpELEmvnJNYH0Bt/J+q8FTXWBXitG4iQKLLtVfjqbbHta7F1v8kHe4OXQiY0FA1eiTprAhZNm4hP80W+eFqk52XSt2U+e7q4hyftrrO1AI9mNxGVSgXN2opCu902RKvV0jUSiQSiVqvpgYqKUVMURffJZBJRrVY7gm0VVTXG3p6yX2FfUDVWobauV+GZ4KkVPOqsHRQ4EcGD40MLHvfZR71oYIXFYpFsNkuhUCCXy5HP58lkMvolYGgPJUmiVCqh3UKauObL5TKyLNNsNnUajYbuj63wb5vf89qiw/yT4H8/NoM4a71TLWiUPwS1ttIS2s/aKFpbahaPxxGcoKVSKUQ4HCYWixGNRg0TiUT06nw+H78BU6xYVu/6WoMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"保存数据\"\n        title=\"保存数据\"\n        src=\"/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png\"\n        srcset=\"/blog/static/1380de4785f0d92cefda9699479135b6/63868/readData.png 250w,\n/blog/static/1380de4785f0d92cefda9699479135b6/0b533/readData.png 500w,\n/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png 670w\"\n        sizes=\"(max-width: 670px) 100vw, 670px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>键值存储</h2>\n<h3>SharedPreferences</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context#getSharedPreferences(java.lang.String,%20int)\">getSharedPreferences(String name, int mode)</a>)</td>\n<td>获取共享偏好设置文件 mode默认为MODE_PRIVATE</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/app/Activity#getPreferences(int)\">getPreferences()</a></td>\n<td>获取活动的偏好设置文件</td>\n</tr>\n</tbody>\n</table>\n<p>以下通过一个按钮触发存储和读取偏好设置文件来梳理键值存储的实现方式。</p>\n<h4>存储键值</h4>\n<p>通过获取到的SharedPreferences的edit方法获取到SharedPreferences.Editor，主要通过调用SharedPreferences.Editor相关方法完成</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#putInt(java.lang.String,%20int)\">Editor.putInt</a></td>\n<td>指定key写入数字内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#putString(java.lang.String,%20java.lang.String)\">Editor.putString</a></td>\n<td>指定key写入字符内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#apply()\">Editor.apply</a></td>\n<td>立即更改内存中的SharedPreferences对象，异步写入磁盘</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#commit()\">Editor.commit</a></td>\n<td>更改SharedPreferences对象同步写入磁盘</td>\n</tr>\n</tbody>\n</table>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.buttonTest);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n              // 获取SharedPreferences\n              SharedPreferences.Editor editor = getSharedPreferences(\"test\", MODE_PRIVATE).edit();\n              editor.putString(\"toastStr\", \"hello you click me\");\n              // apply完成写入\n              editor.apply();\n            }\n        });\n    } \n}  \n</code></pre>\n<p>通过查看对用应用的shared_prefs目录已经完成了写入\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/6569d/writeSharedPerference.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA20lEQVQY00WNWW6DQBAFOU7osWMFLwHGbD3AMCy2SZT7H6Uim0j5KJX0PupF6kd6H1jmkW4YsGVNXlbYYiMvKopKcd7jwkClLXXbUTqlUOXaKLUqTdtTd54ozT45p2cym5HmGbm9kmcnko8D+/07ZmfIrGW6rQzjTDeMuH4LP+26gab125F2REYEMYI8LQZjDDsjvHYR4jgmSY6EaWH9/mGaF3wINOqYlxthmljudx7rF7U6olfkDxH5x2xxIzFyOHKwLTo+SMqet1OBXCouTeBYevJ2pgor+7ThF5+Wh7cLoqijAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"写入SharedPreferences\"\n        title=\"写入SharedPreferences\"\n        src=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/00d43/writeSharedPerference.png\"\n        srcset=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/63868/writeSharedPerference.png 250w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/0b533/writeSharedPerference.png 500w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/00d43/writeSharedPerference.png 1000w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/6569d/writeSharedPerference.png 1328w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>读取键值</h4>\n<p>在上面的基础上按钮点击立即读取内容完成Toast提示。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.buttonTest);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                SharedPreferences.Editor editor = getSharedPreferences(\"test\", MODE_PRIVATE).edit();\n                editor.putString(\"toastStr\", \"hello you click me\");\n                editor.apply();\n                showSaveSharedPreference();\n            }\n        });\n    }\n    public void showSaveSharedPreference() {\n        // 指定名称获取SharedPreferences\n        SharedPreferences pref = getSharedPreferences(\"test\", MODE_PRIVATE);\n        // 通过getString/getInt读取存储内容\n        String toastStr = pref.getString(\"toastStr\", \"\");\n        Toast.makeText(this, toastStr, Toast.LENGTH_LONG).show();\n    }\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 682px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADd0lEQVRIx+2U7WtbdRTHf05mkramSe69ydIHDekDzeoiU6qIQ/piIG7q3OpbH5CsD5MJ7SKj0zrBgbKC+G5ziiC+UNgLGfrSf0Ba2VpJW1vUYhF8I31McpObm4/87u3N0rR1TRio4IUP93fO75zvOed3H4SmBpEcCDUR1EKoSnALSkCjpfkBDoTCKIq2bV9TQ1aeElB5MBJF+JR6vH43obCCX23Ar3nwa3UWAa0On+qhNaIRbGq01s5eCbUOr99Dg9eNP+BFHNYGONI0xlORUZ5sHuXg/nMc8iRt3Pa92zXCQ+5ztl1G931JHlPOc6RllOPxS7SFnkD0NX5HwvsHCWWRV+9f5IT4iVNigRfEPCfFAifFvGVL+sQCL5bRJ+Z5qe4XzrQscqF7jcPqy4jX3DcZ88MFJc3FcJaxoM47IZ1LUZ2LYZ13m3XGNJvRxiwj+7KM3Hub4XsynBXrDAvoaTiNeGXfLca7YDye5aPHc1yO5xh/OMeHj+Z4P2bbHxzMcflQjreDOqdFloFtpDkr4BFXP+K9o7f47Dm4cizD1Wd0Pj5uc+VpnavHbBzftWd1Pj2h80kF155P88UpOBrrR/z82wz2VQCKNWJYCq+/MYhI/WgLGjkT06Am8rmCpTE4MIiYmbEFTdOkWCzWRKGwKThYIVjL9b/gf1FQBjj33aiM27OgaRQxC2UYRYrm9oJ3HNkR3XVMs1j9yJmVIjfezPP1sMGNpME35w2un8mT+tZOlh3vqUOn+p+/mgyIDMn9WZKuLG8FdMv+qj9n/0ryexXc7DCfKXLzep7JL/P8sMn3n+f5fbpQKvzPnqEVaGzHrPYp3/X38N/96e1l3MqxqxKs7KR8XfW3/HedVu7fsUMZsL6+bpFOpy2c9cbGBtlsdnfBVCpVEnFEZcLS0hITExNMT08jY6ampqz17Owsq6urVrz1RzJNDMO4LTg3N7fj03O6Wltbs+6yM6drR6DyfIeGhhCTk5NWgKzqCEikgEQKl4s6wsvLy6UCKysrlmAikUBEIhHa29tpa2sjGo3S1dVFLBaz1o4vHo/T2dlZ8sn4np4eOjo6LNvxhcNhhBCCclRVJRAIbPHJAm63e4uvt7eXylyPx4Oor6+3gqUhcblcW+zdfDvZPp8PoWkadws5nVAUhVqQyTv5hdwopzyhmj157q2trfwFQwS6D7Ui69MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"读取SharedPreferences\"\n        title=\"读取SharedPreferences\"\n        src=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png\"\n        srcset=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/63868/readSharedPerference.png 250w,\n/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/0b533/readSharedPerference.png 500w,\n/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png 682w\"\n        sizes=\"(max-width: 682px) 100vw, 682px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>数据库存储</h2>\n<p>ROOM是SQLite上的抽象层，通过ROOM可以完成对数据库的存储。<br>\n应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。<br>\n<img src=\"roomStruct.png\" alt=\"ROOM结构\"></p>\n<p>在build.gradle中引入room依赖</p>\n<pre><code>dependencies {\n    def room_version = \"2.3.0\"\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.room:room-runtime:$room_version\"\n    annotationProcessor \"androidx.room:room-compiler:$room_version\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>定义实体</h3>\n<pre><code>// 实体会在数据库中创建对应的表\n@Entity()\npublic class User {\n    // 主键id自增\n    @PrimaryKey(autoGenerate = true)\n    public int id;\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    // 定义列\n    @ColumnInfo()\n    public String name;\n    @ColumnInfo()\n    public int age;\n}\n</code></pre>\n<h3>定义Dao</h3>\n<pre><code>// Dao封装数据查询操作\n@Dao\npublic interface UserDao {\n    @Insert\n    void insertUser(User user);\n\n    @Query(\"SELECT * FROM User\")\n    List&#x3C;User> getAll();\n};\n</code></pre>\n<h3>定义数据库文件</h3>\n<pre><code>// 指定实体 版本\n@Database(entities = { User.class }, version = 2)\npublic abstract class AppDataBase extends RoomDatabase {\n    // 指定Dao\n    public abstract UserDao userDao();\n}\n</code></pre>\n<h3>访问数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建db\n        AppDataBase db = Room.databaseBuilder(getApplicationContext(), AppDataBase.class, \"dbTest\").allowMainThreadQueries().build();\n        // 插入数据\n        db.userDao().insertUser(new User(\"xiaohong\", 19));\n        db.userDao().insertUser(new User(\"dawang\", 19));\n    }\n}  \n</code></pre>\n<p>通过Android Studio的Database Inspector查看已经在数据表中插入了对应的数据<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/f69df/showDataBase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAASUlEQVQI142JQQ6AIAwEeZUmRovtFgvE/39njd7g5GEyO9lk0SnmfO315onCPetvjqnThsZFnKuAiMZsPiAKWgki6rfnX/0a+gEPIUZXbc7pYgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"显示DataBase\"\n        title=\"显示DataBase\"\n        src=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/00d43/showDataBase.png\"\n        srcset=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/63868/showDataBase.png 250w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/0b533/showDataBase.png 500w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/00d43/showDataBase.png 1000w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/aa440/showDataBase.png 1500w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/f69df/showDataBase.png 1762w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"一起学Android-数据存储","date":"2021-06-29","tags":"跨端技术","path":"/android-store","top":null,"summary":null},"title":"一起学Android-数据存储","date":"2021-06-29","tags":"跨端技术","path":"/android-store","top":null,"summary":null},{"id":"085008b9-fde5-52fa-adbd-93bb4f539ede","html":"<p>广播是安卓内的消息通知机制，通过接收广播消息应用能收到系统级的消息通知/其他应用的消息通知。</p>\n<h2>接收广播</h2>\n<h3>声明接收器</h3>\n<p>声明接收器是通过在AndroidManifest.xml中声明广播的方式来实现广播的注册。这种方式在应用级别26以上不再支持。实现方式如下:</p>\n<h3>创建broadcast receiver</h3>\n<pre><code>public class MyBroadCast extends BroadcastReceiver {\n// 创建MyBroadCast 实现onReceive \n// 当接收到广播时 会调用onReceive\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context, \"receive broadcast\", Toast.LENGTH_SHORT).show();\n    }\n}\n</code></pre>\n<h4>在Manifest中定义receiver</h4>\n<pre><code>// 定义receiver\n&#x3C;receiver android:name=\".MyBroadCast\" android:exported=\"true\" android:enabled=\"true\" >\n    &#x3C;intent-filter>\n        &#x3C;action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n    &#x3C;/intent-filter>\n&#x3C;/receiver>\n// 权限声明\n&#x3C;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n</code></pre>\n<h3>上下文注册接收器</h3>\n<h3>创建broadcast receiver</h3>\n<p>同声明接收器创建方式</p>\n<h3>在活动中注册broadcast receiver</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyBroadCast myBroadCast;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建广播接收器\n        myBroadCast = new MyBroadCast();\n        IntentFilter intentFilter = new IntentFilter();\n        // 监听网络变化\n        intentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\");\n        // 注册广播接收器\n        registerReceiver(myBroadCast, intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n      //销毁监听\n      super.onDestroy();\n      unregisterReceiver(myBroadCast);\n    }\n}\n</code></pre>\n<p><img src=\"/blog/fa68f00702cb8da7b73fbba300e8fe32/showBroadCast.gif\" alt=\"接收广播\"></p>\n<h2>发送广播</h2>\n<p>Android提供以下三种方式发送广播:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/content/Context#sendOrderedBroadcast(android.content.Intent,%20java.lang.String)\">sendOrderedBroadcast(Intent, String)</a> 发送顺序广播，接收器顺序执行可以向下传递结果也可以中止广播。具有相同优先级的接收器按随机顺序运行。</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ac9f04546701d76768ab99cd9448a116/614df/orderedBroadCast.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3YFB/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERITH/2gAIAQEAAT8hdI700//aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAgMBAAAAAAAAAAAAAAABABEhUaHh/9oACAEBAAE/EKDDyFl8Qdp//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"顺序广播\"\n        title=\"顺序广播\"\n        src=\"/blog/static/ac9f04546701d76768ab99cd9448a116/614df/orderedBroadCast.jpg\"\n        srcset=\"/blog/static/ac9f04546701d76768ab99cd9448a116/0479a/orderedBroadCast.jpg 250w,\n/blog/static/ac9f04546701d76768ab99cd9448a116/41099/orderedBroadCast.jpg 500w,\n/blog/static/ac9f04546701d76768ab99cd9448a116/614df/orderedBroadCast.jpg 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/content/Context#sendBroadcast(android.content.Intent)\">sendBroadcast(Intent)</a> 发送常规广播，会按照随机顺序向所有广播接收器发送广播，无法从其他接收器中获取传递结果和中止广播。</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 766px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e518738eb7cc766faf4e21990f038705/d8ebd/normalBroadCast.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd6aQgD/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAACAwEAAAAAAAAAAAAAAAAAARAxQXH/2gAIAQEAAT8hHtih9Ef/2gAMAwEAAgADAAAAEHDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAAIBBQAAAAAAAAAAAAAAAQARMRBRYYGR/9oACAEBAAE/EL4fIlMHUTu6BpSksmWf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"普通广播\"\n        title=\"普通广播\"\n        src=\"/blog/static/e518738eb7cc766faf4e21990f038705/d8ebd/normalBroadCast.jpg\"\n        srcset=\"/blog/static/e518738eb7cc766faf4e21990f038705/0479a/normalBroadCast.jpg 250w,\n/blog/static/e518738eb7cc766faf4e21990f038705/41099/normalBroadCast.jpg 500w,\n/blog/static/e518738eb7cc766faf4e21990f038705/d8ebd/normalBroadCast.jpg 766w\"\n        sizes=\"(max-width: 766px) 100vw, 766px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/androidx/localbroadcastmanager/content/LocalBroadcastManager#sendBroadcast(android.content.Intent)\">LocalBroadcastManager.sendBroadcast</a> 本地广播，在无需跨应用广播时使用。</li>\n</ul>\n<p>下面发送本地广播的实现方式:</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyBroadCast myBroadCast;\n    private String actionName = \"com.example.broadcast.MainActivity.SHOW_TOAST\";\n    private LocalBroadcastManager localBroadcastManager;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 获取LocalBroadcastManager 实例\n        localBroadcastManager = LocalBroadcastManager.getInstance(this);\n        Button button = (Button) findViewById(R.id.broadcast);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // 发送广播\n                Intent intent = new Intent(actionName);\n                localBroadcastManager.sendBroadcast(intent);\n            }\n        });\n        myBroadCast = new MyBroadCast();\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(actionName);\n        // 注册接收特定类型的广播\n        localBroadcastManager.registerReceiver(myBroadCast, intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // 销毁广播\n        localBroadcastManager.unregisterReceiver(myBroadCast);\n    }\n}\n</code></pre>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-广播","date":"2021-06-25","tags":"跨端技术","path":"/android-broadcast","top":null,"summary":null},"title":"一起学Android-广播","date":"2021-06-25","tags":"跨端技术","path":"/android-broadcast","top":null,"summary":null},{"id":"3e6ee397-5e08-530d-92ba-1e240f8dd7e2","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1e207791889ca13b322aad1f9814efd4/8ae78/viewGroup.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVQoz4WQvUsDQRDF76+0stBSsLWQYLDwC7Qyoo0oabRIoXVIEbExJjGXBAnhcpjI5cD7MruX283t3s5IchjhRHzFwDzmN/MYDf+QUgoR66/9tZ3jzcOz9fxJrnCdmdEyPQAoAABMFCBi13jLFa4OLm93L4qFm/t/4MzxOI7DiHnB54SGEeNSyiRJpJRprixsvI+fu/1ap1fr9NxggghCxEKIBSLSdYwxIYSU8geGRc2fF1e3jzb2T1e29ipPL4j44TiNRsM0TUopAFBKDcNoNpue52nLhPMkANW6XipX7yqPpfKDadkIihDqeR4hhHOOiLPZjBDi+/50OtVSUn5r/itEUMnST5IkNX9Li6LItm3XdTnnAMA493zfsixCqViQYRiOx2Pf9xljWTgIgna7PRgMCCFKqTAMR6NRq9VyHCeO569yXVfX9eFwSCnNwF/EHvWL4zIuSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"布局\"\n        title=\"布局\"\n        src=\"/blog/static/1e207791889ca13b322aad1f9814efd4/00d43/viewGroup.png\"\n        srcset=\"/blog/static/1e207791889ca13b322aad1f9814efd4/63868/viewGroup.png 250w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/0b533/viewGroup.png 500w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/00d43/viewGroup.png 1000w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/8ae78/viewGroup.png 1096w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n安卓的页面是通过ViewGroup + View的组合来实现。</p>\n<ul>\n<li>ViewGroup是布局容器，它定义内部视图的展示方式。</li>\n<li>View是视图组件，例如Button、TextView等。</li>\n</ul>\n<h2>LinearLayout(线性布局)</h2>\n<p>LinearLayout会将它包含的元素按照水平或者垂直方向线性排布。</p>\n<h3>LinearLayout布局属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout#attr_android:orientation\">android:orientation</a></td>\n<td>horizontal/vertical</td>\n<td>水平/垂直布局</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout#attr_android:gravity\">android:gravity</a></td>\n<td>left、right、top等</td>\n<td>定义内部元素的对齐方式,默认left</td>\n</tr>\n</tbody>\n</table>\n<h3>LinearLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams#attr_android:layout_weight\">android:layout_weight</a></td>\n<td>数字</td>\n<td>布局权重，结合layout_width可以实现均等分布</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams#attr_android:layout_gravity\">android:layout_gravity</a></td>\n<td>left、right、top等</td>\n<td>定义组件在非主轴上的对齐方式，会影响父布局gravity的作用</td>\n</tr>\n</tbody>\n</table>\n<h2>RelativeLayout(相对布局)</h2>\n<p>RelativeLayout是以相对位置显示子视图的视图组，每个视图的位置可以指定为相对于同级元素的位置或者相对于父级的位置。</p>\n<h3>RelativeLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_alignParentTop\">android:layout_alignParentXXX</a></td>\n<td>相对于父元素的位置对齐</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_below\">android:layout_below/above</a></td>\n<td>定位在指定视图的上面或下面</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_toRightOf\">android:layout_toXXXOf</a></td>\n<td>定位到指定视图的左右边缘</td>\n</tr>\n</tbody>\n</table>\n<h2>ConstraintLayout</h2>\n<p>ConstraintLayout与RelativeLayout相似，视图均根据同级视图与父布局之间的关系进行布局。在ConstraintLayout中定义的视图必须至少添加一个水平约束条件和一个垂直约束条件。ConstraintLayout的布局方式能有效的解决嵌套问题，优化页面性能。</p>\n<h3>ConstraintLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_toXXXOf=\"id/parent\"</a></td>\n<td>相对于另一个元素或者容器布局</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_marginXXX</a></td>\n<td>定义外边距</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_bias</a></td>\n<td>通常用与调整视图水平/垂直位置</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_goneMarginXXX</a></td>\n<td>定义当相对视图不可见时候的边距</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_minXXX / maxXXX</a></td>\n<td>定义组件的宽度限制条件</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_percent</a></td>\n<td>百分比布局</td>\n</tr>\n</tbody>\n</table>\n<h2>自定义视图</h2>\n<p>在业务开发中，不同页面的组件能力共享能有效减少业务逻辑的重复。下面以一个按钮为例子了解创建自定义视图的流程。</p>\n<h3>创建组件</h3>\n<p>新建一个类继承LinearLayout并且在构造函数中引用按钮的布局。</p>\n<pre><code>// 类文件\npublic class button extends LinearLayout {\n    public button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // 指定按钮的布局\n        LayoutInflater.from(getContext()).inflate(R.layout.button, this);\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Toast.makeText(getContext(),\"toast\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n}\n// 按钮的布局文件\n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    &#x3C;Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/button1\"\n        android:text=\"button\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>\n<h3>使用组件</h3>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n    // 通过类名使用组件\n    &#x3C;com.example.learnlayout.button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        title=\"clickMe\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学Android-布局","date":"2021-06-25","tags":"跨端技术","path":"/android-layout","top":null,"summary":null},"title":"一起学Android-布局","date":"2021-06-25","tags":"跨端技术","path":"/android-layout","top":null,"summary":null},{"id":"7cfe46cc-afb3-5d0e-8730-6da32b59f96c","html":"<p>Hybrid开发模式中经常需要依赖端能力来实现业务和技术方案，前端作为端能力的调用者通过对端能力的系统学习能更好的辅助业务开发。这个系列主要是自己在学习跨端技术上的一些记录，文章会偏短小，希望尽可能覆盖更多的知识点也希望能帮助到你。</p>\n<h2>Android项目目录介绍</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 566px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2922880ba1fa1f5b907f939c9657ebad/6fe44/androidProject.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 177.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAACU9ioYAAAACXBIWXMAABYlAAAWJQFJUiTwAAADdklEQVRIx5VW2W7jRhDk7+QlWCBIbF08dPAcDsnhJa2sWDYiL/Ka/wcqqJZIc3VZ+9AYikMWq7q6e2T5KxeB7yIJl8i2Bj9aHx8vFbSOkapA9vjMo2GlkYs0cpDGLvJkgf/C33Ewc+xeGryscxz3Hw9r4riYOB4mtovRzIF5PSBvtyjKCmPblfuy34d7N6yx7cmLU3cOd+mj2r5ClzXiVAsA9y7DuxlW9xJXe76ErjfImw1inclHZt5CVvu0frL0bjF0MQQdT23oZoP273eoLEdRNzB1i3r9HWWzlg+ML9LwGVZ3IQ+RkTtHvn5Bu9sjVQoqK3pm3fo44Ok6VBpB/R1us0WcZpKKYQ7vgVrnmyPbheN6+DPU+G37L7SpkJf1IH/e14A/5dB2JU9xZvC6a5GoBHM/xF/jqZTV89SWjw4r4CrgObC98KF0jHb3ilgXWEUJ/ChBmKRwFysBv8bWugZ2rEsPzjJAuz9A5UZkF1UjsQrji1x2q3UtD12hU2q7/wdJVkAXJTJTSRnRtLJdI0q1pOCu5CGgtwqx3h+QFqWUD0HZTcxxV/BDuby+CTgTwEAYEpBgsc4vQM7f+4JhgPXbB+ITOxrzNLXxfHJbHJ85Eg/lsAfUheSPxlB6qFL5zZb0YyVGReqYzy8BN28fiNIM2hxlE5BmEIQDhF20DGMppcck7w/iclcyBCVgtd7AWax+kv2QZJoSpblIZKS5QRArlM1R7sMuDwHpbl5WyMoKKi8EsGo3Uo+jmfsrdXhiqD8ZsmuCRMHUjbC923rXXT6IKT1gVohU5pID1xn09QOSQwGMO4ZlJUCUypWyE53/IsP9AaEwLKV0OG3Y42RJYBb744Cn4UCGujDSguxhzsanyawvmavT5tx+6eWFj837j94UAtIQlgwl8zmCDkeYdT7TxjwG2JveHH5dQbE7ciMApmnFFJqRFgaLIJKh65y65DpDHvjzFSYqxrd3gyjLkQnocUB0LUjA6GSOu7wBKKNp5qDY7LB5OyDNcmHxx9NIpDFvw+jujc4l9yfe6ZDnuOIhzzJhHwdnLXbLyAuXmTtVtsiqVlzluKdU1hon9S2Qu4dUYpqjEWTJvJlS5h5z9jx1+lK5deBfMORfOV02UsgcV3lV9zOQwHK2mPLmYX/BcBkpGZjLIJKuoCmUy67hNe+zU24B/g8mjevg4YzNMAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"安卓项目结构\"\n        title=\"安卓项目结构\"\n        src=\"/blog/static/2922880ba1fa1f5b907f939c9657ebad/6fe44/androidProject.png\"\n        srcset=\"/blog/static/2922880ba1fa1f5b907f939c9657ebad/63868/androidProject.png 250w,\n/blog/static/2922880ba1fa1f5b907f939c9657ebad/0b533/androidProject.png 500w,\n/blog/static/2922880ba1fa1f5b907f939c9657ebad/6fe44/androidProject.png 566w\"\n        sizes=\"(max-width: 566px) 100vw, 566px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>build.gradle 项目模块的构建脚本</li>\n<li>res 项目的资源目录 存放布局(lagout)、图片(drawable)、图标(mipmap)、字符串(values)等</li>\n<li>AndroidManifest.xml 项目的配置文件(组件声明、权限等)</li>\n</ul>\n<h2>活动创建</h2>\n<p>活动是一种可以包含用户用户界面的组件，通过活动可以实现与用户的交互，在Android开发中创建一个活动的过程如下:</p>\n<ul>\n<li>创建活动</li>\n<li>创建布局</li>\n<li>在活动关联布局</li>\n</ul>\n<p>以下的例子以创建一个展示可点击按钮的页面为例子来展开活动相关的知识点。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/821bbbd1c5b9eac1daa223540e7913f0/ab98c/create.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzklEQVQoz1WSS0/bQBSF/WsISUqICRD8iGfGr7HHEzt2MFVbqV1U6qYUELDpor/9qzJAVRaf7lkd3XPu9aL2lsv2kXP7wIV9YGXuWZk7zsw9vv5B1Vp2naUyGpEq2l5xPcaMY8DNGPDx+orrfs2uW9N3azxte1TZIIsGVVoiVRLK0k1Z1PT7kXYYsbsBkRVEyYpE+MSJj0h8yvSMKFyyXC7w/QVevW3JdUWUCMJEEAnp9EZK0lJjh5GiMsQyReYl8/mCydGU4+MZk8mUo8mLnk5f8HTTst0NJGlOJJQjTJQzKKoGawd0Y5GH7YRicXrKfD5jPp87PrzON7zSNOS6JlGZM/mHSImVQrcGY7eovHAJThYLZrPZO5P3hnVD0+3Iyopgc4gtHZtDxEJT72+w/Q2brCaQBSenS2f4xvQ/fcDLm4batmS6dpse+lKFJlEpUlvkl2eS4YmV+cV5c0ugSuJNTBCFhFFEGL8SRVxcXuLlW4PtekzbuS7bYU/T9eRljShLsn1PZVqCRJGkhTuSGT6T2xFZDQ5R9Qjds05KPG0aZ1jUho3K3GscDhQLxZUQ5ENL/lqHzDOG74+Yr3/IP/0m2D3hVz8dZ+aOZfaNv/WJPU3ARy2aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建活动\"\n        title=\"创建活动\"\n        src=\"/blog/static/821bbbd1c5b9eac1daa223540e7913f0/00d43/create.png\"\n        srcset=\"/blog/static/821bbbd1c5b9eac1daa223540e7913f0/63868/create.png 250w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/0b533/create.png 500w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/00d43/create.png 1000w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/aa440/create.png 1500w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/e8950/create.png 2000w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/ab98c/create.png 2356w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/24def/createdetail.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjElEQVQ4y62UaY7bMAyFfaY2E9uSRVHU5tjJLJk0aYECvf8pXiE5zXRJOggwPz6QAIUn8mlpUhDY7OFDhgsRhh3IScWwgH1EzJvKUpdL/RpNOxDYJ6RpRhgnkAQoYvTESzQW3UCVkvfn2t+oM01ZZCVi2j0hbbZV0LCvDO4N8w4Dy1nQWsizw/bbjPGYEfcBYS/g0cNLQPAB3oc6ur1FscL5RVAJgWdGylv4vAG7BMoOnA2OWuFgFF6MhrMWygoG66BvsAgywX9lPP7YYv6e4Q8MfzKQnUAkQUKEDxEuJPAtYnrrUDuCO1rELxHxIOAnAr0oUDLYKY3XocNJt3CG0JG7mH+N0mXTk61+Ta+P2Ox3GPc75OcZnOJl93cJpUP585TjOCOkCeQiNBWvpJ7cPVwEh3IpJUCzu1vkH8H/eXIv1cNfyUegqqCxH9ShrTSauM5fdymx5rd9Kl7X5/n70ys1P0JLRvPQKzx011m1PVZth89tt8R1e/6BAlql0aoB615j3St8iieswgE/AbStDGQ+zRPuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建配置\"\n        title=\"创建配置\"\n        src=\"/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/00d43/createdetail.png\"\n        srcset=\"/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/63868/createdetail.png 250w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/0b533/createdetail.png 500w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/00d43/createdetail.png 1000w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/aa440/createdetail.png 1500w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/24def/createdetail.png 1812w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n上面在AndriodStudio中创建了一个空的活动并且同步创建了布局文件，设置创建的活动为应用的起始活动。<br>\n通过查看代码Android Studio已经自动帮我们完成了布局与活动的关联。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/c6162/activityShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKElEQVQY013Py07CQBiGYS5HOp3SMj1PD8O0ELGcQpDElS5caHSB8f7zGgfE6OLJN6s384+O+4HtZknXtcx7Q//PfG4ws4Y4TkgmHpNA4kuJlD7SF0gZIKXE932E8Bit1gOr9QpjLbPOuv01w3SWum3J05Q0HKNCQRhNXTjyb9w7mirCaHIOttYwbNaYWUuhC3RV/lWXlFVJGOdE4RhbjNGZoq5yCt2QF9r9/jsshM9I3b6Q7T9pjh/Yw4lydyId3lHL17O7N+L5IypJCYKAWCmyLCfNcpIkI1EZahpfzx6l3QG7fWJxeKZePpD1x4v7iyOp2TKNE4KJRAjhTvM8z+2ZcDEXLCuN7Tt2m4F+saAxLbqu0E3ltmoqCq0JI+Ui55BwPO+Hd/UFOznJQaz4eeQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"布局与活动的关联\"\n        title=\"布局与活动的关联\"\n        src=\"/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/00d43/activityShow.png\"\n        srcset=\"/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/63868/activityShow.png 250w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/0b533/activityShow.png 500w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/00d43/activityShow.png 1000w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/aa440/activityShow.png 1500w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/e8950/activityShow.png 2000w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/c6162/activityShow.png 2166w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在AndroidManifest.xml中已经自动完成的活动的声明。</p>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapplication\">\n    &#x3C;application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.MyApplication\">\n        // 活动声明 Android Studio在创建活动时候自动在ManiFest文件中完成声明\n        &#x3C;activity android:name=\".MainActivity\">\n            // 定义为启动活动\n            &#x3C;intent-filter>\n                &#x3C;action android:name=\"android.intent.action.MAIN\" />\n\n                &#x3C;category android:name=\"android.intent.category.LAUNCHER\" />\n            &#x3C;/intent-filter>\n        &#x3C;/activity>\n    &#x3C;/application>\n&#x3C;/manifest>\n</code></pre>\n<h3>实现按钮逻辑</h3>\n<h4>在创建的layout布局文件中定义一个按钮</h4>\n<pre><code>// activity_main.xml\n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    &#x3C;Button\n        // 宽高定义\n        android:layout_width=\"wrap_content\" \n        android:layout_height=\"wrap_content\"\n        // 定义按钮的id 可以在活动中通过id查找到对应的按钮\n        android:id=\"@+id/button_1\"\n        // 按钮显示文字\n        android:text=\"clickMe\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>\n<h4>在活动中实现按钮的点击操作</h4>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        // 定义点击事件\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Toast.makeText(MainActivity.this,\"hello\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n}\n</code></pre>\n<h4>通过模拟器查看效果</h4>\n<p>通过ADV Manager创建模拟器<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/a01dc/createVirtual.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQ4y31TW07cQBD0efKDQkISGz/m/fRjDRIEdk02UnKNSPnLCYjggwNwyYp6WO8uKzYfpemZ7il31bQzNzpIqSCVhlQKQipoYxJ8iFiMI4bFiPHiEs6HTc4eRfbn6Rmrm2ssl0tM0wrTNGEYBsQQEGNA8D7Be785i/9FNq1/pqDtOnRdj34YEEKEcx7O7+CPxIfIhDZQNkC7AOMjSiZQ1AznDX8TlMur5mhNpowGVwq27WFCC2k9pAtQPkJQbD2UC+mMaQuhLWxswZR5kzTj4QqFILMVuGComyqtQnEIySGVgLYKxmowISCNS0pqoVBxgYrLLRLh6bdnnAy/wbo7FOE7zvQKn8wKX+wK52GdUMU16u4Hav8VsR/QjReJkBQR+WwFISM5OQ/Ip3uc3j7i3eU9Tq7/4uPyAe9vHvDh9gGfp0ecTU8or35BGQMbu2QFyebabglTh9I61FxAao2aNSirElVTpZgJBi45hJIJJDl0A+KwSBLpcfIDH7P5VemLwngUNU+gJFN22wXXDiWTaQqIbP9BiortJJMXyQ8fE2kjdcJMNMdzbn9k5pXOiSN16NoeBO1jInjZd2mdO5kVHI4KxVRD9eQrxVnyYYN5aPf3u8vNlvw1GuRlva3PXv0ZBwbvX5xJmdLwXY+GrOICRVwib+9Qb2bxH4ZY+0FYxaAIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建模拟器\"\n        title=\"创建模拟器\"\n        src=\"/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/00d43/createVirtual.png\"\n        srcset=\"/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/63868/createVirtual.png 250w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/0b533/createVirtual.png 500w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/00d43/createVirtual.png 1000w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/aa440/createVirtual.png 1500w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/e8950/createVirtual.png 2000w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/a01dc/createVirtual.png 2006w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在模拟器中启动项目<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/df2f9e33e2c539487abb53bf56f18a06/ab40b/launch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhklEQVQI1x3FWQ6CMABAQe5DLYu0bK2ytAiSEA2oyP3v8Uycnwk6P+CGgab3eO9px4lmnnDPF/P24bF9Gdc7drFcF8PWl+yXmrWzHK3lcB3uNlL3nvW9E+RaYVSE1jllWVGUNUVRoU1DWliS3BClChkLZCxRQqBF+F+JkEyERCdBmkiSc8YPbOhEx60iQJUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建模拟器\"\n        title=\"创建模拟器\"\n        src=\"/blog/static/df2f9e33e2c539487abb53bf56f18a06/00d43/launch.png\"\n        srcset=\"/blog/static/df2f9e33e2c539487abb53bf56f18a06/63868/launch.png 250w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/0b533/launch.png 500w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/00d43/launch.png 1000w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/aa440/launch.png 1500w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/ab40b/launch.png 1736w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在模拟器中点击按钮展示了Toast<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a8d23e69732946a44dc47941ae242238/c5bb3/showContent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 188.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAmCAYAAADEO7urAAAACXBIWXMAABYlAAAWJQFJUiTwAAADiklEQVRIx+WWXWgjVRTHry5UKWupTVptaTKZfE0+JpNMktpKV4UVLWVd1rYsuqtik3Z3FSzoqqB1fdg+CT5scXXFF/vW7y7ig68iu/skFfWlIvWl9aGvhdBkmo+fzMSEpKS2Ql0KXvjPuefMub97zzAz94rJyUmCwSDJZBJdT6DrOrGYjqZF0TSNSCSCqqqEw2FCoZCVGwgELCmKgt/vx+Px4PV6mfl6BpGIJ4nHe0iY0svQWDSO4g/g9ZjJPtxuL27Zgyx7cEkyXq+fgBLC51Osvs/nR3K6UPwKItmjE0uoxOJhtFiIiBYgEg2i6aZVCGs+QhEvQdVDIOwmEHKjBF14FScevwPZ041D6kKSu3DJEuIJ9Qyn1NfoVy/ydOwiz8RfoV+9QNx1Ht11nphzhKhjBM0xjNY9RKR7CLXrRcKd5wg+dhbNcY4+dZiEZxi/rCGef/wzXm/9g1fbfuWyc423lN+5LK3xnPiRF8TqvjorfuKMWGXkoZ95W/uNdyN/knS+hHjZtsR1O0zadvioLcc1e45rthxTToMPThq880COqydyXH2wgU7krPsTIsN7AvrsKcSFjkVu9sCn+g63ThtMP2kwJeX4JJTj/YezXBE7vCmyvLGPyvcyTAjoeTSFmDi1yBf9cOOpDNP9O9w8neX7GwY/fG5w55bBva92uXuA7nyZZXUGhp5NIUZOLvDxI3Bd2mHKWS65WCjx71rBul66kkZMf7jM2jewOm+wOpfnl9t5drMlC1rIlygeQrtGGZgaTSO+/e523SyVViqVqvYgFQrlselUCrG8tGI55iyVGWthB7VaYGp0FLGyUgaawcMA7i/QKnl5+ciA1jNcWlo6vkCr5MXFxeMLtEpeWFg4WuD8/Pz/CZhOI+bm5o4MOHbUwPR/ApydnT2+QOtLuS8rrPzaG20Be//khwbutwXsjdW9NmNj+5dc6ReLRatfsf+0wjpgPp9vuKNtb2+zvr7OxsYG2Wy24WOoA9a+h41aJpNhc3OTra0tDMNovM3/PXZ8L9CczVxpowFmybXN9CsrrgAvjY8jZNltHWndbrd1rO3t7a36ppUkib6+PqLRKC6Xy4qZ1jwmDw4OVmNmvluWEU1NTQghqjLP0bW+qXA4hM1mq4s1NzczMDBQF2tvb0d0dnZit9stx7QtLS1Wv+y309HRYcVaW1urOaZta2uzoJVcm92G5HTyF7kXnrJ/9jLzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"展示效果\"\n        title=\"展示效果\"\n        src=\"/blog/static/a8d23e69732946a44dc47941ae242238/c5bb3/showContent.png\"\n        srcset=\"/blog/static/a8d23e69732946a44dc47941ae242238/63868/showContent.png 250w,\n/blog/static/a8d23e69732946a44dc47941ae242238/0b533/showContent.png 500w,\n/blog/static/a8d23e69732946a44dc47941ae242238/c5bb3/showContent.png 680w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>活动之间交互</h2>\n<p>在应用中不可避免的需要不同的活动间进行跳转和数据交互，可以通过Intent来实现活动之间的跳转。</p>\n<h3>使用显示Intent跳转</h3>\n<p>通过Android Studio创建testIntent活动，在testIntent的layout文件定义文字方便识别跳转.</p>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    &#x3C;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"测试显示intent\"\n    />\n&#x3C;/LinearLayout>  \n</code></pre>\n<p>在MainActivity中使用intent实现跳转</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // 显示的创建intent 指定当前的context MainAcxtivity  目标活动 testIntent\n                Intent intent = new Intent(MainActivity.this, testIntent.class);\n                // 启动活动\n                startActivity(intent);\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/3a02576763653fa6a4f4d24e087e0108/intentJump.gif\" alt=\"显示Intent跳转 \"></p>\n<h3>使用隐式Intent跳转</h3>\n<p>区别于显示的Intent跳转，隐式Intent通过定义action和category信息让系统查到对应的活动实现跳转。<br>\n创建testIntentImplicit，在ManiFest文件中声明action和category</p>\n<pre><code>&#x3C;activity android:name=\".Implicit\">\n    &#x3C;intent-filter>\n        &#x3C;action android:name=\"com.example.myapplication.TEST_INTENT\" />\n        // 必须添加DEFAULT category 否则会导致通过startActivity和startActivityForResult无法识别正确的activity\n        &#x3C;category android:name=\"android.intent.category.DEFAULT\" />\n        &#x3C;category android:name=\"com.example.myapplication.TEST_INTENT\" />\n    &#x3C;/intent-filter>\n&#x3C;/activity>\n</code></pre>\n<p>在活动中创建隐式Intent</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(\"com.example.myapplication.TEST_INTENT\");\n                intent.addCategory(\"com.example.myapplication.TEST_INTENT\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/edd3089ae16056b202f01de5ee7157ae/implictJump.gif\" alt=\"隐式Intent跳转 \"></p>\n<h3>传递数据给下一个活动</h3>\n<p>可以在intent中通过putExtra中传递数据。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(\"com.example.myapplication.TEST_INTENT\");\n                intent.addCategory(\"com.example.myapplication.TEST_INTENT\");\n                // 在intent中增加数据\n                intent.putExtra(\"extra\", \"传递数据\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/8d5dedf2170474f96abae68c68fb9d50/deliverData.gif\" alt=\"传递数据\"></p>\n<h3>传递数据给之前的活动</h3>\n<p>通过startActivityForResult和onActivityResult可以实现传递数据到之前的活动。</p>\n<pre><code>protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // 在onActivityResult中判断requestCode是哪个activity返回的结果\n    switch (requestCode) {\n        case 1:\n            if(requestCode == RESULT_OK) {\n                String responseData = data.getStringExtra(\"extra\");\n                Toast.makeText(MainActivity.this, responseData, Toast.LENGTH_LONG).show();\n            }\n            break;\n        default:\n    }\n}\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Button button = (Button) findViewById(R.id.button1);\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(\"com.example.myapplication.TEST_INTENT\");\n            intent.addCategory(\"com.example.myapplication.TEST_INTENT\");\n            // 通过intent和requestCode打开活动\n            startActivityForResult(intent, 1);\n        }\n    });\n}\n</code></pre>\n<p>在跳转的活动中通过setResult返回数据给之前的活动</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_implicit);\n    Button button = (Button) findViewById(R.id.buttonBack);\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent();\n            intent.putExtra(\"extra\", \"数据返回\");\n            setResult(RESULT_OK, intent);\n            finish();\n        }\n    });\n}\n</code></pre>\n<p><img src=\"/blog/af74a5d1e5ef0e39f1fdee8fd10ca82d/resultBack.gif\" alt=\"传递数据\"></p>\n<h2>活动启动模式</h2>\n<p>安卓使用栈来管理活动的层叠关系，系统总是将位于栈顶的活动展示给用户。在声明活动时，可以定义活动的启动模式从而影响活动在栈中的表现。<br>\n通过在声明activity中android:launchMode定义活动不同的启动模式。</p>\n<h3>standard</h3>\n<p>standard模式是默认模式，在standard模式下创建新活动都会在栈顶新增一个活动入栈。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/99d8f33acd23780a98ec21f4c4b832c9/5a3c9/standard-mode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0UlEQVQY01WRiQqEQAxD/f+PFO9b1xsPNMsrdGGFSjJNM20nuO9by7Jo2zZN06R5nvX5fLTvu8ZxNE6e3DAMxjlHA+YcTlzXpWBdV9V1rbZt1fe9mqZRVVVWwHmapsqyTEVRqCxLy4Odo3HOBQG/53nknRJw7ySOY0VRZIVozvM0U773fU1zHIdx8J8hGHGSJL8uMSTohvCcG/p6fobsIM9zE4EpYkw4O/OR0bgh43VdZ5w1/RkyYhiGJiTBaIzITumY7shhgCkczEXU0aE/HvgLUSrFo8BPpOEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"standard模式\"\n        title=\"standard模式\"\n        src=\"/blog/static/99d8f33acd23780a98ec21f4c4b832c9/00d43/standard-mode.png\"\n        srcset=\"/blog/static/99d8f33acd23780a98ec21f4c4b832c9/63868/standard-mode.png 250w,\n/blog/static/99d8f33acd23780a98ec21f4c4b832c9/0b533/standard-mode.png 500w,\n/blog/static/99d8f33acd23780a98ec21f4c4b832c9/00d43/standard-mode.png 1000w,\n/blog/static/99d8f33acd23780a98ec21f4c4b832c9/5a3c9/standard-mode.png 1169w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>singleTop</h3>\n<p>singleTop当栈顶是要打开的活动时，不会创建新的活动实例入栈。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 807px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/80638bb8d399426618fcc157771016a9/d2a60/singleTop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGklEQVQoz52R2a6EQAhE+///UOO+7zqORkcnYXJI8OE+3k5IA10UBe0+n49g13X9y6zWeJw9pGkqr9dL5nmWIAhkGAbNVVWl+bIsJYoiadtW89xhGErf95JlmWK+36+49/utyWma9B7HUTtRAClG7jiOJ8bA0rwoCrU8z2VdV3GAz/MUzn3fSkwxYDvLsqihwg7FqMYgS5JEGzkI/hKisK5rBXRdp2MzCT5EEOMzBWSsAEJqnRFw2IHFdG6a5lGwbdszHrvjtnfIIGVax2jsg0dU4fNJLNqAvEGIUjCQQYRK2x84VQghged54vu+FjB6HMcKpJAcIxNDQCN8I8fg0B2yP1NJYt93VYhPAar4EHIosI8wLOrBcBP/AMUep4pPDBSjAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"singleTop模式\"\n        title=\"singleTop模式\"\n        src=\"/blog/static/80638bb8d399426618fcc157771016a9/d2a60/singleTop.png\"\n        srcset=\"/blog/static/80638bb8d399426618fcc157771016a9/63868/singleTop.png 250w,\n/blog/static/80638bb8d399426618fcc157771016a9/0b533/singleTop.png 500w,\n/blog/static/80638bb8d399426618fcc157771016a9/d2a60/singleTop.png 807w\"\n        sizes=\"(max-width: 807px) 100vw, 807px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>singleTask</h3>\n<p>singleTask会复用栈内的实例，如果栈内已有实例会把实例之前的活动全部出栈。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 659px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/811c885983b4a1125c7429765cb91547/6db71/singletask.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQ4y52T144CMQxF+f9fQ7zxgOh96HXoxehc6WaDtC+7ljzJOPFxSVK53+9xu93i8XjE8/lM8/f7rdH2fM4ao9UMxgqT1+sV+/0+1uu1nMqyjMlkErvdTvbVaqXxdDppnE6nGrfbrdbO53OCCsjG8Xgc7XY7bep0OjGfz2XvdrsxGo1kXy6XWsOOjTl2EhEQGNkcj0eBF4tFbDabQHAmwOFwULaz2Uzlsg8IdvwIzBxoBQNOFqK4dAC5AGHdZVoIAENA+gXAwkb+aTbZ4owCp0ycWAdicVIJ6BKR6/X6BaQcDqHf78dgMJCd9TxDGF9AHC+XixR4DhwOhzqUZrOZgOyhZ2QJmP6iAmLo9XrKpCgKOXEYCHNKJUMUOEBaQPlkRXBOm2skIFEcHXCr1RLcQILgwE0wkIBkTRvwYZ6AnBobcHAmtMG9AgqIkUA4+aoRCCXb9FL44MxrQfOn5Kdm9T+lEsQXn2CA00v5TQ3NlRvgkmu1WlSrVWm9Xo9Go/GT4V/UcN8C+keg9PT+A8xbQpvyQB8SmXvzI+bD0gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"singleTask模式\"\n        title=\"singleTask模式\"\n        src=\"/blog/static/811c885983b4a1125c7429765cb91547/6db71/singletask.png\"\n        srcset=\"/blog/static/811c885983b4a1125c7429765cb91547/63868/singletask.png 250w,\n/blog/static/811c885983b4a1125c7429765cb91547/0b533/singletask.png 500w,\n/blog/static/811c885983b4a1125c7429765cb91547/6db71/singletask.png 659w\"\n        sizes=\"(max-width: 659px) 100vw, 659px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>singleInstance</h3>\n<p>singleInstance会创建一个新的返回栈来管理活动，主要用于不同应用间活动的共享。在下面的例子中从活动C返回时会先返回到当前栈的活动A在返回到活动B<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 990px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/812d44b27c3de2c4bfb00faf3973642c/7a3d6/singleinstance.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQoz02SVwrEMAxEff8T5iOQ3nvv0fIEXmIQstpoLNmc5ynHcQh633fZtk3WdVX7ui71ockhZuMIPuJoK4bCpmmkqioZx1HatpU4jqUsSwmCQBzHkaIopO97zeu6TjU+QPM8l2VZ5L5vbWxIQIZh0CKSrJ1lmRbQBBBbSIzm5BH7Yijg+77CsYmAcrjj4/ASbHRd1wo8TZMyhRkCuIEVSc/z/AHnedYm2DBM01TZ4ieXUYRhKEmSKHOAYQ85gwMBiDkSsDNDA4SmGECYABZFkTaihgYIOAb6ruuK53lazHN931eb5QDEHbEMuX9B0fgAN6wdyjDkS7B6O2x8dvP4iNtZ8QtgxEsggrCUH8gQYLYhbGLGAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"singleInstance模式\"\n        title=\"singleInstance模式\"\n        src=\"/blog/static/812d44b27c3de2c4bfb00faf3973642c/7a3d6/singleinstance.png\"\n        srcset=\"/blog/static/812d44b27c3de2c4bfb00faf3973642c/63868/singleinstance.png 250w,\n/blog/static/812d44b27c3de2c4bfb00faf3973642c/0b533/singleinstance.png 500w,\n/blog/static/812d44b27c3de2c4bfb00faf3973642c/7a3d6/singleinstance.png 990w\"\n        sizes=\"(max-width: 990px) 100vw, 990px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>生命状态&#x26;周期</h2>\n<h3>活动的状态</h3>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>运行状态</td>\n<td>活动处于栈顶</td>\n</tr>\n<tr>\n<td>暂停状态</td>\n<td>活动不处于栈顶，仍然可见。系统一般不会回收</td>\n</tr>\n<tr>\n<td>停止状态</td>\n<td>不处于栈顶，不可见 可能会被系统回收</td>\n</tr>\n<tr>\n<td>销毁状态</td>\n<td>从活动栈中移除</td>\n</tr>\n</tbody>\n</table>\n<h3>活动的生命周期</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onCreate()</td>\n<td>活动第一次被创建时调用</td>\n</tr>\n<tr>\n<td>onStart()</td>\n<td>活动由不可见变为可见的时候调用</td>\n</tr>\n<tr>\n<td>onResume()</td>\n<td>活动处于栈顶运行状态</td>\n</tr>\n<tr>\n<td>onPause()</td>\n<td>系统准备去启动或者恢复另一个活动时调用,通常在这个方法中进行资源的释放和数据保存</td>\n</tr>\n<tr>\n<td>onStop()</td>\n<td>活动完全不可见的时候调用</td>\n</tr>\n<tr>\n<td>onDestroy()</td>\n<td>活动被销毁之前调用</td>\n</tr>\n<tr>\n<td>onRestart()</td>\n<td>活动由停止状态变为运行状态之前调用</td>\n</tr>\n</tbody>\n</table>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/267f6/life-cycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGPklEQVRIx5VVD2xV5RU/7/W99pWREJZsKg6r0+CAEZWMJsahW1xRXJ1xkRSKS4VCMVtmgkAEpiUbmwwyaGnLWq0+KFSrUKSAtAhY+gdbCu//6yu8///un3f/fvfed9+9bSn9lvt0nZotsl/y5XxfvnN+53znnJwP4FvocCjQ2sdDQ3d61qfByd2nfNK7J93CoXPBiZbjbnVxV0CHrlHdBHeKunMp83tD41Dfwyxpd07gPR878Z/eu4ztwzI+cm3izQ+9GI5c0wvg/8Fdy6oBdmHT1g7uhW3H4pu2tEU2bj8hVFU1xX/4x7YMvNZGg8vlAo7jQBCEmWWcvw7jGZbfPF9uxRjD4EDfY5rCX44F/b0B7/XPsyIzpCriOjw9ATQRNy9atBhkSTIPDPSbmxoPmQcHh82appnBZrPl2WbPnl1os9lspaWlVuN85szZ+RmW3+LxBbYPDV/bTlLMDlnJln4xNAyGw0ceeRQkCcHw1WE4dvQYjIw4IJfLAfyo5H547GelBocFAMzGxu12gyiKD0qS1H3zxo0LLrf7vCiKl8Ph8DqDbPny5dY1ayqLBUE4Go/HXF6Ptz8eT3gQQs356Ox2e96rsQ4cbM7LRCJ5jyxLf74xFnh7ZOTa3xBCe6LR6NPGXXl5eUFV1StWnudfj0Yj9b29vY2RSKwRIfR7w7iQ59grDMOoJEFMCjz/QSSehAxDP8SymVNOl/OM2+08TZDpnkgk9DuDcNWqVUXGa4wieDzufABjYzdBlmWAi0sBBEl5I5pMvR+OxdtYRV9PjHpBZNT5Ije+L+CP1Ps8wTqakBvIlPiMYVz75u4Ck8lU1NHRYVGySsGKFSuKXS6PRVVVM+g9jUv5Mweb6E8O7Ge66g5me5p2446m7226ZC0aoCt2fhp4qf4T14sHBjOV+85FVi788GpZPiIAKPyqMwwUzfSKfuKtnWL7DnxlzwbsbfgD1k7U4qnmnQ/+ZfDn9/VGqvHh87/F9R/9GnePvoK7x17eMpDaCPREV+FzK1cWt7S0WL6iKSwpKflyd3Pfmrtu26vXhveu2kDWVdZoreufNyIg6FTJoNfeNOD959F+T/PhK/7Wo75Qb5kj2AnBsehMEf1+P8ydO/c/EYqBIdD77ICVq4DZPpB6mkBVZBjX9a1MRsAZStTINKfTlIAVWe3BGJsEnl8bi0U3MgyzFmM8BwAKHA7Hl4RI4JdNqvIvODL5tMIzv8xJ4q8QQvfrun6vrIjrb4YCmzw+5yaWp2uyWXnpuD4xP0PT0+l0GhMEgTHGPzUizWSYfA+DLMkcSZA4mYjjRCKBOY7HkizbL1y4+GNRFMOjo4FRh8PpY1k2SVHUa4ax1+tZ4vP7FyOEHlJVtXjBgodt1687CqaNYmGMn8wqyrOhUOi5cDj87NTU7XKM8UJBECwSkuopij6fSqVOi6J4UtNyC0VRAJ7ngOU4kBCCUCiUz2UgMAYiQnlCCAWDM0mOxeJ5eenSJZAkqZ0giIl0Oi1QFB3BGH/fMMIYW6LhMGhabhnDMHaCIN4hSfKwpukLjJFjNhJdXl5uKysrK25vb7fOmzfP7HK5fiBJUqXf76txOJw1oiCsS6ZSSwxndXV1hYZEovgSSZG3EomESBDk+K2p2098fXwZSS2sqKiwGcoXLl4sURTlRigUHHM6XX4kimmKovLDYfPmzbMAwFpUZLOWPPCAdfasIst/HayGMsuyhlycy+U6GYbpZRi2j+O4Poqie7PZ7OcY49U8zxs6ptWr10Brayu0NB+aSdk3EAkHzeO6Brms8iRJUUQkHHGGQmF3KpXyxKLxkVQqzUiSXCsrCiSSScu2bdvg+PHj0NnZCRKSYeLW1DcJA+E0SEg0KYoMDMPerUhoe8Dv2+Vxu3aJAr8LicITmqqCjJDJG/B891+iaTqwHG9Ckgwcx/+ER/IXbl9gcMTl60/RrBPJSrWq6cZ0MmfV7HcTTk9PQ6zxVfj3+J7sP/IUebb55fiphko89MELkfa/ziGO1QJ/cl9e944gfVRrVj5+C6jDWxdN9+zHgdYdePjg6zjbtRdPnn77DfzZfpg8u/fOv1G6aR1kWmog0bB+Dmqpbov/o7I7+PeK00xjVY/cWvO4bn8VpHc2mP8Xwb8ALx5OZ/sHMjIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"生命周期\"\n        title=\"生命周期\"\n        src=\"/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/267f6/life-cycle.png\"\n        srcset=\"/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/63868/life-cycle.png 250w,\n/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/0b533/life-cycle.png 500w,\n/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/267f6/life-cycle.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"一起学Android-Activity","date":"2021-06-17","tags":"跨端技术","path":"/android-activity","top":null,"summary":null},"title":"一起学Android-Activity","date":"2021-06-17","tags":"跨端技术","path":"/android-activity","top":null,"summary":null},{"id":"ca85fd25-3188-5457-a2f7-f5f728513933","html":"<p>在<a href=\"https://https://icantunderstand.cn/webpack-tapable\">深入浅出webpack-Tapable</a>源码解析中,我们了解到webpack是基于Tapable来实现打包的任务调度,本文基于webpack的源码梳理打包的实现流程.在源码分析中会主要关注以下几点:</p>\n<ol>\n<li>webpack启动过程(compiler compilation的生成过程)</li>\n<li>入口文件的解析过程</li>\n<li>loader调用过程</li>\n<li>plugin的调用过程(webpack实现任务调度拆分的方式)</li>\n<li>文件的输出过程</li>\n</ol>\n<h2>前置知识</h2>\n<h3>Tapable</h3>\n<p>webpack基于tapable来实现任务调度和代码逻辑的拆分.<a href=\"https://https://icantunderstand.cn/webpack-tapable\">深入浅出webpack-Tapable</a></p>\n<h3>webpack基础</h3>\n<p>webpack是前端的打包工具,通过loader实现了文件转化能力、plugin实现了打包阶段的介入能力(编译能力增强,任务拆分).<br>\ncompiler在webpack启动编译后生成的对象,它负责把控整个webpack的打包构建<br>\ncompilation对象是每一次构建的上下文对象包含当次构建的所有信息.</p>\n<h2>源码解读</h2>\n<p>以下源码解读基于webpack当前master代码.我们在webpack源码下创建如下的目录结构:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 443px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6f91bb1c3d81745f56fc1e823c17e799/a120c/debugCategory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3ElEQVQ4y6WT626bQBBGeZMmwF5YWHNZLsvFxnaiREr/pO//MKdakjRK1TqO8uNoAA2HD2aI8rxgXU88P//i6eknznXEcYoQ6iKhz7l2q2VZU1U187wn0jpDqYz9fuX+/gFry02YppIkEVcRem9vE5qmfRcG+/l8R0j81vQVgrDr+hehlJq6dizLgTy33NzEHxL+ffO/rgVh2/ZEIZ3WZjvxfmIYPMZ8PeUHYWBdj0zTwuFwpO/994QhYZi0SNX2um9D+ZYwX3vy44DMzZ90V085VCnpvCcytsQUJbvFY08T2liUNCiVb8c6vw5lLX4Je5gZtDKYvqG4G9GuwszthjCGVChSqS8iQs0y+nEisraitI7Ke+rznmoeqdeZel2wVUORlxRFdZm8Ii9rlsORyLmBvpsZz0fa5UBTDS+UPa4Zce46mm7idPdIFJZaa0njErJ1oLj3yF1OfJu+fvT0EwRJnBIrSTf6IDTYIqX0FnPyFKdhw4zu+rVJJIlW9NNIJJVhZ27Y9Qaz78m6ilSql6f+SEji1wW/tOhBKF8TKiHR7YDZe4qHEXPoUG5HNjZkvkGY7F36X6EgyTT9PBEpqVC7lrwbKOeOch6wg0N31SYVWfb5b5hIYiHohoHfNU783Lp7nlAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"debugCategory\"\n        title=\"debugCategory\"\n        src=\"/blog/static/6f91bb1c3d81745f56fc1e823c17e799/a120c/debugCategory.png\"\n        srcset=\"/blog/static/6f91bb1c3d81745f56fc1e823c17e799/63868/debugCategory.png 250w,\n/blog/static/6f91bb1c3d81745f56fc1e823c17e799/a120c/debugCategory.png 443w\"\n        sizes=\"(max-width: 443px) 100vw, 443px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>// 启动文件 通过compiler.run开启编译\nconst webpack = require('../lib/index.js')\nconst config = require('./webpack.config')\nconst compiler = webpack(config)\ncompiler.run((err, stats) => {\n  console.log(stats)\n})\n\n// webpack.config.js 配置文件\n// 添加入口文件 配置了解析的loader\nconst path = require('path')\nmodule.exports = {\n  context: __dirname,\n  mode: 'development',\n  // 入口文件\n  entry: './src/index.js',\n  devtool: 'source-map',\n  output: {\n    path: path.join(__dirname, './dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['babel-loader'],\n        exclude: /node_modules/,\n      }\n    ]\n  }\n}\n\n// 入口文件\nimport is from 'object.is'\nconsole.log(is(1,1))  \n</code></pre>\n<p>在上面的代码中指定了配置文件和编译的目标文件,通过node --inspect-brk start.js结合chrome的inspect就可以对webpack的源码进行调试了.</p>\n<h3>webpack的启动过程</h3>\n<p>启动文件执行webpack(config)是通过配置生成Compiler的过程,下面梳理源码创建Compiler的过程.\n启动文件使用的webpack实际是引用的<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/index.js#L94\">lib/webpack.js</a><br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/webpack.js#L97\">webpack.js构造函数</a>中会根据入参来创建compiler.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 117.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAADNElEQVQ4y4WU63abOBSF/RhNDEISEheBEMbYxsRx0mk782Pe/3m+WYg003TszI+9jhBoa2/OZaOKivr8jB1mjN/RHY8U/Yj2e1TdkRhHapoV9i3GPffL+u2dbdjILKPsAuWuZz+3nF4D7dhQ9Y56sAiRkCZb0uRn3JKmCeIOIqHKLcaV9PsSP1S4wSHzHCEyUiEQMkNIidQ5UmuEEOv+W0x/ed5kmSTPFcPUcXh94fT9ifDHGf3tQn49R+jrhNkHqn5PHXZIKUnTNBL8jo2UGWq5ue6oj88UYY/Qhkyp9SO5qlwsJ4+PJNvtO9kt0o3MJCrPsbs94fVv6vMT5vKCHnqypiLrGlRokb5BVpYsW4jETXXvCrXOKdue6jQT5gvjPFGFnqLrKZ0j0wqxQMoPh28rlBKtNMYqzLijOh5o5kB9mbDTGdNUMXvRasx0QrLEGyqXCyLhAuMc7flE4R3h1DKeW7wv6XpH40rKMGBdi3EtVbdDScn28eH9ggXvCpfSceOZ3fU77WEmnC6cLzPz11fmb9/opgv+6Svd/MLw+hf9fKVsu0iuixJjTMS7Qq01IewZjlfK/oCuHTbssN7jmgrbeHRRIXMbVeZljW07ijas698JldJIlZD7GtXUmLFGdQWpTEl+/3/btXRiCb2V0Q3LguYwMf74k/YwMr0+cf1xZX4+4UOLGydqHz50yC38q1BKrO9pT8/Uw4nS9/Gf1sMh2i27XbRqraUoirtd8tZ6WfTf1R3lMnmGkcIHisZThSGiOc7Uw5HKNW9t97GHf0UcDlVVojOFSFJUbtDWxu7RZo15Ucb1krx1qqR3sZG2pg4TfpjYTROuPyCsJ8mbFaZZZ2Kcdy2i8J9ikylNWTb0oacbPbbKUUWO8QWmLVCVReQ5SaZIpf5fRMtSKUwbKLwnn67Y/QHTNdjQUjeW3eBom3pNxrvlOwM2k5KyrGiLFls0yH5C1R4hJKnIyIRAqbU90zuD9UNSrDVYk/Pl4QvbpWgfvvD48LAWappGVT8hRLpm+LOyWVoqsxXW5hijyU1OVS0ZVf85uE6Y+2SRUBQO2ezwncO5grK0jKOPMUk+P3yL8B8xf4859cdqlgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callCreateCompiler\"\n        title=\"callCreateCompiler\"\n        src=\"/blog/static/61143bfacd863a4828a15932971a27f6/9f21b/callCreateCompiler.png\"\n        srcset=\"/blog/static/61143bfacd863a4828a15932971a27f6/63868/callCreateCompiler.png 250w,\n/blog/static/61143bfacd863a4828a15932971a27f6/0b533/callCreateCompiler.png 500w,\n/blog/static/61143bfacd863a4828a15932971a27f6/9f21b/callCreateCompiler.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/webpack.js#L58\">createCompiler</a>中主要做了:</p>\n<ol>\n<li>入参处理</li>\n<li>创建Compiler</li>\n<li>订阅Plugin</li>\n<li>根据入参加载不同的能力和应用webpack内置的插件体系(WebpackOptionsApply)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 597px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/800fff7bc13591c48e262e16c05a1387/17602/createCompiler.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADYElEQVQ4y4WV3XKjOBSE8xpjI5AACYRB5seAwdgm49kke7H7/m/zbYGTGWdmdveiC1WpqtXndJ/DUxj7+HGCrjN2kyPaZUil0DpCG02cpJg0IUkNiVYYrYgiRaQNUWIJtUEphRACIXyevO0W19R004l+njnMzxzHlrfXkb//unD72vH2cuTb64X2dmP4eqWudtiyZteO2KpFJwlCePi+z5MMPUxqqMYd1eQoupysSIjiGJ1qtNVEiUYlGZ7JkcaiYkMQBHjbDYsgz7uTLSqffLFFZiWyPBIeTpjTDbNvCJMcWXXIviN0BaE7IPMakzuypse6PTIIVqIPsrtCXxC6FnW6EZ0n7DBgpxO6awinC/Z0QUcx280XhOfdFW3uypYy7xAPCn2fWCfs+4Hy+kw23VF9+5P9ZcbULeFhInQNtjqQtQO27laVxXDBjTMqitfHVoWB8tDGcDxXHK8lYdkR5A06sQSLc4sSz7vjXckdAX7wjseSVRRgIo2tCqKxJHeWurRkVXXvq2tIm56sO2HzYo2U74v3mPzA95JVGBKFEWXqsGWHrkd0f0FPr2tv0+5MPsy045nuPJOXNXEc4X1S+2iKlARSEkqFqY6o/itF02CHGT3csGWDtRmun3BNizHme4gfCT+wEiqpCKOQfTWxKzt2mSFJNEG2J0hzZGzw4gQ/jNfHH0v8hXAJ6EIahSGxawmLA3VTsC9z1L5FFg0mTfG97S8R+a3C5SKOY+LF+ndHva3HduMhNts7PHF39ad+/ZYwkGIdMz8KEErgBQI/8gniYIU0S48FYvNlHbX/VbjkcLdLGK6OcS45HHO6qeBwyjnOe7prQVo7RFYR2WIdt//sobfZkh063PxGebow3P6gu8w0pzPH2wuHaYnMwOFyxboSpSTiZ2WL6z9M2a5uRtMzcdPixgl3GtmfT5Tzld04rmtqV+RULiHR9zETS/nLtlnOH6RLsKXykNqiu4L0uSI+5ughx1xK0ktJXme4IqGqdoRFg3TduspU2SNdi0mzzwoXZ+OiJR1eiLszxfMb2fFMejhi+4m86ej7PXVdorTBjzTBMn6RXnO5juIj4ZLB3Oa4xBGmBWE9EOclMpA/FsBqgP9pSXw6P5a8/A+WRm+Wnizh/fiKXxeA+JfsPSr8BwDDYDbN/PxcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createCompiler\"\n        title=\"createCompiler\"\n        src=\"/blog/static/800fff7bc13591c48e262e16c05a1387/17602/createCompiler.png\"\n        srcset=\"/blog/static/800fff7bc13591c48e262e16c05a1387/63868/createCompiler.png 250w,\n/blog/static/800fff7bc13591c48e262e16c05a1387/0b533/createCompiler.png 500w,\n/blog/static/800fff7bc13591c48e262e16c05a1387/17602/createCompiler.png 597w\"\n        sizes=\"(max-width: 597px) 100vw, 597px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>创建Compiler&#x26;&#x26;订阅plugin</h4>\n<p>在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L117\">Compiler的构造函数</a>中主要对编译周期的钩子hook进行了初始化和参数的初始化.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 514px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC9klEQVQ4y42UWZbbNhBFtY2kSQLEQAAEOEikBoqtnhzbvYLsfyc3EdWSHTvt9sc9BeCQDw9VQK2Eceh+okwJPY+UuzVVisi8IMsysru7hTzLyfP8Eq/k32JRFEtcFYVAB4UKAaEdwliE0YjqHA3a+QWpSkQpkFreWOZGImRxE12JQlCqAt2NlGmLDBGRPHLdUMaasNkTt0d0sCgnsY3GxDMK7ctlLrVYnL4JFqg6UdYNhfZIm7A2YKqItp4YA9mff5Bn2fJTdnfheuxlfD3yTbDy6JQI+4566mjnljh1uC7gnCPPizeB7JK3H1k2yyjOORRCoqxBViVxrmkfI2Hvl7HfeWxf0Twkwi5QH2rCPuBHjxs8Ve+wXUV9rKnWjryQrErrUf2MPrxSHb7Qv/6NG59Q8xPy+TP2cOLw/MT8+S+a6ZEiDj+TLjH3G1aFEFTO0bQJ7RWlKyidRJ0r7yXSFMtY6JIsO+dJvI8Q5yMXKGOQoSbsOoavjzTHLfUmsH6Z6B9n2mOPstdK5kuu3mMlhFgEy5Cox47Ny0x7v8Onirgd2Hx6oB5asrvs7fJeqvkei6A2ChMEdthghi1qHTDzBj316M6gvViEzoIfsZJnQWsx3UC1PtCevtKcXgjDgB4m7HBEa7V8fN78Q8GLQ4NpInZ9oJ6/UI0j9jihpwndREotf8vdTVBpg25abL8lHl9QrkJutpj9jDIleX53yd3/XeofuBVFNwm3OxFPr6TnT8SXJ8xuQI97bF3fntdvOyx0QFce17SEbsTVDWUhESairH9z8GuX3wRViapyyrpD1gO5M8hth+wTso+IJlAacbmDNwoK8R3XfrgUxWqUN1R9oH0eSfct8WGN3ybC1OI2gaqrsK0jnRJVX+E3lnrvCGNFmj1VZ5aLv7yUUmnKOGBCJO0ONNOJbn4i7Y40h3tc8KhmRPUHzPqAqRvyPENIsbg7N9hzvDn0wV/ajxDLYvbWjq6t6Tb/rk39Moch1v9Z/Ij8vfV/Hf4D1B5Wg3DBIdAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"conStructorCompiler\"\n        title=\"conStructorCompiler\"\n        src=\"/blog/static/16a0e6501593abc91dcd723939d1ab37/dea13/conStructorCompiler.png\"\n        srcset=\"/blog/static/16a0e6501593abc91dcd723939d1ab37/63868/conStructorCompiler.png 250w,\n/blog/static/16a0e6501593abc91dcd723939d1ab37/0b533/conStructorCompiler.png 500w,\n/blog/static/16a0e6501593abc91dcd723939d1ab37/dea13/conStructorCompiler.png 514w\"\n        sizes=\"(max-width: 514px) 100vw, 514px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h4>加载webpack内置的插件体系</h4>\n<p>通过WebpackOptionsApply加载webpack内置的插件体系,用于内部打包过程的逻辑调用.<br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/WebpackOptionsApply.js#L278\">WebpackOptionsApply</a>我们先只关注一个插件的处理逻辑-EntryOptionPlugin.<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/EntryOptionPlugin.js#L13\">EntryOptionPlugin</a>对不同类型的entry加载了不同的处理逻辑,在处理非函数entry的时候加载了EntryPlugin.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 623px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 113.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAELElEQVQ4y52VWY/cVBCF+0dAJm3f3bvdXtp2r9PTMz1rJkAICCFEgkDiifz/9w/Z7oRE8MTD0a17LR9Xnap7PDNBiMqXvF4p3h0V99uAx60bkUYWIQRSyglC/nf82X5mrMXlKXkes8gC0kVMmockeUiYJLg4xTiLtgrjNNpqtNH/xONeYYIpniklMaHFrh/Q9RW6b7G3B/QiJ2068m5DkMS4xBAVjiCxuMgQ5ec4sdjQEC4Cwswx01qTFhFREuLiDBvGuCjEk4qXFxf48wt8z2fuCb6aK772FBe+4sVcMvclwhcIz0N4Pi/nciLs+pr97Ynl1T314ZZ+u+ehT+iWFa5oiLOUdRHyrnnB95XHq8Lju0qwT3xsEJLWLSbOuK4NM6M1Qjt+ONX8+arg+X7Jm8eW359S7k8b7u4P/PFQ8NNDy/tjzI+3G55Pe55WOcfdinx9xf2h5ZdTwalLBg0VzjnWi5xdnpEOyFKM9hn0dUaSWB9rFBfKMFeWl9rxQhh8bVHa4JQgtQJPqCnDtu9wYczck5jhA1qhlEErjZQaIQ2e0Cil0VIRakk8dF0PZwqpNGJ4phUzZzVR2eIWJevjkm/vSz48Gm5vKtpdw/L2hvpqx+U6Z3W5JVuveNiXPG9zgihGnUk/YmacwmpDschItz3NuuSvk+JuE5HXGW2b0rcxbzeKOjfI2KKdxvcFSvhI4X8x/DOtzVRm0WH6I+Fhz+Fxy6+vS1bHlmS3oWmW7K72XF927KqMfbPg2C14fxnztCrYNBVFmqCNmcbGWkO+6MiXHaIpqeuQu14RNDmuLEnrjqhsWFcxpy6lbgqapqDueoplT5JmKCmnkkdCoyfCque+V7RdwsWiRLmAtkmpq5QyjXjfeTzVljpLKZIYIRViKPtMNmlozBhkcUFar1lsDsSbK5rDDft9T3R7R7Xfs1k1/HwouG5zbBCj1UAmR/0GPQcM8Ug4tN+4ALfoscs9enVNU1d8uHP89lTweF1xt3bsWsfN0vB2Y6mbnKrKqOucritplgVFkU4lfySNmxX16Zms2yBsSGQlTSLIYk2e2hGLxLLMLHEcEkXBiCFOkpAwdMNNORMqia03uO4SOX+JVnLUaC4U/idIPH8yhY8l/qvkwcuGLIfr59IUaew4W6OTCImWPmp40femBiiJ0lMD9Hn9fLhndjBKpQnDkCwKMWGKiXK2ZUQeBYiowCQ5SdkQ58U4EcKbI4XA8/yzfc3P3RaThoMDO2sJ4pJ23fLNMeV4rKlXDfn2mmR14LDreXNVEy1qdLUmKkpW/YKyrsj73WhhYRRNhIOOcRShXTAOeRwoPGuRgwxhOE7AkFnkDMoGqDAez+I4wAXB+JsYfHHoxWhfQ7kD5PlODuIrKcb9eE+HVU6ayvHcH88+Ncb3P707ZjiQTTakvnCO/4O/AQ0qm/A91bEeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"EntryOptionPlugin\"\n        title=\"EntryOptionPlugin\"\n        src=\"/blog/static/04665545a50713018764d15fce4fb16a/6114d/EntryOptionPlugin.png\"\n        srcset=\"/blog/static/04665545a50713018764d15fce4fb16a/63868/EntryOptionPlugin.png 250w,\n/blog/static/04665545a50713018764d15fce4fb16a/0b533/EntryOptionPlugin.png 500w,\n/blog/static/04665545a50713018764d15fce4fb16a/6114d/EntryOptionPlugin.png 623w\"\n        sizes=\"(max-width: 623px) 100vw, 623px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/EntryPlugin.js#L13\">EntryPlugin</a>中订阅了make的hook,在触发make钩子的时候触发compilation的编译逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 737px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPklEQVQ4y5WT2XLTMBiF8xhga5flJV7i1NnqNCFpCwM3XDC8/6t8jNSyTQsMF2d+jWx90jm/tHDW4StH6Etc5fFdgWs82jmsL9BGo41CW43SP6uUEqXUCy10/Mk53HrG9iNuv8aMHaEbqFcTLnhcaXCVxfinGqF/AWrqtiR0PaZZ4dsWUzhEliFEjhASKdWz5A/Fxa9BF845uqHl/HDldL2yO1/ppx3VOFH1I33fYLRK8H/BnoGWXGpuh4pPh4FxtaYuK3y1pF5vqIaR0A4UVZ0yNdb+EZaA3nusMbi65fzxPbuHK8PlnsOHT+wv79merkzzmWk74YsCpTVK/QVorSUqZnl7GNk/XmnOF9rjHWHZIUWO+iW7X0/3aoZG6wT0ziOEJn8rkFmOyAQil6kpsUrxpDSXvgmk+n2jqEXMJdoum4CvDLqw2GApakNYujTna4srLa6IY0fZB0IT0omiM51i0M8ZhpCy6U8XVndH5suRm9OJ9eXE/HjgcNrx9Vxz3g90q45mc8P47o5+v6dpKjZTT7NssD4Q3T5ZNgZpPFJ7NrVmVWqy0CFtwBQ1IQSctTgfqFSGzDJyoVKDXliO99AYQ1htaI8P1Ls7Pl9bvjw0VIcD427L/jyzPc1Mx5n725H2ZoOfZnxZvWhMAsYM2qFnP++YDjvGzcR2aXChRPoS5UKS9BXSOLTzaY2U4ke3v4PT0yvLkrquyaOVLCPLct6kzgqUEKk+jeMVEgn0pxeziHaLUDx3Sv2XXruH3wCPH6pUFa9JtwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"EntryPlugin\"\n        title=\"EntryPlugin\"\n        src=\"/blog/static/42bb465a6651f892662fc51d336de4da/d125e/EntryPlugin.png\"\n        srcset=\"/blog/static/42bb465a6651f892662fc51d336de4da/63868/EntryPlugin.png 250w,\n/blog/static/42bb465a6651f892662fc51d336de4da/0b533/EntryPlugin.png 500w,\n/blog/static/42bb465a6651f892662fc51d336de4da/d125e/EntryPlugin.png 737w\"\n        sizes=\"(max-width: 737px) 100vw, 737px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>打包过程</h3>\n<p>通过webpack(config)获取到创建的Compiler,通过调用Compiler的<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L394\">run</a>方法打包过程.\n在run方法中主要:</p>\n<ol>\n<li>定义了三个阶段的函数 run(开始打包) onCompiled(文件输出) finalCallback(编译后处理) 串联起调用逻辑 run => onCompiled => finalCallback</li>\n<li>调用run函数发起打包</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 580px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e68874f5a553ddb3bda084ca7c980972/b6272/compilerRun.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADOUlEQVQ4y42V13LbOBRA9RcriwUgGkGAVYVqVlwUO7v7//9zdkgpideTzOThDHhJ4hDl4nJRFAVKFew2PdtxzXjesj3sqNoeIQtEnpElKVl6J0lu8XfSlHS6n2Xkec6iUAohBE4Z+nZH7A8M+5Hj9crudEKVAVFaROkQ3iFjhazKG8EjnMV7Pzsm6UIXxRxoY6i0xwmFNQVNtIQYyG1E+BJR+RnZRESobvHUlg5fVUgpb0KjNCJLUc6j60j/9IwNFUny14xUCbJIkDJBiBVSrubrQqUonSFlSrJ6IEsT8jRlYWOD0A5Rr9GbA/H1K8M//9K8vVN/fad+OtK+nImXA83zheb5jD+NxPMWf16jh45MTzMJZCawcNaSG0+5PiHrEdXtqS9X3P6Z+PiKDgO23WOaLeXmEdOOyGpAuoZUVXdZJLNxbhdWSvIsxYQeFTcU9ZqiPyDrHYX1iKGjbkrWXU2epKyWS7JkRZalc7/PLIwt5zWUpacceurDSDwcCNuWcjfgh4AuxU8qgVTZvGbZL4W+QpiA7I+Y0xP9lyP7l0cO719oLwfa11fC44X27dtM9/4Nv78g40hRDaS2JXN3ypbFlC65VFTtQOECyjlCF/F1hS4d2keUrTCxQ4cG07ToEFEhUDiHMAZhLLkyZFKzMFVEFBoZGnS/ph472suactvhj2tsFymiR7ce1XjcNmI3Eb9vsEPE9BOBovJkhWVhtCY3FW59RrZHXNPj6jUqDIhqTeE7MluTu2Yms80cp6Ymm7D/Z2EKRZ5nBGMpq5q8rPH9htC2aJWTJiselktWDw/3dkma3BP586ZMif39LAshMfWWbv+F9cvfXB5PXC9HXq7PXN7eOF4unE8jTddiygo5n918LgjZBxbqu1AKtCwwxqFciVOWUnm6tuHl5ZGnpxPX64XtuMP6QHE/u5PwIz+E0xelcejYUw07bDVVmYisepJVwnL5MLNarUjnHLzJPksXxb3aTEGoPZvdgCv97QUhbzXx/vwzvx3hdFE6x74fsdr+KJgf+Z3gt0KtFONmYOj6X3b8E9mPKU/S0pfI4rY50+5l+Z8Jfik01qCNJkl+/hvy7M9H9VH4HwgQWhFREHjXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compilerRun\"\n        title=\"compilerRun\"\n        src=\"/blog/static/e68874f5a553ddb3bda084ca7c980972/b6272/compilerRun.png\"\n        srcset=\"/blog/static/e68874f5a553ddb3bda084ca7c980972/63868/compilerRun.png 250w,\n/blog/static/e68874f5a553ddb3bda084ca7c980972/0b533/compilerRun.png 500w,\n/blog/static/e68874f5a553ddb3bda084ca7c980972/b6272/compilerRun.png 580w\"\n        sizes=\"(max-width: 580px) 100vw, 580px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>compilation创建</h4>\n<p>在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L1012\">newCompilation</a>中创建了compilation并注册了compilation hook.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxUlEQVQ4y2WUy5KjRhBF+zcEFPWmiockhISARmppNBNjh7cOe2M7vPD/f8NxgHqm/Vjcyk3Viay8mfmSZDlTJfnj7vnt7vnzk+evh+WHsaIIAaslRku0UgghEFn2P2VLFII8z3lZDmcUx9PAdOp43Ae+PEbebiPXx5XpOjLMA92pQ2qLdA4ZPNI7tPcoF7DOrbAFugKNsQQTiSaQmUiiA6Zs8Lsjxf6Ia1p8WaN9iaobdNsg6xLTVOjQEGKJlP8AKq0QeUaaJuRpSp4miCQh22xWiWRDmmzIkg0iTRHJU9miNCVdYiY+gNopbFOjfI0KAVWXqPgemwpZRny1pWhalNMopzCFRnuF9hoTNDZqlFULUKJUjt6f0d0N2bTo+YyZe/R4RPcHXFcRux3VucXvHKHzq/zWrsk8wQplJC8iy7HeUDYR7wu8d/hQoEOJLSLGOkSWkovFyXQt/rd6LcqSjCxd3H//sjQpZQxMc8t0a+mnmuPQ0r7NdLeB7alEBY0MBlUaVHzK1gZbGlz9zFKI/Nk2NqYoZVCFJfSR4lhhtwVu64mdpxpr2oNlmgpeLyXjGOg7Rxkdymq0VaupMpdIKd9N0Rp3nDHdhJ0e+PFOHG/4qkHvR366Hfj9Efl5kvwyG3591Qz7kizLEelHUz8bWyxAhR0/Y+cfceNnquGN7vaV5vSK3/WUw53mfMHvzwhdsMkk6WKmNihjvzf1ClRaoLXBNC3lMNDMF2LXsX29sr9cqKeJsus4DzvqYcL1E7o5oGND2LU0/YS1dh3BFahthlIaU1U085H2baAZOnbzyHY+0147jmNNHHpc31OMZ0ysKA8nqvaIUvLjy4vLizvLLO7qjl084E9XXH8jjJ/w227N3hqDsoHcRXJboKzDhoj1AfW+NL7P8nKEMq6PpMgRy4VFUj4vLdvkv1tGLBsm/deW+VbDvwG+jLNEjVhjvQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"newCompilation\"\n        title=\"newCompilation\"\n        src=\"/blog/static/031d2d99ede16679c6a87ef5bb26a337/32056/newCompilation.png\"\n        srcset=\"/blog/static/031d2d99ede16679c6a87ef5bb26a337/63868/newCompilation.png 250w,\n/blog/static/031d2d99ede16679c6a87ef5bb26a337/0b533/newCompilation.png 500w,\n/blog/static/031d2d99ede16679c6a87ef5bb26a337/32056/newCompilation.png 602w\"\n        sizes=\"(max-width: 602px) 100vw, 602px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h4>调起打包逻辑</h4>\n<p>在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L1052\">compile</a>中触发make钩子调起EntryPlugin的打包逻辑.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACoElEQVQ4y6WU6W7bOBhF/Rgzo4USKVKURO2LZSm2m6ZNi3n/9zkDyU4AT1L0R39cSASIg8v7LQelFEkiGeYB1zbU00DZlEht0VqSWY0xiiwzFLnG6IQwCG4Kww86GGMIwhBZDLjlhfL6k/Z4pX164fzjlZfvZ759O3G+HGkuz7jhiLI5MjFEkSC4g7fvpoM1BhGGKGXI25H6ONM2E80wMx1bxnlAjxekTvnrbw/f9wkD7wH04DCxGUIIhFLorqI4j6SnkXTqMc4i0xxbOpzLsEbuYE8XCJl8Cj3oLN+BUaLRfY099eRfZuzSkY+ObKjoJsdw7RjXmn+fHT+/1iy9wfODTzJMNEKERDLBlg3VcaYejjRtx/FYsq4N6XAiqkdEVuJyTWkEqbrn9z+Xh0zrPcMoijFZsxejm6+Mw5X56w++fL/w8nrhfF3QzUhYTYRFh8ocsbFIlTw+OY0l0ZahEKjE4PqZvK4Zqoq2KanbElc5lEn3O0HwsVUegPl2cXcYESuFna5Ul1fK9cLTPLKuC/2y4OoKs+cdftp/70Cr1K0oUXwDy4S0X1DNkaJoGLuKZmip2gptc3w/wPM8Au+fm3yPwPdv2vtQJXdgtEtEManrqdZnumll6heG9YnlujKtJ/qxxWQWkdcIu+WYEW9NvnO2DN+L8gYUSGVw3UTeTVR5T9NNzE8TyzowTD2pNQSmQKQ5kU6JlSaSaucc1PuT70AhiEWEjTVaSVyhb4BIEeqcIC2J0oJ4G7vPnqy13sN8g0kpKV1JqlKSRGG35WBTRKyITHZzZTKiWH4Yu9voJY8ZFkVBHMd4/m1uPc/H34oQ+Hc3d/1qlrdt8+awLEu2874AwvC3+tThluH2k2XZAyz4xb77nXbglpu19n2n/QnwP+14BMalEIq4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compileFunc\"\n        title=\"compileFunc\"\n        src=\"/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/1e043/compileFunc.png\"\n        srcset=\"/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/63868/compileFunc.png 250w,\n/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/0b533/compileFunc.png 500w,\n/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/1e043/compileFunc.png 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n上面从函数调用上打包过程的逻辑已经梳理完毕,那到底是如何触发对应文件的解析和输出的呢?</p>\n<h3>深入打包过程</h3>\n<p>在触发make hook的时候触发了compilation的addEntry方法开启入口代码的解析.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 697px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLElEQVQ4y42T63KjRhCF/Ror5sIMc2G4CiEkZMmKXYnK2X3/9/m2QFZV4nUq++PQ1ECf6tN8PEmp2A41u9OJ+ngljTOhrLGhxPoS5z3eO4SQSPn/etJaYZ1nP888nyYu55lxnkjjjtB1NNuaVHuUkeRWo41G5xql1Jd6MoXC5oZYRZp5JA4dvg7EXU1z2lPPI2kcqKct1VAT2pIi2rVZa73qX4ZKaYzJ8VXL+Xbjenvj8nbh9f3GcP2T7vxGM/9BPx1p2wap8rVxifeonyJrrLUorTnPHT++n3n/+8ztr5mq367n9+a7Ho3/NP00oVoNvfdo4xDKIrVFaEtu7D3SF43/ucPlEmOgsIZs8w2RbRAfdbPZkGUZQgiyDy1Tre8s549nmVjrPbJSGFsQ2i2uagjN8lE6Qt3QdYmqitTB0wRHHRyuKAhNj286XFkRo6PvE4X3q886obGWOD4T+z3l9Ew5nSmPL3SHI2mcCNsDbUpU3Q4X4mpUxMUk4JylqgK2KNC54WlhatmTzC0qlGjnkc4gUkCUnhgtw5AYxoq+D/imQbqA8om86jDGstlkyEfkhUOtNHHY0r9daC8z+8uO6XWgfdmTng+0847+eqS9zpTHPXHbYWON8eFXDlc4lSbVDYfTxHicGA4H6hQw1iFdiTQOaQOyiCjryG2BXghQvyK07nBBpkoJJcWq5b+9S6BEhpRijbTeC/ERT3zJ4zqhc+6+xwXa3+Ttoc9w/wSLso7KFzNfoQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callAddEntry\"\n        title=\"callAddEntry\"\n        src=\"/blog/static/9ef339ea14e4f0e5201b9609222cc31f/7422e/callAddEntry.png\"\n        srcset=\"/blog/static/9ef339ea14e4f0e5201b9609222cc31f/63868/callAddEntry.png 250w,\n/blog/static/9ef339ea14e4f0e5201b9609222cc31f/0b533/callAddEntry.png 500w,\n/blog/static/9ef339ea14e4f0e5201b9609222cc31f/7422e/callAddEntry.png 697w\"\n        sizes=\"(max-width: 697px) 100vw, 697px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在调用了compilation的addEntry方法后触发了如下的函数调用链路:\n<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1762\">addEntry</a> =>  <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1797\">_addEntryItem</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1713\">addModuleTree</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1445\">handleModuleCreation</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1460\">factorizeModule</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1140\">addModule</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1213\">buildModule</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1557\">moulde.needBuild</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1250\">module.build</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1581\">processModuleDependencies</a><br>\n在这一串调用逻辑中完成了:</p>\n<ol>\n<li>入口文件的依赖解析和打包</li>\n<li>入口文件依赖模块的解析打包过程</li>\n</ol>\n<h4>创建模块</h4>\n<p>在处理入口文件过程中,在调用factorizeModule的时候通过SyncQueue发起_factorizeModule的调用,在_factorizeModule主要是根据当前模块的工厂函数创建模块对象,在EntryPlugin设置的moduleFactory函数是<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModuleFactory.js#L192\">NormalModuleFactory</a>.NormalModuleFactory继承<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L173\">NormalModule</a>,在NormalModule中封装了模块的build方法等供后续的调用.<br>\n在创建完模块之后,通过调用addModule将创建的模块加入到ModuleGraph中进行存储.</p>\n<h4>模块解析</h4>\n<p>在添加到ModuleGraph后,调用buildModule通过SyncQueue发起<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1224\">_buildModule</a>的调用.在_buildModule中发起了module.build的调用开始文件的打包处理.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 634px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACY0lEQVQ4y5WU3W7bRhSE9Ra2JJL7z12uuOKPJdlSZEZG2qRugV70qkB71fd/h69YKjWMxm2Si+GC3NnhOTMHuyiEYhs0f0yKvz7V/DbVNIcTYRzZ9oHTNDIcEq5xCCWoqoqyLOf1LSyErVFKknYj3UPP4ZQY7zvaIWK8ohkcYXDYqJFWfCH27/eFEBVCSDbDHtsk2jbSpgbvPet1SVFkopwhpKISgmK1olivX8Reiy7yQwiBqEqaYU//9Ew3/Uj3+IFmd8R1ezb3Z4bLR+5++Jnu/IRvO2yzmcW/qDB/zIJ17WeSjS116rCb9npIW0pp0Xk/trhNwsWECfFtQSmuRvvQkFJP0420/Z5t7Kl9IKVA8BbtasrVktXy9v9b1mWFkAIpJcZvSceJdDjz6/sjv/904s9fjny4PLA7P7J9eMRvErmI8lUorzG3nAlKKex4nL3bv39ien5m2B+Yznvu3p1J+wdCFlN6tui/x0Zcq8uCOZR4P7E73rM7v5t/dHNzw/L2ltVyySq3WpSURfEK6xdUc4VVNQtqJZHWY7aHazhNS93EOQwfanxtCdZgdbamwYYGk4MK8TM/orTOguU8hypXWUfMcKI7XRgun+injwyXZ/rdSPSO5CxeKVzbU6ceF7f4NOK3d/OqtWEhPnuSW9bWYTaJZuywwaKDxUaHMJJSllRGIKxA6hIhiyt0gXLlDGkEC2EcoqquoViLsgoTNbqWaK8wQaGcRDuFbTQm6HnfNJmTuQaX7IzMXVzTERhriJtIVVYU62z8tyPz/znzEkoI4as3ybdgFpxbVerNyf9ewb8BtKTIWzZXMsYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callBuildInternal\"\n        title=\"callBuildInternal\"\n        src=\"/blog/static/a0084889d86f5adb501cad2a829b8292/374ac/callBuildInternal.png\"\n        srcset=\"/blog/static/a0084889d86f5adb501cad2a829b8292/63868/callBuildInternal.png 250w,\n/blog/static/a0084889d86f5adb501cad2a829b8292/0b533/callBuildInternal.png 500w,\n/blog/static/a0084889d86f5adb501cad2a829b8292/374ac/callBuildInternal.png 634w\"\n        sizes=\"(max-width: 634px) 100vw, 634px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n在module.build中发生了如下的调用:\n<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L853\">build</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L661\">doBuild</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L984\">this.parser.parse</a>,主要完成了:</p>\n<ol>\n<li>在doBuild中调用<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L728\">runLoaders</a>调用设置的loader解析文件</li>\n<li>通过parse方法解析生成的ast 生成依赖模块的信息</li>\n</ol>\n<p>在当前Entry模块解析完毕后触发回调回到上次发起<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1288\">processModuleDependencies</a>的调用开启依赖模块的打包.</p>\n<h4>打包文件生成</h4>\n<p>上面梳理完了模块的打包过程,通过loader的转化能力和plugin的劫持能力已经将文件转化成需要的内容,它存在Compilation中.通过make 钩子触发编译逻辑之后通过调用compilation的<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L2141\">seal</a>方法生成文件.<br>\n下面是seal中的一些关键方法的调用梳理:\n<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L2141\">compilation.seal</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L2168\">EntryPoint</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L2284\">buildChunkGraph</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L2375\">_runCodeGenerationJobs</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L3651\">createChunkAssets</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L3643\">getRenderManifest</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L3754\">fileManifest.render</a></p>\n<p>上面的一系列调用主要做了:</p>\n<ol>\n<li>根据入口创建EntryPoint 他是一个chunk group.负责维护与入口相关的依赖.</li>\n<li>buildChunkGraph 生成模块的依赖依赖结构 相关的模块会保存到一个chunk group里面</li>\n<li>_runCodeGenerationJobs调用module的生成代码逻辑,生成代码</li>\n<li>最后通过getRenderManifest fileManifest.render进行最后输出文件的拼接.</li>\n</ol>\n<p>比如在入口函数中会通过<a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/javascript/JavascriptModulesPlugin.js#L546\">this.renderMain</a>的方式拼接代码.这样就添加了打包出文件的Bootstrap逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 646px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNklEQVQoz42SWW7bQBBEdQ6J5Owrd1mUxUSOEPv+Z3oGR1ZiA0GSj4fGdAM11TWzE02NdBE3X5he3kjjjIo9aujQxxE5doShwyhNXdc0TfNHHrNdIxqs8cThiW694WNivz9Q1TWHqi51o/6o+6oq/UOZV4WH2FZ3QkqUkCSfyd/faK+vDC8/ycuV5Xziuk5cziPP55HrOnNbj9zWhSFFotUEZxBC/Ha4HYQUxJiZ5gv9ONBmT3KG7AxWK7xRWCUJRjMEV8gf8xQsQsivglIKQky08zP9NDL0ic5b+mCLizH6gtN34ac2cGojU9r6jqkNOGfvK2+qSiliP2Jixmp9v9kagtNopf76GI/svjg01rAsPzievhG8Y4qOOfmy7ud8/sUvh8YYXO7QIWGUKlltbM4/f4n/4R1XDeNFpqw4PgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bootStrap\"\n        title=\"bootStrap\"\n        src=\"/blog/static/71dda616183f18729fcaba2eba2042f8/27524/bootStrap.png\"\n        srcset=\"/blog/static/71dda616183f18729fcaba2eba2042f8/63868/bootStrap.png 250w,\n/blog/static/71dda616183f18729fcaba2eba2042f8/0b533/bootStrap.png 500w,\n/blog/static/71dda616183f18729fcaba2eba2042f8/27524/bootStrap.png 646w\"\n        sizes=\"(max-width: 646px) 100vw, 646px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>以上从源码的角度大致梳理了webpack整个构建的流程.通过源码的阅读可以看到webpack在设计上一些可以借鉴的点:</p>\n<ol>\n<li>webpack通过tapable实现代码的构建流程这样在实现上业务代码的职责更加单一和清晰,但是一定程度上也引入了callback的处理逻辑</li>\n</ol>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"深入浅出webpack-webpack源码解析","date":"2021-04-12","tags":"工程化","path":"/webpack-code","top":null,"summary":null},"title":"深入浅出webpack-webpack源码解析","date":"2021-04-12","tags":"工程化","path":"/webpack-code","top":null,"summary":null},{"id":"1cb29b0e-5c80-5d18-8eed-d5341dc110dd","html":"<p>webpack是前端代码的打包工具,熟悉webpack的的工作流程和相关配置有利于在业务开发中更好的组织业务代码和实现一些特定的功能.webpack主要基于loader和plugin来实现代码打包过程:</p>\n<ul>\n<li>loader 主要提供了非js文件的处理能力 通过loader依次对目标文件进行编译</li>\n<li>plugin 主要通过webpack在编译期间的钩子来对编译过程进行干预</li>\n</ul>\n<p>webpack的钩子触发逻辑都是基于Tapable这个库来完成的,在深入浅出webpack这个系列文章中我们先从Tapable的源码开始逐步深入到webpack的源码中来了解webpack.</p>\n<h2>Tapable的简单使用</h2>\n<p>Tapabel提供了多种类型的钩子和订阅钩子的触发方式,这里以SyncHook来梳理一个简单的钩子使用方式.</p>\n<pre><code>const { SyncHook } = require('tapable')\nclass Car {\n  constructor() {\n    this.hooks = {\n      // 定义一个同步钩子 钩子的构造函数接受多个入参\n      accelerate: new SyncHook([\"newSpeed\"])\n    }\n  }\n  // 定义设置速度函数\n  setSpeed(newSpeed) {\n    this.hooks.accelerate.call(newSpeed)\n  }\n}\n// 实例化\nconst myCar = new Car()\n// 监听钩子accelerate的触发 \nmyCar.hooks.accelerate.tap('acceletePlugin', (newSpeed) => { if(newSpeed > 100) {\n  console.log('不能开太快呀')\n} })\n// 调用实例方法 设置速度 设置200的时候 会触发提示\nmyCar.setSpeed(200)\nmyCar.setSpeed(100)\n</code></pre>\n<p>通过上面的例子可以看到钩子的触发的逻辑是:</p>\n<ul>\n<li>创建钩子,定义钩子参数</li>\n<li>订阅相应钩子的触发和拦截功能</li>\n<li>触发钩子</li>\n</ul>\n<p>通过钩子的触发逻辑可以看出Tapable的实现逻辑可能是基于发布订阅的方式实现的,但是它里面对订阅的处理是怎么处理的呢、如何高效的触发呢? 这些都是成为一个优秀的库所必须要考虑的事情,我们就带着这些疑问来看Tapble的实现逻辑</p>\n<h2>源码逻辑</h2>\n<p>以下源码梳理以SyncHook钩子为切入点,分为以下三个模块梳理:</p>\n<ul>\n<li>钩子的构造过程</li>\n<li>订阅过程</li>\n<li>触发阶段</li>\n</ul>\n<h3>钩子的构造过程</h3>\n<p>在通过new实例化<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/SyncHook.js#L35\">SyncHook</a>的时候在SyncHook的构造函数创建了底层Hook的实例并且重写了Hook的方法过滤了SyncHook不支持的功能\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 469px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABxElEQVQoz32SSY7bMBREfY1Y1ERNlijTFiXLmmxJnhKgk00WuUZWOf8L7E660Y1OFgUQxK+Hqk8u3CBGbjv8dY1UhrbZchgq5qlmW7eo5kiSpmy1Jsk15fUbySolyEuCckRu9sSmoygLXM9l4fk+wSoiUCGrMmFdJ2z6DDMr1D5l3WvWfUpWRbiehxeEOI6D4/k4foDjSVxfIgP5uF/4novMNkhdI7VBtmdilSFzg78tCcYa1dQU841YrVl3I6Y/EvgeQljYto1tC4QQj/PCc10C0xH2F/L2gBou5N2EPpxJdIGpNNNpz/XzgX7Y4cmAeyvXdZ+TvtPCv1dOQpIyYXdYsW8jmj5GlRGqStkeFc3FkOsUyxI4tv1ivkPf61E5NB1+c+HHmPHru+bn14xOh+Q65zTXXK8tT08jSq2Q0vsw2WvC+w5Ni9ec6dqC26nidtoxDAZjNoxTzTTVzHPN+dxQGI1lWQ/z8/7eauE6NnHRkrY3mn3F/GWi7mviKGIYSo5jRbXbYNsuy6WFEPYL7MOEURyhVzllskFFGW45EBV7HCFYWuIPRLwx/Qv2AKb3LxIGfLKWj+d3xBJbWB8O/w/0F/gbfDImzfUplnYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"同步钩子构造函数\"\n        title=\"同步钩子构造函数\"\n        src=\"/blog/static/fabb95efaaa8baad0c7438753b657a71/5f759/SyncHookCon.png\"\n        srcset=\"/blog/static/fabb95efaaa8baad0c7438753b657a71/63868/SyncHookCon.png 250w,\n/blog/static/fabb95efaaa8baad0c7438753b657a71/5f759/SyncHookCon.png 469w\"\n        sizes=\"(max-width: 469px) 100vw, 469px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n在底层<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/Hook.js#L25\">Hook的构造函数</a>中主要做了如下的处理:</p>\n<ol>\n<li>入参存储</li>\n<li>创建不同方式钩子调起(call)逻辑</li>\n<li>创建不同方式钩子的监听(tap)逻辑</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 441px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cddadaa923563693da8a82c7e4708f08/efc6e/hookCon.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 142.00000000000003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAAE4klEQVRIx32Va2/bRhaG/Su6tkRyOJzh/X4RKVE3y5bt2AnSdNMWbrPtdi/AFtgW7WL/P56CZOzYTdoPQ1Eg9eg9533PzInjCFSUoeoddtVivX2H+eZ7rLf/QNz/G+v1t3h+iMoaVLNB1z1xVRPGEfXVHUW7xPc8TNPEsixOdDTDsmykKwkWAclFRXJRk143xJcNwa4kqD2izifbx8TLgKj1iVcB6SbGVjamMcFGoJucYZk2UgvCxiXZBgQLl6DSlGvNcq8JKxcv14RLH+FKTNtCSIElLUzLxDIn2KDyREUzxKDQ17iFR7UOyDKNqnz6VnHff0YSCYLaJ4wduo1Pe5kSLXzKfYxynecKhZhuVFKj05Yvzhu+2mf4YUTVLFjUJU0V0+9aXl8t+PlKsS89FklEEwdEUfSobgSapoW0bXI/oY0bSi9CJxVeWvHjpcPrlY/2Q+K2pz0/Eo+K5pjvIQ+gR4VybhBE0ahobhqYtj2+LCwL25ghzPn7HxoYhsHcMBhEDN/N8f7hc4Kf+FIivRDVHJB5jdr3uHWF7wcIpbFsOVYgpcSWDo52EWIwxEEoD0sqbEePzyeFjsIZoFGBqrbItEWmS8K6p9ofSboNeVGQJAlh1VLsjrieh5MvccoembX45YogCBC2zYmQJkLY2EIgkxKvrMg3K8rDBa7rElUteb8fWzCW9qS8T5aswik2trRxAhe/DsjPc+IuRjoOUnsMVVi/a/4frZPhMvTEHvqUL1FpQ7m/Jm3XYyQWl7dEefloyhjkJzH5CDg4ZttiKrnoUcmC+vCCvD+Q5hVNt0YqjS0kruthDYb8GdB2jKmHg8I4I6grkvWSaN1THg/k5zv8siCIPepFgRAm89n8EfpRDp/30MMtfYqFZrMOiBpNdShotgXlRUN+XpOsKpwnu8vjGuAPJYuhZFvgFD0yafnuWPOf64IoCvnrv95x//OP3Pz0X27+9yuf//8Xiq5hfno6Tcx8Nq330JPBkMkUgcy60ZQfLhO+2ccUfc/du3t2X37F9d9/4Oa7b9n/7Z/4VYepPOwwRQQJdhB/UPjBZTG67GQt7y4Lfvp8SXN5S7hYE4c+3x9i7voUsXmF3r1E7+5Qhze4118TLvdYQx4/AmZL3Kzhy13Ky5sD2e6aqKgo6obXdwfK7QG5uUX3R9QA3b5AVSuUF2AY84fYmGNkRpezDp0tSDYXlMdX5Os9URzhbF4gr+9R+1cjxL38An14Q7DYYM1OHw0aJ+V5sDvcoiNtl2TdmqDdobMGvbnF21xjJTVm1mHlHU65QvnhM9h0pszNyeUh2HmPSgfghrha4lZb3GyJLLZ4SU2ReGSxRxzqyVnD+JDHx/1Qz6ccDgrDiKDJyHct5dU5+bokyofjoMQtY7bHhtW2oijS8f1PTcuJ4z0BDhttnZL0FWHu4jcxelFTtQHdNsVQJmfGjL98djrO9cPx8RT8YZbHHk6zXO5vKPoD3tCrICetGqplTxS4VFVCloW4rub0dDaCn/XwwZTh34ZJ0XlLc7yle/mW5uoVebdCRxkiX1N0S+7uNty93LLdLWiaDKUUxtNTb7gM27fneQgdYGsfPyvw0gI/K/HSEuVIbDfAVMMp540Kk8SnLJNPA4dyhwfmfD7O53x29riMYRnmNLfDs/mc2WxaZ2cfl/wbpkc9NezuXmIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"底层钩子构造函数\"\n        title=\"底层钩子构造函数\"\n        src=\"/blog/static/cddadaa923563693da8a82c7e4708f08/efc6e/hookCon.png\"\n        srcset=\"/blog/static/cddadaa923563693da8a82c7e4708f08/63868/hookCon.png 250w,\n/blog/static/cddadaa923563693da8a82c7e4708f08/efc6e/hookCon.png 441w\"\n        sizes=\"(max-width: 441px) 100vw, 441px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>订阅过程</h3>\n<p>在钩子实例化的过程中返回的实例绑定了不同监听钩子触发的监听函数,这里我们调用<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/Hook.js#L77\">tap</a>函数的时候,会调用内部_tap函数并且传入绑定的sync参数和入参.在_tap函数中对入参进行了处理和过滤器处理\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABR0lEQVQoz4WRSY7bMBBF+xqtkRLF4iSKtGTHQ3eCbHKF3P8mLzDjAEE2WTyABImHX/Xf3ruRH8fEz+8Of/9G2Av545P8+IqEhIkZEUvXtnRNQ9e1L7rf9+a9vvV9zzAMvI3DwLws+GNnvV/wJeIfG3LPaDFsybGuDhHBxA0tFm0dWmtk3ZBUMC4wjkOVVuGkNf44SB8X1mvCPRLDFtFW2DZPzhHrPPb0BW0Ds3gWI8i2Y/OODZFx6P8R7gfpcSFeInJKqMXjRHM+J0qJpOQ4ZVcTn0qgZE9cYxW6cmB9oO+6vxMW4m3Hl4Bkj44BMZqcQ5V5b/BeKs8VBG+wIWCeY8fEYswr4fgULqhYkOi43jeut0S+3vDnB36/Ms8zTdvStl2laf6cX0W1TS2plqKUqgvvR8U0zUxKMQ4jappR8wul6uf/8Uz4CwkaymFOFPmPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"_tap函数\"\n        title=\"_tap函数\"\n        src=\"/blog/static/b003abad27e92cd6307a316a5118d62a/267f6/tap.png\"\n        srcset=\"/blog/static/b003abad27e92cd6307a316a5118d62a/63868/tap.png 250w,\n/blog/static/b003abad27e92cd6307a316a5118d62a/0b533/tap.png 500w,\n/blog/static/b003abad27e92cd6307a316a5118d62a/267f6/tap.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/Hook.js#L136\">_insert</a>中会根据当前监听项的信息将它插入到taps的正确位置.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABj0lEQVQoz3WSyW7bMBiE9RyRuGshRcm2YsubrDhxXNSXPkRPPff9D18huU2CtD0MBvxJDmcGTISU5Eqwrx4YQkbvJcYVaFdQliXGGLI0Q2SCLBWICdkHCIGUcuYJSSoUbS75cTH8/Ob5fqtZDgOPX270xx2+9Ugr0U5hvcGUGu002qp5pox6E52QTAvnHMYZbHAUq5ywzml2BbEvWY6R9hCIm4r1taV7bQl9SdE4/Logj252+i4oJcZoTFFh1yNlu2S3W/B07nl+2XK97jmeHhnPG8ZxQ7fscMaRPqT/jJ8IKbDW4gqD85ru2rK6xPn1ZvAsn2sW55rVayQePUpLtNVz1AlzdHuvQCpJMtl01uEKhws58RBYnCO+K2n2gXYI1NtA2FSzcL2tCJuSuq8IfUU8eBZPNe0pYJy+R3bWYkuP7QZ819O9fGV9OtP1W6pqEh7pL7e5mrkrJVHqzn+6e+swS1Ni2xDbSJoJlNZoY2dWSv0WuM8+fo//IZn6a5pmvvy+kf19OMuY+v7s6LPDXzgWA4uhdV6tAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"_tap函数\"\n        title=\"_tap函数\"\n        src=\"/blog/static/44794c72173ba543b2450d5ba600480b/f687d/insert.png\"\n        srcset=\"/blog/static/44794c72173ba543b2450d5ba600480b/63868/insert.png 250w,\n/blog/static/44794c72173ba543b2450d5ba600480b/f687d/insert.png 423w\"\n        sizes=\"(max-width: 423px) 100vw, 423px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>触发过程</h3>\n<p>在触发过程中是通过调用hook实例上的call方法,这里我们先梳理出call的实现过程然后在从源码的进行分析\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 363.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCABJABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHu4IVAFRkLGAqUmVNDJvIuAKtNMAP/xAAaEAEBAQADAQAAAAAAAAAAAAABABACESAx/9oACAEBAAEFAtYxjEgiYj4vULjGNxx9f//EABQRAQAAAAAAAAAAAAAAAAAAADD/2gAIAQMBAT8BL//EABQRAQAAAAAAAAAAAAAAAAAAADD/2gAIAQIBAT8BL//EABoQAAEFAQAAAAAAAAAAAAAAACAAATFAQeH/2gAIAQEABj8CW0nkuD//xAAgEAACAQQCAwEAAAAAAAAAAAABEQAQITFBUWEggaGR/9oACAEBAAE/ITkRlP6FDULLvfuic/JtkX4gLjCbQhJ2MWlgm+GtxHruYIpLz9ppmL7K2LvtZppPY8X/2gAMAwEAAgADAAAAEKPMDHPHPOPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAMP/aAAgBAwEBPxAv/8QAFBEBAAAAAAAAAAAAAAAAAAAAMP/aAAgBAgEBPxAv/8QAIBABAQACAwADAAMAAAAAAAAAAREAIRAxQVGBkWHR8P/aAAgBAQABPxC4CltmUYRJoDgAKWV7SfmGoR3EdDhJmid9sJKjpt7D3AFNmKin42TFZ0KhHeBgk24RdhCfZym0m3QN56PgxKH8rlXoV2Or5xHbbyFxIqAZ/tcCh9ncwJYZ/Y47rXu0uNfTfQh/eDn/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"call梳理\"\n        title=\"call梳理\"\n        src=\"/blog/static/542d374ac0a67cda1e65467eec38cd64/aa65c/call.jpg\"\n        srcset=\"/blog/static/542d374ac0a67cda1e65467eec38cd64/0479a/call.jpg 250w,\n/blog/static/542d374ac0a67cda1e65467eec38cd64/aa65c/call.jpg 313w\"\n        sizes=\"(max-width: 313px) 100vw, 313px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/SyncHook.js#L40\">SyncHook</a>实现的父类的抽象方法compile,compile方法也是基于基础类HookCodeFactory组装实现的<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 111.20000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD4ElEQVQ4y32U2Y7bRhBF9RW2h71xF/d9FSmNZvPEAZz8RZ7y/68nIEcTO3bgh4smC+RBVd/CPZTGotWKNjC0vqHbTk/TeJr+aDOmzl6vjdrfh8Shj20qJSnlN9VCkEnJYYju8H2bqA/IzzHZFJIOIVHtUV0TsvlI0gckQ0D1GFE9pCRViJISJSRaSqSU2FpTbcDKlgRZQ1DVHE8l4bknvPQEa0+wtDhNgVtkBO1AOJwI+u27CW9o8YYGp8oJqoLAcSmE4JBakjEP+ftLyl+fE7qhJT4/k5+vpF1HebnSPX/hWLRk8xPpfE/x8Ey2vp3JMFG0Db7jkFsWh21+zyjqKOKxbinSFL+aqOqSeel5eFqZ14HLpWUaG45RhOuH2LaN0QatNUopbKXeOtyArrHRts14OTHfL0RRiOd5uMeYME5Qjk/TZDRNSl7mxGWD7/v73WmtUPoHoGcbjO1QnJ+pH38n7WaOZcuxqPHjFCUFQsibBFKIvautu71Drb8BN2dcrUnTjLSoCOKEY1YSFTVR2RCmOVopjNY/a4MqtQOdd+C2O47vYYchd0ryUVi7Plh3uz5aFp+U+kkft1NrrJs26A58UIoXz2eyBJPQTNKwSMWqNItSLEZx0jcZvZ+LVlyMYbUsKiFItuUWYn8+zJakKWfKpOJyWlgvj/R5QRVXlPVA2bd060y7znSXE+3YUdUFfZ4xbstsWbhKEdycPhTblhcDqj5RLyPLWjNNOV41IIoZp5op718p719ImgHbdZFK82EzU0oiKbnTGnkb+1BYFqHr0/XPRNlMNC401weyfqIbW9brQvv0heb6Qtl0uxnvRhyl3McVt9qmQ2s0WRzjGwfPGKQbINwQ2/UIQ5cg9HCDI05wxA+PGGP2lRFKvQGF+Be41Q+1lHTGkAuxp0YrLRolaLY0sSTFpztqsV2+RXF3t2tPGG1opSIxNsqYtw63kZU2OHmP16x45ch0mblcek7nifLxM/E476NGeUX3+idlP+EXPW454pTTXncdB/kO1ErihAled49fjQTr6x4Ex/ZMWJfU547L05VxPRFVHXk77FG1xdf27x5jN9g+8lY0SYmzvNIsC+vTme58Iq47/GYmP63Uz6/UTY4WFsKydkP0D3qHHmwlKYKYopq51Blfl5IvU8GahvRVRzE9U51+Izm94hVvLv8f8F2HUAimIKYcn3gcWr4+zdy3BUue8Me142XpGJOYRjto17u5+QugYzStF3CftJyOGVU702QVqRSkWpEpSSYFgbCQars3/RZZ36XNf4C242B7HpYUWEphybcdE0q/vSu975n8Lqp+1eE/vS2C791tVqkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compile实现方式\"\n        title=\"compile实现方式\"\n        src=\"/blog/static/f40c6fcf44a8453f6214b5593c81ed49/267f6/compile.png\"\n        srcset=\"/blog/static/f40c6fcf44a8453f6214b5593c81ed49/63868/compile.png 250w,\n/blog/static/f40c6fcf44a8453f6214b5593c81ed49/0b533/compile.png 500w,\n/blog/static/f40c6fcf44a8453f6214b5593c81ed49/267f6/compile.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/HookCodeFactory.js#L14\">HookCodeFactory的create</a>方法中通过调用contentWithInterceptors进而调用子类SyncHookCodeFactory的content方法,在子类SyncHookCodeFactory的content绑定的SyncHook的实现逻辑callTapsSeries.\n在<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/HookCodeFactory.js#L276\">callTapsSeries</a>中主要完成了订阅数组taps的代码串联逻辑最后返回new Function完成call的调用逻辑<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 655px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 122.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAADa0lEQVQ4y5WV627jNhCF/RitLVHiRSJFibr6GifeptldYIGiKAr0/R/lK0gnzgZFiuTHgQiSOpzhnDlcKaXwbcfXv/7h659/c3n6zjjNyLIkrkkpP4WVMYY8z/H7e/rLN+owIoqSXIg0/1kkwqIoaKYd7e6ErmqkUmTZBiHEp7HSWqdBOF2Yf/9Bf7pg+xFVO4TIbxvj6R8jlIpI2oQB03RU7UDle1TdkG3yhDzL35D+H/mqrhWllOjGY6eJZmhxjaSQG5Qt0F6hrLyRvoeXQ1bG6nSHhbVUweP3M37bMTwcafc92pdoF4uUkeeb2+VnWUaeZdfvT5GvjPOJ0DWeZhkJ91u6Q093f2C4HGiPI+1xoLsb03osWCkVta3RRqO1SXJ5jbC5EtbKUHUNuvPo1lIvge64xS89buzwu57utOC3Djc4jKnQlblp9ZWwqilETlk5yn6LP90x320ZdiPd3R3NsqCsRZoYmaCQAlGKW8ovV3BLOZ6Q7lAqnBs43J25/PjO/nRgbGfm3Zkm9Gk97kvFyd8vTNJh3Ki0ojOeYEfGZWKeR6y2iHVGvsnI1hnZJkuESU7r6/hnXGXTKIQo0EZhWoX2IsH0Ejtr6tlgOo2dDHaucEuNaTXNrqYeDFXQ2NFgvEqkqzpqrigolUKFhvow4M4Lfudx+8Bw3zHsPOHY4cYK7SV20tjZIKQgFzmFLCjK4m3KhdQs+y2H8xE7H6jCgmpGjseZ03GinxZcmFGuo/AzXduw3/XMU0CWr8K/mUMhBNPUcv94xg89sfrxxKIQqafTuCwoohOV16ykjBYn33bKS4RlWaZKbp/+YDg9Mi0LztW3+VJphFQJRkuqSif9Zdk7sok/loWgqxucrGl9zTg2WGeJ3WTDgIym4QPj0LDdBrrg35dNTC0czkwPj7hhojt9oRm3NF1PGZYk4s2vv5BnG9brKzabDVnC+r8pR0LTtAwPT4xfvjFenhjOv+G8p3INxkdrC0itqesKbQzKVM+WF27tl4oSmWtr8WHADjMueqMPVOMOG0aqqkqE8XlQxmBiD+tnwuf58oUwRliWRbJ+04brJqUQpUK4QOkCItrVZk22XqcefkGyr+f5W8rx9CiZYXuiDSPjPLDsBtq2SUTxp4++JynCl+fPGXfFMKco3xJFaXzskfoX5gqrdJg+CAsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callTapsSeries\"\n        title=\"callTapsSeries\"\n        src=\"/blog/static/0a6bef843d8f38a95e315423b2739054/ae6b7/callTapsSeries.png\"\n        srcset=\"/blog/static/0a6bef843d8f38a95e315423b2739054/63868/callTapsSeries.png 250w,\n/blog/static/0a6bef843d8f38a95e315423b2739054/0b533/callTapsSeries.png 500w,\n/blog/static/0a6bef843d8f38a95e315423b2739054/ae6b7/callTapsSeries.png 655w\"\n        sizes=\"(max-width: 655px) 100vw, 655px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>以上梳理了tapable中从生成钩子到触发钩子整个过程,可以看到在实现上tapable许多比较巧妙的安排</p>\n<ol>\n<li>Hook基类实现了所有钩子的创建方式 子类可以通过组合或者过滤对应的实现来实现不同的钩子</li>\n<li>在HookCodeFactory基类定义的工厂函数的不同组装方式,子类通过父类的接口自定义了不同的实现方式</li>\n<li>在实现call方法的时候 会使用上一次创建的结果函数</li>\n</ol>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入浅出webpack-Tapable","date":"2021-04-06","tags":"工程化","path":"/webpack-tapable","top":null,"summary":null},"title":"深入浅出webpack-Tapable","date":"2021-04-06","tags":"工程化","path":"/webpack-tapable","top":null,"summary":null},{"id":"60806375-3fd0-5bef-96e6-1328e8a6382f","html":"<p>在使用React进行业务开发的时候setState可以对组件的数据进行更新并且触发页面的渲染.本文从源码角度梳理在调用setState的相关处理逻辑.</p>\n<h2>前置知识</h2>\n<h3>React多平台渲染</h3>\n<p>React在设计上使用了依赖注入的方式,通过注入不同平台的渲染renderer来实现多平台的渲染能力.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/5c744/reactRenderer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABg0lEQVQ4y5WUiXKDMAxE+f/fZLivHBBu3HmiSyCFdsrMxrItrVeyHG+aZjdNk2EYhg37ed/3bhhGWxvH8Xv+9tvD42dZFvd8Pl1RFO5+v9tYlqWhqip3u91cnucWwBwbvziOjXSeZ8OBEIfH4+GCILAAwDxNU5ckiZGiTERRFNmeCDeFTCB8vV7mjBMq6ro21aiUcvyaprG1LEttpAQHhTK0qJRQByFqAAegEmL2sed5+VnDvVzZpNZ1nQX5vm/AZo09sBexjz0QrlhLQG1QI3IUY7O3J7pU+Jm6LqBtWwM2xErzLO5C4Tt9LoBLAthXvr8qlI0qLkKE2HQCKf9LIW1AEJdAW1A72Yzs4fOnQp1CAB+K9EoYAW3Eh8+VUk9kfKQEAYHquTAMDdgiZY8D+U4VkgKOPDs9M/UhTwxg00qUgEbHl0NOXwqOWZYZKQEokVrmSp/gtQSl+XL46VtmkaJD0rYrkd72utZuhPoTYY03fvpvA1CBM8DG4WxNTQ4p+KzhFxiCKgcyB0LkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react renderer\"\n        title=\"react renderer\"\n        src=\"/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/00d43/reactRenderer.png\"\n        srcset=\"/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/63868/reactRenderer.png 250w,\n/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/0b533/reactRenderer.png 500w,\n/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/00d43/reactRenderer.png 1000w,\n/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/5c744/reactRenderer.png 1206w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在创建组件实例的时候,React会注入不同平台renderer最后结合react-reconciler来实现组件的渲染更新.</p>\n<h3>事件循环</h3>\n<p><a href=\"https://icantunderstand.cn/event-loop\">事件循环</a></p>\n<h3>lane</h3>\n<p>在react新的架构中定义了lane的概念.lane用于控制不同任务的更新优先级处理逻辑,具体可以参考<a href=\"https://react.iamkasong.com/concurrent/lane.html\">lane模型</a></p>\n<h2>源码梳理</h2>\n<p>基于React的多平台渲染架构,在梳理setState源码是从以下两个方面进行的:</p>\n<ul>\n<li>注入渲染renderer(setState从哪里来)</li>\n<li>发起调用(setState做了什么)</li>\n</ul>\n<h3>注入渲染renderer</h3>\n<p>在<a href=\"https://icantunderstand.cn/react-render-interpretation\">图说React渲染流程</a>中,React会根据当前的页面结构创建workInProgress树,注入renderer的逻辑就在创建组件实例的过程中.\n在创建<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L943\">类组件</a>的时候,会执行constructClassInstance创建组件的实例.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 724px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACeUlEQVQ4y42T247bNhRF/RuxRPFOUferZXuMMdpBmiAPyUOemqekLfr/n7AKyc5MGwRNHjb2JiQungMe7jIpcc1IHE8My8BwHJhOE93cEnNPlmUIITb/Ge0yISjHhf76muZ4oTssNEOLizn7V/vnH38WuhNpSnv5lfOH3xmuT9SPJ6R3rAet1X+74UfgnVGKEAtsHrEh39r0uSdNEtJkf/eEZP8KIdIfQnd6DcYhpEasrh3GOlxR4coamxe4WJK3A9qY/4Wt33ZZJvD1RPnwRPP2I9Nv76mmI7GfyOv2BiyqO9A+A1f/Xt5JKQnaUtQ9+eFC1fX4siXUPVYrkue2999t+VvwBtRao60i1B5fO0LrCN0t+8ZiosGVFl9bXGXw7S2bqHGlIR89tjT/AhqNcpJ8tITeEjpLPjri7MmHFe6Io6dYAnEKFHPYgF8PWGFrESbolwp9WVEtR8pxpDwsxK7F1S3aWZRRKCNRWm6+tZekiESQJinp5uKlQrUCu57q4bKpXBbifKA6n3BNjS4qpFVkViFWaNBIpzatWTmFdur+UjJJNIa+rpkPh01D1zLPM0NbUg3TdutVDESTEbWkcOse+ZztWr29A7XMaNYqjcZ4g3Gr6829TIk2JTerBEHdsxbkKiUYQakzYpKSiK+DbQQHnfLpMeXzk+DLG8Uf7wyfnwxd3+D7kdB2+KrePO8HbFHgm47Q9eTeUayjIyXy9pYF5+j46+3C3+/O/Pl65MsvHZ+uE9fjA+fjI6dx4TguXE5XjsNhy+fDA8dh5tSODN2IzfNtTrdLKaqGUM2E/oQdz6hmQsYWFSJaydtwp8lda05f1iL9z0v5Bw9BzFQeJzKMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"constructClassInstance\"\n        title=\"constructClassInstance\"\n        src=\"/blog/static/497d1ecebae05943263e87a1e98aa231/a242d/constructor.png\"\n        srcset=\"/blog/static/497d1ecebae05943263e87a1e98aa231/63868/constructor.png 250w,\n/blog/static/497d1ecebae05943263e87a1e98aa231/0b533/constructor.png 500w,\n/blog/static/497d1ecebae05943263e87a1e98aa231/a242d/constructor.png 724w\"\n        sizes=\"(max-width: 724px) 100vw, 724px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n在<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberClassComponent.new.js#L591\">constructClassInstance</a>中主要做了如下两件事:</p>\n<ol>\n<li>执行构造函数,创建组件实例</li>\n<li>注入组件更新逻辑实现</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 642px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1432b8761f07738688fa565358af68b7/1bba8/executeConstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpUlEQVQoz42S7W7bIBhGexmrbcAuBvwBCeQ7Wbt0bZJqSqPe/9WcyY4qdVun7ccR/Do878N7I8qKqkuUbeTb84GXyxvH1wuny4XT6ys/3t6YpkSe50gp/8mNEAK/vid8fWR5OrM9nFk87Nken4mLFSHOqI1BFMX/CYs8x853uLSiWyaElGRfbsmzbCTLbin+kAmE+IuwLEtsSkzuN/QTizaKUiuqWo6phgdHipwiy8ZTfCIaJh2FsqywXUeTeuwq4jYzmnlPs5yimxbbB0zn0dZh/ITaOqQQo+Aj79IbKQp03KH8EjVdU0+X+Pkav30i7k8sD2dm+yPx8cT8cGb+/QXjGpRSSFVe+SWhlNzVNXVao3dHms2e+PBEWm9RztP1ntpPKeMG7RPtfI1rW0wXKP2Cqk/I8u6adBAqJamqikpr9GyLmSSUtlTGXTsbyDPE0N3AeC+uid75+CmyLAixI20Ci8fI7jCj7wzWOayfXukDd8aibEvVTdC1uQqGsaX6TSglIXQE39C3lq51hNDQeI8NEesnuBDRQ2+uo+oj2phxdT5bm59BfiES78o9rwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"执行构造函数\"\n        title=\"执行构造函数\"\n        src=\"/blog/static/1432b8761f07738688fa565358af68b7/1bba8/executeConstruct.png\"\n        srcset=\"/blog/static/1432b8761f07738688fa565358af68b7/63868/executeConstruct.png 250w,\n/blog/static/1432b8761f07738688fa565358af68b7/0b533/executeConstruct.png 500w,\n/blog/static/1432b8761f07738688fa565358af68b7/1bba8/executeConstruct.png 642w\"\n        sizes=\"(max-width: 642px) 100vw, 642px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberClassComponent.new.js#L581\">adoptClassInstance</a>中在实例上注入了updater实现了组件的更新注入能力.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 758px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABRElEQVQoz1WR0XKbMBBF/R1FQkICIYSREGC3rk3cpk3+/49OB+xk0oczV/tyZnX3UBqLDok29ixLT54C849Imnt8ytRpweUzNgzUsacOnjZO+HGmOQaabZ4idVMjheCgjcLnkeHnzHDOhCVzunT8XQO3qeeaPesycB4ctTHYqkLpB6aqMFrTGINSirIsOWitidcX8u838usbw3VleVn59f7K5XZi/XPndr+QBocyCmXVntsi2j5Qz5RSPoRp9KSpI06Bboy0OWGPAZdHmjHjUkQbidLiM1UlqRq9Y565C1VZEodEvL9z/H6jn057R12a8TsTTddThYRqjw/8gHYdUsj/2L9srcE2DuM8la0xrsW2Htt2O9ust47agHLdk4Bu2l3wlX1DY7dCS0Txbb+SEAWi+IIokFIgiwIpnny8pfwUfUj/AfXDysLcW3bxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"注入updater\"\n        title=\"注入updater\"\n        src=\"/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/c8e86/adoptClass.png\"\n        srcset=\"/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/63868/adoptClass.png 250w,\n/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/0b533/adoptClass.png 500w,\n/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/c8e86/adoptClass.png 758w\"\n        sizes=\"(max-width: 758px) 100vw, 758px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>发起调用</h3>\n<p>在组件的实例化过程中,注入了提供更新能力的updater.调用的逻辑其实就是梳理对应的updater如何触发页面的更新.通常调用setState是如下的方式:</p>\n<pre><code>this.setState({  })\n</code></pre>\n<p>setState是挂载在组件实例上的方法,在创建类组件的时候会调用React<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react/src/ReactBaseClasses.js#L20\">类组件的构造函数</a>来初始化实例.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 723px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB70lEQVQoz22S6XLbMAyE/R6WRPDWQdm6bCdO4jTt9P0f6euI8tiTtj92FiAxywXAnU8G7RXaCcYLJghiq4z13ER5xGIl19nWZC7LkqqqvmFnmog4iwoGaRwSLMp5bAz41GLrQOgTfq0zCqW3x1f+WywLSrcQlxv97Yt4vpCuP7FpxoYG1/RYXxP6CesCVVlR7MsHyuKO8sk7XXfU84nxdiPNR/qXF7plRtvVTYnSFUo2Fre1LFahg87xlm+8OQwB23WENuKnAT2fsdOMbTzaKbTfitcHdJ7xXcjLP3kW1NFRzw3dpcOniO1qXKpxjWO9c31AR4uJDhNtdpZFVsE1rvVDfHPoIr470C5njPPEfiB0B4z1qG5C9SfkeEEOJ0yaUEooi+I5t+L7LHc6Bipn0dZhfMyiJkRMCJm182htENkcVKr673afW+47VLu2mIiHCd/2mdfNNtM55946rDEU+z3Fvrhj/+0fZsfZ4ZgwQ0s8JprlRDMODGPNcawxwaHbhD8OtPNEuyy0y0w99PQvr6RholKKongK72zf071dGH9+Mr2feP0xc/2aef81M1xn4jLRX88cP64cP95I55H5943x80qKgaEJtDGg7iPZxbqhLAXRDlGC0Ru0SM4rpVErxGyoJPN6LqrCrrVaHm3/AZ0jV2qMuOQFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"baseComponent\"\n        title=\"baseComponent\"\n        src=\"/blog/static/2ae56cda731fe7c84a8d82990745f055/c67d4/baseComponent.png\"\n        srcset=\"/blog/static/2ae56cda731fe7c84a8d82990745f055/63868/baseComponent.png 250w,\n/blog/static/2ae56cda731fe7c84a8d82990745f055/0b533/baseComponent.png 500w,\n/blog/static/2ae56cda731fe7c84a8d82990745f055/c67d4/baseComponent.png 723w\"\n        sizes=\"(max-width: 723px) 100vw, 723px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在调用setState的时候其实是调用注入的updater(classComponentUpdater)的enqueueSetState逻辑来实现页面的渲染更新.\n在classComponentUpdater中主要做了:</p>\n<ol>\n<li>创建update 形成update的链表结构(updateQueue) 在更新阶段会依次处理链表的update</li>\n<li>通过scheduleUpdateOnFiber触发更新</li>\n</ol>\n<p>在<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L456\">scheduleUpdateOnFiber</a>中获取到根节点通过ensureRootIsScheduled发起根节点更新调度.</p>\n<p><a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L632\">ensureRootIsScheduled</a>的功能是在根节点上调度任务的执行,主要功能如下:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 759px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 125.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD+klEQVQ4y32V2W7cRhRE9RnJDMneSPbG5q7ZR5a8JDYMBHnK///JCUhNZFm281DongFYqMuqW7yTpUWFhBsb5nPL7tJzfNdxOiWGNmBjom4CfmwxtsbUjtIFSudwfcJ6hxCCPM8py4o7qRTaR6phpAiR3Do+7Cv+Piq+ToJKFWSbLWK7Jc8ysmxLtty3W4rbfwtZURTreSeKgjokmvmAdR7fz/huIkx7bOqpfMSNO2w/44Z7/LRfT9dPGB9R3Q5Z+5V4Ib0rhUS7BlEHZDOg2hnZjAiXqKyl7TxDH+m6Z6Q2UlbVi6r/sPzOF0IlBFUcMNMFffiAuXzGnP5A799TT0fSOJGuT7SPn1akyyNxmF4UrUSvR1Y2YJQknhLtx5F46fCHlnBu6Z5a4j5g+kg1J6oxUo0BZfRPFa4jS2MwStNYjykleb4hz7cImaNKgVBiNeA7vCF7jTtVLlEocb3DthbbLXGwGK/INhn5ZkOe3dxcHf025s+wxsb6RHr6RPr4hf7zX8SHpzV7dVxcnFFpRDWL4x6pnlULuaCgEMV6rvdVofVIUSCtRjclJpXoaKiHGjtZ7D5Qzw6789jRop1c1RsvkZXAOPWMoJFacCetR2vJcIpMDw3jNTJeIuO1YbhEpmvD/JiYHhLd3uM6T9Va4j7hR7eSLypfTFnWpi5Ldqc9+w+PzA8Xdo8PzOcTqfU0raNJjhBqQqiwwSPLmirc8ljkb1yWEikkLtR0UyQuBL0nNJZmUdLWpM4RfI3Wmu1qUsZ2s6xg9mMOl5drTMn9MDDdt4RUEzuHjZbQOkLniL2nGQJlXa4PSvlsirxBiDcKlZI0yTLMka539FNEDztUN6LHe9QwI1NH4RqcqxiHQNt6hiEyz4kY3Zt3aD2u6akXdBOq8hTGkmX5OlaWCwqpKJRekQtJIeVKkv3QNkIQm477658MT19JX/7BXz4xvv9Id76yO0w093tEM6LStEKEltI3yKUHfzBFCJZwh8OZ4fE9/fWR8XplPB0Zjgd8ainrmrKqKdaN2VLctubtHt9Mkdi6JpYaq3NqnWFNQaUFlZFIbSiUQVf1bcQbbvfXZDdTBNYuJXpFzVfk/IDoj4g0U/iesirpF5cbS9cHpqmh7+OazSWny/Ovy2IdecnX8l1RsUc3A9I16NoilURptaZgjYl4HZVnvFb34nJZW+LhgXh8t56uG5iOO/oh0XUe758dz4ufN813Iy+ExhjaeWa+nOl2M/1+x/3lxDT3a95i1yIrj2uHdZpfletz22iDMRqpljz9Rp7/TlFsEGLBUqibb7j1YVHkvyzZO2mqtffSeSad98TDTNwNuClR7eb1wyVDh/QJqfT/tvVC+C8D+9HyjMLmcwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ensureRootIsScheduled\"\n        title=\"ensureRootIsScheduled\"\n        src=\"/blog/static/df31f836b5cc428cf2864f9bdd7254d1/ef3e1/ensureRootIsScheduled.png\"\n        srcset=\"/blog/static/df31f836b5cc428cf2864f9bdd7254d1/63868/ensureRootIsScheduled.png 250w,\n/blog/static/df31f836b5cc428cf2864f9bdd7254d1/0b533/ensureRootIsScheduled.png 500w,\n/blog/static/df31f836b5cc428cf2864f9bdd7254d1/ef3e1/ensureRootIsScheduled.png 759w\"\n        sizes=\"(max-width: 759px) 100vw, 759px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>根据当前任务获取优先级通过Scheduler发起不同优先级的任务调度</li>\n<li>同优先级任务合并,不发起新的任务调度</li>\n</ul>\n<p>setState是SyncLanePriority优先级,在调度上就会通过微任务发起调度逻辑等主代码块执行完毕后开启微任务执行(调度更新)</p>\n<h3>图解setState更新逻辑</h3>\n<p>假设我们在这样一个场景中在一个函数中连续调用的两次setState</p>\n<pre><code>this.setState({  })\nthis.setState({  })\n</code></pre>\n<h4>第一次调用</h4>\n<p>在第一次调用setState的时候在fiber的根节点上创建了updateQueue添加此次的更新内容,通过微任务发起调度.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/00a176694c87a68e767f39aea74c21fa/61016/setStateFirst.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/0lEQVQoz41S266EIAz0/3/TC8YLRBBBFLuZrt24J+6efZhAUzqdTin2fadt2xg5ZzqO4wXkBMjdvc3InXmgWJaFjDGktebTe89A3LYtNU3DMYpTSvzGWkvDMJC3lqwxNGlNKYQnYQiBi7uuo3meuQgAyTiO1Pf9G+E0TeScY9I1BPLOMVKMT8IYIxdCDch5jHMcxFAk4wLSkG242CNveGQoxAhQKF6gkVIt1XXNisRTyV/9vaK4Gi1mA+u6sjqoR9NvJG+EQnDtLKcsDI1+IXspvPse1jpegFgRzi1+J8yfCZVSVFUVlWXJd5D+/ZsfFOZbQiwCJADu8fwW/yl8AGbIDaEzSvt9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setStateFirst\"\n        title=\"setStateFirst\"\n        src=\"/blog/static/00a176694c87a68e767f39aea74c21fa/00d43/setStateFirst.png\"\n        srcset=\"/blog/static/00a176694c87a68e767f39aea74c21fa/63868/setStateFirst.png 250w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/0b533/setStateFirst.png 500w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/00d43/setStateFirst.png 1000w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/aa440/setStateFirst.png 1500w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/61016/setStateFirst.png 1770w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>第二次调用</h4>\n<p>第二次调用setState获取的更新优先级跟之前任务一致,这次只进行updateQueue逻辑增加任务的操作<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/b6e50/setStateSecond.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUElEQVQ4y5VTa6+CMAzl//9BEz8J4SWMMQGBjY3enGrRq3gfS5qWPk572hB578laS/M8k3OOQgi0ritrax3Lsiz8DY08iNRAIyYSAdC0LSmlqO97diKx6zrK85yyLKNhGLiJ1ppzLpcLlWVJ1+uV6xCHfxzHG2DbtreEYWBAYwwnAaCua26A6WAjhnzEqqpiIMTADjryIWyAmGqaJu6Mh46IoSkEMfggYsP/TtkY7giNRNlVmqaUJAlPIXsVHcLKtjQTibwPW+JKtBUAFA2wI1n8a/G7BIok0eJ6dwoQPAABFO93sCdAZy1VZUlFlpFWineI/RRFQefzme09ej8CAqhRNRmt+WJN0/AO87xg+5Xy3jcfRQK8wyfBDkEZx4J+BfkIuDc6T+0cnU4nOhwO/6B8v/InwDiO6Xg8MuDfruwflB80wlYMUPkDxPddhzfKX/ab9wsUR/UWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setStateSecond\"\n        title=\"setStateSecond\"\n        src=\"/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/00d43/setStateSecond.png\"\n        srcset=\"/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/63868/setStateSecond.png 250w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/0b533/setStateSecond.png 500w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/00d43/setStateSecond.png 1000w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/aa440/setStateSecond.png 1500w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/b6e50/setStateSecond.png 1862w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>更新任务执行</h4>\n<p>微任务执行,开启更新逻辑</p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"setState源码分析","date":"2021-04-01","tags":"React","path":"/react-setstate","top":null,"summary":null},"title":"setState源码分析","date":"2021-04-01","tags":"React","path":"/react-setstate","top":null,"summary":null},{"id":"e0bace90-1cb6-58ad-8127-8cfb29194aa1","html":"<p>本文主要结合源码梳理React事件系统的实现过程.React事件系统通过模拟浏览器的事件系统实现事件触发逻辑从而实现不同浏览器的兼容.本文从事件的注册和响应两个阶段梳理具体的实现过程</p>\n<h2>前置知识</h2>\n<h3>浏览器事件</h3>\n<p>事件的触发阶段</p>\n<ol>\n<li>捕获阶段(根元素最先接收到事件)</li>\n<li>目标阶段(目标元素捕获事件)</li>\n<li>冒泡阶段(从触发事件的元素向上往根节点传递)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/030ae70f0fe588d9c5d6d53043bb3559/9685e/eventBrowser.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVQoz4WTXa6CQAyF2SpvLoYlsAEXwrMIXA0m8AhEAQUE+bXmlBSQ671OUgZmpl9PO0Xp+57EhmGY5rZtqeu6acaa7C/PzjZ+K2sgBgBxHFOWZZSmKd1uN95/PB70fD6/AwGQjSAIqaoqhomVZUnX65W22+0U8B02m4KIYohqmiYDi6Kg+/3OQBz0PI9UVWWYnF2WSEyBIxQAUtc1OY7D77ARmDPAdV3SdZ1r2rZzbX8pPJ1OZFkWg6IoosPhwCDUDYGgEEFhx+ORgiAgx/kh27bJ9/03dawQDwBQcESAkwAlZcx5ntN+v2cnyUh83hQKGQOOmqaxCqQEVQAhNYChCgPnpY7LGuKmp1vGAmq42WwoDENqmmZShnUAdzvzn1v+0Ic4aBgGK0MfJknCcKknava1bf5q7Mvlwr13Pp+5uSXVZZpLP/lW1hG6blY7/nrdVJJPKa4VvgB7m51af9s2ngAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器事件模型\"\n        title=\"浏览器事件模型\"\n        src=\"/blog/static/030ae70f0fe588d9c5d6d53043bb3559/00d43/eventBrowser.png\"\n        srcset=\"/blog/static/030ae70f0fe588d9c5d6d53043bb3559/63868/eventBrowser.png 250w,\n/blog/static/030ae70f0fe588d9c5d6d53043bb3559/0b533/eventBrowser.png 500w,\n/blog/static/030ae70f0fe588d9c5d6d53043bb3559/00d43/eventBrowser.png 1000w,\n/blog/static/030ae70f0fe588d9c5d6d53043bb3559/9685e/eventBrowser.png 1336w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\">浏览器监听事件api</a></h3>\n<pre><code>target.addEventListener(type, listener, options)\noptions\n* caputre Boolean true 在捕获阶段触发 false 在冒泡阶段触发\n* once Boolean true表示该listener在添加之后只会被调用一次并且在调用之后会被移除\n* passive Boolean true表示该listener不用调用preventDefault()方法\n\ntarget.addEventListener(type, listener, useCapture)\n* useCapture Boolean true 在捕获阶段触发 false 在冒泡阶段触发\n</code></pre>\n<h3>事件委托</h3>\n<p>事件委托是实现事件处理的一种通用手段.通过浏览器事件冒泡(或者捕获)过程在目标元素的父元素实现对应事件的处理逻辑,能一定程度上减少内存的消耗.React正是基于事件委托来实现事件的处理的.</p>\n<ul>\n<li>event.target 获取实际触发事件的元素</li>\n<li>event.currentTarget 指向绑定事件的元素</li>\n</ul>\n<h2>React中的事件系统</h2>\n<p>一句话概括React的事件系统就是基于事件委托机制模拟浏览器事件系统来实现事件处理.</p>\n<h3><a href=\"https://github.com/facebook/react/blob/master/packages/react-dom/src/events/SyntheticEvent.js\">合成事件</a></h3>\n<p>React通过SyntheticEvent来模拟底层事件实现,通过React传入对象的nativeEvent可以获取到底层的事件对象.</p>\n<ol>\n<li>React通过SyntheticEvent可以更好是实现跨平台逻辑,通过不同平台的React Renderer来实现具体SyntheticEvent的封装.</li>\n<li>React能更好的做性能的优化.比如React在17之前的事件复用,需要主动调用persist才能持久化React的SyntheticEvent.在React 17中已经去掉了这部分逻辑.</li>\n</ol>\n<h3>事件监听</h3>\n<p>在react 17中,事件委托的绑定节点是React应用的Root元素,在创建Root元素的时候完成的React对事件的监听逻辑.<br>\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMLegacy.js#L287\">ReactDom.render</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMLegacy.js#L175\">legacyRenderSubtreeIntoContainer</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMLegacy.js#L113\">legacyCreateRootFromDOMContainer</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMRoot.js#L164\">createLegacyRoot</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMRoot.js#L110\">createRootImpl</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMRoot.js#L140\">listenToAllSupportedEvents(rootContainerElement)</a><br>\n以上梳理的React在首次渲染事代码的调用逻辑,重点关注listenToAllSupportedEvents的处理逻辑,这里完成了页面根元素对相应事件的封装逻辑.</p>\n<h4><a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L88\">注册支持的事件</a></h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 467px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/85ff8/registerEvent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABi0lEQVQoz2WP2Y7aQBQF+Y0J2N1eutu4bTde2OIFbCAhk0Sa//+ZijAK0mgejs7LvaU6izS1rFYrhBCIQOD7Pr7wCaQgkpLw0YEkjiRSPm8ekaGY7zzPm3/+92KdGjyxIlCC9TbGlBEqD0gPijgPSRqF2sSE6wCpJJENCU2AyiOiJMTzfHz/CZuBrk7wgxU6t9iDw40VebvBnUrWjcX1lqpNUSrCmBitY6IoRIhgXvbF0KYWXwY0tz9U0zuuv1Kef7Lpb9TXv7jdgW440vcNw9BwPu8Yhi37fY3WCinlC/acnCSIMHpCTlfK041qus9ddCPlMFG3LW1bMY47uq6e4cdjRVFkKKU+A43WCBnMgPr6m2q84/oLm/6CG264suDHtaHt6tnwdHrYlVhb8Pb2jeVy+Zr8yCIxBhkrdvePF7S+/KK+vLO9f1API91t4ntbM017zuOOcdzT9zuKwmKM+WxorcUTAlNsiNcZOnPofIPOCuI0Q2UOlVcoHeNcSppqrDVkmcHaBK31J+A/ZObxOpJI9VwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"事件注册\"\n        title=\"事件注册\"\n        src=\"/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/85ff8/registerEvent.png\"\n        srcset=\"/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/63868/registerEvent.png 250w,\n/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/85ff8/registerEvent.png 467w\"\n        sizes=\"(max-width: 467px) 100vw, 467px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4><a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L384\">在root元素绑定对应事件的回调函数</a></h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/0ef7e/rootListener.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACh0lEQVQ4y52Ty5KjOBBF6zemLQkhHkI8BBgwL9tdPTGr+f//OROiyq5y1G4WNxJpcbiZN/Vm84wptWznkct2Z74s3G431nXhuk9s+051e6f4+1/8/s79MuHKCp1m6DRB5xk6S4mUQkrJW12mzPoX07ll20aWZeD30vLPWvO+dtz2kd9/FvZLzVLHXHNFJgUnIZBBp88qJUop3vI8xyiFKzJKb3GNxfuUs0/ph5K2Lei7Au9imsrgqhilFUqqA/BQAB4OU5tRR4KLjVkmz7b0rJeOqU7YW8PWGK5NzOoT5jaMRyIDJDh66Bv4LXc5nRb4xHDuG/xtoV5X6n2mWwf2vWO9b8zXhWWbWIxGxTH6kDnqCzDLcmIlaWLN6h372HKde9bBM48j8xRAd7qmo608nW8pzheKbqAcZmxVo5T8ajnMUEpFXlhcaXEuoyjSo2a1J206krJCxAk6s6RlTVY1h/Lao6PoGcinwwytY4qmI8s/QEGx1ojTCSnFx8wORUgVIUIIQiDE6Ql7phyA4cPkjmoY8dMFf5lx3UBWV8RlxV9VT5ZblPP88hOinZBx8gzkxWGapkRRRGoM/jzSLleaaaWeb9TjinEFZV3hG0fblhgTI8QDII9xvaac5wewqCzt6OhGR3O2uD44bshcjC01udOkzmBsjMk1KnrdwSfQWntcZDalPnuqsDqTx54dZmzR44S83RHTStE0JMGhlIdL8e2FvLyUcEiShGldmG874zrTTz3tMGLbATvtFL6n6QfqtqUsc+qmoCztT4chlNByAGqtiD9lYn3sp1GCJCiSyEgfixzmmCQf9QcwgIwxB/SxnF9Sh8SnHvdfLcufLVdV9fKH/6PvDv8D+gnOAI7KStsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件\"\n        title=\"绑定事件\"\n        src=\"/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/00d43/rootListener.png\"\n        srcset=\"/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/63868/rootListener.png 250w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/0b533/rootListener.png 500w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/00d43/rootListener.png 1000w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/aa440/rootListener.png 1500w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/0ef7e/rootListener.png 1594w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4><a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L412\">绑定事件逻辑</a></h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2d77c3580045c4aec287855218f49bcd/6569d/addTrappedEvent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 136.79999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABYlAAAWJQFJUiTwAAADkElEQVRIx41V7XKrNhT0YzRGICQkJAQCDMYYY+J89ibtj07f/2G2IxE7NHGS+2PHgjFHq7O7R6soisDzGqLaoWwbdMMWu75BOzSougrNfgOVSoRhCPffn7AKgzWyzRa713/RPv2N9uEFYjqAPU/gr/dI9lsQShFSimhR9KsNViEhEFmO8nCCHSbYwwn1cEQ19LBDh2zsoMcOPFMIAwJCwm/ZriISIs0tysMdzPaAfDci3x1RdEfoTQdzGJEPI5QpIHMD2lZgeebZhm9Ml1jFPIQQAjyNwHUEJkOwNPJIDEfMKUhA/O6MUggWg8V0ZhleYRjHBEwqmL5H+/SAYuix2Tc4nFrspxpNZ1HXOdrWYtdXaNoCVZ37d7bKrxw5jMAYg92fUB7uUR0fkVUtYhpfGFB6Bn3D+/NnUcIQUgpUXpRbVMcH2H4EFxIkCC6K/i5WPCCQJgdPNRKVIUm1V13m1hcNSYBw0avlx8vn82lWcRgiEQKmq1FOBxTDDnYcYA97bxtlFYRhSDIGrhm4YmBp7NdOtMT9Zhw0nouvnPSCJSiMhekG5J2zzhvaHllhkZgSLCshdYYomu3iGdP3Hp/ZrvyLKIJUGerTMzZ3f2Jz9wvN4yu0rVGVGbqhQ7Nr0O02qCqDzSb3cMqfHaB1CkLIXDCOYw8nijN4ffsEZSu4FM09Im+4npBlPy8FnQWK/YTm/hdM00GaAlyk/8vvV4ovi66iaPZWKiWkMkhUDi41hLHgMp0/+o1CF4Yuep6dGxDW2YWDKxe3te/Jd6PqWgtWMZ9FSZRGOY2oTgfUpyOKfoQ0FqUTpSu9CE3jYmewaXIodX1G+uh5UWiMop9Qjo+op2eYtvfMvzTyFyxn21D6lufJK+xEiRn/du59LPxJ5TRN4aZ3cPMHgpsbn+P3WBGPn66BOSnhPA+3eQOd5WAyBUsEmJBgPEFEY5A4AWESNOZ+NgZXsLBNhJhSKGW8EEV/9CjHe2RVg6oqUPe9R7ffwmQp8lzB2gxFoS9rztnM8DzjuBBoHl7QPv2F7uUf1NMjEplCCg6tBbRKoJSATBNoLf16Cde2D0mJYLZ7Hz93C8ac++i5S2l5NOfNH4/sGXKOrNn5+Omq9evUFD56yym9nC5XRTmP8kLnUFwgigIQskZI1l5pt/t6HVzwkdEnHzJBQCOKVGvUY4/qdotympGkyvfLWu0FcM3PMumFYCy+mpT/AFUJAmOJILa1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件逻辑\"\n        title=\"绑定事件逻辑\"\n        src=\"/blog/static/2d77c3580045c4aec287855218f49bcd/00d43/addTrappedEvent.png\"\n        srcset=\"/blog/static/2d77c3580045c4aec287855218f49bcd/63868/addTrappedEvent.png 250w,\n/blog/static/2d77c3580045c4aec287855218f49bcd/0b533/addTrappedEvent.png 500w,\n/blog/static/2d77c3580045c4aec287855218f49bcd/00d43/addTrappedEvent.png 1000w,\n/blog/static/2d77c3580045c4aec287855218f49bcd/6569d/addTrappedEvent.png 1328w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在具体的绑定事件逻辑中,主要做了两件事:</p>\n<ol>\n<li>根据事件名的优先级生成不同分发事件的响应逻辑</li>\n<li>在捕获阶段绑定1中生成的回调函数</li>\n</ol>\n<h3>事件响应</h3>\n<p>React的事件响应过程其实就是在冒泡阶段处理不同优先级事件分发逻辑的过程,假设我们有下面这样的页面结构:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 662px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 120.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+UlEQVQ4y5WV26rCMBBF+/9fJYI+iC8iIuiDaOu93updq3NYqVOTGg81ENokzcyemZU0eDweoj1NU9OL79n4/Z2u+8aBPfl8Pp2uczR1oP1+v3uFBNliajbN53MZjUYymUwkisYyHo8liiIJw/C1OTOuTmznOCCKQD3QMHA+n0WbqlSDOGu329Lv980Tx8vlUqbTaa7YMcjC7XYzCyg7Ho+5I+Y6nY5Uq1VpNpvSaDSkXq+bORxcr1cjIND41SAbaXygDSUoSJK97Pd7SZJEBoOBxHFsnJ5Op1yIYxAlGF2v1yafbKCzmW/s3F0ul9d7Nv6oMpPkD2O73U56vZ7E8Uo2m40cDgcHDR8yXmzshkFVpNiU4lCtsxl15Iswa7WahGFkQl8sFo4S5dAdp59VBo/tdmsSrGyRcM3h91NUCFkNzmYzY4wcgs1wODRrzP8QssthhkdiQl2tVg42tkIN8cvRu+fYEDIMggVPOFOl/+cwGwd2hYEWlRSh1WoZB4QLOjZrP9022rSyP2NTnNB8clapsN4mpavsnuWZuVFQ1+1286NIDotOizn0YkM1gZvCUGnt8PlTyGoQVLjfYLBSqRigQQelvjC/Hj0bG80ZYeo8Cr9h4sXGBht15JDQefpyWBobJgGaa4wK03n3XVulDbp/vfffr2xR/gAJ9ExAqedGIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件逻辑\"\n        title=\"绑定事件逻辑\"\n        src=\"/blog/static/94e1459206a4767463eb204c53278e46/be86f/pageStruct.png\"\n        srcset=\"/blog/static/94e1459206a4767463eb204c53278e46/63868/pageStruct.png 250w,\n/blog/static/94e1459206a4767463eb204c53278e46/0b533/pageStruct.png 500w,\n/blog/static/94e1459206a4767463eb204c53278e46/be86f/pageStruct.png 662w\"\n        sizes=\"(max-width: 662px) 100vw, 662px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在上面的页面结构中,App组件的div中绑定了click点击事件.那下面从这个div的click事件响应的触发逻辑来梳理react事件系统的响应过程.<br>\nclick事件在响应过程中的优先级对应的是<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L368\">DiscreteEventPriority</a>,对应的事件分发函数是<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L122\">dispatchDiscreteEvent</a>,在dispatchDiscreteEvent中调用<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L160\">dispatchEvent</a>来完成对事件的派发处理.在dispatchEvent中主要调用<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L195\">attemptToDispatchEvent</a>来实现事件的派发处理\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 665px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACb0lEQVQ4y42U25KbRhRF9Rd2jWj6QnNtBAiEGIGQZI1Kk4mTOM6D//9PVgpky0lq7MzDrnP6ZfXm9OYsjDG4OCF1MSZPMS7BVTHNNqOqU8o6od446i7HxgE6UtjMECR6lok0OlRzP9WFkpK66WlPL6yffqM6XKlPe7bPR5rnI+XQkhQZiUuQvsTzBGIpEN7rWkjpo7MVbn/BDRdcfybf7Kj2WzYfBsp9h6tLbBLhLZf4vv9TLbSUhEVNOl5ZnX4lejyQjgPN0zg7rI49xlpkEKC1/ilMCMHCRAlhElK0GevOUQ4FzVhRbnKyrsLtKrJhTbqriMqUByHwHh4Qy0lLhDfJm2GzQzPdHDvCuiUbTyTjB5LdwOPTgW5b8jzmfP7Y8vFS8ccvDZfLgNudyPdPZPUWGcYoGzGN7uYwjJBBSLypKA89bteSFimfTzFfLiFfLhF/doZPreKvR8OnPiLIK1Reo/P1XKezVuoGDJOMyDXk/ZHV+QV3upB2PaYdMd0B22x5Z1e8twXvghXvgxVemN9kc8S3PioQccHCTrmKImxmsc7i+xJfKqTSyKlKhdIaNZ3/If+VOmkRWE3mYo7PPYdrTz921LVjs8nZbguaJqfrSrI0xvO8ry8qfqjF9KcobSiG8y3U5xdW3YAO7AyY5nLX12gI4f9QM1CbCXhic/2dajxjkxQdBPcofM+Z///Bnh0qxerxwPp4JW97wjSfZ3l35ok7/L+XvAq04fQgCTZLsGlCmDtMaJDaRwUSFag3we7AKIwoMofNMoI0QgUCE9+2x7RNpk3iyzcCJ3cT0KoApS1Sme/bQ4h/9W/55L8B3fXQMpznV5sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"触发事件逻辑\"\n        title=\"触发事件逻辑\"\n        src=\"/blog/static/a2c6e09fbe8033f2e125bf216f32261e/5f4af/dispatcheEvent.png\"\n        srcset=\"/blog/static/a2c6e09fbe8033f2e125bf216f32261e/63868/dispatcheEvent.png 250w,\n/blog/static/a2c6e09fbe8033f2e125bf216f32261e/0b533/dispatcheEvent.png 500w,\n/blog/static/a2c6e09fbe8033f2e125bf216f32261e/5f4af/dispatcheEvent.png 665w\"\n        sizes=\"(max-width: 665px) 100vw, 665px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L250\">attemptToDispatchEvent</a>主要通过原生的事件对象获取到实际触发事件的元素和fiber节点然后发起事件处理逻辑.\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L534\">dispatchEventForPluginEventSystem</a>中最后调用dispatchEventsForPlugins完成事件的触发逻辑.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 718px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.20000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACtklEQVQ4y5WT4XKbOBSFeYsmBglJCIGEQYBjGzu202TTtDu73dl9/4f5dkxaJ+mkP/Lj09Uw0uFczbmJW0bW3/6lPT7RHr8y3u3YPB3YfD0xbAfaPjAMDV3n6ftAXTuyTCClvCCEuNQkV4p2OhIP97TTgeW0I+5uWJ12LNcjVVwitWZxvWCxSMmy7HL5p9Br0UQXlpunf2aX8fZEf3dL/3lPfDxSNp5cCPI8f9fRuw6LwrLc7QmrNdUyEkKgawNd31I1HineXngt9B6J0oay7VmuJ6p+hWsjtvKEmwkfVyitEfPh/Lcir3+UnNspnMJ4ibKCopaYKsc4iWtztE7Jrq4Qi2uyxXOd91lKmmZv3vTZYZ7TxpGw3hLGNc16R4g9thswqx1m3KHHPabfUowTut9g4hpXe3yocc69dXhemjjQ7T8TtkeW+3vCsMbELWr6gtk+YKYHqmGDH0ak80hbo5TGGDNzeeNnhxJtK3Ktab1meSYU9G1JcBqrFbYsKUqHsSXWFlS1pYoNta/IFtdIkSGzZxJlK1Q74jdHusMDzfYwt15tp7mquiP3PcrHZ+oO7TtMEzG+Q9qALF9IlClphhu0a8jdEmk9Qru5LV16pHYIZRGqnElVyXXunlGOha4upLoi0SondCXNqsQFQ90WVK2l8BpTK2yjqfqCqjOU0bIZBE/rBX/0VzwOP4if+DJ84tRekWit2E49d3crDrcDp9PINA3EMVKUFplLcpXPSJVTakEoUrx5SzAptc5IpBBU3nP8/h/7b3+z//M7yxgJvkSfQ52Jy9yeyYQkzSSp+IUf35I8lyhT0Ewn2tsHwmpCl9Uc2Jc4vMRCzvvfk+RSznG4efyL8f4b/eEeU9gPze+bWT6PXukcRe0xrqaoPNqWHxa6CFpr57Sn6QKRpWRpivhlPj8i+D/4zQP4aPV0xgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"触发事件逻辑\"\n        title=\"触发事件逻辑\"\n        src=\"/blog/static/55b63edef27c0d88877678a01ccc9f9f/57dc1/dispatchEventSystem.png\"\n        srcset=\"/blog/static/55b63edef27c0d88877678a01ccc9f9f/63868/dispatchEventSystem.png 250w,\n/blog/static/55b63edef27c0d88877678a01ccc9f9f/0b533/dispatchEventSystem.png 500w,\n/blog/static/55b63edef27c0d88877678a01ccc9f9f/57dc1/dispatchEventSystem.png 718w\"\n        sizes=\"(max-width: 718px) 100vw, 718px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L273\">dispatchEventsForPlugins</a>主要是从触发元素中获取相应的事件监听函数然后依次执行.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACt0lEQVQ4y32T2XLbOBRE9RmxCYDExk0iwU0Uqd12nEpmXqdqZh7m/z/jTMmSK07s8kNXEyjcRjfu5cI5h86WmGogrQLjpqUdKuoxEIaauq/ouxWpswghUEohpXzhj7AwWmPSjHr/RNg/MJyfqbcz5WlmeZ4pzzNpWKHLHJXEn4r9FPQp7fkb3eMPwu6BdL/HH2bs4w5/mrF9gwkrEms+FHy7tzBGk2hD2J4J+0fKbk21Hen6QHjcU65bEp0g7yPUm0L5m9grL7x3aOtIDweq7Q6/rHDliiTz2LC8Okv9y/tFUnInxLVYyndiF15Yaymtpe02FHWP7bbYfoe/oJ2oi4zjtmWeGo5DxdPUUdQt5TBRtGt8mv4auc4TJqMIRcqwLuimQLepCX3NvF1xPAYOh5r9vmKeCg6VI8iIKI6J4/j9G1a545AmPGwqvh47nk8Du35Fk9zTO0lvBZ0W9EbQesWQRFQXQanexb5Fdug4xrcj6faRdPeVdHMkUTGxkMTyDW7rl4a88u8OvffESrEaJsbnPxmfflCuKuTdl5eCj/BT7P0ILZzz6Fhh6w43n3GbI7pZI/KKJEnejIr8FFJezyyc9wilMN2G9PSd9PBM/vAHbn5AxAn3UnIv1ad4FbvwIrOWTium1ZJdPzDVNdu2ZZ2nVCqiUoI6vkGJ6/rGr9/6rcOhiBmNYplrmqBpWkPTGJZZTFVo2t7Rdo5QWwqjyKQgU5JcCbyStLdL729dX8ytoYgVSeMpDyXZlOP69IrgyHqPTC6xrn9KJOSVpeSLkKQXp7EgUuqluYsu02xzzV97w78nyz9Hy997w39PjvUmcFcPiDASVT22WFK0A3nTU3YjWTfSZJ5aRUSXMbsIrpzllBsOXnJ0guOFveDkJWsbE4yhtZrGGXqTMDjDYPWVnWHUV5fiFvl/hIvsXePavXkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"执行逻辑\"\n        title=\"执行逻辑\"\n        src=\"/blog/static/e0440598172879af25eb01e9f8c9a669/00d43/executeEvent.png\"\n        srcset=\"/blog/static/e0440598172879af25eb01e9f8c9a669/63868/executeEvent.png 250w,\n/blog/static/e0440598172879af25eb01e9f8c9a669/0b533/executeEvent.png 500w,\n/blog/static/e0440598172879af25eb01e9f8c9a669/00d43/executeEvent.png 1000w,\n/blog/static/e0440598172879af25eb01e9f8c9a669/844cc/executeEvent.png 1306w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>图说React事件</h3>\n<h4>事件绑定</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/c5bb3/listenEvent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 144.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRklEQVRIx51V6c6CMBD0/R/M+5dG8T7jCeKJB1D3y+zXbSqKok2atmCHnZ3ZNXc+n+l+v5NSimKleP11AicHQAaLY4rimNdfJ3AMoIDKCzkn38mMosgwegYUynhhUXgFaI+He8kIHyLQ+bR/KPuN79Nms6H1ek232+0NYAplGxA0u90utVotqtfrdDgcWIivcxhrBdOGBMMqXy4X8wIP7Iv2OQgCWi6X5Hoe08V0XZefmdwDED88nU6ESLHHB7DijCnnxWLBU57jGWa/3+dcGsrH45EajQaVSiWe5XKZZ7VapUqlQk3HoWKxyGAAwEBkuIeBCG9haFKUu16v/IV2u03NZpMT3ul0aDAYkOM4VKvVWNXdbmdAECHuGEC93+/3/6JInpL5s1dEBXqr1Yrm87lJAQIJw9AI+lh6UfRfAXY1WHvkEysAEQ0ik/w92OZuOV6lVAorrqMfDofswaRtMgOKbWazGfm+z4KBvud5TFsifOo2aZWCsXZd9p58ACtyNxqNTAli/VgpAgil4VdQBYj4DyJhRXTAeqKc7DYCCHqgDVG22y3bCEMAnxvshwhhG3hTOo2rU2DbJr19vejEuATKKITxeMzAUoY/2UbEwABlfMDYJqlyFkDsAYTf5/N5pg+BTkFg3n+VQ/gPFQLaEAJnAIJ+qCsqc8cWQAghwGgKUBp7FkXf+UjZBoQQiKpQKFCv1zPVE+r2pWzKKoNtAComl04/mUyMDzPbBgzQC3EZFKWFIbrpdPqjbTL8SalvbfP2rEvvD19u0smyeaCTAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件\"\n        title=\"绑定事件\"\n        src=\"/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/c5bb3/listenEvent.png\"\n        srcset=\"/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/63868/listenEvent.png 250w,\n/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/0b533/listenEvent.png 500w,\n/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/c5bb3/listenEvent.png 680w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>事件响应</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/d9b5d/eventSimulation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABz0lEQVQ4y42Ue2+CQBDE+f5fzj/UGGtiitSigoK8lIds89uw9OorJdkcDrdzM3N3erfbTbquk2djXddyPp8lz3NJ01Su16v0ff9yPqNnL1bjhL6XsizlcDhIlmUSRZEURTES3tcDIRMh4TfFg6LtdqukjJfLRXEjoHqnRwntIyriOJa6adRmGIZyOp20ILMRvGkayYti/E40IyEr8JBR27a6Ig1BECgxqpI0laqqtPnT98dmnizP1Ykp9/iBus1mo2M5NO52OyUEM/tJksh+v9cRnMW+w1Ax3hHkYXMymchisZD5fC5RHKsaCFAKOYrYaRfH0Xq9ltlsJtPpVN9b2xTKLNPAIqgAY+yHHXdxChylLGS77bEaALI5FpYjlvlmx8RGcNtIzXAgHDPkx8dqJcvlUnzfl3OWyfF41EbUjAqrShVahuRLHNbH0dIMmcy2o45VCZfJNJMbzeBYtgNuNwcxwdeXHiWz7XV2QEVUCRmikNVpghycBhe33bfHInl69f6T4asr+Es4KMU+drGBIpTQTBTYtRuEbe199+eg1rgZSaJB27FhTlGWf3DK7X0kHKzajUAF+bkZQgKOauqtQpcYexBDwlGwby4+5nZH+ANo8SR51FsE7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"事件触发\"\n        title=\"事件触发\"\n        src=\"/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/00d43/eventSimulation.png\"\n        srcset=\"/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/63868/eventSimulation.png 250w,\n/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/0b533/eventSimulation.png 500w,\n/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/00d43/eventSimulation.png 1000w,\n/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/d9b5d/eventSimulation.png 1224w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>React中的合成事件和原生事件的关系</h3>\n<p>React的事件系统是基于原生事件系统在捕获阶段事件触发事件的回调处理逻辑,原生事件的处理逻辑会影响合成事件的触发逻辑,我们通过几个例子来看他们之间的关系.</p>\n<ol>\n<li>原生事件的stopPropagation会影响合成事件的触发逻辑.</li>\n<li>在事件更新中开启了isBatchingEventUpdates,同一次事件处理过程的中更新逻辑会被合并.</li>\n</ol>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"React 事件系统源码解读","date":"2021-03-28","tags":"React","path":"/react-event","top":null,"summary":null},"title":"React 事件系统源码解读","date":"2021-03-28","tags":"React","path":"/react-event","top":null,"summary":null},{"id":"8080f2de-e3d4-5143-a419-b85bc551c360","html":"<p>本文通过图解的方式尝试生动的叙述React渲染组件的过程.</p>\n<h2>前置知识</h2>\n<h3>react渲染模式</h3>\n<ol>\n<li>Concurrent 模式  异步渲染模式,实现了基于任务的时间切片等特性</li>\n<li>legacy 模式 同步渲染模式,现在主要的渲染模式</li>\n</ol>\n<h3>react渲染阶段</h3>\n<ol>\n<li>render阶段  基于已有的Fiber树(current)构建workInprogress树 在workInprogress记录了需要进行更新的操作(effectList)</li>\n<li>commit阶段  commit分为以下三个阶段:</li>\n</ol>\n<ul>\n<li>before mutation  此时dom节点还没有渲染到页面中,执行getSnapshotBeforeUpdate周期函数和useEffect钩子函数</li>\n<li>mutation  渲染DOM 根据effectList的tag标注进行dom元素的更新,删除,替换等</li>\n<li>layout 执行useLayoutEffect,componentDidMount,componentDidUpdate等相关逻辑  进行current和workInprogress的替换</li>\n</ul>\n<h2>图解渲染</h2>\n<p>我们先假设我们的身份是React的好友,React是前端世界里面的一个一流的画师,我们希望他给我们画这样一幅画.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 370px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz4WS7Y7aMBBFeQsg+DOJnQQiCA3kQ93AgirBj+5WVd//WU6F0dK0u21/XNme0YzH53qSZTlKLCi6M/70g3xdo5TCGIPR+iGpFErKkPuXJmmaIqTEKIHf9khfstp37J+OdGXGabehWhUorT9sIKX8TRPnXNgYa4mTBL874KqWxBqiKEKKBfPbKmU4R9EixOTiHns3ofc+JKyNiWOLL1b43YBdVrRtwzAMQUVR0DQtz88D2aYm3z+xWpehVmv90KihJY7jMJnbNOw/H3l5+cr1eqXvey6XC6+v3+iPJ9yyJC23uNwHrnqEY5Ikyf3JxmCNwXmP2/a0XUdd1zRNEy46n88MhwMmX6OVRERzhBDvOAZT3hjemhfVjuTTgE098/nswW86nTKbze785IjbHxx/uawVebHEbHrSLA+FY2ffGI3d/fDb3FxWUlBWNe74nbz/QhLbvxb87x/+BPj+AExOixcKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"画的模板\"\n        title=\"画的模板\"\n        src=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png\"\n        srcset=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/63868/draft.png 250w,\n/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png 370w\"\n        sizes=\"(max-width: 370px) 100vw, 370px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact大师稍加思索(babel)就把画的模板构想出下面的两张蓝图:<br>\n元素的语言表达\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 703px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz5WS4W6CMBRGfY3RFiilBaRUpsLEOZ3b+z/TWVozf22J/vhymzQ5Od/NXemyRDuLnWc2m55lPzCOPet1i1I5eZ6jlErzkax0VVHmOcPhTD8dca4lE5KXLEugX9ij0JUxhmhZWUd3uRCOC4dpYJ4Du12gqqrnDMuyJCZXEtO09PM7wXtqUyGkRMYIgZQigeNbSYmQKv1n8S3Evc2qrutkURQFxjma7yvj6cjneeL69cb5PBHmBT8f2dgKv93jlwtbv+Y09ny8euYx4FxzA1pr0VonS2tritZhnMH7lhA6hqGj9QN111PrEtcP1G3H2ho6axi7hjEMSShVbprmZmcMzjlyKVGxjpD3PFU5QmLlaBr39ejy/z8brRMwzmdP5C/gD6QJ/B4bz1bsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"语言表达\"\n        title=\"语言表达\"\n        src=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png\"\n        srcset=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/63868/structDraft.png 250w,\n/blog/static/15014ea5ae1e57d91a06216d3982962b/0b533/structDraft.png 500w,\n/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png 703w\"\n        sizes=\"(max-width: 703px) 100vw, 703px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n元素结构\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 868px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 102%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQ4y5WU6Y7CMAyE+/4vyB8kJG5oOXogrrZBn3cn65Z2d4lkJXGd8dhjSJqmCXVdB/am/jmz+3P/u/f72ESXvvnA5/P55otxdQ+ww+D7zMrzPKxWq3A4HMx2u51Z27ZvDD3zN4aw4dHxeAy32818l8vFkuz3+zBWkdiOMgQQIBKw8w2Gihvt4RhgkRdhs9kYyHa7NXZjJf9bFFZVVaEoCjsDJoE+Ktlnhd18PjefV/vjklFZ5aJ2lmWxh/35/LVkqXw6ncL9fjfwx+MxqvLgHOLsMxQg4NfrNQIOqewt8RnEUGIAkKapGcOdpVkU588eemOgy7I0W6/XYblcxjuJNJ9DkxEBySpms9nMRuV8PtuAw44WYPhgvFgsOmxjyUKuysqUJHA6ndpDAPSIBXNiaMVkMomt8OUnEoGPNB8nquqnRmnqKwkYJ7HCzzv2DkMByqk/AwUrBtZSXKMEQxGIgPp3wdR8egjDqHz7Newkoc/EcKd8L1DiZwoQgrTTM5L58fAxMCam00N/6a+hAZZAWkoowBehpBywowW5SAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"元素结构\"\n        title=\"元素结构\"\n        src=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png\"\n        srcset=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/63868/draw.png 250w,\n/blog/static/9f629706c2e341539b8d92bc7a0db691/0b533/draw.png 500w,\n/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png 868w\"\n        sizes=\"(max-width: 868px) 100vw, 868px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nReact真的是一个画术大师,他有两个最出色的技能:</p>\n<ol>\n<li>在脑海里面构想画图(workInprogress)然后一次画到画板上,画出的画大家都称赞道奇(首次渲染)</li>\n<li>在已有的画上修改(current => workInprogress) 画出的画既有原来画的痕迹又有新的神韵(触发更新)</li>\n</ol>\n<p>React欣然接受了这次的绘画任务,因为他很喜欢每次作画后大家对他的称赞,于是他开始作画了.</p>\n<h3>构思(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L991\">render阶段</a>)</h3>\n<p>React大师看了下自己空白的画布,决定先在脑海里面构造画的样子.React看到画的模板的时候第一时间是看到了各个节点之间的联系于是他对画的模板有了重新的构想.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 598px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQ4y5WUSa+CQBCE+f8/igN3Ew8ejYILsrjhAi5Am6+TNgPoi2+SzgDTXVNdNYP3eDyEuN/v8nw+5XA4SBzHkuf5O9brtZxOJ10nz2o+hecCNk0jaZrK7XYTBt8Z5/NZdrud1HX9P0AKsix7A+73+4+Af4EOALfbrRbTIkDH41FZI8XPDN1dq6rS4vl8LqvVSnzf101g3c/9CTBJEjVlPB7L9XrVZ4AxxnLc/P4GXt9lWgRkMpnoHIahLJdLKctSTSOXPKtx5wFDc5m2GWjGKIpCgQG9XC4argRfWzaXeW7bVrVjwDoIApWD2Gw2yhpQq7UYnEMOMkBmEME3WDFolzyAjUSn5b7AOBxFkYxGI5lOp3oWYU27rFurMMQo5HC7fAOaIWjFkaEAdzmTLgMYIQeG0QkbuVeyw5C2aAV2gMLAbY1iO/iz2UxnOkAWY9kBtJ8A75xBNsAAnIcRMyC2xmzfTEvP1Y9FBs9mgp1FdOXWsGY5DFh/BYQhorOz/a4Wi4UKz3faxDTyueesIwHRATRQ9EAz+w/CmKCQAjZiHddZZ0YSujFjBlePwn64m35ad2/MCzzXa7RrdkvIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fiber结构\"\n        title=\"fiber结构\"\n        src=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png\"\n        srcset=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/63868/fiberStruct.png 250w,\n/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0b533/fiberStruct.png 500w,\n/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png 598w\"\n        sizes=\"(max-width: 598px) 100vw, 598px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个是React画师特有的作画方式,还是我上次跟他一起喝醉他说漏的,哈哈我就这样把他的秘密告诉大家了,大家还是装作不知道让React来给大家讲他作画的过程把.<br>\nReact: 我在作画的时候主要思考了两件事:</p>\n<ul>\n<li>怎么把画的模板对应成更好解读的结构(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiber.new.js#L110\">Fiber结构</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1543\">performUnitOfWork</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L782\">completeWork</a>)</li>\n<li>如何在构思的过程中把绘画的思路记录下来在画的过程一蹴而就(effectList 创建节点)</li>\n</ul>\n<p>经过一番构思,React想好了绘画的思路\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 885px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y52U2W7CMBBF8/+fhQRIUF54YhGITewBwpaExJnqTDup24aqraWRrVmu7yx2kCSJOOdU8jyXx+Mht9tN0CP3+13SJC3tiH/2BX1ggCiKopDz+Sz7/V7CMJTdbieHw0EFW579EZD9er0qw+l0KqPxSBlyyb8YsgA8Ho+6A3S5XOR0Oqkty7JKoG+ApMOCTRRFEu7DN4ajkaYOIDYC8LXd4rQcBkgTACXN5XKpAJwBYI/jWGu4WCyUMb7EcMYOAcQuCtI01RS3260GrddrBfFv5qLJZKJCw7BTCpoGe7/GCgiD1Wolw+FQU7X0bIwAJP3xeKwXowNos9mUoDZ6CogCllCHgQG63GmwZYAfPugh0O/3pdfrfYwVDKmJpQcIyx8jdjpu6dpl/vrUFH9sqsbAasxu5akaH1iXKRs7U5qgNxCYAWSAvp8vPzPMnQZTO9Ltdru6W4pV/srQ/xy+PjEAo1Mk8/lcBoOBglcB/o7hew0BsadJPel8VUxZw2cMC/dRQzqN8JKshpUMnwFqU1yhbGq1mtYuiROdv09Nyd3PgPYv2tNikBlezvE91gEnbfs0fAIKaOOQPTJlg+CAM/W1C2ezmTSbzdKODlCLQcAJ5MnCCCDBfAYWYIBm/7qCVqslnU7nTV465bndbkuj0VBW9Xpd8KvSlbHv8got71ieyO6scwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"render阶段\"\n        title=\"render阶段\"\n        src=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png\"\n        srcset=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/63868/renderPhase.png 250w,\n/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/0b533/renderPhase.png 500w,\n/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png 885w\"\n        sizes=\"(max-width: 885px) 100vw, 885px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>挥墨(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1008\">commit阶段</a>)</h3>\n<p>在挥墨这个阶段对于React大师其实是小菜一碟了,因为费心的事情已经在构思阶段解决了,他主要根据之前的构思思路(effectList等)去作画就好,不过大师的作画方式还是不同于一般画师的</p>\n<ul>\n<li>在开始作画之前他要喝一杯酒,他私下跟我说这杯酒会影响之后的作画(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1800\">before mutation</a>阶段 周期函数钩子),我心想也是喝多了肯定不能画了吧</li>\n<li>在作画中,他又老能搞出一些新花样(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1818\">mutation</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1842\">layout</a> 组件添加到视图 生命周期函数执行),正是这些每次不同的新奇花样让他成为一个出色的画师</li>\n<li>在绘画后脑海中那个构思图成为了真实的画(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1829\">workInprogress => current</a>)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"图说React渲染流程","date":"2021-03-25","tags":"React","path":"/react-render-interpretation","top":null,"summary":null},"title":"图说React渲染流程","date":"2021-03-25","tags":"React","path":"/react-render-interpretation","top":null,"summary":null},{"id":"31eeff5e-284b-587a-831c-38d2fc3d52b0","html":"<p>React在函数组件中引入了Hooks机制使函数组件拥有了类组件的生命周期能力(本质上有差异),本文主要通过源码和图文的方式用最简化的方式来阐述React Hooks的实现原理.</p>\n<h2>前置知识</h2>\n<h3>Fiber</h3>\n<p>React为了实现时间切片,将页面的组件节点都进行了新的抽象-Fiber.通过引入Fiber结构React可以更好的实现组件更新的调度.Fiber结构主要有以下几种类型的结构:</p>\n<ol>\n<li>Fiber节点的连接结构,在组件更新时候需要依赖这些属性</li>\n<li>动态的运行数据(updateQueue,memoizedState)等,在渲染更新的时候会利用这些属性存储需要更新的操作和数据.Hooks的实现就是依赖这块的结构.</li>\n<li>Lanes 这里主要定义任务的优先级,Fiber Reconciler实现了一套新的优先级更新机制,这块在之后的文章会重新介绍.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e25e72a540b8d4ed7997271e175c0bff/9516f/Fiber.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAADcklEQVRIx5WV53LkNhCE9RjWMgeAJBgAxs1J2ZZ/uFx+/1f5XAtJt6dTSbf6MTVAgWxOs2caV2Hgk5oF+bRBH7fo+yOiqQiSGD8K8TzvW3EVhiHNYoveHOiPt4yrHUpr2ps1ejnhux6+718cV6cK9fpAu95TzVv648qCdfsVhSrsQ0EQXBxXeZFTtz1JViAzSakrVFORihTXcSzgtynHytjQqz0ilejlnigM8VwXz3O/R9n3PaKyQ5g57e6Wapgz3j8ji4IgSgniDM/1cB0Pd+bata3mtHdcu35jYQED3ycqe9Jmojs+0W6OZP0GNaxIVUE+GopekqgYNWWkKiZMAtIyITMpfuC/A30BzCSiKdD7jnJekY8leXeqMCCMfCIR2nWcRTafXg7jgDB9bSv3Jc4V5iXSaOrVRP9wS3dzQJYS0Q4IlRGEPlEa2ghf8499EtgPhkn4S4VaoaaGam3ITYY0FbLJyHuBqBOyVlAM0mZpUpvtWZWQd8L+gjNgPZI2c8z2jma+RRQ1absmjhOcmXMWxXFf8znezt5TVoa0GWyD18sdZdsT1z1pUeF7l0/Ka4UeUTWS1CP98U+qcY3uB+JE4PsBfhB8fPFrwJMoyopSTi1CpYjeIGuJ5zk419c4s+vXPMPz/Hd996GxX0TJkaam2Yw0mwV6t6TZ9IhckpuBoptQ/Zys1l+CnQGrAWFWTI//0N08Mz39S3d4otQtanlDOa6RtUaoitNk/R5QtQgzMdz9RXt4YLj/m3paISpjxzKKIpzrP3CdSymr1qrc3zxhDg+0h0erdlFrEr1AqvonAO8yyrJfs3j+j253R3/7TLe7JYwioqKx2buwfV5FEaRVhhobEhmRqpxY5i/2NbvGc50PrvI1YGlI6xazO1DPF2TDkmR+RAwbokwRJJIgCC+q8mxf9US7e8ScYn9v7xnZLSxw0q+JUmErvpByTj5ozHFOvR3J6oYoCAhlyenO8ay63xGlqBFaY/YbqrElLg1Bv7XzHLhnZ35z69+3TdEgdEe9XNOstuj9kaLtEIst2e6GrG0J4xdT/dmhP7lTTrOck48NejdQrwaazclYBdloKFc1WSuRTWq9781IPwVM4tgqGUqFrAyZ7slOExIlRFlNGEYvlN3zVfkl5dNYBZ5nx8qdzayzuNZV3F/EeG9Tn1X4P50bH358JSUOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Fiber结构\"\n        title=\"Fiber结构\"\n        src=\"/blog/static/e25e72a540b8d4ed7997271e175c0bff/9516f/Fiber.png\"\n        srcset=\"/blog/static/e25e72a540b8d4ed7997271e175c0bff/63868/Fiber.png 250w,\n/blog/static/e25e72a540b8d4ed7997271e175c0bff/0b533/Fiber.png 500w,\n/blog/static/e25e72a540b8d4ed7997271e175c0bff/9516f/Fiber.png 538w\"\n        sizes=\"(max-width: 538px) 100vw, 538px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>update</h3>\n<p>react在处理更新中引入了update的概念,在触发更新的时候React将update插入到对应的updateQueue中然后调度页面的渲染更新.最后通过updateQueue的执行来完成更新的实现.</p>\n<h3>React Fiber Reconciler</h3>\n<p>React为了实现更新可中断等特性,在具体的渲染过程中会维护两个数据结构:</p>\n<ol>\n<li>current Fiber树结构  当前展示的页面结构</li>\n<li>workInprogress树结构 在更新中添加了更新但是没有渲染到页面的结构</li>\n</ol>\n<p>在具体的渲染过程中主要分为:</p>\n<ol>\n<li>render阶段 render阶段主要根据已有的Fiber节点构造对应的workInProgress节点 这个阶段实现了任务的中断,优先级任务处理等逻辑</li>\n<li>commit阶段 commit阶段主要根据Fiber节点的类型不同来执行对应的更新操作(更新Dom等)</li>\n</ol>\n<h3>Hook的数据结构</h3>\n<p><a href=\"https://github.com/facebook/react/blob/0203b6567c6fd6274866c853ef938241d24551ec/packages/react-reconciler/src/ReactFiberHooks.new.js#L140\">hook的数据结构</a>如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 477px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuklEQVQoz12S6W7bMBCE/RiJJR6iSFESJR8SLV9xbMcJkrRpgbz/w3yF7RxIf8zOLkgOONgZ5eUYYTIeult+bxLKpcfWhiRJkVJeIIRACkEq5AXn+RNf5x93R9ooYuh5iWu6psQuD/jVQHW/IrQNw7C4PlASowUuS1FaIrX8IfbJI+UbrHX0z+802xPd6Y3++Mx6s6ONKyZxQGcp+dSy3yreNzc0y4KwLcnLjDT5/t1F8FxsUdA9vNIdn+kfXqjbCZP7I9Z7tDFordEmJ880uRZIkyGVQsqfYlfBzGBdQXz6Q3d8Zbp/pF0tyQ4b7GHD/PBIPdxTL+7o1nvKukYPPXmoEUlKeoG48jhlpJs51uY06y3ToaeMNcVhgdt0mDihPw28nSJxEeif9sxjwC5nuNhiS4MLOcZn2JBTTCwj3fZoLSm7OXUMlHczfF9RTT35NNBGx6/1Dbujwy8L2sHx96SIiwwTLH7mcK3FT92lH8ncEReRyWpH5StUE1DekzmHDhVKZaSZxlQGdWYtOM7G1CZhfPth9cPuxbIUKbM2oERKkowRSYJI0yvO/WcGk+/s3Y6vefx/Ieel/AOaqgbxYD1/+wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hook的数据结构\"\n        title=\"hook的数据结构\"\n        src=\"/blog/static/c3abb96049ba35de696bfaeac50d17b8/d743b/hook.png\"\n        srcset=\"/blog/static/c3abb96049ba35de696bfaeac50d17b8/63868/hook.png 250w,\n/blog/static/c3abb96049ba35de696bfaeac50d17b8/d743b/hook.png 477w\"\n        sizes=\"(max-width: 477px) 100vw, 477px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Hooks实现思路</h2>\n<p>Hooks在组件初次挂载和组件更新阶段是调用的不同的<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L389\">实现逻辑</a>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 561px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABh0lEQVQoz12RW5LaMBRE2caAJOthy5Yf2NgYg4cZBuaZqmwgO8j+N3BSCFKZykdX36+jVvfCWEsTajZhTZo6pFghpUBIiVQSldx1vZVCJYpEJ7dbqpvHWyKlZGGMwWWeamgJU41tCsquoN/ldHNFMZaUu5uyxpLVhnxj0VYhhIiPR93BC6MTdFHh9i/43RNuODBNAz+eB86PW4qup5lm2scToe1wRcA3bXRjNNqmJDb7ntCSKIXPc+rjK/XzB1+niffTgf00kh8/KS8/8eue0O8Im5FymMjbgTIE0qImSYsIjAmtMUSoEJhmi9u/8evS8fur4+04IsZX7PyJrTrEwwNitUKsljcJgbh2Hr9+T+icI8sc2imM19jgSIPD5A6dWbS30dMyxVqNWC4j4JomSZJ/o/zt0DqHrRvqQ8/mcqQ7jfTHNU8fW+bzht15y+ZlZj13tIcD5bCn6rdcx/wfdhvFWJRJMc7j8gptPUZrqpBT5BlZ5mNPxmZYH0jLGl/WESjvvX0H/gH+iejWe9cPNwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"挂载不同的hook\"\n        title=\"挂载不同的hook\"\n        src=\"/blog/static/79d42a604971a40c38b3cd9a50682d77/410f3/different_hook.png\"\n        srcset=\"/blog/static/79d42a604971a40c38b3cd9a50682d77/63868/different_hook.png 250w,\n/blog/static/79d42a604971a40c38b3cd9a50682d77/0b533/different_hook.png 500w,\n/blog/static/79d42a604971a40c38b3cd9a50682d77/410f3/different_hook.png 561w\"\n        sizes=\"(max-width: 561px) 100vw, 561px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 501px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC2UlEQVQ4y3WTyXLrNhRE/RGpLCxxEmdwAMRZokRNfJKVOMvsUtnm/7/gpEDZtPwqWTQuCkU0+t5uvqyCJY5I8JTArRR+uybqC8S+JOr0vkEcWqI6I94mxENOuM2IuoSsFsTrEFessGwLwzB4MU0LX1bkdYs6nEl3J8J6x1KUGKLAlB1G1mIGKXEmyNsS2RTEWUIcx/i+z+J1gWmaE15WhoEQPuOl5XQoGc81SgmS2EVmAZnwWMuQRAQYyyWmxmIx1eVyOanSRIZpPBQahkmaxozjht2+4nRuSfKM263n9tZzPnfs9jVxHKK/NcwPGMYX2VOdCJMk4nLpOB5rqloiVcr53HI41Ox2JUKEvL4usKxHW7rato1tW98Ip5YfCiOOp2ZSud9XDEM1Ky5rxfHYTI9dxm56YLNZT4/1fUEQeCyXT4R60Qq1ov1Qsd0WDENJuykoypy2lVRVNhG1raLrFEJELBaP+VmW9V3hJ+H9tx1v9z1Vo6aZ3W5b3t8HpBSzCt22JnpW9PMcZ8K3t57h0EztFLXi8qMnzRNUkZLnMauVM8/vk+y/8GXK2LHtS1Qp+eua8c/vGX+fQvrU4pdfX1ksFt9j8uHyz5gVjmPH9brlcGx4P0rufcKfo+SPsWY/NJNRdZ3jee5E/L8K9aJzqHOnM6gvnsYt3b5h3ZQcz93kuI6VToB2t+vWSJl9jMCaq8Yc7NOpmXOnL9banF3FYajm82GoyTKB6zpTBrVJzw4/5TDmft9xvfb8uG4n6MvNpmTbPzJ5vfVcnqpSKbEIcBznQfo5Qy3T911UHrJWMUrG5GmAiFakwp/UpImPkhHFhHBC+vGvu471NdNPU9wgws9LoqLFFTlxtSHpBgJZEsoCP1UYXoSZ1Zhqg7nusfIGI5bYaYnjehjGg/TFc13WdYUnMoJM4kUxYaaIZEGQ5ngixYsEdhBhixwnkTjpetrbUYoVCmxnNQf7XxK2AFDTeZdbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mount阶段hook\"\n        title=\"mount阶段hook\"\n        src=\"/blog/static/55b46db6b69afb0beaa46bd58608e2fb/55811/mountHookCode.png\"\n        srcset=\"/blog/static/55b46db6b69afb0beaa46bd58608e2fb/63868/mountHookCode.png 250w,\n/blog/static/55b46db6b69afb0beaa46bd58608e2fb/0b533/mountHookCode.png 500w,\n/blog/static/55b46db6b69afb0beaa46bd58608e2fb/55811/mountHookCode.png 501w\"\n        sizes=\"(max-width: 501px) 100vw, 501px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 485px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC5ElEQVQ4y31UWXLiShD0NWwQvbc2hCS0byBWY3vuf52c6MIm7Bi/91FUtEKR5KZ+YpxD5x3kOodq9jDDBbIcIZsZshgh6xlquEJ2J+h1inVXYj02SMYaQZYgCkMIIeB5HlarFZ7cj7YW075GO1ZopwbpNoMnFDwu7iM0llxhxTiMVjDW0JZSgDNGQA9Axhg4W8EaBaMlrJFQSkBwBqU4pORQgkFrAc4Zlsvlt/EI6AvM7SfPWyEIDI7HBtNU0s6LFHWT4fY2Yrer6Lnb6ySEe5+xFQF8nwfDB+CpJbBhLBFEIU6nhp6dzy2GYYvFwsPz8wsWizs7t5+fF3h5WfzO8HRqsd9XaJoMZZXi42PC5dyiKDeo6hTbbYJkEyJNI3p/swlRVRtkWQQh+HeGHqLI4nBsCPT8Cbzf18i3G+znGpdrj7e3kSz4+LPD4VCjqlJkeYwsi6GU/CnZ9w0ulw7nS49su8E8V5jnGvOhQd9vKU1jFKyvoV1wVoNz/mnBL5J9X+N67Qm06wukeULeubPzsW0zJEn06Z9HHn6B/Gcor689hrEi/3b7is7TVBErYySx/D+gryHAMLQ4nzvMhxplnWEcS/LUyXZ1ieOAOujkOqmOqZvvUn8ABqF5SHbAh0ODqsnRDwUFcn3tcbsNFMYwFIgiH9YquI/iV4bOQ5fwtCvRtBklO4wF8uKesuunA+u6nABdUGW5gZTyH5YPyU6u+yKczHEqsS1SYkh/NJXEepoKssCl7KriAvql2B4Bvr1PuL4OOF866ptj5WR3g/Ozxe024vU23Dv5PlHFXOlTV2z547ZhdAFEgUISG8SRQRgoGMXg2/uF4FuJdWyxjjQ2a4M4kAitQGAF4lBDsBWWD0DPgzA+4mZCMhxhkhzrbo/t8Z12VHWIqgEyiLHKevBqhuiu4PURPB/AshYiKegaI8lSCKRpBi4VpLH3sT6N0AZCaRouBJjSYNqCGf++3VlqMKEeHv4Fc1cdpF0sQpIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"update阶段hook\"\n        title=\"update阶段hook\"\n        src=\"/blog/static/25312134b5bc77843da2562709c24e6e/44c61/updateHookCode.png\"\n        srcset=\"/blog/static/25312134b5bc77843da2562709c24e6e/63868/updateHookCode.png 250w,\n/blog/static/25312134b5bc77843da2562709c24e6e/44c61/updateHookCode.png 485w\"\n        sizes=\"(max-width: 485px) 100vw, 485px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n下面先整体的介绍不同阶段Hooks的实现过程然后在深入到源码中看具体的实现.</p>\n<h3>图解hooks的实现思路</h3>\n<p>Mount阶段Hooks的实现逻辑\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 652px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/a6d32/MountHook.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe41ACywA//EABgQAQEBAQEAAAAAAAAAAAAAAAABEBEx/9oACAEBAAEFAuuplTxU2P/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CT//EABgQAAMBAQAAAAAAAAAAAAAAAAABMRAh/9oACAEBAAE/IahEZ0sjaDhY4Qf/2gAMAwEAAgADAAAAEPMPDP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB0QAQEAAgIDAQAAAAAAAAAAAAERABAhMWFxgaH/2gAIAQEAAT8Qrh+MUpA9kxcjfuquM850VugMJcJEJNd2j//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mount阶段hook逻辑\"\n        title=\"Mount阶段hook逻辑\"\n        src=\"/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/a6d32/MountHook.jpg\"\n        srcset=\"/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/0479a/MountHook.jpg 250w,\n/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/41099/MountHook.jpg 500w,\n/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/a6d32/MountHook.jpg 652w\"\n        sizes=\"(max-width: 652px) 100vw, 652px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nUpdate阶段Hooks的实现逻辑<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 685px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0a2b8/updateHook.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 149.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAeABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe41koLnUIo//8QAGhAAAgIDAAAAAAAAAAAAAAAAARAAAhEhMf/aAAgBAQABBQLMJ0jwK0CK/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwJP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQETEh/9oACAEBAAE/IdYaKYuqbENSG5CWhYf/2gAMAwEAAgADAAAAELPKMP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EABsQAQACAgMAAAAAAAAAAAAAAAEAERAxIVGB/9oACAEBAAE/ELWLcdRBAK7jpXG6a8By34Qa79MFQlwgKCp//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mount阶段hook逻辑\"\n        title=\"Mount阶段hook逻辑\"\n        src=\"/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0a2b8/updateHook.jpg\"\n        srcset=\"/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0479a/updateHook.jpg 250w,\n/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/41099/updateHook.jpg 500w,\n/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0a2b8/updateHook.jpg 685w\"\n        sizes=\"(max-width: 685px) 100vw, 685px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>源码解析hooks的实现思路</h3>\n<p>以下主要以useState这个hook来分析React在mount阶段和update阶段的源码实现.</p>\n<h4>mount阶段源码分析</h4>\n<p>在mount阶段组件,useState调用的<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L1235\">mountState</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 548px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADoUlEQVQ4y22U23LcNhBE9Rn28gKCAAEQvC+X3OVyL9JasqWU/QGpylP+/x9OilQiy4ofmoPCQ3Ma0z13URSjfYXvR4ax4++vnr/uDX9eLO22RbmcREqiJGGz2bAJAqIwIo5joui1vsfd8im85XjsGc8Du9tMO+8ZzzO7457Dw4npeqQ+9NR9y9B3GGcJw/CN5D3xXRxHZK6g2J2wuyP29MgwdDx9O/Ht+cSXxyP3t4mH28TXx5k/ns7s+o4kka+dRr+Srh1abTGZI+lGRNlRtpZhX7HbV/RDSV56jNF0PqOvLE3lyMucRAli8aFDIQRJkpAXGbtDyTjX7C8trrTU25x+qhjPDbt9jW880iakTiJNQlYqhBTvCCPulj9YYzBZiss1zmlyp5FSYIxaz84qnNUomRJuAsIwIghCgk241vDdkO7SLEAZi6o9xbHGTzX+UOH3NaZe7h2685gmR2aGVGdImaB1is7S9adpKn++oVQhqc3R+wPtdaa7n2mvZ+rzTNlX6G2HPRyo55linHHtDpNptttyxTDUVJUniv6VLHVIqg2qKtFdgR53uMbihhY7DTSnkWJs8JUhCgPCxYdRRBi8yg2C4M1Cq+TlIJUmH69Ulxfc8RGZd6hyR6wcOq+R2pEIuXaxvNeC6IOh3yQvU5aJoBz27J9e2M5nTNPjtwNKxog4RIoQlcZoJdbhZUoixP+Tsna4EAqR0Pcl379feHk58fw88+PHdTVzs+s5fbnn9PjA9fmJ6+OZ6ctEWRWr7N9Gz1lHVXgKb/Aue0Vu1kmKVCOtR7kC5SukNljvsCb7fZaXS5MXlMcLcdEQdRNhM5J4j596yn2PsRmfP31i8/kzwWZDsAnYbII3wg9JiSmMoZkG6vsz1e1G+3hj+3Bhfroxjj15btboWZuRZQqdqfW8JOxjl3cijtn6nCIvsbszqujwZUPVHzCuwKRyfd/FbwsW77VtwTg2KJX+snXeZVmgq45yP5NvB8rDmXy3X1HN92hfs/m87ML/vBf+IvnDUARKStJuws7fUMvWSTNEote6IkmJwvgdohVh8BPr3WqbNMIZg64r6suJujUIGZDaiNS8QmYxyiZoJ1BWkC4bx6aoPEW51yp18m+WdUiWGbqhpj3U+OtEPo30Tye625H+64XmPJDvW/z9EX+Z8GOD9ilZqckKta6xNJOvhIlM8XVNbh2ZNsSmRLoKU3Zr7Fa4EpFaYtcgbIVIs9XUHyUvhP8Axs1mSXuqYs4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mountState代码逻辑\"\n        title=\"mountState代码逻辑\"\n        src=\"/blog/static/52a5be7aa726b705f79a180697dd6fe8/a58fe/mountState.png\"\n        srcset=\"/blog/static/52a5be7aa726b705f79a180697dd6fe8/63868/mountState.png 250w,\n/blog/static/52a5be7aa726b705f79a180697dd6fe8/0b533/mountState.png 500w,\n/blog/static/52a5be7aa726b705f79a180697dd6fe8/a58fe/mountState.png 548w\"\n        sizes=\"(max-width: 548px) 100vw, 548px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\nmountState主要做了:</p>\n<ol>\n<li>根据initialState初始化memoizedState和更新queue</li>\n<li>返回memoizedState和更新函数(绑定了当前的hook的queue)</li>\n</ol>\n<h4>update阶段源码分析</h4>\n<p>在使用useState返回的回调触发页面更新的时候是调用的<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L1901\">dispatchAction函数</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 485px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 142.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEE0lEQVRIx5WVZ3LbSBSEdYy1CEwexAEIEgRzkinJYe3avf9lvq0BJZVkOdT+6HoDFNmYfqlvpFRUw5bp6RNlG9g+bljtZlReEgpNmSmcc1hrEFKSpilCiF/iRkpBvdyxuHylmnVMH09M7/aUhw3tbk0z7+jmHVopkiey35HeaGNol5uRtOrmhKbCCYGTEicFXimsUggh3/35Z8Q33vuRJLn9QDK5JZ3cjjFJJuON0uSWNJkgXiFNkheyH0lvjNYI41FZjfQFqu6Q9YzUVwhtmfjAxAUS3zBxNYmvsb7A6J+nYCQ07QrbH9DdCrd7IOsGloct203P+v6B/efPLD9eWF8+0py/Mnz6l+l0SpIk7yVHQh0W6DAgQ487fcOHKdPdnOnDgeG4ZLGe0fUNy74lyzNsXmKt+4VkY5DGEbZ3FLMB4Quk9bjMUdQlZZFTZh5nLbHF4q2uOU5II0nM8xvJxqCUojtcmJ/ux557TnoySZhMkivJq0K8IJK9kxwJjWH+8Qv9/Tf6+79ptydc3aLCApNXSJH+sV3eSpaKxeN3uuOF+d2nkdCEOeVii9b6j9ORvpJ9Y43B+2xsbFfUlM2UvJ2T1w3T1Y5YtGe5L0je4t0Nq1ChjEA5ibQSqQVCpSgnUCY+K5RVKBOjRHuFzq7niNcfu7Gxeial6B3Tc0U5s+StIWwL6nVG3hnymaFeO8ImJwzV+BFbGIzXmEz/eENN2Q90hz3FekF+OONWe8quor/c0R0PY1x8ume4nMhy/06mlPIFo+R2GqiHLWbziFpeKIc9TWixsz1VN1CFKUI6jCve5e8FT7kdCbUWmMLh5wHblGShoOwyTJ3hmwxfGbLOYnI1SsymDltoTK5xlcEHO76P5yuhsfjtBbc8UPUL6mGFyzx2dcStDriiQMgJUgmEFMhYKCWeEIsmr++VuBYlL0rq3YUQW8dnaOuvOfEFwmbjaBqXoZR+2z4/wXhDoTTu+BWz/0y9PTM73lNUNW73iD1/p9jc0QwbsiqMY/lbC4heYZ1HtsMI0/bk7QxflOgyoPs9tmrGxft6Yn41PaPkajojqwNZWVG0HXloRw8RcdkWARn95DZu8skY0zT5tQXEWW02JxYP3ylXZ8rjF+q772SzFdXmTPvwD/ViTdH1VIs19bAZFf0o/WWWYw5dmVMNgXBqyBaBfNUgYxFEis0LrM9xRTUuVl+FsStGgvT9FnpasCl572iPJWGXU608QsSFIJhMJuMPJ9HEonF9+GuMo3FFJ0yTt9smEvaLltN5yWY74+NlzfluyXY353DoWa9nNKs9Tdw8RY1dnrBVi14c0fMdbnmirMOV9NlGn41cKYnWakQ8P0NIhdRPS0Dp8fka5Rhjzz5bwU1c+dEC3u28/4unKv8HIjYjhkrSpr8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dispatchAction代码逻辑\"\n        title=\"dispatchAction代码逻辑\"\n        src=\"/blog/static/ffb63f0539dcde4bca5e0f77c2ba284d/44c61/dispatchAction.png\"\n        srcset=\"/blog/static/ffb63f0539dcde4bca5e0f77c2ba284d/63868/dispatchAction.png 250w,\n/blog/static/ffb63f0539dcde4bca5e0f77c2ba284d/44c61/dispatchAction.png 485w\"\n        sizes=\"(max-width: 485px) 100vw, 485px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在组件更新执行到对应的函数组件的时候,会执行对应hook的update阶段对应的hook逻辑.useState对应的就是<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L1262\">updateState</a>.从updateState的代码可以看出useState底层是使用的useReducer代码逻辑.这样具体的更新逻辑就在<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L710\">updateReducer</a>中了!!!\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 570px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 152.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEZElEQVRIx42V627cOBaE/Rg77pZ4E0mJut/VdrfdcWIn2SAXLPbH/pknmEeYh/8Wkp0gcOJMfhRIUFDplFh1zoUwlmqcqMeBfqg4HGemZaAZW/KmpMg8oQhIKYmiiDiOf4kLEccMVwvL+ZZmPjKMM3mWYROL0opov3/EE9nz9QdCpTXF4YZyWnBdRzZNuDxDbRW9XMmLhFpryjylrXPqsaYeaoauJnjLfndJtN89w/6XVV7EQiB9ifAFohxQNkWEFlEvqGpGVROyGJDFiKhm0rJBq5f/54WQEt0e0PWMO38gGxbcckc4f6R7+ELaLcTKYHyK8gGlDHEcEb14KVJhljck/YlweEV195Hi+pb6/i3N4YZ6OdFOM68/vGNcRnRI0do8XVb0Ay6EEOgsJSlTTBkwRSDrM4oxJ60dWVuQ9TVp35K2OdVUEKoUmQi0V5hMo53CpApp5COh8THp4nCTJWkMaZ9QXDnCYjG1JvYxcRpjgiIWEULFCCWQWiAT+bgasZ1thDIEjq9K3ryquLkOmMQgbEpsM9oy5TwUnPocazT7VVr0hOeSo4iLNQEubfjz3YG//3fDX58WuqZENTOiueJmbnk7ZdxPAZ9o9v+QlgspBEliqPucfspphkAoHdOcMTSOsrbEmWGnInaXu1+a+lv0pMuQ5YSuBlR/TVEEPt8f+O/7Ew9317SvHqimBW2Sf8zzhRAx0q43PDA9fGR695lqOWLrAVnP2PZAVjW4qsNmYbPLbxHqsqd//Z7p/Rf6Nx/ozvcU4wFfNqi8Q2nDfve7km2GKSeGh88M95+ojm8oz/8mdDM6SdF5j1L6N9uXEAitN1O3d1dUxxbfOuxQkXYeWyqSIDcjPyd8oTnEpImnLgu0F+hUbglQ+sm8Rm7YCJ78tt9FL3acx+gpjbYaN1jCwZONDlsmKKtQaxKM2OK17pWVmKAR8oUKpZCspD51jF1D1RfodJWpcVXymFWvsKXZzmxh8K3dqv8p4RY9KTFa05aBckxxjd6w/oJ1TXJFUhpck3B5uefyX7tN+lfJ3xN/I9xInSZfKrKhJIwVWV9RnTp8k2GMwjpFliXbfn1v/5Pu/UioFEpIQqgY336iubmnmg6Md++Y3v+H8nBDezgxHE8cz1f080xVNyTeIZ5dzEaopEJIQVP1LPOJUJWI3SWJdRifoa0jyUuUS1HGkaQ5qfdYZ39O+FXy+kWZOIR2REmKEAptPSrxSGW2/frSmphV7lfJ32NrX+soXcem9hm2rfFLh5tnXJlRna5pzgfysaM8zGhjiJ/yvBbzo21WQqW2CrOqpj3fUh8Xiibl6twyzgXt7UJzviUfWlQo0c2MDzlRtH8hekJiE4Pzjkgookiw++MSGUeo9bnUSJ1ssoXSxNtePcr8zjqb5HWMrqRZ0+GrlnXwu6LClQ1JKND2ceBv+Dro97ufWuZbhYkx9P0143RDNS709x9plmvKYcHWE0VeELqJrJ/xaYrLAr7ucd7/IPv/GmRg+gK7bPkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dispatchAction代码逻辑\"\n        title=\"dispatchAction代码逻辑\"\n        src=\"/blog/static/275788fe27b5e1522a0d62b15f3b7910/432e7/updateReducer.png\"\n        srcset=\"/blog/static/275788fe27b5e1522a0d62b15f3b7910/63868/updateReducer.png 250w,\n/blog/static/275788fe27b5e1522a0d62b15f3b7910/0b533/updateReducer.png 500w,\n/blog/static/275788fe27b5e1522a0d62b15f3b7910/432e7/updateReducer.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\nupdateReducer主要逻辑如下:</p>\n<ol>\n<li>根据fiber上存储的hook链表获取到当前的hook,hook的更新queue</li>\n<li>循环执行hook的更新queue,将执行结果保存到hook的数据结构上</li>\n<li>返回处理结果和更新函数</li>\n</ol>\n<p>以上梳理完了React Hook的源码执行流程,也能解决开发中的一些疑问:</p>\n<ol>\n<li>比如hook的添加为什么不能使用条件语句  因为前后会导致hook的链表无法对应</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://react.iamkasong.com/hooks/prepare.html#%E4%BB%8Elogo%E8%81%8A%E8%B5%B7\">React技术揭秘</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React Hooks源码解读","date":"2021-03-17","tags":"React","path":"/react-hooks","top":null,"summary":null},"title":"React Hooks源码解读","date":"2021-03-17","tags":"React","path":"/react-hooks","top":null,"summary":null},{"id":"920475d0-e103-5307-a3bf-1471ce48b961","html":"<p>javascript的执行是单线程的,React老的架构是利用栈(递归)来完成组件的更新渲染,这样当组件层级较深更新任务较多的时候,js线程会阻塞UI线程导致表现上页面卡顿的现象.React新的架构Fiber中将更新任务进行了<a href=\"https://github.com/facebook/react/blob/f227e7f26b81cb1eba0c837ab2acd7fa7f91404f/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1472\">细粒度的划分</a>并且实现了新的任务调度系统.这样保证了React页面更新的流畅和响应的速度.本文主要从调度React更新任务的Scheduler包入手从宏观的角度了解React中的任务调度机制.</p>\n<h2>前置知识</h2>\n<h3>事件循环</h3>\n<p>javascript中的事件循环可以参考<a href=\"https://icantunderstand.github.io/blog/event-loop\">事件循环</a></p>\n<h3>isInputPenging</h3>\n<p>isInputPending是Facebook实现的一个浏览器的新的api标准,现在只在最新的chrome版本上有对应的实现.通过调用navigator.scheduling.isInputPending方法来获取当前是否有高优先级的用户输入需要处理,从而实现打断js执行响应用户输入的目的.</p>\n<h2>任务调度的演进过程</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 943px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQFB/9oACAEBAAE/Id4qv//aAAwDAQACAAMAAAAQc8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAADAQEAAAAAAAAAAAAAAAAAASERYf/aAAgBAQABPxB24lpLzGLhn//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"长时间执行任务\"\n        title=\"长时间执行任务\"\n        src=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg\"\n        srcset=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/0479a/scheduler_long_task.jpg 250w,\n/blog/static/08a926bcf0d7610b88cd024eff38d4ba/41099/scheduler_long_task.jpg 500w,\n/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg 943w\"\n        sizes=\"(max-width: 943px) 100vw, 943px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n当js线程执行一个比较长时间的js任务的时候,会导致UI线程无法快速的响应用户的输入,造成体验卡顿等问题.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/71f0d49fe6d23486141918239a4604af/faa66/scheduler_split_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3AUH/8QAFhAAAwAAAAAAAAAAAAAAAAAAABAR/9oACAEBAAEFAir/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQEAAT8huqV//9oADAMBAAIAAwAAABBwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAgMAAAAAAAAAAAAAAAEAESExQVGR/9oACAEBAAE/EAlxd53DoPYN4J//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务分片\"\n        title=\"任务分片\"\n        src=\"/blog/static/71f0d49fe6d23486141918239a4604af/a2510/scheduler_split_task.jpg\"\n        srcset=\"/blog/static/71f0d49fe6d23486141918239a4604af/0479a/scheduler_split_task.jpg 250w,\n/blog/static/71f0d49fe6d23486141918239a4604af/41099/scheduler_split_task.jpg 500w,\n/blog/static/71f0d49fe6d23486141918239a4604af/a2510/scheduler_split_task.jpg 1000w,\n/blog/static/71f0d49fe6d23486141918239a4604af/faa66/scheduler_split_task.jpg 1056w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n将长时间执行的任务划分成多个短时间执行的任务,能有效的降低js执行线程卡死的状态,这样就引入另一个问题就是如何划分任务切片才能产生更好的UI体验.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe4g0o//xAAYEAACAwAAAAAAAAAAAAAAAAAAAQIQIf/aAAgBAQABBQK5CeH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAEBAQACAwAAAAAAAAAAAAABABEhMUFhgf/aAAgBAQABPyHfTfGHfDJ6LLDscl//2gAMAwEAAgADAAAAEIMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBUXH/2gAIAQEAAT8QU31Z1sLKHX5kQcH2UGzTklACfYqEvfZ//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务调度\"\n        title=\"任务调度\"\n        src=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg\"\n        srcset=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/0479a/scheduler_continuous_task.jpg 250w,\n/blog/static/150e0b4d08aa0861f4343a41e1c4da61/41099/scheduler_continuous_task.jpg 500w,\n/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n基于以上两种模式的思路,js如果能在执行过程中主动的获取用户的输入(执行的deadline),主动的暂停当前js的执行并通过事件循环在下一次的事件循环中再次唤起js任务的执行，这样就能充分的利用起所有的执行时间来执行任务并且保证用户输入(高优先级任务)的响应，以上就是Scheduler在调度任务执行的实现方式，下面从源码的角度来看下Scheduler是如何实现任务调度的.</p>\n<h2>Scheduler的实现思路</h2>\n<p>以下源码分析基于React master分支的<a href=\"https://github.com/facebook/react/blob/master/packages/src/forks/SchedulerDOM.js\">最新代码</a></p>\n<p>在React进行渲染任务调度的时候,是通过调用Scheduler暴露出来的unstable_scheduleCallback将任务函数作为callback传入等待Scheduler调度执行.<a href=\"https://github.com/facebook/react/blob/00d4f95c2ad000f40ea0c774cc1ced3a0ceb6f23/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js#L131\">源码位置</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/84f4d/scheduler_call.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQY022QW0vDQBSE8/9/jPiqeMEnpX0QrGCtF6zdjZu0qdlks0n39kmKikgHhuEc5gyHyWLdELuOoEe1GO3RW0dbe5rtgPeBESmlX/7Mh5B1WvMhc6pyTVUoSrXGbkqGYsXwWRGaithWxBR/j/6G/2dWa83j8wvVWuHkAzv5gFcLvJgRqndi3+BNi7c9ZhfxYQw+/N24z0xr6bsBFyBG8CHt7WGcXdqr6yOuC3Q9DEMiffu8j4SQcD7iXGBsIYs6x6k3xP0ly5sjxPSY4u6UfHpGPjmhmF2jhEStBKUUfI61SEEun5BigVwtKNUr9XZFcFsyZ9dEW2HFLXp+jn2+Qs8vaBaXNPMzmuWEzhTYrsC0it2w2as1Jb3dYJqC6GvAQNR8AbVpy5r5USwPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler调用\"\n        title=\"Scheduler调用\"\n        src=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/00d43/scheduler_call.png\"\n        srcset=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/63868/scheduler_call.png 250w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/0b533/scheduler_call.png 500w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/00d43/scheduler_call.png 1000w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/84f4d/scheduler_call.png 1208w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在使用Concurrent Mode的时候此处传入的callback是performConcurrentWorkOnRoot函数，这个函数是React内部调度更新的起始函数.</p>\n<p>以下是Scheduler_scheduleCallback的代码逻辑\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/67a79/schedule_callback.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 112.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIklEQVQ4y42V6W7cOBCE/RrJSBRJiaduaaSxxxd8rBf7/g/0LUQldgLbcX4UmoDIQnd1detC6BLlA815ZXw806wz7XnCtoH+YSXOA7qy+GFGV4Y8zxBCfIoLISXKOFw/Uq+X1OOIa2qklAhxIM8OZFlG9v0bebaT5Xn+OWEhBJUPDHfPjPcvhGnF1i1lWZHn7x/8iWwnLAoq64nLFe3lbSLbMsmy7DeSv8VFUWwZRrrrB/qbR9r1jIsxlSrEn7P5MENZCJquw3cTflywIWKso1AapaukZZ7lCSIXr/HzkpXGVQYTA7ZtqILH1AE/DYRpxDiLMpIy6D16jSzlh/omwlwqSmsY725pr8501zd012fqZaK/vaVZFqpQoZ1AlgJlJUIKssNhR3Z4bVQuci62gzWG4zwwrgvd1T3Nck3sJ+JwRBtPZSxV6Ci3c1kSg8PEBtP0SSKt9U6a/+hyUUhi9IynkfZ8ot+yPR3prhfCcaadGvzUYZtAPXiayeOGmjD3+KHBxBLtVJIlEW7CK6kwbSRMHWHsCFNPOI6EsU0PXg2eZRxSfF/yqw83OGs4nyamOdL3nmmuca4iFwcK9bVdfvHhTmitZ1xu8f0R9wN+XKlcQJqYbLTN8dbdjwz9k3QvuZDoSqOcQjuNNpoqlCluF7c7YsMXGf5WctM51nPP8dQyLw3Hq555aRnHmmmqccHj+gnfT5TWYdutIcfkBlkUb4SiENjKEkxMM3z49n0XfouHjDxlUHw502/rK8/xMXLz9MJ498Rw/0J3dUd3umG6e04ZxWnXcn9Y/FKmeKfphRIFqpS4psQPIS1WU1eY1uM6iyxzhMrQvkjnQmUJyhRor9BW7dGrNJpJQ6UUvvHEdcTPA2GZqC+PxHWmPk3UU5O+2bbDdWNaxpWpkGprlkgo5B73LouC/rhyevqX5eGZ9fGF0/N/LA//MJ4u6Y6XlNanzV66QOljSuIjXfcuS4l1JdFrvFUEv81rhbeaprG7wX+djsPhXTPe9qEQBBuwpUP7mtLX6WKW5WQ/Y5Z/6b9XQiUlRlcJpQ9pexefmPir/8lG+D+6pI2XBDmakQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler调用callback\"\n        title=\"Scheduler调用callback\"\n        src=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/00d43/schedule_callback.png\"\n        srcset=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/63868/schedule_callback.png 250w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/0b533/schedule_callback.png 500w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/00d43/schedule_callback.png 1000w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/67a79/schedule_callback.png 1408w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在unstable_scheduleCallback中主要做了如下几件事:</p>\n<ol>\n<li>根据传入的执行函数和优先级创建执行任务，加入异步执行队列或者同步执行队列</li>\n<li>调度任务更新</li>\n</ol>\n<p>以下先只关注同步taskQueue的执行流程,requestHostCallback通过Message channel发起宏任务来执行flushWork,最终走入到workLoop整个调度的<a href=\"https://github.com/facebook/react/blob/00d4f95c2ad000f40ea0c774cc1ced3a0ceb6f23/packages/src/forks/SchedulerDOM.js#L200\">实现逻辑</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 733px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 131.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAD9UlEQVRIx42Vy27dNhCGz1sEjSXxTlGi7jo+Olc79zRANl0UfYsWBYp20V374F8hyY6dxEG6+DEUIQ5n5p/5udFGYIKnOjTEqUfnAWUcNpTYvEBKSZokK9KELMsQQnyF+/2NNorpuOP46sR02jJOI/3xTHfzhtiPn37O7u13sFFS0bcT/e6CawaqqiBUNaHp8UW5/HQf3QPSb2IjhcDmOf76jN/dYPsJ2U648YirOvKiIHQjoe3J24G8atdL0vTpCKWShDygrScVklQqshnGIYxHSIXQdoE0FmXMGs23Up6LrpWm3R3pLm/ozi9pTi+J447heKS/HuinHdc3F8ZpjzWGJEm+cnQf8RKhMQYXAjZGfF3jmxrjHc4oiuDIvV2s0Zo0SZ/EvdPN3DZSKnxpCYPFd5py5/CdRVqB0ALp5GqtRFmJ9gqdK5STmKCWvYcI5RphWzTkzpOJFCEzhJydSTK5OhVKIB/ZT2uz2kcOBcYHhI+koUFWA9oHXGwp24EQK6phh/WB5OrqIc00u8O6/owUqy31/pb69gPx9Ip4+57hdENdN2zHLVUV0cYuzT2zPh9Mrp6TJFdLj84XLZctfSglUmuK6xP15S3V5R3V5S3x/Aa7PROmW6rdifb0kub4gvbyiridcLHBlxXW57hY46sWqRQbpQVKKeq2ZNw39IcR148U0558vMb3PXGaqHYTWmvUDGPR1i3npNJoly9lm8ldWVYa1/aUhx3l+UA8TFSnifK4p51adueG7alDVANp0SKKBhl7ZL3FOH9X2+QhZaU0sdsRj69x44nmsKI9X+jPN8S6pfSOGHLKEDA+J1NmnSApybKHMdxoK5BCorTCthWuqzFtjR86TF0g65rMBuQsaXO9vEeK7JGkPTT1EuFcB5EJuqHn8uqW/WXP9jDRnF5Q78/4cb8IR3F6Tdi/QIaK7ItZfiwUGy0lQkmaENkOW8qZkG4kL0qapqRqW0K/pahb7DJ6V3fO0icVZ9FDIeQyp23fUm6PVLsz1nqMlhhrUS5fmJ3FNn0iqs8dKrnQb/06u/MoKTfPbUaaJQ8MflGvbyu2EYt89dtqaY9hKmkOHdXxmri7Rt/pX/adyD45nNO11jD1A1XTkccapRxpki2lWNNM/9d7srA8H/Ah0I4jxfawCGtVx0UgbIgobR4JwiObfr13l7LF5gETI7Yssd5QtYHQtYRhiyvmHpRIo5B6tbOszZ2x7qnFrq+imEkROJMSWkveePLa4aPC1RofEqT6AVem2JCg3dWyNvm6nvfMbIuE7OoZ6fNnbOyPvxE//kX/8z/EX/6l/Olv8o9/4D7+if/wO+bdr+i3v6LffQ7z5ff7Ff8BGwXxHBeZuTwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"workLoop调用\"\n        title=\"workLoop调用\"\n        src=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png\"\n        srcset=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/63868/workloop.png 250w,\n/blog/static/698bc99b2ece9e667db04ba2c3e361f0/0b533/workloop.png 500w,\n/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png 733w\"\n        sizes=\"(max-width: 733px) 100vw, 733px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0f586/yieldTimeout.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACs0lEQVQ4y4WU2W4cNxBF9RlG1NybO3ubGY2txWNY8Ev+/4NO0GxFseEkergokkAfXNYt9l2KEeUiqS2cHzY+P125XM+cdz1slJJxsWLdiBQC8YHuaq1IqQjTRn7+Rry9Mt5+UL488fT9kfOXE+enK/M6oaxCGoXUCm0USu+Sh+yxvvMxEoRg0gNTFMxRMgfBmgRbVX2/BMGSFFuznKthqhZbLb45xl3V4rJFGXUA0yAoKZJOE3GOjEvGLg3tPWOI+FIYU0Jbi5OCogSDlCgl312+XznXShzuyW3DXV4Qp0c+Xb/z6fINOV+IywO+rbiYkcaih4F0PzAI+VtPpZTcpZzx+5XVwDTuV9OsWbMEyZo00yhpZqDZgeYkq1dkr7HZYoPpMl53WHe4p7xvzKgPuaNab7pkd/KmQSCGN0fD7wl3hznnA+gUYzWMVffqksZlg58cLpmj+c3h57GfhWVkrK4H09fNHQ5LKQfQj5TrzHw7Ux4afor4OeFnh02mw8Ps8Hu6k+va0x2LwTeLtuoAxv3KQhBCJc0n/LQyxoIdPS5ErNGYNwltGbRFKIOQGiHVsdf2px6mhJSCGBOnyzPTdu2wWgLzlFmWQq2R1jKyLPzRTtzXE0OaECFzv9eyYIx5eymldvpoHcu0sT5/pTxcia0grUQogTT7S5Boc/S6y2u0U+j93Kq+7qEcT28fUtWbX7ZAOyema2b5XChrJFVPrB47mgPyNgkHUL3X7jCEcIRiDGub2OZGDI6SAyV78l5LIMWA0YZhGI6R+Rf9MjZaKebrC+fXP1luP5hfXpkeb4x1wbbzL7P2X/rpbyMZnUM7h/Wxp2t6ygltLMq6fz76H2B3uI+N1ppWZlIsB8AYlNbHx3pPb3h395HLA6gUPlfydiGtZ+JyIrSluzWxIJX6EPQ38C/i5f+uoA5LswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务过期处理逻辑\"\n        title=\"任务过期处理逻辑\"\n        src=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/00d43/yieldTimeout.png\"\n        srcset=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/63868/yieldTimeout.png 250w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0b533/yieldTimeout.png 500w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/00d43/yieldTimeout.png 1000w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0f586/yieldTimeout.png 1498w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nwookLoop是实现任务调用的核心逻辑,它主要实现了如下几件事:</p>\n<ol>\n<li>对可执行时间进行了切片(yieldInterval == 5ms)</li>\n<li>当超时可执行时间后,进行任务队列的调整在下个事件循环中唤起任务调度逻辑.这里有区分的是同步任务队列是直接通过postMessage发起调用,延迟任务队列是通过timer(setTimeout)发起调用.</li>\n</ol>\n<p>抛开源码可以简单的理解Scheduler的调度任务实现思路如下图,它正好实现了任务调度切片,优先级,高优任务插入等逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 984px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9INAQKD//EABcQAAMBAAAAAAAAAAAAAAAAAAABIDH/2gAIAQEAAQUCFl//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAACAwEBAAAAAAAAAAAAAAABIQAQETFR/9oACAEBAAE/ITyelNuDcVGDlf/aAAwDAQACAAMAAAAQMwc8/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHBABAAICAwEAAAAAAAAAAAAAAQARITEQUWGB/9oACAEBAAE/EN1dRqHbhBk0fNTqPsLrNQYmPD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler整体的思路\"\n        title=\"Scheduler整体的思路\"\n        src=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg\"\n        srcset=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/0479a/how_scheduler_work.jpg 250w,\n/blog/static/d056dfc402ef23dd6cb937078e3b9073/41099/how_scheduler_work.jpg 500w,\n/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg 984w\"\n        sizes=\"(max-width: 984px) 100vw, 984px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考链接</h2>\n<p><a href=\"https://engineering.fb.com/2019/04/22/developer-tools/isinputpending-api/\">isInputPending的实现背景</a><br>\n<a href=\"https://web.dev/isinputpending/\">isInputPending的使用思路</a><br>\n<a href=\"https://someu.github.io/2020-11-10/react-scheduler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\">react scheduler源码解析</a><br>\n<a href=\"https://react.iamkasong.com/concurrent/scheduler.html#%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%E5%8E%9F%E7%90%86\">React技术解密</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"从Scheduler包来看React的任务调度","date":"2021-03-15","tags":"React","path":"/react-scheduler","top":null,"summary":null},"title":"从Scheduler包来看React的任务调度","date":"2021-03-15","tags":"React","path":"/react-scheduler","top":null,"summary":null},{"id":"5a169371-ce61-5740-8df6-19cc70f60667","html":"<p>最近公司组织架构调整，来字节的一年多时间难得有这样一段清闲的时光来思考下自己这段时间做的事，坐在电脑旁想用一句简短的话来总结下这一年，想了半个小时愣是没想出来。所以还是以片段的方式来思考下2020一些做的不好点的，希望2021这个新年能做的更好。</p>\n<h3>技术能力</h3>\n<ol>\n<li>从原来的B端业务场景比较快速的熟悉了C端Hybrid项目的开发流程。对于跨端开发的知识的深入度不够。</li>\n<li>快速处理问题的能力有提升</li>\n<li>业务实现设计思考比较欠缺，在忙于业务的时候并没有思考好业务代码的组织形式和方案。</li>\n</ol>\n<h3>业务理解</h3>\n<ol>\n<li>低头看的时间比较多，没有看的更宽或者从业务的视角看的更远。</li>\n<li>没有更好的从业务的视角去思考技术，导致从开发视角看一直在实现PM的各种业务，没有一个长期的技术路径视角。</li>\n</ol>\n<h3>管理协作</h3>\n<ol>\n<li>没有把握好自身的精力。有时候会压缩自己在短时间内做更多相对简单重复的事，而不是压缩自己做超出自己能力的事。</li>\n<li>原则性不够  需要意识到良好的规则能更好的让事情发展，应该与协作方一起建立规则，否则会导致自己疲于奔命得到的事情的结果不一定是正向的。举个例子：需求排期的时候会估算需求的测试时间，如果一味的为了赶时间点，去压缩这个测试时间，就可能导致下个需求跟这个需求同时出现问题。保证一件事做好有可能真的不比两件事做完差(自身成长+ 业务价值)</li>\n</ol>\n<h3>2021的一些小目标</h3>\n<ul>\n<li>在技术和业务上希望自己能小步慢走，踏踏实实，走几步回头看看。不是一味的低头快走。</li>\n<li>自身学习上多看一些书，给自己的笨脑瓜充电点。体重上要控制住自己的嘴，减重年度okr: 10KG。</li>\n</ul>\n<p>结尾附录一段看到的话，共勉</p>\n<p>当我们提，技术驱动业务的时候，我们说的是：“我们已经想清楚业务的目标是什么，知道技术能在其中起到什么作用，目前现状是什么，我们可以怎么做，并且每个双月都定期复盘和回顾。”\n当我们提，我们这个方向好缺人，里面隐含着：“我们知道长期这个方向要解决哪些问题，目标是什么，需要招什么样的人，招来做什么？”\n当我们问，如何才能在技术上走到下一个阶段？除了执行力和自驱力之外，想清楚规划和执行路径，也是很关键的一步。</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2020年总结","date":"2021-02-01","tags":"年度总结","path":"/2020-summary","top":null,"summary":null},"title":"2020年总结","date":"2021-02-01","tags":"年度总结","path":"/2020-summary","top":null,"summary":null},{"id":"4151e490-cb74-597a-b9ce-9c6fa68b6efa","html":"<h2>概要</h2>\n<p>本文主要梳理前端路由的实现方案，按照如下的逻辑进行梳理：\n前置知识 => 路由方案现状 => 从源码的解读理解前端路由的实现过程</p>\n<h2>前置知识</h2>\n<h3>history</h3>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>history.length</td>\n<td>只读, 代表当前会话历史的长度</td>\n</tr>\n<tr>\n<td>history.state</td>\n<td>只读, 代表当前会话栈顶的state</td>\n</tr>\n<tr>\n<td>history.go(number) history.forward() history.back()</td>\n<td>从当前会话加载特定的页面,会触发popstate事件</td>\n</tr>\n<tr>\n<td>pushState(state, title, url)</td>\n<td>在当前会话的添加一个新的记录(关联state) url参数需要保证同源策略</td>\n</tr>\n<tr>\n<td>replaceState(state, title, url)</td>\n<td>替换当前会话栈顶的记录(不会增加history长度,关联state) url参数需要保证同源策略</td>\n</tr>\n</tbody>\n</table>\n<h4>history相关事件</h4>\n<p>当用户触发浏览器动作或者js调用history.back/history.forward/history.go方法时,会触发popstate事件。</p>\n<h3>hash相关事件</h3>\n<ol>\n<li>当url片段标识符改变(#xxx), 会触发hashchange事件。</li>\n<li>当设置与当前不同的hash片段的时候，会在当前会话中添加一个新的记录。</li>\n</ol>\n<h2>路由方案现状</h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>原理</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于history实现的路由方案</td>\n<td>使用history相关事件和方法完成路由的切换</td>\n<td>history可以设置同源下的任意url，需要注意与服务端结合的场景，防止出现404</td>\n</tr>\n<tr>\n<td>基于hash实现的路由方案</td>\n<td>使用hash相关事件完成路由的切换</td>\n<td>hash只能改变当前url的#，有局限性</td>\n</tr>\n</tbody>\n</table>\n<h2>从源码的了解路由的实现过程</h2>\n<p>以下源码分析了history路由的实现过程,源码涉及<a href=\"https://github.com/ReactTraining/history\">history</a>, <a href=\"https://github.com/ReactTraining/react-router\">react-router</a>.整体的实现逻辑如下</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 424px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 172%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC8UlEQVRIx62W6U5yMRCGuf/rIPzgF3dgQgCDyCIoyL7JjrKobAo1zyRz0gOFD83XZNKeLtN3+r6dnsB2uzVfX19ms9mY9XottRrfjO92O6/+lwW+v7/NaDQytVrNtFot02w2PeP7+fnZfHx8yKbXOA3s93tZDCJX6ff7ZjabGTa+2mG73ZbwDoeDmc/n4uDz8/P/OHx5eZHwB4PB3x0SMpNdBcdvb28+h9TnyBJShsOhoAJpo9Ew8XhcCOl2u6ZcLgspbGw7OEdSQDtXq5UQ8/r6akKhkHl/f5dQF4uFtDHGmUvNJk6Ex53s3Ov15OwymYxJp9MmkUhI/fT0ZKrVqle7ztVDyCBhsXsul/NNBg2hwzzkEQ31WYQMTqdTCZFzDAaD0qYPQpiDs+PFzjNU2UDAeDwWgyQMh6VSSbTJPGX3IstMhFHOzlW4lsc6vKRHcdjpdIRdkNIGGdoENUIH4Z9uihqLNSG4EF51U1iIE3QHImqIqFQqv3MICkSL7tTQn/19TiJOh5pgSQygpXButLXvVwnWztjUkBOJRLw+W3O2MeaSkCSHyWTisUpyuLm5Ebb55opxtsxT00g0CjsCIQUny+XSm0BhIQUFQBJO2RgjpdXrdakZhzzNPp5s9AmAXe4qpvmQzbhBJAXu9MPDg7m/v5c2NeOqAp8OtQ1iwqWQediEq8g1BBnJ4/HxUdr0oQQfQs4Ph+cyNmFyPdmIVzCVSokVCgVxWiwW/aSwyH5G2Z0atExGp4pAVcE6zZ929g643gmQqCyOZeOSkE829hNAm8MPh8PShj3VosuJaxPvz4GzIETqWCwm4fPNmWnImtlVixq2D+E1zyjJAX1qZkcmEEU0RGAnjpOHnpSPA4RsP/QswBGIIQrpZLNZkZX9Ap44BBGkoDt1yCZcRdhHdzjN5/MmGo2a29tbEfhJyJd+lrh6jPMDcHd3JxrkWU0mk/LEcgzeTTn+nQOdGshBZOvw+NWz5eXJ5rc/nK7cqKT8ABAkKsYiO95UAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"route\"\n        title=\"route\"\n        src=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n        srcset=\"/blog/static/b70462c5399fc0b238df6097205f72be/63868/route.png 250w,\n/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png 424w\"\n        sizes=\"(max-width: 424px) 100vw, 424px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>下面代码是在react项目中使用history路由实现的一个例子，它能实现根据特定的path来渲染对应的组件。</p>\n<pre><code>import './App.css';\nimport React from 'react'\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nfunction App() {\n  return (\n    &#x3C;Router >\n      &#x3C;Switch>\n        &#x3C;Route exact path=\"/\">\n            &#x3C;div>home&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/about\">\n            &#x3C;div>about&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/dashboard\">\n            &#x3C;div>dashboard&#x3C;/div>\n          &#x3C;/Route>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  );\n}\nexport default App;\n</code></pre>\n<p>react-router/packages/react-router-dom/modules/BrowserRouter.js</p>\n<pre><code>import React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    // 初始化browser history 可以推断出路由的切换逻辑是history与Router结合的实现\n    return &#x3C;Router history={this.history} children={this.props.children} />;\n  }\n}\nexport default BrowserRouter;\n</code></pre>\n<p>packages/index.ts</p>\n<pre><code>// 在最后执行跳转的时候 会执行所有的listen函数\nfunction applyTx(nextAction: Action) {\n  action = nextAction;\n  [index, location] = getIndexAndLocation();\n  listeners.call({ action, location });\n}\nlet history: BrowserHistory = {\n  // 以下为主要的跳转函数，在实现跳转逻辑的时候都调用了applyT方法。\n  push,\n  replace,\n  go,\n  back() {\n    go(-1);\n  },\n  forward() {\n    go(1);\n  },\n  // listion方法用于增加路由切换的监听函数\n  listen(listener) {\n    return listeners.push(listener);\n  },\n  // block方法允许传入一个block函数,在路由跳转的时候会执行所有的blocker函数\n  block(blocker) {\n    let unblock = blockers.push(blocker);\n    if (blockers.length === 1) {\n      window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n    }\n    return function() {\n      unblock();\n      if (!blockers.length) {\n        window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n    };\n  }\n};\nreturn history;\n</code></pre>\n<p>从上面history源码看出，history这个库主要是维护history的相关状态(state, location, hash)并且增加路由跳转的告知能力.</p>\n<p>react-router/packages/react-router/modules/Router.js</p>\n<pre><code>import React from \"react\";\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.history.location\n    };\n    this._isMounted = false;\n    this._pendingLocation = null;\n    if (!props.staticContext) {\n      // 这里订阅了history的变化并且在变化的之后更新location\n      this.unlisten = props.history.listen(location => {\n        if (this._isMounted) {\n          this.setState({ location });\n        } else {\n          this._pendingLocation = location;\n        }\n      });\n    }\n  }\n  componentDidMount() {\n    this._isMounted = true;\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n  render() {\n    return (\n      // 将location作为context 在需要订阅的位置获取   Route消费location完成特定children的渲染。\n      &#x3C;RouterContext.Provider\n        value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      >\n        &#x3C;HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      &#x3C;/RouterContext.Provider>\n    );\n  }\n}\nexport default Router;\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊前端的路由方案","date":"2020-12-15","tags":"JavaScript","path":"/history","top":null,"summary":null},"title":"聊聊前端的路由方案","date":"2020-12-15","tags":"JavaScript","path":"/history","top":null,"summary":null},{"id":"d63f14dd-5eb9-58f0-b5db-568acadf7f7d","html":"<h2>为什么开启设计模式系列</h2>\n<p>在业务压力下，仓库的代码量是快速增长的。最近在思考如何能让代码有灵活性和扩展性。随着产品的迭代，一部分业务逻辑需要重新实现，那一种良好的设计是否能在重构代码中帮助我们呢？答案是确定的。开启这个系列主要有这两方面的原因:</p>\n<ol>\n<li>在翻译业务的时候更高效和优雅</li>\n<li>通过对模式的学习能加强思考</li>\n</ol>\n<p>设计模式是解决一类问题的通用的方案，希望通过对设计模式的学习能完善解决问题的能力，本系列会结合《设计模式-可复用面向对象软件的基础》来对设计模式进行比较全面的梳理。</p>\n<h2>创建型模式</h2>\n<p>创建型模式通过对实例化过程进行抽象，隐藏了底层的具体实现，从而实现更多的灵活性。创建型模式有以下几种:</p>\n<ol>\n<li>Abstract Factory(抽象工厂)</li>\n<li>Builder(生成器)</li>\n<li>Factory Method(工厂方法)</li>\n<li>Prototype(原型)</li>\n<li>Singleton(单例)</li>\n</ol>\n<p>本文会结合一个创建迷宫的示例来介绍以上几种设计模式.通常实现一个迷宫会定义以下基类:</p>\n<pre><code>// 方向枚举\nenum Direction { North, South, East, West };\n// 迷宫组件的公用抽象类\nclass MapSite {\n  public: virtual void Enter() = 0;\n}  \n// 房间  保存其他MapSite的引用\nclass Room: public MapSite {\n  public: \n    Room(int roomNo);\n    MapSite* GetSide(Direction) const;\n    void SetSide(Direction, MapSite*)\n  private:\n    MapSite* _sides[4];\n    int _roomNumber;\n}  \n// 墙 \nclass Wall : public MapSite {\n  public: \n    Wall();\n    virtual void Enter();\n}\n// 门\nclass Door : public MapSite {\n  public: \n    Door(Room* = 0, Room*  = 0);\n    virtual void Enter();\n    Room* OthersSideFrom(Room*);\n  private: \n    Room* _room1;\n    Room* _room2;\n    bool _isOpen;\n}\n// 迷宫类\nclass Maze {\n  public: \n    Maze();\n    // 在迷宫中添加Room\n    voidb AddRoom(Room *);\n    // 根据RoomNo查找Room\n    Room* RoomNo(int) const;\n  private:\n}\n// 一个可能的迷宫生成代码\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room* r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n</code></pre>\n<p>上面代码在定义迷宫布局的时候对布局过程进行了硬编码，在未来需要对迷宫布局进行修改的时候就需要修改硬编码逻辑。通过创建型模式可以实现将实现的细节封装起来，给予代码一定的可变化性。</p>\n<h3>Abstract Factory(抽象工厂) - 对象创建型模式</h3>\n<p>抽象工厂提供一个创建一系列相关或相互依赖对象的接口而无需指定他们具体的类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 891px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABK0lEQVQoz41S147DMAzL//9gkYHMZu80O01UkAcd0ocDToBgW5ZpkrYhInJdl7zfb9n3XZZlkW3buP5v4LyGoYWqqsT3fXk8HuK6rqRpKl3XyXEcvACX6fh6vbjfNA3376CGTnA4CAI2Pp9P5rqu3APb8zyZiGmaSKBt2y8lwCJDNCoT3cAazfcDd1t0Pc8ze/UyoyxLSjVNkwyLoqCUMAzFsixxHEeSJKHMKIq4hiUIMLRtm7W6rn8AIc3zPAIAGIcAeq9hDkAo6Puec2U4jiNrYP77KGhUc++ButoAmQCHd/A5jmPOcRkIQB1Y8lHQjFTP9BHgDx5Ae/I8p0wkQIZhkCzLOOqagGr0PcEMLw8/AYzUOkZcBFUq9UvyXwGmCoIvpKk1BVRr8G0+DjIE5/TLV5AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"抽象工厂结构\"\n        title=\"抽象工厂结构\"\n        src=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n        srcset=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/63868/abstractFactory.png 250w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/0b533/abstractFactory.png 500w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png 891w\"\n        sizes=\"(max-width: 891px) 100vw, 891px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>AbstractFactory</li>\n</ul>\n<p>声明一个创建抽象产品对象的操作接口</p>\n<ul>\n<li>ConcreteFactory</li>\n</ul>\n<p>实现创建具体产品对象的操作</p>\n<ul>\n<li>AbstractProduct</li>\n</ul>\n<p>为一类产品对象声明接口</p>\n<ul>\n<li>ConcreteProduct</li>\n</ul>\n<p>定义一个将被相应具体工厂创建的产品对象，实现AbstractProduct接口</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>仅使用由AbstractFactory和AbstractProduct类声明的接口</p>\n<h4>适用性</h4>\n<p>抽象工厂通过将具体的对象创建延迟到ConcreteFactory中，能提供丰富的灵活性，适用于以下场景:</p>\n<ol>\n<li>一个系统要独立于它的产品的创建，组合和表示时</li>\n<li>一个系统要由多个产品系列中的一个来配置时</li>\n<li>需要对一系列相关产品对象设计进行联合使用时</li>\n<li>对外提供产品类库，提供统一的接口</li>\n</ol>\n<h4>优点&#x26;缺点</h4>\n<ul>\n<li>分离了具体类的实现，通过具体工厂封装对具体产品实现的细节。</li>\n<li>通过具体工厂的实现，将具体产品的实现逻辑封装在一起，增加了整体的一致性。但是在增加新的种类的产品的时候需要实现新的具体工厂。</li>\n</ul>\n<h4>代码示例</h4>\n<p>下面的代码使用Abstract Factory模式来创建一个迷宫。</p>\n<pre><code>// 定义抽象方法类\nclass MazeFactory {\n  public: \n    MazeFactory()\n  \n  virtual Maze* MakeMaze() const { return new Maze; }\n  virtual Wall* MakeWall() const { return new Wall; }\n  virtual Room* MakeRoom(int n) const { return new Room(n); }\n  virtual Door* MakeDoor(Room* r1, Room* r2) { return new Door(r1, r2); }\n}\n// 通过传递具体的工厂实现迷宫的创建\nMaze* MazeGame::CreateMaze(MazeFactory&#x26; factory) {\n  Maze* aMaze = factory.MakeMaze();\n  Room* r1 = factory.MakeRoom(1);\n  Room* r2 = factory.MakeRoom(2);\n  Door* aDoor = factory.MakeDoor(r1, r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  \n  r1.SetSide(North, factory.MakeWall())\n  r2.SetSide(North, factory.MakeWall());\n  // 省略很多的SetSide操作\n  return aMaze;\n} \n\n// 创建过程\nMazeGame game;\nMazeFactory factory\ngame.CreateMaze(factory)\n</code></pre>\n<p>通过传递ConcreteFactory,上面的代码将创建逻辑都封装在具体工厂中，这样通过传递不同的工厂就能完成不同类型对象的创建。</p>\n<h3>Builder(生成器) - 对象创建型模式</h3>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Builder模式能更好的封装产品的内部表示。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 871px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuTSRRX//EABcQAQADAAAAAAAAAAAAAAAAAAEAICH/2gAIAQEAAQUCBg7T/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABUQAQEAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Aqv/xAAYEAEBAQEBAAAAAAAAAAAAAAABABEhEP/aAAgBAQABPyED3cSusO+EX//aAAwDAQACAAMAAAAQpA//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCn/8QAFhEAAwAAAAAAAAAAAAAAAAAAECEx/9oACAECAQE/EEg//8QAGxAAAwACAwAAAAAAAAAAAAAAAAERMVEQIYH/2gAIAQEAAT8QqGJomDZtdCEqvvGTMD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"生成器结构\"\n        title=\"生成器结构\"\n        src=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n        srcset=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/0479a/builder.jpg 250w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/41099/builder.jpg 500w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg 871w\"\n        sizes=\"(max-width: 871px) 100vw, 871px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Builder</li>\n</ul>\n<p>为创建一个Product对象的各个部件指定抽象接口</p>\n<ul>\n<li>ConcreteBuilder</li>\n</ul>\n<p>实现Builder的接口来完成对象的创建\n定义并明确它所创建的表示\n提供一个检索产品的接口</p>\n<ul>\n<li>Director</li>\n</ul>\n<p>构建一个使用Builder的接口对象</p>\n<ul>\n<li>Product</li>\n</ul>\n<p>被构造的复杂对象</p>\n<p>抽象的Builder类为Director要创建的对象定义操作。ConcreteBuilder实现Builder定义的方法</p>\n<h4>适用性</h4>\n<p>通过生成器可以把复杂的对象创建过程隐藏，通过不同的Builder来完成系统的创建, 适用于以下场景：</p>\n<ol>\n<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li>\n<li>当构造过程必须允许被构造的对象有不同的表示时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeBuilder {\n  public:\n    virtual void BuildMaze() {};\n    virtual void BuildRoom(int room) {};\n    virtual void BuildDoor(int roomFrom, int roomTo) {};\n    virtual Maze* GetMaze() { return 0  };\n  protected: \n    MazeBuilder();\n}\n// 在具体调用的时候 可以传递一个实现了抽象类builder的ConcreteBuilder\nMaze* MazeGame::CreateMaze(MazeBuilder&#x26; builder) {\n  builder.BuildMaze();\n  builder.BuildRoom(1);\n  builder.BuildRoom(2);\n  builder.BuildDoor(1,2);\n  return builder.GetMaze();\n}\n\n// 创建过程\nMaze* maze\nMazeGame game\nMazeBuilder builder\nmaze = game.CreateMaze(builder)\n</code></pre>\n<p>对比抽象工厂,Builder模式封装了创建过程的细节，通过不同的builder实现可以创建出不同的对象。</p>\n<h3>Factory Method(工厂方法) - 对象创建型模式</h3>\n<p>工厂方法定义一个用于创建对象的接口，让子类来实现对应的接口来创建对象。Factory Method使一个类的实例化延迟到其子类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 818px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABdUlEQVQoz5XRwY6DIBAG4L7/g/XQSisJcTSgoIK12GqtgDXadlPd3Zi97XeawPwBhs00TcYYa61zbhgG55yZTdP0/tH3fdd1fd8/Hg9rbdd1y+6mKAohhNaac04IWWo5m6bpMWOMaa0ZY0EQFEWRpmlZlp8w5/x0Oo3jqJTCGOd5boxpmoZS2vf9/X5vmuZ4PDZNQwjxPE8pJYSI4/g7jDEmhPi+DwBKqSzLktly59frxRiL45hzDgBZlgFAVVWf8HKg7/sIoe12myRJnudJkiilluTvy8dxbNt2vbh5rxhj1t1/PJ9P59x6ZWOt1VrXs/P5vBRa63Xf9Xqt67qqKinl7XbTWltrP2EhhJQSAA6HA0Jot9uFYXi5XBhjbduWZVnXte/7QRAghPb7ved5GGMp5ffAOOdpmgJAGIZxHAsh8jynlI4zYwxCiFK6NERRhDEWQnzCZVkCQBRFABAEAWOMUkoIWX5yYX+4Wdd1wzD8Hdh/fQFNImIPdtdAXwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"工厂方法\"\n        title=\"工厂方法\"\n        src=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n        srcset=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/63868/factoryMethod.png 250w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/0b533/factoryMethod.png 500w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png 818w\"\n        sizes=\"(max-width: 818px) 100vw, 818px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Product</li>\n</ul>\n<p>定义工厂方法所创建对象的接口(抽象产品)</p>\n<ul>\n<li>ConcreateProduct</li>\n</ul>\n<p>实现Product的接口(具体产品)</p>\n<ul>\n<li>Creator</li>\n</ul>\n<p>声明工厂方法(抽象工厂)</p>\n<ul>\n<li>ConcreteCreator</li>\n</ul>\n<p>实现工厂方法，返回ConcreateProduct实例</p>\n<p>工厂方法依赖它的子类来实现工厂方法来完成对象的创建。</p>\n<h4>适用性</h4>\n<p>工厂方法适用于以下场景:</p>\n<ol>\n<li>父类不知道它需要创建的对象的类的时候</li>\n<li>当一个类希望它的子类来指定创建对象的时候</li>\n<li>当类将创建对象的职责委托给多个帮助子类中的某一个并且希望某一个帮助子类代理这个创建过程</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeGame {\n  public: \n    Maze* CreateMaze();\n\n    // factory method;\n    virtual Maze* MakeMaze() const { return new Maze(); };\n    virtual Room* MakeRoom(int n ) const { return new Room(n); };\n    virtual Wall* MakeWall() const { return new Wall; };\n    virtual Door* MakeDoor(Room* r1, Room* r2) const { return new Door(r1,r2);  };  \n}\n\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room&#x26; r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n// 子类实现工厂方法来完成对象的创建\nclass BombedMazeGame : public MazeGame {\n  public:\n    BombedMazeGame()\n    virtual Room* MakeRoom(int n) const  { return new RoomWithBomb(n); };\n}\n</code></pre>\n<h3>PROTOTYPE（原型) - 对象创建型模式</h3>\n<p>原型模式通过原型实例指定创建对象的种类，通过拷贝原型来创建新的对象</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 747px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY03XQ224EIQiA4Xn/x5wLKzr1iA6guG3cbA9p+l0S/pBw1FpjjABQSqm1Pl7GGMwsGxGFEGKMPyeqepznaYwJIVzXZa3tvRMRM8cYvfcppbC9bYhYa0XElNIY40gplVJ67601Zv66rKrMXEpBRGaem6q21u77VtW11vFcXWs9fltriQgiEpGIrI2Z28bM3/FfRAQA1loAcM6NMUTEGOOcs9uc89+Ymb33Oef3bc4pIgCQc34+6DP+AFoUWqjoiPwWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"原型方法\"\n        title=\"原型方法\"\n        src=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n        srcset=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/63868/prototype.png 250w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/0b533/prototype.png 500w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png 747w\"\n        sizes=\"(max-width: 747px) 100vw, 747px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Prototype</li>\n</ul>\n<p>声明一个克隆自身的接口</p>\n<ul>\n<li>ConcretePrototype</li>\n</ul>\n<p>实现一个克隆自身的操作</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>让一个原型克隆自身从而创建一个新的对象</p>\n<h4>适用性</h4>\n<p>原型模式适用于以下场景:</p>\n<ol>\n<li>实例化的类需要在运行时刻指定</li>\n<li>类的实例状态是相似的，通过原型的克隆能减少类的创建</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazePrototypeFactory : public MazeFactory {\n  public :\n    MazePrototypeFactory(Maze* , Wall*, Room*, Door*);\n\n    virtual Maze* MakeMaze() const;\n    virtual Room* MakeRoom(int) const;\n    virtual Wall* MakeWall() const;\n    virtual Door* MakeDoor(Room*, Room*) const;\n\n  private:\n    Maze* _prototypeMaze;\n    Room* _prototypeRoom;\n    Wall* _prototypeWall;\n    Door* _prototypeDoor;\n}\n\nMazePrototypeFactory::MazePrototypeFactory (\n  Maze* m, Wall* w, Room* r,Door* d\n) {\n  _prototypeMaze = m;\n  _prototypeRoom = r;\n  _prototypeWall = w;\n  _prototypeDoor = d;\n}\n\nWall* MazePrototypeFactory::MakeWall() const {\n  return _prototypeWall->Clone();\n}\nMazeGame game;\n// 需要初始化传入的实例支持clone操作，可以通过传递不同的实例完成不同的对象创建\nMazePrototypeFactory simpleMazeFactory(new Maze, new Wall, new Room, new Door);\nMaze* maze = game.CreateMaze(simpleMazeFactory)\n</code></pre>\n<h3>SINGLETON（单例）- 对象创建型模式</h3>\n<p>保证一个类仅有一个实例，并提供一个访问他的全局访问点</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu6QD//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARIUFR/9oACAEBAAE/IVnbLE7KXJ//2gAMAwEAAgADAAAAENDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECExkf/aAAgBAQABPxB7NzXBiTW+QRKuDzP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"单例模式\"\n        title=\"单例模式\"\n        src=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n        srcset=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/0479a/singleton.jpg 250w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/41099/singleton.jpg 500w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg 750w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Singleton</li>\n</ul>\n<p>定义一个Instance操作，允许客户访问它的唯一实例</p>\n<h4>适用性</h4>\n<p>单例模式适用于以下场景:</p>\n<ol>\n<li>唯一的实例需要全局访问时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class Singleton {\n  public: \n    static Singleton* Instance();\n  protected:\n    Singleton();\n  private:\n    static Singleton* _instance;\n}\n\nSingleton* Singleton::_instance = 0;\n// 对成员初始化未空，第一次访问的时候创建成员，再次访问直接范返回成员\nSingleton* Singleton::Instance() {\n  if(_instance == 0) {\n    _instance = new Singleton();\n  }\n  return _instance;\n}\n</code></pre>\n<p>在单例模式中，想要实现动态的确定单例的类型方式，可以通过维护单例注册表的方式来实现。</p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"编程拾遗系列设计模式-创建型模式","date":"2020-07-06","tags":"设计模式","path":"/build-pattern","top":null,"summary":null},"title":"编程拾遗系列设计模式-创建型模式","date":"2020-07-06","tags":"设计模式","path":"/build-pattern","top":null,"summary":null},{"id":"0b34442c-60aa-5d28-afd8-15a19f696f40","html":"<h2>前言</h2>\n<p>在react native开发中通常会使用Touchable<em>组件来实现对用户手势的处理.本篇文章从Touchable</em>组件的基本使用出发,逐步深入到react native中的手势处理的原理.</p>\n<h2>Touchable*组件</h2>\n<h3>基本使用</h3>\n<p>在react native中通常使用一下几种组件来实现点击的处理</p>\n<ol>\n<li>TouchableOpacity</li>\n<li>TouchableHighlight</li>\n<li>TouchableWithoutFeedback</li>\n</ol>\n<p>对于TouchableOpacity的基本使用如下,通过绑定onPress事件就能获取到用户的点击行为进行处理</p>\n<pre><code>    &#x3C;TouchableOpacity\n      style={styles.button}\n      onPress={(evt => { this.onPressEvt(evt)  })}\n    >\n      &#x3C;Text>Press Here&#x3C;/Text>\n    &#x3C;/TouchableOpacity>\n</code></pre>\n<p>在开发中不禁会有这样的疑问,为什么TouchableOpacity能响应用户的手势点击而普通的View组件却不行.这就引出了React Native中的手势处理流程</p>\n<h2>手势处理流程</h2>\n<p>React Native中组件对手势的响应是通过如下的阶段来实现:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 862px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAEWH/2gAIAQEAAT8hVFRU/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAABEAASFR/9oACAEBAAE/EH3VNXZv1f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 手势\"\n        title=\"react native 手势\"\n        src=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n        srcset=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/0479a/gesturelifecycle.jpg 250w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/41099/gesturelifecycle.jpg 500w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg 862w\"\n        sizes=\"(max-width: 862px) 100vw, 862px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在每个阶段会有相应的处理函数来处理当前阶段的行为</p>\n<h3>手势响应的阶段</h3>\n<h4>申请阶段</h4>\n<ol>\n<li>View.props.onStartShouldSetResponder: (evt) => bool(返回true 代表当前组件申请在触摸手势的时候成为响应者)</li>\n<li>View.props.onMoveShouldSetResponder: (evt) => true(返回true 代表当前组件申请在移动手势的时候成为响应者)</li>\n</ol>\n<h4>通知阶段</h4>\n<ol>\n<li>View.props.onResponderGrant: (evt) => {}(获取手势处理回调)</li>\n<li>View.props.onResponderReject: (evt) => {}(获取手势处理失败回调)</li>\n</ol>\n<h4>响应阶段</h4>\n<ol>\n<li>View.props.onResponderMove: (evt) => { }(手势移动回调)</li>\n<li>View.props.onResponderRelease: (evt) => { }(手势行为结束(touchUp)回调)</li>\n</ol>\n<h4>释放阶段</h4>\n<ol>\n<li>View.props.onResponderTerminationRequest: (evt) => bool (当其他组件想成为当前手势的处理者时会触发,返回true表示释放)</li>\n<li>View.props.onResponderTerminate: (evt) => {} (当前组件失去响应者身份触发）</li>\n</ol>\n<h3>手势拦截</h3>\n<p>手势的响应是冒泡的,父元素可以使用如下的方法来实现对手势的拦截处理.</p>\n<ol>\n<li>View.props.onStartShouldSetResponderCapture: (evt)=> bool (返回true成为手势的处理者, 子元素不响应)</li>\n<li>View.props.onMoveShouldSetResponderCapture: (evt)=> bool ((返回true成为手势的处理者, 子元素不响应))</li>\n</ol>\n<h3>自定义响应组件实现</h3>\n<p>通过对手势处理阶段的了解,在定义响应组件的时候可以通过添加相应的函数来实现,react native定义了PanResponder.create()方法来快速的实现组件的定义.PanResponder响应回调函数中封装了事件和手势的状态信息,能更细致的实现对手势的处理.</p>\n<pre><code>class App extends Component {\n  constructor(props) {\n    super(props)\n    this.PanResponder = PanResponder.create({\n      onStartShouldSetPanResponder: (evt, gestureState) => true, // 触摸的时候成为手势响应者\n      onPanResponderStart: (evt, gestureState) => { console.log('someone touch me') }, // 触摸时间回调\n    })\n  }\n  render() {\n    return (\n      &#x3C;View style={styles.container} {...this.PanResponder.panHandlers} >&#x3C;/View>\n    )\n  }\n}\n</code></pre>\n<h2>后记</h2>\n<p>最新会按照下面的思路逐步的梳理下React Native相关入门与实践的一些知识.\n<img src=\"reactNativeBasic.png\" alt=\"react native 入门\"></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"react-native中的手势处理","date":"2020-04-15","tags":"跨端技术","path":"/rn-gesture","top":null,"summary":null},"title":"react-native中的手势处理","date":"2020-04-15","tags":"跨端技术","path":"/rn-gesture","top":null,"summary":null},{"id":"78aae74d-c5ef-5f1d-be91-cf676102521f","html":"<h2>前言</h2>\n<p>长列表优化是一个老生常谈问题,优化的方案也是相似的(减少内存占用,复用渲染结果,可视区域渲染,预渲染),在跨端开发的React Native中列表主要有FlatList和SectionList两种,以下主要通过对FlatList的介绍来了解React Native中的长列表.</p>\n<h2>FlatList</h2>\n<p>FlatList通过预渲染和可视区域渲染的方案,来降低列表渲染时候的内存占用从而提升页面的性能.下面从FlatList的基础使用来逐渐展开.</p>\n<h3>基本使用</h3>\n<pre><code>renderItem = ({ item, index }) => {\n  return &#x3C;View>&#x3C;Text style={{ color: 'white' }}>{item.name}&#x3C;/Text>&#x3C;/View>\n}\nrender() {\n  return (\n    &#x3C;FlatList\n      data={[{ name: 'a' }, { name: 'b' }, { name: 'c' }, { name: 'd' }]}\n      renderItem={this.renderItem}\n      keyExtractor={item => `${item.name}`}\n    />\n  )\n}\n</code></pre>\n<p>在上面的例子中通过设置data, renderItem(条目渲染函数)就完成了列表的渲染功能</p>\n<h3>结构</h3>\n<p>FlatList数据渲染的原理是通过数据项和底层容器ScrollView的布局事件计算出需要渲染的条目,在滚动过程中动态的更新渲染条目来完成列表的绘制.FlatList渲染的内部结构如下:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 157.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsTAAALEwEAmpwYAAADeElEQVRIx6VWS4/TZhS1xKhQsUfqhkUXlUCCUhYUqZVaCQmVAv+jSEjdTIuEkKpu2k2X7T9ohbqoVAQbEBKLMu9h3knITDJ24vgR5+XxK4kd56BzwenAamJs3Xyfbfn43nPPd74ocRwjDEP0ej0cHBxIuK4r1/1+H3w+HA5lPEoofEnXdTQaDezt7WF/fx+1Wg31eh22bWM0Gk0HGAQBLMtCs9nE7u6uAJZKJZimKfdyATITZrm1tSVZbmxsCHir1UKSJNMBkj+WR2BmtrCwIOUzO8Mwps8wiiIpk80gCMHZEM7JZZqm+UrmwRdZImMwGAi3uThkNr7vo1gsolqtTjLOBUgOydV4PJaXGZyTitwcMivKJJMKM9M0TficmkNmSKBMLmzE+vr6pNPTlxyEMEwDcRqj8LKA+aV56JaOcBCiYTQmgEcJAfQDHx2zg9iJ4Rs+AjOA1/AQ2REcy0E6TpHEiZTO7mc8Z0GQTBkEVRABv1f+wJf2V7hu3cQ31re4Zt/AFfUqnqnPkIQJ3AMX7XZblECNZkZCE6G8OOczgioIgNv2d1AOn66Cr9cv4f7cX3ix+AJaTRN+V1ZWsLS0hLW1NSwvL2N1dVWkVigUZJkyY8nwzv5vUNyzONn9Ase7l3HCvYwZ+yIe1Z8iDRMM4oFkUC6XJ86kqqoogWBUyqGSQ/xY0aH4wAc+MOMBygBQemM81HRZQYM3HPKgRhnZnAcz+x8wDDGra1AwwgzIQYqPWgY+L23iz+f/QS3vouk42N7eFmnRQFgm3YjBe1y6XAT8qIIwwA81C8oYmEkh4ykPuGCGeLBdhKPr8IJAyqM+yeHc3JzwSF4XFxdRqVTE9UU26AN3yn9DMWdx0vwJH5r3cKz1M5TGXTzSVl6bRvJatFz35JJdJQCvOSeHmV6ly983b73dZZ4jBf9a/wAjIBpGb+nt3Ti870iXf1F/xengY3zqXcTZ3jmcDz7DJ60zeFx/AqRAf9g/0iqRDMMoRF2rQ91ToVZUtO02quUqtIoG0zDzb1JOy8Hm1iZ2Cjsoloroub332/W4nbJb7BxNwfM9caHcewplQfXTAzkSnKtiaj8kIMEycrnY+YAGkAuQJTuOg2w7pasw+KFcewqFSkACEJBzOkduQL5I26fiPc+bjLR/usrUJfOHWXY6nUl0u10Jfmzaf1+vACaDAH8XnMbBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listSection\"\n        title=\"listSection\"\n        src=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/list.png\"\n        srcset=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/63868/list.png 250w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/0b533/list.png 500w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/list.png 523w\"\n        sizes=\"(max-width: 523px) 100vw, 523px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>FlatList性能优化</h3>\n<h4>减少更新时列表项总体数目和条目的重渲染,</h4>\n<ol>\n<li>列表条目使用PureComponent或者shouldComponentUpdate来减少条目的更新.</li>\n<li>调整windowSize大小(默认是21)</li>\n<li>调整maxToRenderPerBatch的大小,控制每次更新的最大条目</li>\n</ol>\n<h4>减少内存的占用</h4>\n<ol>\n<li>在列表项中合理的使用缓存</li>\n<li>减少匿名函数的使用</li>\n<li>列表条目的渲染逻辑尽量简单</li>\n</ol>\n<h4>减少渲染过程中的计算</h4>\n<ol>\n<li>使用getItemLayout减少列表条目的计算过程</li>\n<li>调整滚动事件的触发频次(scrollEventThrottle)</li>\n</ol>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"聊聊React Native中的长列表","date":"2020-03-22","tags":"跨端技术","path":"/rn-list","top":null,"summary":null},"title":"聊聊React Native中的长列表","date":"2020-03-22","tags":"跨端技术","path":"/rn-list","top":null,"summary":null},{"id":"539f2928-413b-54c3-8c37-f42a442c9ec9","html":"<h2>前言</h2>\n<p>最近这半年从原来的PC转到了移动端开发(主要使用React Native),在跨端开发的时候需要与端上进行交互(jsBridge,使用端上的组件等).通过对端上知识的学习能在业务开发中知其所以然,也能更好的把一个方案落地.这篇简单梳理了第一行代码-Android的总体大纲.</p>\n<h2>读书导图</h2>\n<h3>笔记图片</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/6f464/android.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 124.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAACt0lEQVQ4y41Vy5KbMBDk//MT+Yoccs8hx1Tl6N31Az+wAYEkQBhwp3rYYbGNq6IqWbI06ul5Et1uN3AMw4Dr9Sqz63ro0HuunH3fo65rNCGgLEs45zAfEX8IYq1DHO9xOBwRQhBBPp6DKpi1FpdLijzP5b8q4hqpYNM0uKQp0ixD27YoikJWBeN9VVWyJ0iSnJGcz0Li7f1d2NLKiA/40JgcqSlQ1Q26rpvcoJq99zL1XBUYYxDH8aQsorb1ZoPNZismUFjNVEBVwH1ZWgFRAHFZ102WRKO5QfxGM2n23FSCcZIdgQ7HI3ZxjCRJJsbzAEb6h4+OxyNWq9VdQAhOZbxXpfQXA1PXzV0GCEPd0AQKn04nZFku5tNPCqjgPGcglN0c7A6QK5lx5rn5NBsorUUI7QS4P10EsG6apzyd8nCuwXkv5tAs3AYMgUzGoARf4pLFTyCLDMcIljifzzCmgHcWcerw888ev99ytD3QtQGuSBeBngA1edM0Q1GU8LbA322Obz9W+P4rxikrUXmHqjRw1k3l+eTDz1MpPzrfOifBIctb3wEdfXUTGSosyhKr1RtMUSyyFEBGbLvdSXKnaTqrFAbKS+JqzefG4P3jY/TxK4ZkxmQlKItemForjLjXnCQgFZLhfn+YwO7yUNOBJtB/WZYJmArwTgEJzqbwsV5L6lDBU5S1e1RVLaWlbUmFx/741SyodH84SPIvJXf02AikjV2+6llrWbIgBHELWZLtvJEsVMp4cCkbFK7GMPTo+1GJdvOxDybSILT8Hptw9EjZFB5t2wnDtr1OLFjr9C2bKtOKvmZVPfrxCTA1O9TBwvtKQOfCVuo8n2r78buzCJikG1iXv/xIaXAe0+WO4fzA+1qmBuLx4StmLxmWhzWulcVww2JXecXsCVAjHSqHaxswLJj6P+MfteqgdEuoDakAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"安卓基础知识\"\n        title=\"安卓基础知识\"\n        src=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/00d43/android.png\"\n        srcset=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/63868/android.png 250w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/0b533/android.png 500w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/00d43/android.png 1000w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/6f464/android.png 1464w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>笔记导图</h3>\n<p><a href=\"https://github.com/icantunderstand/learnStuff/blob/master/androidBase.xmind\">第一行代码笔记</a></p>\n<h2>后记</h2>\n<p>后续会逐步更新react native和跨端开发的基础知识,希望能坚持下来.</p>","fields":{"readingTime":{"text":"1 min read"}},"frontmatter":{"title":"第一行代码-Android读书笔记","date":"2020-02-01","tags":"跨端技术","path":"/android-basic","top":null,"summary":null},"title":"第一行代码-Android读书笔记","date":"2020-02-01","tags":"跨端技术","path":"/android-basic","top":null,"summary":null},{"id":"03092f3c-0c57-5f81-b05c-9a7974eeb81b","html":"<p>本文主要对EcmaScript规范中函数对象解读。</p>\n<h2>函数对象</h2>\n<p>函数对象是对外部的词法环境和有一定入参的代码进行封装后的对象.函数对象的调用支持动态的绑定执行环境.在javascript函数执行的时候,实际上是调用当前函数对象的一些内置方法来实现的.下面是函数对象的一些内部实现:</p>\n<table>\n<thead>\n<tr>\n<th>内部实现</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[Environment]]</td>\n<td>Lexical Environment(词法环境)</td>\n<td>词法环境定义当前函数对象生成时候的外部环境,例如引用的外部变量等</td>\n</tr>\n<tr>\n<td>[[FormalParameters]]</td>\n<td>Parse Node</td>\n<td>定义函数的参数列表</td>\n</tr>\n<tr>\n<td>[[FunctionKind]]</td>\n<td>String</td>\n<td>函数类型(normal, classConstructor, generator, async, async generator)</td>\n</tr>\n<tr>\n<td>[[ECMAScriptCode]]</td>\n<td>Parse Node</td>\n<td>代码体</td>\n</tr>\n<tr>\n<td>[[ConstructorKind]]</td>\n<td>String</td>\n<td>构造类型,当函数通过new操作符进行调用的时候,会用到这个属性.(base derived)</td>\n</tr>\n<tr>\n<td>[[Realm]]</td>\n<td>Realm Record</td>\n<td>当前函数对象的Realm记录,在函数执行的时候需要将函数与Realm进行绑定,由Realm提供全局的环境对象等</td>\n</tr>\n<tr>\n<td>[[ScriptOrModule]]</td>\n<td>Script Record or Module Record</td>\n<td>记录当前函数对象不同创建方式的记录</td>\n</tr>\n<tr>\n<td>[[ThisMode]]</td>\n<td>(lexical, strict, global)</td>\n<td>this会在进入函数的执行环境时进行绑定.lexical代表着this的确定规则是由外部的词法环境决定的(箭头函数),strict代表this是由函数的调用者提供的,global代表着this由外部的全局对象指定(需要区分严格和非严格模式).</td>\n</tr>\n<tr>\n<td>[[Strict]]</td>\n<td>Boolean</td>\n<td>确定当前函数是否是一个在严格模式下执行的函数</td>\n</tr>\n<tr>\n<td>[[IsClassConstructor]]</td>\n<td>Boolean</td>\n<td>是否是构造函数，如果是构造函数通过[[Call]]方式会报类型错误</td>\n</tr>\n</tbody>\n</table>\n<h2>规范详细解读</h2>\n<h3>[[Call]]</h3>\n<p>当通过指定this调用函数对象的时候，实际上会执行内部定义的[[Call]]方法。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/da952/Call.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACJUlEQVQ4y42SC4+tKBCE/f9/cHfmzpnjG48KKiIgoN9GZ242+7ib7aRIA6Horq6s719UVUn+fFJ1glpJKiVplaSUI41eEXrF7gG/71hrcc7hY8SnhN8Dbk+4kDjOk6wUA3nT0/aSVggaOdIpieh66qqmrBrK5kVeC4qiuD/O85xCCIpOkFcVz6rlWQs268jmZcG4nZgOnPd3FXsIhHTi48F5nnAenMfBX+I+P7/z6+5rn3nv6aeFblkQQ09ZljTDRKs2WmWQqyOk45vj/BNfFJw/+b+RGWNohpHKrLSrpnqNFK+JYtCU0lKOmkdRk1cNKaV/Ev8N2SXwpc97UfCjKvl4PHh/e+O3t3c+niWjmpn0hg+J/xPZtax6oShLummiapo7z9uGZyco64au75FS0Q2SfjaMq2VPiRgjIaZb/wvpOL8IQ4jU4sViLWvcWTeD1prVxRvaBqbVotSEVAplLcvuWbRmWS3TtjMZj9sj2XEc9P3A74+Cclip5UY+GGo1M7sNnyI2BmyKpJ9T/a+Wr0o+i5yi7/l4TfwQirey50MoHv1EriY+p5l8HNDriosBl+JtMef8bWi7R/b4pXF26dDLmdVa/BFxu2dbNZsPbD5iXMC4iDEbyzyjncXEgLEbZrNoF9B2v9u9CZdl4dFJ3quOz6KmaMU9ADktSO1Qxt9enJ1lGMeb9Fdx2+ZquREvhFqplaGdDXI21HWFlPKXD/8NV4V/AHQW58QcFWiNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Call步骤\"\n        title=\"Call步骤\"\n        src=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/00d43/Call.png\"\n        srcset=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/63868/Call.png 250w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/0b533/Call.png 500w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/00d43/Call.png 1000w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/aa440/Call.png 1500w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/da952/Call.png 1872w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>将执行上下文切换到当前的执行上下文并对当前的执行上下文做基础的设置</li>\n<li>如果当前函数是类构造函数报错并退出</li>\n<li>在执行上下文上绑定this</li>\n<li>执行函数</li>\n<li>恢复执行上下文，如果有返回值返回结果</li>\n</ol>\n<h3>[[Construct]]</h3>\n<p>当通过new操作符调用一个函数对象的时候,实际上会执行内部定义的[[Construct]]方法,下面从规范上理解[[Construct]]方法从而理解调用构造函数的实际行为.<br>\n在通过new调用构造函数的时候会进行一些参数的修正然后调用构造函数的[[Construct]]\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/5068c/newBefore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABlklEQVQoz42Su27cMBBF9f9t+nxG6sCt26RJvGuJEiW+RFLUY7VriSeQErsL4AEOwEvM3JkBWUgpEULw+lpifY8eBsQQkWlAx4j2jtJ1SN0xpkTOmW3b2Pf8l5zZD71t5H2nkI1EdR1N02CtRWlNpxRKK3QYaH58p3v6ivz5hAkDSim01tg4YdOKiQsuBFqtSdNEIQ4za88pGymRbUdVVVRCIFR3UoqSsqkpmwZR12fzqpaUdUvVKoT3VKEnLQvF78vlTKrKksv1SlW3XF5esMYweI+PETtN9N5jtcaHcOKspXcO73uMtYQY2Y+VjwIzJlwMWKMxWtPHiFtm0u3Gtu+w7+S885kotA80Q6IbbnRmoq47tFL4ZaFfZoZpIqWE73timnjb9vNh/kchtacxA7X+RdU9I+wV4Xpc71gfD7acPzVZ/pdXaGOIw0hrvlG3X2jtM2a8YWLApYQbE/f7ncfjcXKcj29zX1fWdf3Q76bFcXHE9IDpDR73zDJPrLeVZZ5P5mVhHEfmeT7XP2pijIQQPvS74R+Y/K4/ae/U/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"newBefore\"\n        title=\"newBefore\"\n        src=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/00d43/newBefore.png\"\n        srcset=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/63868/newBefore.png 250w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/0b533/newBefore.png 500w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/00d43/newBefore.png 1000w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/aa440/newBefore.png 1500w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/5068c/newBefore.png 1917w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/9efb3/new.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIklEQVQ4y42T2Y7bMBRD8/+/VxQoWkydWNa+Wd5i2UlO4Uy36cxDBRDSiwjykveUc0Z2EqUUnRBIrZExYnJ+RYrInEnjwlJ31roxzzPLsjBPM8v1yrJvXPf9+T7lcUDlhCsZ02d8SqhOouUBhVQG0Qo65bh0GtFJRNvSdR3n85lWCIS1CGNIOXPat400LLh+xsWIdPap0oRMnipLvfF6HvzPOdW6YqznHBJtSjRKcu40L60ijVfytDIslcfj8V841VqJOeNK/7RhteaYaykD9/v9nbjnxw+U/SbctkouBeEsX7Xiu7Eol1BxQoYRGQZ0HpFpJA4Tpa44759ztNbS/rx/kT4VGh8RMXOJAeE9rTQ0KnC2I40ttKHQxp65Vrb7jXq7sd1ub6z+IVxXYt8TxwFpLSEGnDHYkLAho13C50JY5iemulLWlWldD4b3oRydUkcQKdA4T+MT343jpbN8bS3fWk3jEnGeqfv+4dz+Vnm6LgttJ2mNxZSCGSa0C+hQUGnB9jO6zJiYSSGQx5G+rvTzRN8X8rg+21Dm+kq4Xq/kccKm8kx3GAopRa7L/K5/h4j748G27xz9ffxj+WfKG/tWMSFysY6mvXBpGkSnEMrRaY/wBRELIhTCMNIPAzHG37V6Y/lIuT8KrS3fpObT5y80QtCcW17OAmUDnTK8tBeUs3jv36l6E8qx5FJKrI+4cUZaj9CaEDw87h+u10d1+UX4A21fMqcRX5VbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"new\"\n        title=\"new\"\n        src=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/00d43/new.png\"\n        srcset=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/63868/new.png 250w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/0b533/new.png 500w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/00d43/new.png 1000w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/aa440/new.png 1500w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/9efb3/new.png 1894w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/161ec/createObj.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQoz3WS646kIBBGff/368kmCiLSAord4/3aezYwmZ9byUlRX6Coj5BJY3jkOX+kJBcCXWmMMdR1nei6Dj9PuGWmW2bcHJkw00gzTzTjwHEe/EZWhQ4dOqrWY71jnibWdWVZFuZ5Zt02tuNg3Xf242DZtrT+JdXryr7vnOdJJqREx2kaj7YBqTRfXw8ejwdCiISuKkqlkJGypCxVQhQFpZR47wkhpCEy5R3Ke+ouYBr3c1AIpJQoVaUcNWVtclHZJu3TpkGVJZWuecZaa8ZxJHNNg7cNMbfO4Z3DWUfbtolo575vrvPkvi6O4+A8D67r+tHvD+f9SXoka/sB17/x32+efaAdvulCoHmaRB8CXWzufSLWfegTzvlkN178er24rpusfloKrSlKRVFbRG1RxiGUoVCGsjbkukJoTfwRea3JtaY2T5y1OOfS+8WmwzCQNdHqe8C/V/x7wY8zYVnxy0o7LeznxQcSN3Dxl4v/xz9Dj1l5z6jTKAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"objCreate\"\n        title=\"objCreate\"\n        src=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/00d43/createObj.png\"\n        srcset=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/63868/createObj.png 250w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/0b533/createObj.png 500w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/00d43/createObj.png 1000w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/aa440/createObj.png 1500w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/161ec/createObj.png 1840w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n[[Construct]]主要分为一下几个步骤:</p>\n<ol>\n<li>将执行上下文定义为当前的执行上下文</li>\n<li>获取当前函数对象的[[ConstructorKind]], 如果是base类型, 将当前的执行环境的this设置为以构造函数为原型创建的对象</li>\n<li>创建新的执行上下文将2中的this绑定到当前的执行上下文</li>\n<li>在当前的词法环境和环境记录上执行构造函数</li>\n<li>退出当前的执行上下文,返回到上次的执行上下文</li>\n<li>如果执行构造函数的结果是有返回值的,当返回一个对象的时候直接将执行结果返回.当有返回结果但是不是对象的时候返回之前创建的this</li>\n<li>没有返回值的时候,返回之前创建的this.</li>\n</ol>\n<h4>简单实现一个new的调用过程</h4>\n<pre><code>function myNew(Con, ...args) {\n  const obj = Object.create(Con.prototype);\n  const ret = Con.call(obj, args);\n  if(ret instanceof Object &#x26;&#x26; ret !== null) {\n    return ret;\n  }\n  return obj;\n}\n</code></pre>\n<h3>Object.create</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6cf0fab11d6071570431a07fe120598e/019a6/ObjectCreate.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+klEQVQY032QW26DMBBF2f93V9Bt9Ct7aKUooQ8IoRA/iAUo4NepbLVRko9auhpd2XfmeAohJX3bUG2eaV6e6F43qNXSjoZhnoghEGO8KoRwp9u7pEJKyaGuqD92HKuSrm0YjEFojVQKYwxaa4ZhuCr5lOv7Pvvz+Zz9PM8UKdD1J3qhSLRaKZxdcdayXC4sy8I0Tfnx5dffEnrv72ph15VDd6KWmqrt2X81bN8ryqqh7TqmccxDhBDoYcjE/50ikZy0Yn885IbbzyNvZU1ZfyPMxOwso7WEGK+hx73d7dB5h5IKoRTWe1wAH8l1sZ7Fuaz0pb/QbeNHwh/2uc30ZuRRvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Object.create\"\n        title=\"Object.create\"\n        src=\"/blog/static/6cf0fab11d6071570431a07fe120598e/00d43/ObjectCreate.png\"\n        srcset=\"/blog/static/6cf0fab11d6071570431a07fe120598e/63868/ObjectCreate.png 250w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/0b533/ObjectCreate.png 500w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/00d43/ObjectCreate.png 1000w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/aa440/ObjectCreate.png 1500w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/019a6/ObjectCreate.png 1818w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>判断传入的原型是否是Object/Null，不是的话抛出异常</li>\n<li>根据传入的原型创建对象(如果传入的原型参数是空那么创建的对象没有原型)</li>\n<li>在创建的对象上定义属性并返回结果</li>\n</ol>\n<h3>规范示例</h3>\n<p>[[Environment]]定义函数对象创建时候的外部词法环境.实际上在javascript中函数就是闭包的概念.函数在创建的时候就已经跟外部的词法环境进行了绑定,在调用的时候并不会改变函数的外部的词法环境.</p>\n<pre><code>const a = 100;\nfunction test() {\n  console.log(a);\n}\nfunction test2() {\n  const a = 200;\n  test();\n}\nconst obj = {\n  a: function() {\n    test();\n  }\n}\ntest2() // 100\nobj.a(); // 100\n</code></pre>\n<p>在一个构造函数中返回一个非对象:</p>\n<pre><code>function Person(name) {\n  this.name = name;\n  return 1;\n}\nconst person = new Person('ss'); // { name: 'ss' }\n</code></pre>\n<p>对于this的确定,可以参考下面的确定规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://tc39.github.io/ecma262/#sec-ecmascript-function-objects\">ECMAScript2020</a><br>\n<a href=\"http://ldllidonglin.github.io/blog/2019/04/26/2019-04-26-ECMAScript2016%E8%A7%84%E8%8C%83%E7%90%86%E8%A7%A3%EF%BC%888%EF%BC%89-new%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/\">ECMAScript2016规范理解（8）-new表达式的执行过程</a><br>\n<a href=\"https://icantunderstand.cn/2019/01/15/LE/\">深入理解javascript系列之执行环境</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"ECMAScript规范-函数对象","date":"2019-05-29","tags":"JavaScript","path":"/ecmascript-function","top":null,"summary":null},"title":"ECMAScript规范-函数对象","date":"2019-05-29","tags":"JavaScript","path":"/ecmascript-function","top":null,"summary":null},{"id":"e89f4cab-35d0-5952-9b50-1f844568b2f2","html":"<h2>前言</h2>\n<pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nReactDOM.render(&#x3C;App />, document.getElementById('root'));\n</code></pre>\n<p>当通过create-react-app初始化一个项目的时候,上面这段代码就在浏览器中绘制出了内容.ReactDOM.render(ReactElement, Container, callback)是怎么将React组件绘制到浏览器中的呢?本文是React源码阅读系列的起始篇,在这篇文章中主要围绕以下两个方面进行介绍:</p>\n<ol>\n<li>render()方法调用中相关函数的调用</li>\n<li>render()方法调用中产生的数据结构的梳理</li>\n</ol>\n<p>阅读源码是一个知其然知其所以然的过程.通过源码阅读的过程中我们能学习到一些设计,代码优化,解决方案等,通过这些来反哺实际工作的遇到的问题.这个也是这个系列想要获得并且与大家分享的内容.</p>\n<h2>如何阅读React源码</h2>\n<p>React仓库是一个包含多个package的仓库.在阅读源码之前需要对独立的仓库有个简单的认识.比如react通过react-reconciler和renderer(react-dom, react-native)来完成页面的渲染.</p>\n<ol>\n<li>\n<p>下载<a href=\"https://github.com/facebook/react\">react源码</a>, 打包本地文件</p>\n<p>yarn build react/index,react-dom/index,scheduler --type=NODE</p>\n</li>\n<li>\n<p>通过yarn link声明包的指向</p>\n<p>cd build/node_modules/react\n// 声明react指向\nyarn link\ncd build/node_modules/react-dom\n// 声明react-dom指向\nyarn link</p>\n</li>\n<li>\n<p>把项目中的依赖指向设定的包</p>\n<p>yarn link react react-dom</p>\n</li>\n<li>\n<p>增加断点调试</p>\n</li>\n</ol>\n<h2>ReactDOM.render()调用过程中的函数调用</h2>\n<p>以下所有代码基于React 16.8.6</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 218px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/548b054e096b5dbdd8ab61b79d1b93ba/5c416/renderFunc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 241.28440366972478%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAwCAYAAAARtFotAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHUUlEQVRIx41XCVNaWRbmj07VVHei2dNVE2MiLqhIlGjU9GSbpaqno6QjCrKDS0eT6ThqOu7GhSgCb+WxKKuKfF33PBaJS88rP+653znvcOWd+93zNAAQjK3DFtDBE+6CTzTCy3fBJxjJHivOS5xX6IKXM8K2p8M8ZwUK7K+AQqHAUkHDPkLxdbjkFjiCbRhYrMfwViNMKw/wevE+Xi/cx9CGFkNftDCtPsDb9QbYAq0U/0myACcXJHRLbRj92oY+1w08cVzHU+9NGnvs1/Di17t46r2FJ/Zr5DctauGR2/BJtJ6fcC++AgtfB5esgzfWCk+Ujarti6vzEudRdHBJLbCKdZgV3xYTnlQnjKYELMguLEd8WJK9ZSxKHvzOOas4Bha3KDuxG1s8+xsWCvQV9E1VYFweyKaOz/cXY9j9KljS4govu3K5Q/z/VwGaWEqAkgojmuLOgPHbgXVEkmFE02zOXRiXyETUFXr3euHi2uEKdxDcXAdcRbg5A2x+Q9mnchXQPGyAPdyCD9x/UDgGNGNcL7wRPbyyAR6pA25BD4/YQXDzjFc5r2RQOUFfBpt7pUdwSTr8JhYTjqwY0Gb6Cx5br6LfewPtpr/isa0GncPfo2vkCrosV8g2Wq+S3W2rwRNHLfrc12G0XIHRchXd7u8rCcfCfRjxN2F0pxX2vTY4Qu1whvQ0usLq6GRjUOUZR+A6aO4M6mELNeOj9FpN6A52wSU307KdYssZuMTz+Yq/FTbxIab5f+HkCNAE4+sIxJewF19WkSgivozg/gr88u/YiS6UubL/FHbjCxAOvqqFnclmkMmkkclkqpDOpJHNZREKhpBIJMhW406jcm86k0Qysw/NeLgP4xEjxqXHFcjdmIh0Y1LphifEuG6Myypf8jGUYsmvdGFy95/QWDf1MG83wPK1CeYtLd5uNMC8qcWbtYf4eaEOlp0mGks+JmuDy/XEDW83YmhTS/L2dqsenu1+aAZmm2EY+g7do7Xod9/Eq+kf8NhaC6OlBj/6bqHXeR3Pxm+ThJE9cYckrcd2Dc8n75Ck9TpuoNddA8dqHzRsBzjlJpIkgtwCd0SVKY/SSrYv1kYjQ8nvVk7Zsg7uWBM8O73QfOJtmJdGKhCrMRMewvTXgQp3OqZsWzAnmfE57C2qTeFipA8OoUiJS2PKKOlhAfkLkcokkT3MkABeFqeq9gk0JSFl24ZwpIJxudQxhHAEmeRRxXd8FixWFdsCNJnDJGb4X2gvzkiDmIu+waxiwnzsDWbkAbwP/4S5qIn4OcVEMTPiAGakAbI/Sj/Tb3h4mFP/5WQ2pmqd3Ax7uBmD6/eopgZW/gbTeh1Ma3X46fMPGFy9R3M711Te92yfO6RGjPE9yOYyxYS5OHxcD8aUTtgDeqrF55N38WqK1WMNfhy7Rccpq8m/j92GPdCO8UgXfFInxqQu0st3wrNKwoNsDI69Djj4Fjj5Vngi7fDIKryRdlV8FT3xTFkcnO4UWmnFvtCTSsKj40M66IOJVQI7o0tgc7+0gB1lqew/ixVwiU3k88eVc/myK39UKNfYn5557CmzjxN2NuP8Qk3up5FOZs/1l+49KZx8c9CzdiS2go/8IOZEM20jhk+RYfw3YMKHgIns+SI/KwxhVjAjldkvr6x0lROuRn7FqFAPl9AKa7AR1j0tRnYbMLKrhS3cBEtAnY+GmuCU2APUIZ6UL074RXlPHZgzaECv8wbJV6f5Kp6N38FTz010j16DcaQG//7tHiaias+YSCmXrXASVuE+nIIODqGZwIqXlQXN+QrnENn8whWqEy6xjQXJiWXZh2XWYclezIfs1Gl95l3UiVV1Z5IP6VzybMJvidOXyMv0NI+yeRTy57VGBZT+Q7X7KlRWeN6VTasbPp3KolRZF9Vf1QrTuQOqdn5/G/z+FriEikBkFWLSj2X//xBUvpCf8WrcNrj9TURTfPUK1beANYyGG+Hi9XCLevgiBowpBnilDjj5Nowpj+Di2b7ugC/SQTaLtXGNmOXNVV2s2rQn1unpTihGmDeaSGFYM8QaKDb2OGqpSXo+eRs99lpYv+owrhhJvuhN4NuEwfga7IKWlGV0rxlv1usxuFKHXzYe0JnN7GG/lvjXS/dgC7XAK+thF7W0s84k5BN+jIf78Y5/iSnhJd7Lr/Ah8g9MiS8wJbwg+53wAtPSq7LNYie4fiyKvrMJ8/k8cofZMpi2HeePEOZCiMYUsuOJODLZdFUcA5M/esoF/HnZHOdOcHJcbN4zR5fKWNV7SiIdIZFlpRNObBCYvRddo/dA4WAba7tz8PNL4A+21Ji4GsPuY/eX9ZD2sTyJUa4BLqGdjgGX2EZHALPZQ2I2e1l0i+3kY4rEODYf5R5iTX5XTHiiJlxXpmjTe8VHGI92YnDxAfXXL6fvUtmwkimBlQ3rtR+Zv6MDjQkGU6rqhJEpOIQW6uhZt+8Mt8Pib4Z9r5XeUJnNxpHtZlh3dLD4WzC81QSLX1dMOF1O+Ad/ywI6ZgPl1gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reactRenderFunc\"\n        title=\"reactRenderFunc\"\n        src=\"/blog/static/548b054e096b5dbdd8ab61b79d1b93ba/5c416/renderFunc.png\"\n        srcset=\"/blog/static/548b054e096b5dbdd8ab61b79d1b93ba/5c416/renderFunc.png 218w\"\n        sizes=\"(max-width: 218px) 100vw, 218px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>走入ReactDOM.render()源码</h3>\n<p>首先定位到packages/react-dom/src/client/ReactDOM.js\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 698px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ccc403ac7ab7468246c5721e902cf82e/487bb/domRender.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC+ElEQVQ4y52U226jVhSG8xSpOR+92YABY2OM8RHHsevJTNJeVDMv0Mve9P2lr2LbsWamSaXmYmn/WoKP9e/1i7tCuPz1lPL384h1HjDQDUxDR9cGGLqOaRhog3t0XVM9bTDAtCxs28a6nt/X3dBz6NoJz89n2v2RaFRQ1EvKdke53FMuO6abI+O6ZbJYU7UbQt+/Qf8FdBwHNxpR7r8we3yh2p+ZTmecn77y+9c/OTx84dPnb3x++cZ6vqTKCnzPe3M6BXQdmzAeKdDs8MTi199IkpSm27E6HZlv1tTLlkmaE3geA027wd607PseSVYg0gJfZgRxRuB6FGlMmkqyUUwcR5imqQC9o/dgCuh5Hkkimc8yUukxHUsSGTK4v0cf/II+GKBrGqauqWVdTuNN2MWy6+L7Lov1gqbbsz4eaPaPiKIiKmuicYUc5cSTOSKfIssamWZouoFhWuimiW6YGFcHasLeThSPWKx2tKst9apjsdqy7Q6sNlumVUW93NKstjTrjrqascgTkmFILocUckgyDHBd5zphEBB6LsXQo0kChGNQCJ9p5DOLh0jfJfYd8qFPGrgkoU9bJArW5AmLPGYkQoIg4M62HeJYUo5zTNslzKb4UYzjenhBiGFZKnOmZX+nLbSrzd7uRVsXy/3W4liQZxKR5pTro7onEUmiKMLqQf0Lhqmu5mdtXvXr1hVQiIgkjvF9H8+xiESAEAFShupjURSSxOLaG6rqezK6aCFC+vhdJ3QRUcSu65gvlhTjjNOpZbetOZ2WPDw0rFYVh8OCpinpujm7Xa16m81M6badqGszTbVlH8s0iIqK8fqAzMbomo6uG2iarupVX84fdX/21du+BduxbeJxRf34QvvpD/KqwbJMHMdW9V6If65bDm3LIi5nTHZHxqsHZvszkUywrl/9GHA8Y9qdKdsttm398ND/gd6Aspgy2R6pjy9Um0f6wP/XX+Vd4Gts0jRVge0D7Xr+h6ZTQCEERVGoJfSAS5kfmq4H/gP/FkIGbbuk8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domRender\"\n        title=\"domRender\"\n        src=\"/blog/static/ccc403ac7ab7468246c5721e902cf82e/487bb/domRender.png\"\n        srcset=\"/blog/static/ccc403ac7ab7468246c5721e902cf82e/63868/domRender.png 250w,\n/blog/static/ccc403ac7ab7468246c5721e902cf82e/0b533/domRender.png 500w,\n/blog/static/ccc403ac7ab7468246c5721e902cf82e/487bb/domRender.png 698w\"\n        sizes=\"(max-width: 698px) 100vw, 698px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n可以看到ReactDOM.render()方法将当前的ReactElement和Container信息传递给了legacyRenderSubtreeIntoContainer.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b5582cb16e1290c05326982304c8019a/fe9e8/containerRender.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC7UlEQVQ4y4WU627bRhCF+RrlbS+8L6+iSNOUFCVV7LS1oaBFgwJtUPRX3/8RvmJXieE0sPzjYHbJmd2ZOWfWy7sZs/uZD3dv+fePO/5+XPl8vuHP8w2ff1v563zDPx9vOJ82ZHVNHEXEcfwivLSo2BxOtMuRat3R7ncM+1vaaUTnOTpN0UlKmiQUeeaCoiuHemnVsD58Yv/4iel0Yno4MT+8p+lbQt93wVEUOhuGIVH8WoZ5Sbe8oZlW6q5j2A70fUMcRkT/c74cfh1emqYorYlFjJQxSgqEEMQW9qCvayEQ8lvYGPEMdu/FIiIzkqJVZLWFJq0kaSXc3q6zWl6+lQKdCVQmSEpFUijS0vprZ3Wu8FSSUU8zm8OedhkxvaGdt/T7A808Uk8Tm+OR8d0b2mVHWXfU/UhRlERh+H0PE5ViTEO/rjRDjU4FUmuE1MSxLV8hVHKBTomFQn75FwQBQRA6svwgcNazuir7ATN0NDcL7e1CXtdUw0Q93TprNjNJXjJ0FduxYRgM89yx2dSs64ZpatluW4wp8UQckdcdy0+/sv7yO2aYEUIikxTbDqETtxZSkSSaNNXPrPrGKiXxpJQUWU5SGNKqJats2ZljWsYRWsQox6IgDC9afMk62SilaApDUvXIsiNvB8x2obJl5ylDldObgjzPrwr6iRR7c14lVI2mbjWllU4u0IVC55JYR0grk0o5nX0du5fGz7OCHfuG0/sfuf/4yP35gcPdB4ZlR9MNFE2PqQq0lmitXp9lIaXTU9FNjOuB5bBjOR7ZH3eM247tNDBPHePYMI4tyvo/y/L70UskF6Zbx/Jyf6a2MimqS6O/NP150NUedrV0t2ZlST3v6eadYzcMfIRzip7eQNvv1+DFscRKZx4WTFGiVeRko7McqbTTols/K/VqhtbRZlgPM90wMG1bqm7AjAt5VVN2I832ljTLnmb36vNl0zTGuOfH9318PyC0c+n7hGHgSg/8H1w/X2PYZvgf6TQ+Dh0+uR0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"containerRender\"\n        title=\"containerRender\"\n        src=\"/blog/static/b5582cb16e1290c05326982304c8019a/00d43/containerRender.png\"\n        srcset=\"/blog/static/b5582cb16e1290c05326982304c8019a/63868/containerRender.png 250w,\n/blog/static/b5582cb16e1290c05326982304c8019a/0b533/containerRender.png 500w,\n/blog/static/b5582cb16e1290c05326982304c8019a/00d43/containerRender.png 1000w,\n/blog/static/b5582cb16e1290c05326982304c8019a/fe9e8/containerRender.png 1146w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n由于是首次mount,这个时候还没有root节点并且是应用的根节点这里直接进行root节点的创建.最后调用root的render方法就开始进行页面的绘制.在legacyCreateRootFromDOMContainer方法中会对当前容器的内容进行清理.这里调用创建了ReactRoot节点.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 972px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/7ae9c/createReactRoot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABu0lEQVQoz22S3U7cMBCF9y0qNrFj52eT2InjkGQ37MLC0iJVAgoUbtqC+v5P8VUJVEUqF58851wcz2hmkZWOZneF333h9umJ+98v3Dw/8+3lF7c/f3Dz8MDd0yPXd/fcfH9ktz9Ha02SJB+y0HGCP/vM5usD/vQSvz2h3Y90hy3W14TLgCD4RxiGSCk/RAjBIs8L7G6L7ToK68hyQ2ksRWmQoeBoDgxZvnsn768OgiXB8mhm+mwRRQrbbmk25/SX1wxXtzQnF3TjiG8sTWNwrqRxhrouZz1RVQXWrChsRV635LUnzbIpUJKZgnocqNdrqnVHWZf4Y8N627DZeYbRMe5bfGvnYO/ta6DNKWxN7o4pXPsWqCKiKEDpACE+EakjIhUgY4FUIXKuJdFEEhHK8L+Rw/cjK61J64ayd7hxTb3uqfp+7nLlagrvSHNNvFJkJp5rKcW8ACHCN171tJiF1jGdP8VVA2ZzwOzPMYcD5WbAbS7mkzK+Jy0stjuhaHpMO7AyNbbf4sYzqmFH5TtUJFlkWUYcKZSMCIVEKInQEVIrdBwznZVOUlQcE2eruZ68WaerVy/NiJN07vAPulILAw+TO9QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createReactRoot\"\n        title=\"createReactRoot\"\n        src=\"/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/7ae9c/createReactRoot.png\"\n        srcset=\"/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/63868/createReactRoot.png 250w,\n/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/0b533/createReactRoot.png 500w,\n/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/7ae9c/createReactRoot.png 972w\"\n        sizes=\"(max-width: 972px) 100vw, 972px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c5e79bbf934850f9fe4c7198d42ec888/46e51/ReactRoot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFUlEQVQY052Qy1KDQBBF+QxlhsDAPCBAIA9CHkQqhIVa7nSvW///A44F2bi0XJyqvnfRt297WXtj2V75fDvw/bHn6/2CSS2RTgjDkCAIWCwWf8ZbX0Z2wwur00CxP1JeDuyer6y7FhVF/1jY3ajPA/l2R3U+sjk0ZM4RhSG+EEgpkVIghSCQckbO/p3fegr37LJEGUdiLdrEOJdgTIzWCqMV2mgSm5K4DJVolDbzHBtLrO3sTVpbN7/IM5seu2pohlfq9kw3jvRDx/npRD/2VFVJvj1S7jvSosKVNUVzIls3LOsdrqgo9h3ltiVWCi+MDcl04ZSS5ui8Ioo1odIokyJ8H+E/zszVxF1L378jBMJ/mL2p8g9NYa5liRgmAQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reactRoot\"\n        title=\"reactRoot\"\n        src=\"/blog/static/c5e79bbf934850f9fe4c7198d42ec888/00d43/ReactRoot.png\"\n        srcset=\"/blog/static/c5e79bbf934850f9fe4c7198d42ec888/63868/ReactRoot.png 250w,\n/blog/static/c5e79bbf934850f9fe4c7198d42ec888/0b533/ReactRoot.png 500w,\n/blog/static/c5e79bbf934850f9fe4c7198d42ec888/00d43/ReactRoot.png 1000w,\n/blog/static/c5e79bbf934850f9fe4c7198d42ec888/46e51/ReactRoot.png 1003w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\ncreateContainer根据当前的container信息来创建根容器.\n定位到packages/react-reconciler/src/ReactFiberReconciler.js\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 983px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d744dcb576c159192651c4712d527cc4/91b29/createContainer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+ElEQVQY04WNSU7DQAAE/Y3EM94nnsXbTOIosYMUCCCxiAMP4AT8/weFSCQOHOBQUnUfuqM8y5n6mdaNKH9FEa6Zxp7P54GPlw3vT56325a6KoiFJEmSP4mkWFI2geH0Sjvf0x0eqEOgPx0YjjOVUiwWS6RM/h07DyZSYMOIv3vETTNuv8VPW5zVFGmKiJdIESPiC1KIi4tf+dulJEqThLb37G5OjMcD++OO9brHuhprVihtUab5IS8VyraUtaHSlqJanfvaNmRZRpRmKXalaXONLSt8Z+g7QwgNfnCYzmP8iO7X1O1wPjDDBt2FM0o7zDDi/IaiKPkCswmTgkGvCxoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createContainer\"\n        title=\"createContainer\"\n        src=\"/blog/static/d744dcb576c159192651c4712d527cc4/91b29/createContainer.png\"\n        srcset=\"/blog/static/d744dcb576c159192651c4712d527cc4/63868/createContainer.png 250w,\n/blog/static/d744dcb576c159192651c4712d527cc4/0b533/createContainer.png 500w,\n/blog/static/d744dcb576c159192651c4712d527cc4/91b29/createContainer.png 983w\"\n        sizes=\"(max-width: 983px) 100vw, 983px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n定位到packages/react-reconciler/src/ReactFiberRoot.js(Fiber !!!!!!)\n在createFiberRoot方法中,创建了根据当前的容器信息创建了FiberRoot并且创建了一个HostRootFiber进行相互引用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/52525f7a291707863825ad97e39b8ba5/05fb0/createFiberRoot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABr0lEQVQoz42S2WobQRRE5zeiWXvvHs2u0UhCXmMldggB61H//yEnjBYTCAY/FNW36S6KqhutlyNl6NDtFlONrH4d2byf2B5P7I4nlHUkSUKWZV9CVE13bF7fGb//pr17pnl5IEwjWSFIs+LLQh+Cy9XE8HSgmiaa7UjdVhgpSNOUNF6QxjHp4oIknrEgWSwuPM+Lb9f7mCSJiXwz0OwfGB8fqboWO7SoqsRYh/QNoq2QfYNctdiuo+wmQj8x/3PLlnLY4MqaUHf4UBLlhSAXkpmlEoRgcU4htUQYg/CawmkKr5HeoJxDeYtyFmU12nuMMxhrkEISSSMJg6OaPMsxEHpH6D1CC5TJcaXElQrnFb7SmKAwQV9QGpQt0EFQqPxcXqRDi2vX1NOOZrOnWu/o7w/4dqTuenZ3W1ZDxWqoz1w3DaGbcPVA2a3PruI4IU1vpYw7+oefdPcHxqc3Vk+vdPtnNm9Hph9/GO5fWPbrc+jnomZk6cf534bnOVJSY5VDWY9y/pxllucUc655TpamFEJ8uiY30RtHwQaC8tiyvixxHF8fJFcX2X9OPhOdBf8CLMQh8QdqEjAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createFiberRoot\"\n        title=\"createFiberRoot\"\n        src=\"/blog/static/52525f7a291707863825ad97e39b8ba5/00d43/createFiberRoot.png\"\n        srcset=\"/blog/static/52525f7a291707863825ad97e39b8ba5/63868/createFiberRoot.png 250w,\n/blog/static/52525f7a291707863825ad97e39b8ba5/0b533/createFiberRoot.png 500w,\n/blog/static/52525f7a291707863825ad97e39b8ba5/00d43/createFiberRoot.png 1000w,\n/blog/static/52525f7a291707863825ad97e39b8ba5/05fb0/createFiberRoot.png 1138w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>ReactDOM.render()调用过程中的数据结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/f058b/renderStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.999999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIUlEQVQY032RXUvCcBjF95WDboIKyVCq267Eu6CQzMILTSovhLoLUpmpaep82XTa3KZD5/b/RYkVIh04nIcDzwvnkYQQrNMXPl+w50NS3RDJ1gHxyv633mphekaNXldF10bk9RTxcoBLOUBhmEbiH9jukIx2RLIVJCbvkWwuB+oThYXr4S+gbGZJd45Jt08oje+QPOb8UMzxhYdhGKiqSqfbRhlUsRZ9bG+A6fYZz1Q83/1dak7RtQ9MY8LUmiFdVw5JvAa5qYSIybtUjScc28W0xjiOgzvzNl6/iqeu5SkqOWr6M03jBemhEeH+PUK2GSVTP0Wx8hua/TWKpe8LHkdRLt62OC9tE2/sbM5w/Ul/vVW90lzzjFghwFUxREIO8wk517n0JFsJLQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reactStruct\"\n        title=\"reactStruct\"\n        src=\"/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/f058b/renderStruct.png\"\n        srcset=\"/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/63868/renderStruct.png 250w,\n/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/0b533/renderStruct.png 500w,\n/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/f058b/renderStruct.png 630w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n通过启动最开始create-react-app创建的项目,可以看到以下的输出.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8bea5b913ac20f4f3d728869ac3041fd/2c0d3/showRenderStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAmElEQVQY05XQywqDMBCFYd//HVvwUk3UxFzEadTmL0oXxVV74IMzMKtT6EYzjJFlEebZ4Zxlmgx2Moi37Gkh55382sj547tfFF3T4l0gycYqK9fkQ/5dcb/dUaqnqhrKskIpzTMlUkrs235+5T8UbdcxjCN13aD7HqU1xhi6h8HaQAiBGCMicjq6954QjpkSMYbznucFkZU3QZw2325BZlsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"showRenderStruct\"\n        title=\"showRenderStruct\"\n        src=\"/blog/static/8bea5b913ac20f4f3d728869ac3041fd/00d43/showRenderStruct.png\"\n        srcset=\"/blog/static/8bea5b913ac20f4f3d728869ac3041fd/63868/showRenderStruct.png 250w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/0b533/showRenderStruct.png 500w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/00d43/showRenderStruct.png 1000w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/aa440/showRenderStruct.png 1500w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/2c0d3/showRenderStruct.png 1849w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>后记</h2>\n<p>这篇文章只梳理了React在实际调用渲染函数之前的函数调用和数据结构.在这个过程中终于盼来了千呼万唤的fiber.之后的文章会继续深入react的渲染流程和fiber的实现来对react进行学习.</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"React render流程梳理","date":"2019-05-10","tags":"React","path":"/react-render","top":null,"summary":null},"title":"React render流程梳理","date":"2019-05-10","tags":"React","path":"/react-render","top":null,"summary":null},{"id":"fccee0d2-2a7a-5228-b6ca-58de7a6fb82d","html":"<h2>前言</h2>\n<p>在react最新的reconciliation使用的是Fiber架构.Fiber使用的增量渲染的模式,具体的实现是渲染的任务可以被拆分,在页面更新的时候具体的任务可以被打断,复用.这些特性无疑对页面交互是有很大的提升.下面通过React Fiber Architecture这篇文章来对Fiber有个大体的认识.之后的系列我会深入react的源码来仔细学习Fiber的具体实现.</p>\n<h2>基础知识</h2>\n<h3>What is reconciliation?</h3>\n<h4>reconciliation</h4>\n<p>react通过Virtual Dom和真实Dom之间建立缓冲,通过diff出变化前后virtual Dom的差异来将差异更新到真实Dom上.reconciliation正是对比Virtual Dom差异的实现.</p>\n<h4>update(更新)</h4>\n<p>渲染页面的数据发生变化导致页面更新</p>\n<p>在没有reconciliation(调和)的情况下,数据的变动将会导致整个页面重新绘制.通过Virtual Dom来代表将要渲染的页面,将Virtual Dom交给对应的renderer(react-dom, react native)来进行页面的绘制.在页面更新的时候通过调和来生成前后Virtual Dom树的差异来进行页面的更新.这样一定程度上提高了页面的性能.React的更新策略是在下面的假设下进行的:</p>\n<ol>\n<li>组件很少进行跨层级的移动</li>\n<li>不同类型的组件生成的结构是不同的</li>\n<li>相同类型的列表元素可以通过唯一的标识来进行复用</li>\n</ol>\n<h3>Scheduling(调度)</h3>\n<h4>scheduling</h4>\n<p>确定哪些更新的任务需要执行</p>\n<h4>work(更新任务)</h4>\n<p>需要执行的任务,通常是页面的更新\nReact的构建UI的库,它采取pull(拉)的模式来处理页面的更新交互.在push(推)的模式中数据(更新)推动整个页面的更新.React对更新的任务进行了一定的调度,来达到更好的页面交互.React采用这种策略主要有以下的原因:</p>\n<ol>\n<li>在处理UI界面的时候,通常上不是所有的更新都需要立刻被执行的.(可以类比图片的懒加载)</li>\n<li>不同的类型更新应该有优先级.为了更好的交互体验,通过优先级可以提供更好的页面交互.(比如动画的优先级更高,页面会更加流畅)</li>\n<li>push的模式需要开发者组织页面的更新,pull的模式使得React可以帮助开发者实现更好的页面交互.</li>\n</ol>\n<h2>what is Fiber?</h2>\n<p>通过Fiber使得React可以更好的调度任务.主要有以下的功能:</p>\n<ol>\n<li>暂停任务并且在之后继续执行</li>\n<li>对不同的任务设置优先级</li>\n<li>复用之前完成的任务的结果</li>\n<li>丢弃不需要的任务</li>\n</ol>\n<p>在这里可以简单的将fiber理解为需要做的任务.在进行页面绘制的时候组件更新和函数执行的任务都会被推进执行的栈结构.这种模式当太多任务需要执行的时候会导致页面的交互变的卡顿.浏览器提供了两个api来处理上面的问题.</p>\n<ol>\n<li>requestIdleCallback 通过requestIdleCallback可以在空闲的时候执行一个低优先级的任务</li>\n<li>requestAnimationFrame 可以在浏览器下次重绘之前执行一个较高优先级的任务</li>\n</ol>\n<p>为了利用上面的函数来实现页面的更新,就需要将渲染的任务拆分成多个任务.Fiber架构可以理解为重新实现的栈而fiber节点是一个虚拟的栈帧.Fiber架构通过调度帧的执行逻辑来完成页面的更新.</p>\n<h3>fiber结构</h3>\n<p>一个fiber节点代表一个栈帧,也代表一个组件的实例.下面是fiber结构一些重要的属性:</p>\n<h4>type  key</h4>\n<p>type和key对于fiber节点的作用跟type和key对React element的作用一致. type可以判断fiber节点对应的是React组件还是宿主环境的组件(div).key用于调和的时候复用fiber.</p>\n<h4>child sibling  return</h4>\n<p>fiber是通过单链表进行关联的.fiber节点的return指向它的parent.child指向fiber第一个子节点.sibling指向当前fiber节点的兄弟节点.</p>\n<pre><code>function Parent() {\n  return [&#x3C;Child1 />, &#x3C;Child2 />]\n}\n</code></pre>\n<p>上面的结构Child1是Parent的child,Child2是Child1的sibling,Parent是Child1和Child2的return.</p>\n<h4>pendingWorkPriority</h4>\n<p>优先级</p>\n<h3>alternate</h3>\n<p>一个组件至多有两个fiber结构与它对应: 当前的fiber(正在处理的fiber),flushed fiber(处理完毕,准备渲染(commit)的fiber), alternate(当前fiber的替身).</p>\n<h2>参考</h2>\n<p><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a>\n<a href=\"http://www.ayqy.net/blog/dive-into-react-fiber/\">完全理解React Fiber</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"React Fiber Architecture(译)","date":"2019-05-09","tags":"React","path":"/react-fiber","top":null,"summary":null},"title":"React Fiber Architecture(译)","date":"2019-05-09","tags":"React","path":"/react-fiber","top":null,"summary":null},{"id":"df8f6b88-1488-54c8-9389-2453fcc16845","html":"<h2>为什么使用容器技术</h2>\n<p>在传统的软件部署方式中，开发者需要在不同的主机之前同步配置来确保应用运行环境的一致性。通过容器技术能有效的优化集群环境的部署，极大的改变软件开发和发布的方式。下面从容器与传统的虚拟化技术对比来揭开容器的面纱。</p>\n<h3>docker与传统的虚拟机方案的对比</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/91bde82c19e5c029f3ea93c87ea5572c/a0b80/different.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACMklEQVQ4y22U6Y7CMAyE8/5Pxx8kQJzaIu6rLbRQWq8+o4myXSpZOeqMx2Mn4fV62eFwsOPxaKfTyfI8t7Zt7f1+x9Hn78+86zr322631jTNHx8sAHa5XOx6vdrtdrPdbmf3+90PRrC29TWjjC9dCzgQDZbL5dIjA1YURQTEESZ1XVtd1T7H+Me55/PpJrbOECDsfD57KilDxv1+75KQBfOu7ZwhvmTEHiO+oaoqK8vSxuOxZT+ZPR6PyEAMCbZarfzgdDp1QyYA1+u1G+uoIYVgg5F1n6GyQOPNZuMECAorsuIfPs6QVHCCAQ4x5baL1UU//LIsc904iOEHCYzMooZsEJVNDjJPq6yKEhCWnCFI//OUqSiOg8HAJpOJA8JCfQcQOuMnJnQEmgPKHv8iQ7UKkRnRRBriADjFKPLCfTiM3vgx1x6sq0f1AWSBjuiXtg0GC9ol/QjAGTU4H2eQKpCuqkhUWqAsysgQQFWW9GCEH0Yg9gADxwHRh/zn87kfVB+m10m3B9Pdx5c5IOwzxquHA8yIgklgVRm2fADASG3GHEJ86oqgaKPRyBaLhevTfxwEyj6+Shm9kUAtQ2c4IAtGmKkNvgHyH910O9S/EZC2yW+5pzkcDm02mzkwr0f/nQOQ9GCloJxjFGDUENoaaWyY9BkqADoC7M9ZXf97iAP0ceCe0rCkkF49dEkrrnbqP7iyQBFIAWBGGH7TMLX4vDX//wUqpwYlZeZpH34zpfmN4S/QFFY8EAFUSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"different\"\n        title=\"different\"\n        src=\"/blog/static/91bde82c19e5c029f3ea93c87ea5572c/a0b80/different.png\"\n        srcset=\"/blog/static/91bde82c19e5c029f3ea93c87ea5572c/63868/different.png 250w,\n/blog/static/91bde82c19e5c029f3ea93c87ea5572c/0b533/different.png 500w,\n/blog/static/91bde82c19e5c029f3ea93c87ea5572c/a0b80/different.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>传统的虚拟机技术主要通过虚拟机监控器完成虚拟操作系统和宿主操作系统之间的交互.docker容器直接与宿主系统通信，减少了语言转换的过程,因此在启动速度和运行效率上更胜一筹.</li>\n<li>容器技术更加偏向于程序的移植和依赖的打包而虚拟机技术则是侧重于完全的虚拟出一个另一个虚拟环境。</li>\n<li>docker能提供更快的交付过程.通过合理的对宿主操作系统资源的划分,能有效地提高系统的资源利用率。</li>\n</ol>\n<h2>核心技术介绍</h2>\n<h3>namespace(隔离)</h3>\n<p>通过NameSpace技术可以修改容器的视图.</p>\n<pre><code>int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);\n</code></pre>\n<p>在linux中可以通过系统调用clone来创建新的进程,当第三个参数flags指定CLONE_NEWNS就会在新的namespace下启动新进程.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/3279e294d23ef287fc82b78db94dc906/f32b7/namespace.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABSklEQVQoz51S2XKCQBBcjajReJCrkh9ITEBUYDkEhJjy/z+pUz0LllYkSeWha4dhp6e3Z9RolWEaFOi+aajXAGoR4nq1xWidSdzk5GzinzANdpiFOzymnxgsU0z8AvfJHrauBCTvXCpsI5/rypDEe/SXCW42Oea6xMTPMQ9LDL0UahFAvfiGpDnbSElk6xJP2QEDLwUVUy1zJOu7CXpOLM2u3iPJdU7s+a4wLEXVXfwhxfSOCsfrTIrZYOhthbRbE0ohlTYQ5bXH9Iukz9nhSMAcGxCMb6NK7hD0ld/MS60uMQt2cpeNFX8KSbzHoPbQrn2lSstNJE9wQGzK4bG4iRtLek4ExSISmqeZi1wjEvP5lhOfD+QSTp/MlSEJ/aPZhjTF1C/Muvxl905huTHGm1wUcrnpy0NiJq/+Qyhm6+q4vFTKJr/uWwu+APHeN3Z6HfW8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"namespace\"\n        title=\"namespace\"\n        src=\"/blog/static/3279e294d23ef287fc82b78db94dc906/00d43/namespace.png\"\n        srcset=\"/blog/static/3279e294d23ef287fc82b78db94dc906/63868/namespace.png 250w,\n/blog/static/3279e294d23ef287fc82b78db94dc906/0b533/namespace.png 500w,\n/blog/static/3279e294d23ef287fc82b78db94dc906/00d43/namespace.png 1000w,\n/blog/static/3279e294d23ef287fc82b78db94dc906/f32b7/namespace.png 1136w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子中系统本身有已经运行的很多进程,通过运行镜像并且执行bin/sh进程可以进入容器的交互界面.在容器中只能看到root进程和ps进程.这样通过namespace技术就实现了不同进程间的隔离.</p>\n<h3>Control Groups(限制)</h3>\n<p>namespace创建的进程与其他进程之前对主机的资源是竞争关系的.Linux Control Group技术就是限制进程组能够使用资源上限的一种技术.通过对容器使用资源的上线进行设置能有效地使用主机的资源和防止资源的过渡占用。</p>\n<h3>联合文件系统(Union File System)</h3>\n<p>联合文件系统可以同时挂载不同的实际文件或者目录到同一目录.Docker基于联合文件系统提出AUFS(Advanced Union File System).AUFS通过将新的镜像层挂载到老的镜像层之上,通过共享基础镜像和增量更新可以使docker的镜像管理更加快速。</p>\n<h2>docker核心概念介绍</h2>\n<h3>镜像</h3>\n<p>镜像是封装了虚拟环境的运行内容的文件包,docker通过利用AUFS实现了增量的镜像结构.</p>\n<h3>容器</h3>\n<p>容器是隔离的虚拟环境,里面运行着docker镜像.容器有以下的运行状态:</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Created</td>\n<td align=\"center\">容器已经被创建资源已经就绪,应用程序未运行</td>\n</tr>\n<tr>\n<td>Running</td>\n<td align=\"center\">容器中的应用容器处于运行中</td>\n</tr>\n<tr>\n<td>Paused</td>\n<td align=\"center\">容器暂停</td>\n</tr>\n<tr>\n<td>Stopped</td>\n<td align=\"center\">容器停止</td>\n</tr>\n<tr>\n<td>Deleted</td>\n<td align=\"center\">容器被删除,占有的资源以及资源的的管理信息已经被删除</td>\n</tr>\n<tr>\n<td>### 数据卷</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>docker运行时的持久化目录,通过将外部目录挂载到容器中,来实现数据的持久化.</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<h3>docker engine</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 780px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/a1792/dockerEngine.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACF0lEQVQ4y4VUa1faUBBMUNSivNS2fm5PaQnhlTdgIGB9W7GHWvv//8j2zCQ3JEDTD3uSm2xmd2Z2ow2f3+SwG8jJ8FK0r7Zo35x14JwN9Sybsxnm4yvBTr25HPVGorWs9MP9ji9NN5KGG8me4f0fLAZ8k8pgLDV7Kk13JlUrFL0dA5baLgu964+LwbLv2ncrUm44MwaAFcUDMyAgivxTki3A+18p4MX4uxwPJilg2Qzk3F/IxeQ6fg45NnXdBO3/+M1kdFA2fdFVpZYlh72RnHlzFoO+CMiC84kVSiORKN/5zVKqdsikA9PPmQIjTt1I6s5UPo6uCK63XT6HvqXkmgPsPKyoG5LfBwtWRacK8NyPNdzveGuniygb9yvRPvU5IqpydgZxputfhmsNi1y2ln/oJkYDOkKjymDC+Ws6MxaBXuge1DmrRaDG3QsTQQ1UVZe4giZMKhlu7t3ObUrvb5asivFIHUO0rNgUL6KuW7SzQLkOH1YErNtTBt3uBql+oF6zQ7478+dSs0IWRl6lP5Hj4SWvWkuB375IueOTNpLQ0Z7hshMAY1NYzJmyY9I2Ykl0GuamqxrP7/UzP6wmwsMUPRlsbAq6wqZwn3fR3Rqd259MBjW4vWtTlLtHvTE7Bos6fybR9qZ0n17ZITrJ7rEabHSsNgVAWuL6mu7GpnxePFJY0AJlhPqzAPDD6IqbxFVTHxdsyl+4DAFtbO+JwQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dockerEngine\"\n        title=\"dockerEngine\"\n        src=\"/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/a1792/dockerEngine.png\"\n        srcset=\"/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/63868/dockerEngine.png 250w,\n/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/0b533/dockerEngine.png 500w,\n/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/a1792/dockerEngine.png 780w\"\n        sizes=\"(max-width: 780px) 100vw, 780px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\ndocker engine是负责启动镜像的服务,通过docker client提供的指令调用docker server提供的接口来实现对镜像和容器的操作.</p>\n<h2>使用镜像</h2>\n<h3>启动指令</h3>\n<pre><code>docker run --name nginx -p 80:80 -d nginx // --name 执行容器名 -p 宿主端口:容器端口 将宿主端口映射到容器的端口 -d 后台的方式启动 \n\ndocker run --name myredis redis\ndocekr run --name test --link  myredis:redis debian  // --link Container:Alias 目标容器的名称:目标容器的别名 建立容器之间的链接\n</code></pre>\n<h3>操作容器指令</h3>\n<pre><code>docker ps -a // 查看所有的容器  \ndocker images // 查看所有本地镜像 \ndocker stop name/ID  // 停止某个容器 \ndocker rm name/ID // 删除容器\ndocker rm $(docker ps -aq) // 删除所有容器\ndocker rmi $(docker images -q) // 删除所有本地镜像\n</code></pre>\n<h3>使用docker创建一个hello world应用</h3>\n<h4>编写程序文件</h4>\n<p>创建一个目录结构如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 599px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9e987ebb1b9062f3b284fb7472d9291a/43142/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA50lEQVQoz52Q0W7CMAxF+Q+mUWInXcfWUAhp2m6QIFoGiP3/39ypAR4QE9N4OLqyYh/ZGbzPLKplgG+/UH0GzGwN26ygjcNkavBWXDN3DbQpsVx3mBqHuftAYSssmhUSkhiwTKFzjePxG9aWGA6fMBqNQcQgljcIwfEtSQQEcayFIIxJ4Vn0QmK8Oo9FWeOwPyCEAO8DlEohWUJK9SvqqpaQKjsL0wwT41DVDUJYR9lm00Yh3xFe4D5ZgtXLSZiZGkXjsW1b7HZ7dN02Zp7reNq/hf0Q0+kf6Jw9l+3+2vJWyHeaHzj5B5La0UdAZFlIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/9e987ebb1b9062f3b284fb7472d9291a/43142/category.png\"\n        srcset=\"/blog/static/9e987ebb1b9062f3b284fb7472d9291a/63868/category.png 250w,\n/blog/static/9e987ebb1b9062f3b284fb7472d9291a/0b533/category.png 500w,\n/blog/static/9e987ebb1b9062f3b284fb7472d9291a/43142/category.png 599w\"\n        sizes=\"(max-width: 599px) 100vw, 599px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在index.py中编写程序的主要功能如下:</p>\n<pre><code>from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n  return 'Hello world\\n'\n\nif __name__ == '__main__':\n  app.run(debug=True,host=\"0.0.0.0\") // 创建一个服务 在/路径下返回Hello world\n</code></pre>\n<h4>编写Dockerfile</h4>\n<p>镜像的构建可以通过Dockerfile和构建环境的上下文来完成.通过Dockerfile可以将镜像的构建过程持久化.</p>\n<pre><code>From python:3.4 // 从某一个基础镜像开始 From语句必须是Dockerfile的第一条语句\nRun pip install Flask==0.10.1 // 执行指定的指令  由于每次执行的执行都会行成新的镜像层,可以将多个指令进行合并\nWORKDIR /app // 执行Dockerfile指令执行的工作目录\nCOPY app /app  // src dest 这个指令将上下文的app目录复制到容器的app目录\nCMD python index.py // 容器启动时执行的指令\n</code></pre>\n<h4>构建镜像和启动容器</h4>\n<pre><code>docker build -t hello . //在当前目录的上下文上构建镜像\ndocker run --name haha -p 5000:5000 hello // 以haha容器名字启动helloword镜像 并且将容器的5000端口映射到外部的5000端口\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/218a4/run.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABEUlEQVQY02WQ6W7CMBCEXZIg7gQStU9AW0gK5LBzx0kptPT932eq3YAQ6o9Ps2vZs+MVxlbCLU/w9AVj1WGaHeGUZ6yqbyyKL3jNBS/tL7OsznCbH9jFCWas8RTWEPsS4lDdMXyFlergyBbzuGFdJBqzqMb4UHI92hcM9ZOwwvAjZzWDFOI9gdjIXgljq/CcH+GqDvOohh03jOkriNcIYh32emMdPfZv8SPDIIOXfbLpLKzgSH1NrOEkGlaQwQpShoaYfgrLTzHYSNDbf4aLuAFB6QZbybWbdmy6JFPZYqVa2Mn9HtXTsOLz8a5g49Eu779sRzVfnNB+DiXsRHMSSmRcExE0jNZzS0ja94rVuu7zD6I7rWtyPWZUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"run\"\n        title=\"run\"\n        src=\"/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/00d43/run.png\"\n        srcset=\"/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/63868/run.png 250w,\n/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/0b533/run.png 500w,\n/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/00d43/run.png 1000w,\n/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/218a4/run.png 1052w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"docker入门","date":"2019-04-28","tags":"工程化","path":"/docker","top":null,"summary":null},"title":"docker入门","date":"2019-04-28","tags":"工程化","path":"/docker","top":null,"summary":null},{"id":"76895145-6bce-5daf-ae09-0fdaa2ce4753","html":"<h2>简介</h2>\n<p>　　WEB同构应用指的是通过代码的编译转换手段(通常借助于babel)来让代码在不同端client(浏览器), server(服务器)运行.同构的web应用主要有以下的优点:</p>\n<ol>\n<li>一套代码多处运行减少维护成本</li>\n<li>任务拆分,通过同构可以实现更多的功能(SSR, fetchData)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b82aa5b7dcbe650b3365aa69d1137419/5a190/isomorphism.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACH0lEQVQ4y22U547CQAyE9/1fi780iSIheockJPSS5tPnO4cF3Upml8RlPJ6sy/NcsCzL5PtcFEW1s9iDIJAwDCWKosr4j+33e3FlWarz906w2ePxkOfzKdvtVlarlRY8n89yuVzU7ve7pGkqSZKIu91u6hiFUVV5s9lokrIoNdF8PpfT6SSNRkNms5lcr1eZTqeVER/Hsfq44/GoVUlC4HK5VCMh6/V6aSEWKIJ9oEUMNQZC9sPhIA7ok8lE6vW61Go13YfDoVYm8Wg00oKWEBTwaGb8cdaWDSpVOp2O7rQNcviDI5yV36KUMAj1HUCI42yG35tDb2q0Twss45AWQQtqaGCiIKIgiXlPEZ2yyiP7k0mRf0wY2STxb2Cv19P2Sci+2+0qZAyKpM60R8J/z3n+ISWCSU5nJDHpcIZL5yPxz76wfY3S/ng8VvmYMUAGizkLYoIINs3Sj+QYHMGPTZxn8GcGWmJB6vhZr9eqISDjQJDpkKGYLvv9viwWC1UCPsRh0ACXlbDtAclIypRBBBK4MdmAnOkaZ2b2GSqH/CGA6s1mU9rttk4PbpAT/PjCxt+/FPwzoByoeEAlHsAHKNitZfv0QEwx6CHOFzX/9baxAJz4ajAQozWmCneghJ9Wq6WThDfjk3cMC5qUw+9ry5Y/ZYZAAYYDDSzkMxgM1Lrdrk4ZP2cXql6qmXfBZm+Rk9S+KBLSml0KxiG3EO9+AMYPXMq0YF8iAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"isomorphism\"\n        title=\"isomorphism\"\n        src=\"/blog/static/b82aa5b7dcbe650b3365aa69d1137419/5a190/isomorphism.png\"\n        srcset=\"/blog/static/b82aa5b7dcbe650b3365aa69d1137419/63868/isomorphism.png 250w,\n/blog/static/b82aa5b7dcbe650b3365aa69d1137419/0b533/isomorphism.png 500w,\n/blog/static/b82aa5b7dcbe650b3365aa69d1137419/5a190/isomorphism.png 800w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>简单的实现思路</h2>\n<ol>\n<li>将client端的代码转换成server可以执行的代码(es6 => commonjs).</li>\n<li>在两端组合出一套模式相同的代码逻辑.下面的例子中在server和client端使用不同的react-router提供的组件.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bf1905df4de812eae1d1f3e6776426ad/35751/app.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB10lEQVQ4y5WS2W7bMBBF/RVJrIWiqIVaKUuyIsux4y2Fu+SlL/3/PzmF6RRB0ARIHi5mOOAc3BlyFhUdab/HTAdWP37TH75TLTrK6Rv5sKcet6yf/9CtH2mahmlYclyvOEwjQ78kjGKiNCPOS0KlmMlYozJDWrXk7T35YqDoV1TDRJplpEVFuZzQpiNKUsrhgayfyLoV5f2GONUU7YCZdqRZfgXK1GBMRlUkpHGM8Fzmtze4zhzXcXDubnHnty/5DZ4zt3KdOzzPs3V3fs1nKtHU04n77Z5FPzAcflK2g3XVrPfoylCPG9rtk3Vhxg1CCIQIXiSuCq75LNeavF0SFQW+CvGFwPc8AimRoULKkECGNg/CaxS+b++JdzQLhCBpDNXpRLV/JK0aksLgi8CC/UuzlfcaL80v9f+AMghQKiarO3Reoy+xavF98W6D+Af7yKGUEhUp1KJCNiXSFISL0p5F8Ar9EP4e8OIyH0b68zPNww7z+ER7PKN0aUf8DOgN8LLHrBnod2e6zZFue2Y4/aKejvYlP+vu1eFl7DAmChVmtaPsR+rxwX5mz3W/5lD4grTISZYtarkgTCI8x7Eg33O/tD8L1FqT6BSRxIS5RkbqzYWvwC7Av9bTc0i3qhGxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"App\"\n        title=\"App\"\n        src=\"/blog/static/bf1905df4de812eae1d1f3e6776426ad/35751/app.png\"\n        srcset=\"/blog/static/bf1905df4de812eae1d1f3e6776426ad/63868/app.png 250w,\n/blog/static/bf1905df4de812eae1d1f3e6776426ad/0b533/app.png 500w,\n/blog/static/bf1905df4de812eae1d1f3e6776426ad/35751/app.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n3. server端路由匹配,组装资源(css, js, data), 可以通过不同的中间件根据请求信息来组装.<br>\n4. client端路由匹配,匹配资源(data, 检查页面渲染结果是否正确).</p>\n<h2>过程</h2>\n<h3>代码转换</h3>\n<p>　　在进行代码转换的时候,首先要明白代码转换的目的才能明确对不同文件的转换策略.比如为了实现同构将client端的代码转换成server端可以运行的代码,对不同类型CSS文件的不同处理策略.通常借助于webpack来实现代码的转换功能.webpack会根据入口文件依次的解析引用的各种文件类型,通过配置的webpack loader可以实现对应文件类型的转换.以下主要从不同类型文件处理的角度进行介绍:</p>\n<h4>javascript</h4>\n<p>转换的目标是client端的代码(排除node_modules).\n将client转换成server端可以运行的代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 871px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e5742945b47fa9c8c9867704e895953b/9d5da/srctolib.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB40lEQVQ4y42U63KbMBCF8xiN0V0ISQjMxZjEt/oycWfaP33/pzkdCU/rNE3NjzOzEuhj9+yiJ84YlCnQHa5otmcUxoAxBkJpUowppUkxfqQnzjkYozDGQOcGUhsIzqGlQK7khwOPwAkopAQjBNWwQbM9wecKfWlRO4uMUCwygueM/Ib9DzoBhQDnDMYHtLsT+t0RXAisygKNmzQEByXlzAyFgJRTed3Xb1hff6LqBvTBpWy90ahsDinFfOCUJYerOwzn72gPb5DGgjKOL4sMz1mGjDwu+x0wNiOujSlgTQ5nchitYJRMik2Sgs/z8F6cC2yagE0o0FqNl8qh9ZOXWql34/QQyJOfArkr4YcdbLsGVxpLm2MVHILRqYp5Jd98jA1yZYUiNDBlDSEVnFYIRY5Cq/TebGDcLL1HaQ04zSAZhRI8+StumdH5JfNUcu0KnPo6lThULs1g9G+sPIzW85sSY1+WUNH4OCJ3//Gkz+aPfgTGRQgBtiiQZQvQCCQEhNCbyN0e+etDf3QDSjBKENoVuv0FYdig7F+wHPdY9RW2mw5tt4RthnQj1eMOVks03qZLhdF/ZCg4g28HDJcfaPeXdLA/vCXY5TxifF2jfj2l56vjNY3Psa+x62rs25D8ttbiF1VywpYXj5JcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"srcToLib\"\n        title=\"srcToLib\"\n        src=\"/blog/static/e5742945b47fa9c8c9867704e895953b/9d5da/srctolib.png\"\n        srcset=\"/blog/static/e5742945b47fa9c8c9867704e895953b/63868/srctolib.png 250w,\n/blog/static/e5742945b47fa9c8c9867704e895953b/0b533/srctolib.png 500w,\n/blog/static/e5742945b47fa9c8c9867704e895953b/9d5da/srctolib.png 871w\"\n        sizes=\"(max-width: 871px) 100vw, 871px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>css</h4>\n<p>对于CSS可以有以下两种的处理方法:</p>\n<ol>\n<li>css-in-js (css-loader style-loader)处理,包括node_modules,client端不需要提取的CSS</li>\n<li>client端全局样式或者通过mini-css-extract-plugin提取的样式</li>\n</ol>\n<h4>代码转换优化</h4>\n<h5>公有代码提取</h5>\n<p>可以使用DllPlugin对使用的基础组件库进行统一的提取和引用.提取公有模块代码主要有以下的好处:</p>\n<ol>\n<li>通过DllPlugin对公有代码的提取,能一定程度上加快webpack构建代码的速度</li>\n<li>公有部分的逻辑相对来说是变化的较少,可以充分的利用缓存</li>\n<li>减少其他bundle的体积,页面加载的资源更少</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/821e520963f2813946911c2ecea26c92/40601/dll.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACG0lEQVQ4y51T2XLTQBDUZ2DtrvY+dVmyJMeJDVRcBAqe+P+PaUorJ1DEvPDQNTvSTqt7ZlQIHSFNhA01Yj8jdBOkEBjHBm2f0EePYxuxjw59cBiiy+chejhrUVUVGGM5rijU0EKPPVSbIPYNhDP5IqEUhNAcS/o7ln/klLE3stdYmLbF8PwN3emM2DXQRsNoBSk4lBDQUuTzlm8xP5PiTdWfKCTncKGGMh7JakzJQyuJLlgcao+5CfDG5HxMPlueag/n3tvNhC5E7E8fEboRSqnNCmXZLl3tlSUIKTfLtxb8y24m5JyjXS6Yr98xXK4IMeFyaHHsa3TRY+w6uJAgBIdV8p3VdwoZJWjmJ8zXH+ifrhiXI57PI57PE47Lgv54Rnf6BO8sDskhBX+X6I1Qaw1jHWxqoYyDrhicEKitzmuyfpDsdrkNJd3a8Ep4j7SwPmC4fEGaH2FTAFMKlZS5eEcIqoqj4jxf5n8V83sK1wLbHNBcrrDTgLjs0R8GNFbDSA5KCCgp8xDWYbBbXPGBMOwIy6rJTX0xdgLWCCwvP9HOj1geHnGa93i5LDhMM5rphNAfENcWRJeHsq7P+gd93Wt87i2Ss+iDzf0ttOLo+g6h7iC1gUktrLcwzkL5BBubDUrCGwUhRCZf8RAlBi/htEI0CtYaFD5ErIOhlICtsld7N/nrQDbLJFumdyyXlG17S7f3RQjh7vj/F78AVLmMr+asXT8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dll\"\n        title=\"dll\"\n        src=\"/blog/static/821e520963f2813946911c2ecea26c92/40601/dll.png\"\n        srcset=\"/blog/static/821e520963f2813946911c2ecea26c92/63868/dll.png 250w,\n/blog/static/821e520963f2813946911c2ecea26c92/0b533/dll.png 500w,\n/blog/static/821e520963f2813946911c2ecea26c92/40601/dll.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>加快编译速度</h5>\n<p>可以使用happyPack加快编译速度,happyPack通过多进程的方式来加快代码的打包过程.\n使用happyPack的例子:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 784px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/40f9262c0aafbe2acfc44122737b534e/4971b/happy1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJklEQVQY032P3U7bQBSE/Rxk/3ftrNchideObaBOk1Cg6UUveP93+aq6KgIuuPh0NNJozkyxPdzR5AHnHEpKhJSshEBKiVLqS/573nsLZw2hisR9j/eeYDX7FLHGcCPEEn6zIN/4/PBDoFaSet+Tz1fSuuLUNlyHLcf2lm1V0qf1Qo6BabNmSCWbWKGtRQiBUh+XFFop4i7Tzk/k+ULuDsyXF+6mge/3Lc/nkanb0/YTD6cffLs80dSRrqlZVyXq75LVCiHk0rTQUhJ3Hd3pJ8Pzb2IeOby80o4Tx2PH5XGin0Y294/k8y/G6yuhLDm1G+a8Zc63POwSuakpq4oipUSdEtpYrPMYa7E+LNc58w8fsL7EOI8LAa01zhhKZwjO4K1ZtDaGP709r9YMfGdnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"happyPack\"\n        title=\"happyPack\"\n        src=\"/blog/static/40f9262c0aafbe2acfc44122737b534e/4971b/happy1.png\"\n        srcset=\"/blog/static/40f9262c0aafbe2acfc44122737b534e/63868/happy1.png 250w,\n/blog/static/40f9262c0aafbe2acfc44122737b534e/0b533/happy1.png 500w,\n/blog/static/40f9262c0aafbe2acfc44122737b534e/4971b/happy1.png 784w\"\n        sizes=\"(max-width: 784px) 100vw, 784px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 625px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/de4d6689ef1ce9cb39affd3fa962b202/80d71/happy2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA30lEQVQY042Q3W6CQBSEeQ7ZH5eFZVk3IIgIQmNqY5rU3vb9H+VrqvGiiU168WVmbibnTLLWiswFfDNhYsAeOtZ9i+63+F3LpgoIIVBK/YskFRqTe8p2oZpmwunAcJ7ploFm3ONcySpNEVKSCnFDCImUz0n2W0luNG5T079+EMqKy7Dj3NXU3uELi7MZeWbwuaX88TbDGHO7SGv9i+RlXOMKS1FFhssn0/WLMJ6wPjA0ketxx9JG2lDyPna89TXbGIgxPi9cpRrvK5Z5RiuJSFcoed/s/qa86cM/8l8bfgPDJ4+/gqBPswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"happyPack\"\n        title=\"happyPack\"\n        src=\"/blog/static/de4d6689ef1ce9cb39affd3fa962b202/80d71/happy2.png\"\n        srcset=\"/blog/static/de4d6689ef1ce9cb39affd3fa962b202/63868/happy2.png 250w,\n/blog/static/de4d6689ef1ce9cb39affd3fa962b202/0b533/happy2.png 500w,\n/blog/static/de4d6689ef1ce9cb39affd3fa962b202/80d71/happy2.png 625w\"\n        sizes=\"(max-width: 625px) 100vw, 625px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>资源匹配</h3>\n<h4>静态资源(CSS js)</h4>\n<p>可以通过webpack-manifest-plugin生成资源的位置信息文件,然后通过该文件查找资源的位置.\n资源位置文件\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6e4772a601a10df8ea960d04f7109c5b/37523/manifest1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABSElEQVQoz4XQy46bQBCFYR5jMtA3czfQgE0gxGCDkSYjbybrvP97/BGdmSiKImXxSbVondNV3jhapukL9/vGPM/Osqxcponr9cq6rgzDQFGUhKGmrmOW5c7j8eB2u7FtG23bUpYV1hZ4RZlibUXf94zjiK1KmrrGVvsDy/l8cnMUxUgpCCNJWVkX0jQNXdcRxzHGGLIswRNCYswBrTW2tghl0IcIE6coc0CaEKkUB60ItSbSGiMFKvBRIuDp6RO+7xMEAUIIPCmla9jbpdKcl1eGl+9Mbz84L99oLytFnvPVHtm6mpe+cboiw+YZQir2jA8uMEmSX18+HqmGmfqyYoeJ42kgSTOqJGRuK/oq53OZUyQRgRDs2ykl/w5UpGlKFEU0pwb/+RkR+I4UwhFSugD/fd4ppf7J2/f+2H+33+u3P5rVO/kfPwH7ocz+Fbi26AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"manifest\"\n        title=\"manifest\"\n        src=\"/blog/static/6e4772a601a10df8ea960d04f7109c5b/37523/manifest1.png\"\n        srcset=\"/blog/static/6e4772a601a10df8ea960d04f7109c5b/63868/manifest1.png 250w,\n/blog/static/6e4772a601a10df8ea960d04f7109c5b/0b533/manifest1.png 500w,\n/blog/static/6e4772a601a10df8ea960d04f7109c5b/37523/manifest1.png 720w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n通过manifest查找资源的位置\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/6bfd0/manifest2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAuklEQVQI1wXBW3KDIABAUdfRVkhNiAiK+KigoqadZPzrTPe/mNtzMqFKlPGUPlL7gXj+4eeD2miGecXYivtd4seSLlr8ZOhni+s0PliayWBHTf2l+SwuZFIKbrZHdYlufzE8TtyUGJaV4/mNHyfCerBvG6HRLE7TaoVRV1qjkTLn4/0NIXKEEGQXKbiajls74+KOixtN25J+duISKLUlrQm/PAmvX8bHSV0Z+kpRaU0TNlxIFEVBnuf8A+AOXPtnf8/gAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"manifest\"\n        title=\"manifest\"\n        src=\"/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/00d43/manifest2.png\"\n        srcset=\"/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/63868/manifest2.png 250w,\n/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/0b533/manifest2.png 500w,\n/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/00d43/manifest2.png 1000w,\n/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/6bfd0/manifest2.png 1011w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>data</h4>\n<ol>\n<li>server端执行匹配到组件的获取数据的方法(返回promise),primose执行完毕获取到最新的数据储存.将数据通过脚本挂载到window上的属性上.</li>\n<li>client端通过window属性的获取,生成存储数据.</li>\n</ol>\n<p>服务端获取数据和注入数据\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c7802c7fda66242f6b27d030fd19a685/78958/serverStore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACNElEQVQ4y42S6XKcMBCE9zFiELdgJYSkBZbDZ2znquRX3v9lvhRybK/jdVV+TEkDNa3unt61fmb+8Zvx7hvu8gE7X6OtR5uOdpjZ2wPKD+h+pvUHjHMoe8AME6pzFEVOmqVkeRrOnfdH+uUG5Xq6cea4HBmmAXtc8Zf3mHHFX91jl1vGZWJex/B/vV7onEc2JY2V6L6m6Sp2xng6P5GWJZlR1EriOkVdS0QckyQJSSJIxPP9qRdbL8TLtzRNQ+3MuGD6kWH01LqldQ4pS4qieAOYbucJSJZlZ2tXu4V2eWR9/E5/85W7L/f8+nnN48PKsFxS7zWNcUjVovspeNrs9y+M/q1dpR1+uWK5e2BvLAevmSbHOHQM80Ila/KyIi9KStlQVDKw34ZfLXitXVVV3IyOXtfoqiBLUj5dRERRTBxFT/4lf706kfzM6PQeGG66J6M46CZ4kGcZRb75kZKkKZEQxLEgFtsikhdAcbKMN0tJswxZljyMjs+D5a7vwnk/Wm77jl439EajGklZbbLrILkq8vD4O4YboJJVGPaqxqmarpGB8dDu6ZoKpVuca7G2pT2M7PcK20hkkQem7wB1XaFlSRSLIDESSaiLrd/kxvGT7Fgg4gix2SCSF7B3kjeGU6cCw6FV+GHGjguHVmPqKnj7UUzOSpZlETxcrWLwnnG94ei3XjNbzWI12ZnhsznM85zVtWEoRCPNSLL8DYNt4+n/AhpjKPL8KRLbwJmwJh9E5BzgHwrjq/i/6imaAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"serverStore\"\n        title=\"serverStore\"\n        src=\"/blog/static/c7802c7fda66242f6b27d030fd19a685/00d43/serverStore.png\"\n        srcset=\"/blog/static/c7802c7fda66242f6b27d030fd19a685/63868/serverStore.png 250w,\n/blog/static/c7802c7fda66242f6b27d030fd19a685/0b533/serverStore.png 500w,\n/blog/static/c7802c7fda66242f6b27d030fd19a685/00d43/serverStore.png 1000w,\n/blog/static/c7802c7fda66242f6b27d030fd19a685/78958/serverStore.png 1320w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nclient端提取数据\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/ffe34/clientStore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAApUlEQVQI113OXW6EIABF4dmIjFABHZCfUWlQJzZN97+l0wx968OX83Zzb1JK7lLTDyMfxjZ6UHhnGmNHtEso/VftAtpHrI8opei6DiFE69tNyR4XHEOo+O0g1ItHSNRXpR6F17nw8134ulb2o7DuF+nzxG07xgUeuTDnFdEGxXtQMseJMT9JZyWWjdEF3FrxKZOz47nMLMtMzp44WSZruPd9e/bfLyKkWa3wDvPqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"clientStore\"\n        title=\"clientStore\"\n        src=\"/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/00d43/clientStore.png\"\n        srcset=\"/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/63868/clientStore.png 250w,\n/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/0b533/clientStore.png 500w,\n/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/00d43/clientStore.png 1000w,\n/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/ffe34/clientStore.png 1055w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>扩展性</h2>\n<h3>配置单页是否支持服务端渲染</h3>\n<p>通过中间项配置是否支持服务端渲染\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28b4d894e176fc6f70cfdb3580c17811/8cdda/configServerRender.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjElEQVQoz5WS2Y7UQAxF+yuAzlZblkoqa2XpdYAB/v+XDupKM4KHEfBwZFtVsq+vfOgGR+c3nD+zvLyyvnxjuX1hvr/Sj56mqbHWUpYleZ5TFEWoq6rCmD/rRzyUNqVwDc1ypxpXjPNIUwSEVKRJQhxHJEnyLnEcv+WHutXUtkAJicoeCISUpGlKJgRKG6TSCCHIsuyvHIpS0dqO3i14NzM0I27wNNOCKSvqwZNXNVqbfUiWhfgeh8pJtNE4f6PbLgzLRj+MDOsFZfJ9slT/pC40rDtNnium8cRy/ozzG7afqKcV23uUKTFVGz4nSfwkIYnj4O+uLHlTHzzUJsO6BTeemF5+4OYzZdMxzBPT2NK2LcM8o/PySYGp6t1fqRAqD34HhU1n0EZQ9Z52vTLev9NtN7rTnX67YJ2j2+5065Vm2nDLhdZvDNev1N1AUVp0M6GU2htqo7C2ZBodWkqOHz8QR0fi485jtVBHR5IoeuYR8fFTeHusnybRbyvXDcaYMEEIGc7jf8h+8Tybn8y1HPDoF0VLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"configServerRender\"\n        title=\"configServerRender\"\n        src=\"/blog/static/28b4d894e176fc6f70cfdb3580c17811/00d43/configServerRender.png\"\n        srcset=\"/blog/static/28b4d894e176fc6f70cfdb3580c17811/63868/configServerRender.png 250w,\n/blog/static/28b4d894e176fc6f70cfdb3580c17811/0b533/configServerRender.png 500w,\n/blog/static/28b4d894e176fc6f70cfdb3580c17811/00d43/configServerRender.png 1000w,\n/blog/static/28b4d894e176fc6f70cfdb3580c17811/8cdda/configServerRender.png 1168w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>思考</h2>\n<p>在是否在项目中使用同构应用的时候,还是要结合具体的场景.可以有以下的几点考虑:</p>\n<ol>\n<li>项目中是否需要进行服务端渲染 => 使用者角度</li>\n<li>是否有引入node中间层(api转发)的必要, 其他的替代方案是否可行(nginx) => 整体设计的角度</li>\n</ol>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"如何构建一个WEB同构应用","date":"2019-04-24","tags":"工程化","path":"/iosmorphism","top":null,"summary":null},"title":"如何构建一个WEB同构应用","date":"2019-04-24","tags":"工程化","path":"/iosmorphism","top":null,"summary":null},{"id":"4cdd0882-440a-5f52-8e06-f45478281f93","html":"<h2>函数</h2>\n<h3>函数声明</h3>\n<p>函数声明包含函数的名字,形参列表,返回值列表(可选)以及函数体构成.</p>\n<pre><code>func name(parameter-list) (result-list) {\n  body\n}\n</code></pre>\n<p>需要注意一下几点:</p>\n<ol>\n<li>\n<p>函数的形参列表和返回值列表组成函数的签名,函数的签名会在函数被调用的时候做校验是否调用合法.</p>\n</li>\n<li>\n<p>参数的传递是按值传递的.当传递引用类型作为实参的时候,可能会修改实参变量.</p>\n</li>\n<li>\n<p>支持多返回值.</p>\n<p>func test(a [3]int) (int x, int y) {\nreturn x, y\n}\nfunc add(vals ...int) int {  // 变长参数声明\nsum := 0\nfor _, v := range vals {\nsum += v\n}\nreturn sum\n}</p>\n</li>\n</ol>\n<h4>函数变量声明</h4>\n<p>函数声明只能定义在包级别的作用域,函数变量声明可以在任何表达式内指定.函数变量生命能获取到整个词法环境(可以访问外部的变量)</p>\n<pre><code>func test() func(int) int {\n  x := 2\n  return func (y int) int {\n    return x * y\n  } // 这里的函数变量(匿名函数)可以访问到外部的x\n}\n</code></pre>\n<h3>函数流程控制</h3>\n<h4>defer</h4>\n<p>defer语句是普通的函数调用,defer语句能确保函数的return语句或函数执行完毕之后执行对应的defer函数.主要为了在函数的执行完毕后做特定的行为.</p>\n<pre><code>func test(x int) int {\n    defer func() { fmt.Print(x) }() // defer语句必须返回一个可执行的语句\n    return x\n} // 这个函数会在返回后打印入参\n</code></pre>\n<h2>方法</h2>\n<h3>方法声明</h3>\n<p>方法是声明特定类型(对象)上可以执行的函数. 通常可以使用如下的方式声明:</p>\n<pre><code>func (p structName) funcName(parameter-list) (result-list) {\n  body\n}  \n// 声明可以在p类型上调用funcName的方法 \nfunc (p Point) add() int {\n  return p.x + p.y\n}\np := Point{ 2, 3}\n  p.add()\n</code></pre>\n<p>注意:</p>\n<ol>\n<li>由于方法的调用是p.funcName和获取p结构体上的属性一致,要注意同一类型上的命名冲突.</li>\n</ol>\n<h3>指针接收者方法</h3>\n<p>由于方法会复制实参,当需要方法的调用对外界产生影响的时候,就需要通过指针类型来完成方法的声明,如下面的例子:</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10} // 获取指针\n  p.ScaleBy(2) // p{20, 20}\n  q := Point{1,2}\n  q.ScaleBy(3)  // q{3,6} 当类型符合的时候,会进行隐式转换 相当于 (&#x26;q).ScaleBy(3)\n}  \n</code></pre>\n<h3>方法变量和方法表达式</h3>\n<h4>方法变量</h4>\n<p>可以将一个特定类型的方法赋值给一个变量,这个变量称为方法变量.该方法变量已绑定到特定的接收者上(caller),通过传递形参就可以完成方法的调用.通常用于绑定特定的接受者.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := p.ScaleBy\n  scaleBy(2) // p{20, 20}\n}  \n</code></pre>\n<h4>方法表达式</h4>\n<p>方便表达式必须在调用的时候,提供接受者.方法表达式是把对应结构的函数行为进行声明.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := (*Point).ScaleBy // 方法表达式\n  scaleBy(p,2)\n}\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"go语言入门之-函数和方法","date":"2019-04-19","tags":"Go","path":"/go-func","top":null,"summary":null},"title":"go语言入门之-函数和方法","date":"2019-04-19","tags":"Go","path":"/go-func","top":null,"summary":null},{"id":"c97e3748-f65b-5727-ba7a-18d780b68885","html":"<h2>前言</h2>\n<p>React在处理界面更新的时候,是通过对比虚拟DOM(js对象)之间的差异来更新UI的.这种方式能一定程度上的减少对DOM的操作.通过虚拟DOM这个中间层结合多平台的renderer使React实现了跨平台.本文梳理了在medium上关于Virtual DOM的两篇文章来介绍如何简单实现一个Virtual DOM.</p>\n<h2>为什么虚拟DOM</h2>\n<ol>\n<li>UI = F(data)  Virtual DOM使数据,操作,属性可以集中在一起,这种方式能一定程度上降低项目长期维护的复杂性.</li>\n<li>页面性能 通过虚拟DOM的对比,进行差异的更新能提升页面的性能.</li>\n</ol>\n<h2>如何实现虚拟DOM</h2>\n<p>虚拟DOM可以理解是真实DOM的映射,如何实现虚拟DOM主要需要考虑一下几点:</p>\n<ol>\n<li>如何描述虚拟DOM(create)</li>\n<li>如何绘制虚拟DOM(render)</li>\n<li>如何差异化的更新虚拟DOM并且更新UI(update)</li>\n</ol>\n<p>下面主要从上面的三点来逐步实现一个简易版的虚拟DOM实现.</p>\n<h3>创建Virtual DOM</h3>\n<p>DOM的节点可以通过type(节点类型),props(styles, event), children(子元素)来描述.可以通过下面的函数来创建虚拟节点.</p>\n<pre><code>// 创建虚拟节点\nfunction h(type, props, children) {\n  return { type, props: props || [], children: children || [] };\n}\nconst root = h('ul', { name: 100, onClick: () => { console.log(1); } }, [\n  h('li', {}, ['sss'])\n])\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVQY022PyW7DMAxE8/8/1muBXtogrpN4k0wvihfJm/SK2EUPQQcYgCQGj+RJa839fkeXmjRL6Jqaoevo+x7TthhjdidJglKKqqrI8wLnHEPf77lxHBmtZZpXTiEE8jwn+vymVQ32mjHVDWmW8nU+01tLKYK1lsfjgYhQliVN26JESLKMNE3JC01nAyeAVgzqXaM/hCIS4vjGJbpglGITwTtHPww7TBUFTdPgrcWLMImwLAuHfoHzOHN/Symjik4KsujCYB1+npmrisW5/cInqK5rWmPY5pm1bZiMYV3XAxfC8bKzjkfW0ekeWw0sbiKOY663G90w8J/Cax/CAVy2Z+GPgQ/4LeB92Lc+X/He/4Wffu1f/QOtmsze8Gl17gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"virtualDom\"\n        title=\"virtualDom\"\n        src=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n        srcset=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/63868/virtualDom.png 250w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/0b533/virtualDom.png 500w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>绘制Virtual DOM</h3>\n<p>在下面的实现中,以$开头的元素指代真实的DOM节点,node指代虚拟节点.</p>\n<h4>绘制元素</h4>\n<p>在绘制元素的时候,如果节点的内容是文本,就直接创建文本节点.否则就创建当前类型的DOM节点并且遍历它的children节点递归的调用自身并且添加到创建的节点.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\nconst root = h(\"ul\", { name: '111', className: 'test' }, [\n  h('li', { name: 'child' }, ['text'])\n]);\n// app是页面中已经存在的容器节点\nconst container = document.getElementById('app');\ncontainer.appendChild(createElement(root)); // 已经能绘制到页面\n</code></pre>\n<h4>添加属性</h4>\n<p>在添加属性的时候,有以下的节点需要注意:</p>\n<ul>\n<li>对DOM节点上不存在的属性名字进行转换,例如ClassName</li>\n<li>布尔属性值的设置</li>\n<li>增加属性过滤功能来实现特有的实现</li>\n</ul>\n<h5>实现</h5>\n<pre><code>//设置布尔属性\nfunction setBooleanProp($target, name, value) {\n  if(value) {\n    $target.setAttribute(name, value);\n    $target[name] = value;\n  } else {\n    $target[name] = false;\n  }\n}\n// 属性过滤\nfunction isCustomProp(name) {\n  return false;\n}\n// 设置所有属性的入口\nfunction setProps($target, props) {\n  Object.keys(props).forEach(name => {\n    setProp($target, name, props[name]);\n  });\n}\n// 对单一属性的设置,实现过滤,转换\nfunction setProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.setAttribute('class', value);\n  } else if(typeof value === 'boolean') {\n    setBooleanProp(name, value);\n  } else {\n    $target.setAttribute(name, value);\n  }\n}\n</code></pre>\n<p>通过将设置属性的操作加入到之前的createElement函数中,来实现DOM属性的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n} \n</code></pre>\n<p>通过运行之前的代码,发现属性已经添加到DOM中了.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABIElEQVQoz6XO207CQBSF4b7/I3nphcSEKFAoyqkoh0Kn9DhMp8PM/IYYTUw8XLiSL3tf7bWD8UtJv7dlOBaMJnOGjyPuh4LbfspTIgl3NQ+rjCg5syo9i9z+KmjOkmR2IO6tOb4KmkohZimnWGCdx3vw3uOcx33Mj/0bQWc6xEtKfBdT7E50Mke1jv1e0umOP/Pe+CkAj9Yt2aug3Obk6wnJckk0EazjHK00phFIscN2LVmmSMX5x7Kgbi2VupCViu3yxHax4rl3w2GzIZwWjKOMKFwTDQaE0ZzpNCXs7zkeaxrtqJX9ImiNo7Oe6nrw6UBVKGRV0tQNUllORUclHVJbsqKh1QZ9Nqj2gr54tHFfBNc3rTEcnxPSRcrFGP6TN4i4F/4kEuvBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domWithProp\"\n        title=\"domWithProp\"\n        src=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n        srcset=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/63868/propShow.png 250w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/0b533/propShow.png 500w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>添加事件</h4>\n<p>在对事件的添加上,由于具体的事件也是在创建Virtual DOM的时候添加到props的,如果不想通过之前声明的setProps函数进行事件的处理,就需要将这些属性过滤出来,具体实现如下:</p>\n<pre><code>//判断是否是event属性\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n// 获取属性的后缀  例如 onClick => click\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n// 修改之前的过滤属性函数,加入对event属性的过滤\nfunction isCustomProp(name) {\n  return isEventProp(name)\n}\n// 添加属性函数\nfunction addEventListeners($target, props) {\n  Object.keys(props).forEach(name => {\n    if(isEventProp(name)) {\n      $target.addEventListener(extractEventName(name), props[name]);\n    }\n  })\n}\n</code></pre>\n<p>将添加事件的函数增加到createElement函数中,完成对事件的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  addEventListeners($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\n</code></pre>\n<h3>对比差异更新UI</h3>\n<p>如果完全的对比两个树形结构的差异,时间复杂度是O(n^3)的.为了一定的性能优化,可以有以下的假设:</p>\n<ol>\n<li>节点的类型变更,两个DOM的结构就是不同的.这种情况可以直接进行替换操作.</li>\n<li>很少存在跨层级的节点移动</li>\n<li>同一类型的节点的DOM结构是相同的</li>\n</ol>\n<p>通过对上面假设的分析,在更新Virtual DOM的时候,主要有以下几种情况</p>\n<ol>\n<li>对比两个node的类型不同,直接替换</li>\n<li>最新的node中没有元素和属性,需要删除对应的节点的属性</li>\n<li>最新的node中增加了元素和属性,需要添加对应的属性和节点</li>\n<li>节点类型相同,对子节点实现1 2 3的操作</li>\n</ol>\n<h4>更新节点</h4>\n<pre><code>// 判断两个node是否是同一个节点\nfunction changed(node1, node2) {\n  return typeof node1 !== typeof node2 || typeof node1 === 'string' &#x26;&#x26; node1 !== node2 || node1.type !== node2.type;\n}\n\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  // index是子元素的位置\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新属性</h4>\n<p>在更新属性的时候跟更新节点的步骤类似</p>\n<pre><code>// 删除布尔属性\nfunction removeBooleanProp($target, name) {\n  $target.removeAttribute(name);\n  $target[name] = false;\n}\n// 移除属性\nfunction removeProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.removeAttribute('class');\n  } else if(typeof value === 'boolean') {\n    removeBooleanProp($target, name);\n  } else {\n    $target.removeAttribute(name);\n  }\n}\n// 当不存在newVal的时候,remove对应的属性.其他情况进行覆盖\nfunction updateProp($target, name, newVal, oldVal) {\n  if(!newVal) {\n    removeProp($target, name, oldVal);\n  } else {\n    setProp($target, name, newVal);\n  }\n}\nfunction updateProps($target, newProps, oldProps = {}) {\n  const props = Object.assign({}, newProps, oldProps);\n  Object.keys(props).forEach(name => {\n    updateProp($target, name, newProps[name], oldProps[name]);\n  });\n}\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    // 增加属性的更新\n    updateProps($parent.childNodes[index], newNode.props, oldNode.props)\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新事件</h4>\n<p>函数是不好判断是否有变化的,可以通过一些参数来完成事件的更新(触发重新更新,通过节点替换来完成事件的更新这样不好)</p>\n<pre><code>function changed(node1, node2) {\n  return typeof node1 !== typeof node2 ||\n      typeof node1 === ‘string’ &#x26;&#x26; node1 !== node2 ||\n      node1.type !== node2.type ||\n      node1.props.forceUpdate;\n}\nfunction isCustomProp(name) {\n  return isEventProp(name) || name === ‘forceUpdate’;\n}\n</code></pre>\n<h3>参考</h3>\n<p><a href=\"https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060\">How to write your own Virtual DOM\n</a><br>\n<a href=\"https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76\">Write your Virtual DOM 2: Props &#x26; Events</a><br>\n<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"How to wirte your own Virtual DOM(译)","date":"2019-04-02","tags":"React","path":"/react-virtual-dom","top":null,"summary":null},"title":"How to wirte your own Virtual DOM(译)","date":"2019-04-02","tags":"React","path":"/react-virtual-dom","top":null,"summary":null},{"id":"b6744961-a515-567c-9bf3-185d20eae82e","html":"<h2>go数据类型</h2>\n<p>go语言数据类型主要分为以下的四个大类:</p>\n<ol>\n<li>基础类型(整数,浮点数,负数,布尔值等)</li>\n<li>聚合类型(数组,结构体)</li>\n<li>引用类型(slice,指针,map,函数,通道)</li>\n<li>接口类型</li>\n</ol>\n<p>go语言是拥有类型系统的语言,相对于笔者最熟悉的javascript这种动态且无类型的语言来说有着长远的好处.通过类型系统能在编译阶段减少一定的运行时错误.例如在go语言中不同类型值之间必须通过显示转换来进行赋值操作.本文主要从go语言中的基础类型开始,逐步的讲解go语言中几种基本的引用类型.</p>\n<h2>基础类型</h2>\n<h3>字符串</h3>\n<p>字符串是不可改变的字节序列.可以通过[i:j]操作符截取对应字符串的子串.由于字符串不可改变的特点,子串和母串共用一端底层内存.</p>\n<pre><code>s := \"hello world\"\nb := s[6:] // [i:j] 从i开始不包括j 注意越界 b world\nb[0] = 'a' // 错误 \n</code></pre>\n<h3>常量</h3>\n<p>常量是一种表达式,可以在编译的阶段来确定相应的值.在声明常量的时候可以指定类型和值(如果没有指定类型会通过值来推断常量的类型).在连续声明多个常量的时候,主要有以下两种方式:</p>\n<ol>\n<li>\n<p>在声明枚举值的时候,可以通过iota常量生成器来实现.iota从0开始,逐项加1</p>\n</li>\n<li>\n<p>省略赋值语句的一项会复用前一项的表达式和类型</p>\n<pre><code> const (\n a  = iota\n b\n c\n d\n )\n // a b c d 0 1 2 3\n const (\n a = 1\n b\n c = 2\n d\n )\n // a b c d 1 1 2 2\n</code></pre>\n</li>\n</ol>\n<h4>无类型常量</h4>\n<p>无类型常量(常量字面量)是还没有确定从属类型的常量值.无类型常量相对于同样的有类型的常量有更大的精度.例如0.0相对有浮点数拥有更大的精度.在将无类型常量复制给对应的变量的时候,赋值的变量会转换为无类型常量默认的类型.</p>\n<pre><code>i := 0 // int(0)\nb := 0.0 // float64(0.0)\n</code></pre>\n<h2>聚合类型</h2>\n<h3>数组</h3>\n<p>数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列.由于数组在声明的时候对长度有限制,当存储元素到达数组的容量的时候就需要申请新的内存空间来进行数据的存储.所以在存储数据上一般不会使用数组.数组元素的初始值是该类型的零值.在声明数组的时候需要显示的指定长度和类型.</p>\n<ol>\n<li>\n<p>声明数组需要有长度的定义和类型定义,可以通过定义长度或者数据数量来确定数组的长度.元素类型和长度相同的数组是可以比较和复制的</p>\n</li>\n<li>\n<p>数组元素的初始值为该数组元素类型的初值</p>\n</li>\n<li>\n<p>在函数中使用数组指针来完成对原数组的修改</p>\n<p>b := [...]int{1,2,3}  // 通过初始化数组元素的个数决定数组的长度\na := [3]int{1,2,3}\na == b // true\nr := [...]int{99: -1} // 定义一个含100元素的数组r 最后一个元素是-1 其余都初始化int类型的零值 0</p>\n</li>\n</ol>\n<h3>结构体</h3>\n<p>结构体是将多个命名变量组合到一起的聚合数据类型.可以通过下面的方式声明一个结构体:</p>\n<pre><code>type Person struct {\n    name string\n    id int\n}\n</code></pre>\n<p>在声明结构体的时候需要注意以下的几点:</p>\n<ol>\n<li>结构体变量的大小写决定变量是否可以导出(可以被其他导出的包读写),</li>\n<li>结构体变量不可以拥有自己本身的结构体类型,可以通过自身结构体类型的指针来实现递归结构</li>\n</ol>\n<h4>结构体字面量</h4>\n<ol>\n<li>\n<p>可以按照声明的顺序来初始化结构体变量或者指定变量名称来初始化结构体字面量</p>\n</li>\n<li>\n<p>可以获取结构体指针来设置结构体的值</p>\n<pre><code> a := Person{ name: \"haha\" } // 指定变量名声明\n b := Person{ \"haha\", 20 }\n var copyPerson *Person = &#x26;a // 获取结构体指针\n copyPerson.name = \"100\"\n</code></pre>\n</li>\n</ol>\n<h4>结构体嵌套</h4>\n<p>在定义结构体的成员的时候,go允许只指定成员的类型来实现成员的声明.通过这种方式定义的结构体成员成为匿名成员.匿名成员的类型必须是一种命名类型或者指向命名类型的指针.匿名成员可以为方便变量提供便捷的操作.</p>\n<pre><code>type Circle struct {\n    x int\n    y int \n    radius int\n}\ntype Wheel struct {\t\n  Circle\n  color string\n}\nwheel := Wheel{Circle{ 10, 10, 19}, \"red\"}\n// wheel.x = 10\n</code></pre>\n<h2>引用类型</h2>\n<h3>slice(切片)</h3>\n<p>slice是用相同类型元素的可变长度序列.可以基于一个已有的数组来创建这个数组的slice.slice有三个属性:指针,容量,长度.可以在一个数组的基础上产生多个slice,它们共享内存空间.需要注意的是slice可以理解为对原数组的引用,通过对slice的修改是会影响到底层数组的.</p>\n<h4>声明切片</h4>\n<p>主要有以下两种方式声明切片:</p>\n<ol>\n<li>\n<p>通过切片字面量和内置的make函数</p>\n</li>\n<li>\n<p>slice的操作符[i:j]操作数组或者切片字面量</p>\n<pre><code> var b = make(int[], 3, 5) // make(type[], len, cap) 声明一个长度为3容量为5的切片\n var b = []int{1,2} // 声明一个长度和容量都为2的切片\n var c = []int{ 99: 1 } // 声明一个长度和容量为100的切片,初始化第100的元素为1\n slice := []int{1,2,3,4,5}\n newSlice := slice[1:3]  // 通过切片创建切片\n var num = [10]int{1,2,3,4,5,6,7,8,9,10}\n a := num[1:4] // 操作符[i:j]创建一个新的slice,引用原数组i到j-1个元素.slice的容量是slice起始元素到底层数组最后一个元素之间的个数,切片a只能看到底层数组i以及之后的元素\n len(a) // 3 获取切片的长度\n cap(a) // 9 获取切片的容量\n b := a[:5] // 可以在一个已有的slice上扩充容量,产生新的slice\n len(b) // 4\n cap(b) // 9\n</code></pre>\n</li>\n</ol>\n<h4>操作切片</h4>\n<ol>\n<li>\n<p>slice相当于对底层数组的引用,通过操作slice可以修改底层数组</p>\n<pre><code> a := [3]int{1,2,3}  \n b := a[:2]\n b[0] = 100  // a[0]也是100\n</code></pre>\n</li>\n<li>\n<p>append函数可以动态的添加元素到slice.append函数会返回一个新的slice</p>\n<pre><code> slice := []int{1,2,3,4,5}\n newSlice := slice[1:2] \n newSlice = append(newSlice, 10) // newSlice容量足够,修改底层数组返回新的slice. a[2] = 10\n a := slice[1:2]\n b := slice[2:3]\n c = append(a, b...) // 支持批量添加\n</code></pre>\n</li>\n</ol>\n<h3>map</h3>\n<p>在go中map是对散列表的引用.散列表是无序的键值的结合.可以通过如下的方式创建map:</p>\n<pre><code>var test = make(map[string]int) // 声明map的键值的类型 \ntest[\"name\"] = 100  // 赋值\nvar person = map[string]int{ \"card\": 1, id: \"2\" }  //声明并初始map\nperson[\"card\"] // 1\n</code></pre>\n<p>map有以下几点需要特别注意:</p>\n<ol>\n<li>在赋值map类型的值的时候,需要对map进行初始化.初始化的map的值是对应类型的零值.</li>\n<li>map是引用类型,在函数间传递的时候会对原值进行修改.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null},"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null},{"id":"b1b97732-ab7b-5428-9c38-f5af9e4d1fa1","html":"<h2>go语言简介</h2>\n<p>go语言是一种编译型语言,在设计上融入了设计者对复杂项目中易出现问题的思考,go语言在设计上突显了简单性.这种简单性在长期来看是会为项目带来收益的.下面主要从go的环境配置开始进而通过一个简单的go程序\b来认识go.</p>\n<h2>go环境配置</h2>\n<p>当go安装完毕后,可以通过go env来查看相应的环境配置,如图\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 641px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABiUlEQVQ4y51U2VLCQBBcOQRFzoCgFo+inELuhJCEcMj//9BYPZsNFmUh8DC1u7Op3u6emYjS1KOHL5/aTkJNK+Yoz3zKDS0SHwaJT/O66Ppb6kcH6rgJ1c2Qut6GOu6GcqMbATvehvrhgVp2TIWxQ2Kgk3hfkBgYEvBc4NvTnOasWe7LckcNM6KmFZHmJNm+qq9kzl5T3QipYcXUdhPSbGkP8rgHofupKxn2ljsCcHnmUX5kU3HiMFus+fHxXEj36nw/cbPvWJ2SDP/wKopzNzSlZBVnJf+RQwGeU5ZYH+dLfhkrGN9UFPjX9bb0GuzZC3j1tvrm/dWVBsOeL9kpMMjHvgSTFeDpeo5hz99mQKju0yKQLaHiUjDFEM2NKgOsnbZMzQj5kZYVc+tcLB1S4R1Aa/qK2aGfMJJqLLklLgXUuKn3LBeMOMmTov+aGv3/qVEBhqgoerEyD7ixEWjiYzhZXt4dz8WTO6HGDl5VFgGPEWTLv08kfeQxi9hnjBv8rab24A524R6AP/kYq3qmQSoOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"go env\"\n        title=\"go env\"\n        src=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n        srcset=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/63868/goEnv.png 250w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/0b533/goEnv.png 500w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png 641w\"\n        sizes=\"(max-width: 641px) 100vw, 641px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n其中GOPATH,GOROOT是我们需要关注的两个配置.GOPATH指定的工作区间的根目录,在GOPATH下通常有三个目录:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 596px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQoz53OSY7CMBSEYd/EwXHiAWXhDMgWqJsM4gAsEFIvcv9T/C0jOIBZfHp6tSiVWNeVfd+Z55lxHEkpEWP8ilIK4b0nhMCyLPR9jzEG5xzWlquqCuHckRBGtu3GMEwY48iZteVehSn9cr3eeDz+uN+fTNOFnMVY6gel9GfhwLJsnE6RtrXvhb6YlBVC6wbvj5zPF7quQ6manGmti0kpEU3TUteaw0G9bv6/lQv/AcdU1m38VSPNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n        srcset=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/63868/category.png 250w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/0b533/category.png 500w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png 596w\"\n        sizes=\"(max-width: 596px) 100vw, 596px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在src目录下的每个子目录是一个包.pkg子目录是构建工具存储编译后的包的位置.bin子目录放置可执行程序.GOROOT主要提供标准库的包.</p>\n<h3>go语言的基础结构-hello world</h3>\n<p>在GOPATH下的src目录创建helloworld文件夹,在该文件夹中创建helloworld.go.(通常文件的名字都跟包名一致),通过在命令行使用go run hellowrld.go</p>\n<pre><code>package main // 定义包名\nimport (\n  \"fmt\"  // 导入包\n)\n//  main函数可执行程序的主入口\nfunc main() {\n  var a = \"hello world\"  // 定义变量并且在控制台输出\n  fmt.Print(a)\n}\n</code></pre>\n<h2>go中的包</h2>\n<h3>包的初始化</h3>\n<p>包的初始化从初始化包级别变量开始,按照这些变量的声明顺序进行初始化,对于一些复杂的初始化场景,可以定义init函数来初始化变量,在其他包对当前包进行引用的时候,init函数会被调用.</p>\n<pre><code>var a = b + c\nc = 100\nb = f()\nfunc f() {\n  return 1\n}  // 会按照 c b a 的顺序依次初始化\n</code></pre>\n<h3>包的命名</h3>\n<p>在go源文件的开头都需要进行包名的声明,同一个包下的所有源文件同属一个包(有一个例外是当前go文件是一个可执行的go程序时,只能声明main包来生成可执行的文件)</p>\n<h3>包的引入</h3>\n<p>包是go实现代码复用的一种主要形成.在声明包名之后,可以通过import语句对需要使用的包进行引入.通常有下面几种方式导入对应的包:</p>\n<pre><code>import (\n  \"fmt\"  //正常导入\n  XXX \"fmt\" // 别名导入 XXX可以作为fmt包的别名来使用\n  _ \"image/png\" // 空导入 通常为了执行包的初始化函数来获取副作用\n  import \"github.com/xxx\" // 导入远程包\n)\n</code></pre>\n<p>包的查找是先查找go的安装目录,然后GOPATH</p>\n<h2>声明</h2>\n<p>实体的声明主要有以下的规则:</p>\n<ol>\n<li>如果声明的实体在函数体内,该实体只在函数局部(存在块级作用域)有效.实体声明在函数外,该声明对当前包所有的文件可见.</li>\n<li>实体的第一个字母的大小写决定其是否可以被其他包调用</li>\n</ol>\n<h3>变量声明</h3>\n<p>在go语言中可以通过下面的几种方式来创建和声明变量.</p>\n<h4>常规变量声明</h4>\n<pre><code>var name type = expression\n</code></pre>\n<p>上面这种声明方式指定了变量的类型和初始值表达式,类型和表达式可以忽略一个:</p>\n<ol>\n<li>当类型忽略的时候,变量的类型会由初始化表达式的类型决定</li>\n<li>当初始化表达式忽略的时候,变量的初始值对应着相应类型的零值.</li>\n<li>当把一个类型的变量赋值给另一个类型的时候,需要通过显示转换.</li>\n</ol>\n<h4>短变量声明</h4>\n<pre><code>name := expression\n</code></pre>\n<p>上面这种方式称为短变量声明,这种方式声明的变量类型由表达式返回的类型决定.在使用短变量声明的时候,需要注意一下两点:</p>\n<ol>\n<li>短变量声明在左侧已经存在对应变量的声明的时候,相当于赋值</li>\n<li>短变量声明要求至少声明一个变量</li>\n</ol>\n<h4>new操作符</h4>\n<p>new(T)创建一个未命名的T类型变量并且初始化T类型的零值,返回其地址(指针).</p>\n<pre><code>p := new(int) // 初始化一个int类型的变量返回地址\nfmt.Println(*p) // 输出0\n*p = 2\nfmt.Println(*p)  // 输出2\n</code></pre>\n<h4>指针</h4>\n<pre><code>x := 1\np := &#x26;x  // &#x26;操作符获取变量地址 复制给一个int类型的指针p\nfmt.Println(*p) // 输出1 *操作符获取指针指向的变量的值\n*p = 2 // 通过指针修改变量的值 \nfmt.Println(x) // 输出2\n</code></pre>\n<h4>变量的生命周期和作用域</h4>\n<h5>生命周期</h5>\n<ol>\n<li>\n<p>包级别变量存在于整个程序的执行时间</p>\n</li>\n<li>\n<p>局部变量有动态的声明周期,在执行声明语句的时候会创建一个新的实体.当局部变量不可访问时会被回收.</p>\n<pre><code> a := []int{1,2,3,4,5}\n for _, num := range a {\n   fmt.Printf(\"%d\", num)  // num变量在每次循环创建\n }  \n</code></pre>\n</li>\n</ol>\n<h5>作用域</h5>\n<p>作用域指的是用到对应变量声明的源代码段。go语言中声明的作用域是词法块的，词法块决定着声明作用域的大小。</p>\n<h3>变量赋值</h3>\n<ol>\n<li>\n<p>在进行变量赋值的时候,go语言有对应的类型检测(例如你不能把一个int类型赋值给string类型的变量).</p>\n</li>\n<li>\n<p>支持多重赋值语法</p>\n<pre><code> x,y := 1, 2\n x, y = y, x\n</code></pre>\n</li>\n</ol>\n<h3>类型声明</h3>\n<p>类型声明提供了一种方式来区分底层类型的不同或者不兼容的使用方式。相同类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，不同命名类型的值不能直接比较.</p>\n<pre><code>type name string\ntype id string\n\nfunc main() {\n  var a name = \"\"\n  var b id = \"\"\n  fmt.Println(a == b) // 这里会报错 a b 不是相同的类型无法比较\n}\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://golang.google.cn/cmd/go/\">go命令行使用</a></p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null},"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null},{"id":"0f98dd9a-5532-56d0-bc00-01267ece2905","html":"<h2>前言</h2>\n<p>在开发公司内部web版聊天工具的时候,用户联系人数目是100+的.最近在思考如果每次都把100+的联系人进行渲染并且更新,这种实现是过度的.用户可能只操作20个联系人,浏览器却要为此付出多余的渲染性能.因此考虑通过虚拟列表来实现这个功能.虚拟列表只渲染可视区域,这样一定程度上降低了性能的消耗.本文主要通过react代码来描述如何实现一个简单的虚拟列表,在实际的生产环境还是推荐使用比较成熟的包,例如react-virtualized.在最后分享下自己在工作中的一点想法.</p>\n<h2>虚拟列表的简单实现</h2>\n<p>使用虚拟列表的前提是容器的高度是固定的,渲染的每个条目的高度也是相对固定的,这样就能计算出容器能渲染出的条目.下面是页面的结构:</p>\n<pre><code>import React, { Component } from 'react';\nconst allData = Array(1000).fill({ title: 'sss' }); //所有的渲染条目\nconst styles = {\n  container: {   // 外层容器样式\n    height: '400px',\n    border: '1px solid black',\n    position: 'relative',\n    overflow: 'auto',\n  },\n  openContainer: {  // 容器内通过定义一个空元素 高度为所有条目的高度,撑起父元素显示滚动条\n    position: 'absolute',\n    height: allData.length * 40 + 'px',\n    left: 0,\n    right: 0,\n    top: 0,\n    zIndex: -1,  //显示在列表条目下面\n  },\n  listContainer: {  // 列表容器\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    top: 0,\n  },\n  listItem: {  // 列表条目\n    height: '40px',\n    lineHeight: '40px',\n  },\n}\nclass VirtualList extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      visibleData : [],  // 实际显示的条目\n      visibleCount: 0,   // 显示的数据\n      start: 0,  // 显示条目的起始位置\n      end: 0,  //   \b显示\b条目的末位置\n      itemHeight: 40, // 条目的高度\n    };\n  }\n  render() {\n    return (\n    &#x3C;div>\n      &#x3C;div\n        ref={container => this.container = container} // 外层容器\n        onScroll={(e) => {this.scrollHandle(e)}}\n        style={styles.container}\n      >\n        &#x3C;div style={styles.openContainer}>&#x3C;/div> // 撑起父容器,父元素展示滚动条\n        &#x3C;div\n          style={styles.listContainer}   // 列表容器\n          ref={listContainer => this.listContainer = listContainer}>\n            {this.state.visibleData &#x26;&#x26; this.state.visibleData.map((item, index) => (\n            &#x3C;div \n              key={index}\n              style={styles.listItem}\n            >\n              {item.title}\n            &#x3C;/div>))}\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>);\n  }\n}; \n</code></pre>\n<p>接下来在组件挂载的时候,\b计算出\b\b\b容器可以显示的列表条目和初始显示的数据</p>\n<pre><code>componentDidMount() {\n    const visibleCount = Math.ceil(this.container.clientHeight / this.state.itemHeight); // 计算实际应该显示的条目数\n    const end = this.state.start + visibleCount; // 计算位置\n    const visibleData = allData.slice(this.state.start, end);  // 计算应该展示的条目\n    this.setState({ end, visibleCount, visibleData }); // 更新状态\n  }  \n</code></pre>\n<p>在父容器绑定滚动事件,在滚动列表的时候,计算实际需要渲染的条目并且列表的位置.</p>\n<pre><code>scrollHandle(e) {\n    const scrollTop = this.container.scrollTop;\n    const fixedScrollTop = scrollTop - scrollTop % this.state.itemHeight;  // 计算到父容器顶部的距离\n    this.listContainer.style.webkitTransform = `translate3d(0, ${fixedScrollTop}px, 0)`;  // 移动列表\n    const start = Math.floor(scrollTop / this.state.itemHeight);\n    const end = start + this.state.visibleCount;  \n    const visibleData = allData.slice(start, end); // 重新计算需要显示的元素\n    this.setState({ start, end, visibleData }); // 更新状态\n}\n</code></pre>\n<h2>一些想法</h2>\n<p>在最近学习和工作的思考中,产生了几个想法:</p>\n<ol>\n<li>学习是一个需要渐进坡度的过程.在我刚开始工作的时候,自己还没有接触react并且对MVVM等概念也不是很明确.\b在对一些类库的\b使用之后比自己之前直接去看相应的文章更加能理解文章的意图.学习的\b\b坡度\b最好是渐进的.</li>\n<li>在工作上,在完成业务要求的时候的同时个人应该有更多的思考.让自己有一个正向的工作模式.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/14b5013e441a414126d7d5ce364726a9/20785/work.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHElEQVQoz02S246DMAxE+f+/6xNIfaiAUhAtlHArd6/OSFkFyXKYjO2M7eg4DjvP04ZhMOecfNd1Bt62rdV1be/32/q+t3EcxcHg7Ptu3+9XMXCnabKIZAR/Ph9dQCA4z3NL09Sez6eScn48HkoEt6oqYa5z4oNRMKLKPM8iQCahr9o0jbwvRBCe13AmERxejIppnCzioixLkXjpuq6Scl2X/Lqswnxrtm2TcRf+Y8d+WETmoihUkQ8iwT6hN4LP4/xPFhYNMUn+/X7q2f1+tyRJ1LOhHyQDiXjagbxQMkPAc+dlaygYsuM4ttvtZlVZWZZlGgi9fb1eOoOREIyi4L4ofQaPwrWBhNFs8HBVlmXR8MC0Yp2TZL9qfnB/0aNjqAd6ymQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"how to work\"\n        title=\"how to work\"\n        src=\"/blog/static/14b5013e441a414126d7d5ce364726a9/00d43/work.png\"\n        srcset=\"/blog/static/14b5013e441a414126d7d5ce364726a9/63868/work.png 250w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/0b533/work.png 500w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/00d43/work.png 1000w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/20785/work.png 1307w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"虚拟列表的简单实现","date":"2019-02-24","tags":"JavaScript","path":"/virtual-list","top":null,"summary":null},"title":"虚拟列表的简单实现","date":"2019-02-24","tags":"JavaScript","path":"/virtual-list","top":null,"summary":null},{"id":"6c1963de-72c8-5ab9-8515-232321c28746","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有先入先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这个在一定程度上也解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定(<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>).</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a></p>\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a></p>\n<p><a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a></p>\n<p><a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null},"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null},{"id":"64e44923-c974-57a6-9439-3efd01fbd7b5","html":"<h2>简介</h2>\n<p>最近在做业务中,\b需求的场景是需要在原有的组件上添加点击\b事件\b并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.\b高阶组件能最好化的复用代码.实现高阶组件\b有如下几种方式:</p>\n<ol>\n<li>属性代理(\b操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state\b完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(\b子组件先\b\bDidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.\b通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有\b调用\b,不会执行Wrapped的\bDidMount)\n    }\n    render() {\n      return super.render() //\b在这个可以实现渲染劫持,例如\b\b常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的\b时候通过在定义一个render函数来决定组件的具体内容.(children API\b)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个\b实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的\b可以\b\b复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的\b问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null},"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null},{"id":"1f2ad40b-098b-52f8-a30d-d3cd6c4e0a51","html":"<h2>简介</h2>\n<p>\b\b如何利用缓存在计算机系统或者网络服务中\b都是提升系统体验的\b的一个很重要的思考方向.相对于网络(磁盘)的I/O,直接将需要的数据存储到一个相对较快的获取位置,这样就能尽快的获取到需要的资源.这里\b主要总结下\b在前端开发中一些缓存方面的知识.</p>\n<h2>请求资源</h2>\n<p>下面这个图总结了网络请求中缓存涉及的几个\b方面,\b下面将具体的从每个方面进行展开.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvTUgo/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQITFh/9oACAEBAAE/IWxwjVLNf//aAAwDAQACAAMAAAAQO8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJVpB//EABsQAQADAQADAAAAAAAAAAAAAAEAEUEhMVFx/9oACAEBAAE/EKAD7uLzWqMJSlfrK2AtzJQeCf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"缓存\"\n        title=\"缓存\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/0479a/cache.jpg 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/41099/cache.jpg 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>本地-强缓存</h3>\n<p>强缓存\b是浏览器在请求具体的资源的时候,直接使用本地缓存的资源的副本而不通过服务器\b去验证资源的相关信息的一种方式.通常有通过expires和Cache-Control中的max-age来控制.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"right\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>expires</td>\n<td align=\"center\">指定缓存的过期时间(与客户端的时间设置相关)</td>\n<td align=\"right\">HTTP 1.0 \b max-age优先expires</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">\b指定请求资源过后多少秒后资源过期</td>\n<td align=\"right\">HTTP 1.1 \bmax-age有优先expires</td>\n</tr>\n</tbody>\n</table>\n<p>当请求的资源存在本地缓存副本并且处于新鲜期的时候,直接返回本地资源.<br>\n当请求的资源没有本地缓存的\b时候,向服务器拉取对应的资源.<br>\n当资源存在缓存\b但是\b\b已经过期的时候,通过是缓存协商去服务器获取资源.</p>\n<h3>请求-缓存协商</h3>\n<p>\b缓存协商是指通过与服务端交互\b缓存资源的信息来判断当前缓存是否可用的一种机制.<br>\n当通过缓存协商服务端认为当前的资源是可用的,返回304(响应体是空).客户端可以时候当前的缓存资源并且可以更新\b缓存的相关信息.<br>\n当服务端\b认为资源不可用的时候\b,返回200(响应体中包含请求的资源).</p>\n<h4>Cache-Control</h4>\n<p>Cache-Control 被用于在http请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求设置的指令,在响应中不一定包含相同的指令.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td align=\"center\">下次请求是强制验证资源有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td align=\"center\">\b\b不进行缓存</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">\b\b相对于请求时间设置的最大过期时间</td>\n</tr>\n<tr>\n<td>public</td>\n<td align=\"center\">\b\b可以被\b客户端和代理缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">\b\b只能客户端缓存,不能被代理缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td align=\"center\">\b\b缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源</td>\n</tr>\n</tbody>\n</table>\n<h4>last-modified和Etag</h4>\n<p>last-modified和Etag(Etag还可以结合If-Match来判断当前提交的内容跟服务端存储的内容是否一致)都是在响应头中返回的对资源的一些设置\b信息,可以通过这两个值\b来缓存协商当前缓存资源时候可用.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">作用方式</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>last-modified</td>\n<td align=\"center\">资源在服务端的上次修改时间</td>\n<td align=\"center\">通过在请求头中设置If-Modified-Since的\b值为缓存资源的last-modified值来与服务端询问\b缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td align=\"center\">\b代表资源的\b实体标识,当资源的内容在\b服务端修改的时候,需要重新生成Etag</td>\n<td align=\"center\">通过在请求头中设置If-None-Match的\b值为缓存资源的Etag值来与服务端询问\b缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n</tbody>\n</table>\n<h5>last-modified和\bEtag的区分</h5>\n<p>Etag的出现更像是为了弥补last-modified的不足.例如:</p>\n<ol>\n<li>last-modified的时间只能\b\b精确到秒</li>\n<li>一个资源的频繁修改但是内容并没有修改</li>\n</ol>\n<h2>存储-协商存储</h2>\n<p>\b协商存储就是根据上面学习的相关字段来决定获取到的资源是否可以被存储被下次请求使用的策略.上文已经对响应的字段进行了说明.</p>\n<h2>CDN</h2>\n<h3>CDN简介</h3>\n<p>CDN(内容分发网络)指的是一组分布在各个地区的服务器.这些服务器存储着数据的副本,当用户访问资源的时候,CDN服务器可以根据用户的IP,服务集群的负载状态等信息尽快的返回给用户所需要的资源.</p>\n<h3>CDN优点</h3>\n<p>CDN主要的功能是托管静态资源,项目中对静态资源进行CDN的配置已经是标配,使用CDN主要有以下优点:</p>\n<ol>\n<li>将静态资源托管给CDN起到给源站分流的作用,降低服务端负载,解决网络网络带宽问题和不同服务商网络速度不同的问题.</li>\n<li>对资源的请求大部分都在CDN的边缘节点完成,访问延迟降低,用户能尽快的看到内容.</li>\n<li>CDN域名与源站域名不同,源站的cookie不会随着静态资源的请求发送,能一定程度上减少网络数据的发送.</li>\n</ol>\n<h3>CDN请求资源流程</h3>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器.</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户.</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求.</li>\n<li>CDN全局负载均衡设备根据用户IP地址,以及用户请求的内容URL,选择一台用户所属区域的区域负载均衡设备,告诉用户向这台设备发起请求.</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近;根据用户所请求的URL中携带的内容名称,判断哪一台服务器上有用户所需内容;查询各个服务器当前的负载情况,判断哪一台服务器尚有服务能力.基于以上这些条件的综合分析之后,区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址.</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户.</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地.</li>\n</ol>\n<h3>CDN优化</h3>\n<ol>\n<li>合理设置CDN节点的缓存时间，保证用户能及时同步到最新的内容</li>\n<li>根据不同的路径 配置不同的缓存规则，实现缓存的最大化</li>\n<li>CDN缓存节点预热</li>\n</ol>\n<h2>缓存的意义</h2>\n<ol>\n<li>资源或者服务的尽快到达和可用</li>\n<li>解决网络带宽问题和服务负载</li>\n<li>减少网络流量,让流量做更加有意义的事</li>\n</ol>\n<h2>思考</h2>\n<p>缓存能给应用带来\b一定的好处,同时也给服务增加了一些\b负载\b(保证资源的更新,增加缓存的成本等等).在对系统的一些基础\b服务做修改的时候,先要把这些有可能出现问题的点考虑清楚或者为什么这么做想好,在去做事.</p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null},"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null},{"id":"717227d4-91ff-5f6b-aee3-770c03c30d3d","html":"<h2>简介</h2>\n<p>作为web开发者,CSS是必备的一项基础技能,下面将从CSS的盒模型开始,来展开了解CSS的相关基础知识.</p>\n<h2>盒模型</h2>\n<p>当对一个元素进行布局的时候,渲染引擎会根据CSS-Box模型(box-sizing)将对应元素表示为一个矩形盒子.理解好盒模型能让我们更好的理解生成元素的大小和布局.生成布局的盒子由以下的属性决定\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/705cc/box.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABkklEQVQoz52S3UobQRiGc1VegFDBE4Vqq9Rjr6DQIz30xDsoQknbg0CCFgqKmFIFNdskNhip1F+oFsTEg6wmutn5e2RmXJKupaWd5Zllvu/dl3dnJhNFEVJoRKwccSzdWynDddimVquxt1en2bxCSeM1Xa8RQvV9KxFCkAnblxRKU+SDZxSCCUe+9JzF8gRvi2PMZ4eZWxjkzepTV7O9ROeZJLc9yqfdWbQ2ZJqtI16vDXDW+MKPS0vg+HlVoX6wxsfVLMvF92xWljhvlh/6Pe1Zo8LJxTpLwTSxiLzhu/Vh7DDKToB2S9rXXfa/HfB1p87h91NfNH3gtTbZys4rYnHnDbOfnyCVdBj7GI1BI6Wg02kThi1ubzu9XgIapTTd+Ibl6st+wyGUUkgpfQhjHOmR1Pv7zlB0eoaN1qEztGkspFP8AatVUhGlEyZ7iP7NHqXX6Zq2yWGlmuxhePxwymXHr6f4d84bVU4vNvgQTCNE19/D/PYL8qVxd8f+lUJpktzWCMXdGbQyZKRUj3/jfwHuAf3PF8lVSwfnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"盒模型\"\n        title=\"盒模型\"\n        src=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/00d43/box.png\"\n        srcset=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/63868/box.png 250w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/0b533/box.png 500w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/00d43/box.png 1000w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/705cc/box.png 1071w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nbox-sizing是设置盒模型的属性，分为IE盒模型(border-box)和W3C标准盒模型(content-box).</p>\n<ol>\n<li>W3C标准\b盒模型: 属性width和height只包含content, 不包含 padding border 也就是标准盒模型的实际宽度 = border-left + padding-left + content(width) + padding-right + border-right 在实际布局的时候还需要将margin考虑在内</li>\n<li>IE盒模型:  属性width 包含content, padding, border. IE盒模型的实际宽度 = content(width)</li>\n</ol>\n<h2>布局</h2>\n<h3>Box</h3>\n<p>Box是CSS布局的基本单位.元素的类型和\bdisplay共同决定着这个Box类型.不同的\bBox类型会参与到不同的格式化上下文中.</p>\n<ol>\n<li>block-level: display属性为 block, table, list-item.</li>\n<li>inline-level: display属性为 inline-block, inline-table,inline</li>\n</ol>\n<h3>布局模式</h3>\n<p>在进行布局的时候，浏览器采用一种dirty位系统，如果某个呈现器（需要渲染布局的元素）发生了更改，将其自身或者子代标记为dirty，则需要布局，在进行布局的时候，元素会确认自己宽度和高度.</p>\n<ol>\n<li>父呈现器确认自己的宽度</li>\n<li>父呈现器依次处理子呈现器\n<ol>\n<li>放置子呈现器（设置x y 坐标)</li>\n<li>如果有必要，调用子呈现器的布局</li>\n</ol>\n</li>\n<li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用</li>\n<li>将dirty设置为false</li>\n</ol>\n<h3>布局上下文</h3>\n<p>布局上下文决定在渲染容器中各种盒子的布局方式,主要有以下几种\b(本文简单介绍BFC和FFC):</p>\n<ol>\n<li>\b块级格式化上下文(BFC)</li>\n<li>行级格式化上下文(IFC)</li>\n<li>网格\b布局格式化上下文(GFC)</li>\n<li>自适应格式化上下文(flexbox)</li>\n</ol>\n<h4>BFC(Block formatting context)</h4>\n<p>\b通过为元素进行一些属性的设置,可以生成\b块级格式化上下文,其中的块级元素会按照BFC的规则进行布局</p>\n<h5>生成规则</h5>\n<ol>\n<li>根元素，即HTML元素</li>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为inline-block、table-cell、table-caption</li>\n<li>position的值为absolute或fixed</li>\n</ol>\n<h5>布局规则</h5>\n<ol>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。不与float box重叠.</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h5>作用</h5>\n<p>关于BFC的作用和例子可以阅读下这边文章,博主写的很详细.<a href=\"https://juejin.im/post/5909db2fda2f60005d2093db\">关于CSS-BFC深入理解</a></p>\n<h4>FFC(flexbox)</h4>\n<p>FFC就是CSS3所说的弹性盒子布局. 详细的使用指南可以参考这篇<a href=\"https://css-tricks.com/snippets/a-guide-to-flexbox/\">A Complte Guide to Flexbox </a></p>\n<h2>定位</h2>\n<p>Box一共有以下三种定位方式:</p>\n<ol>\n<li>Normal flow: 包括块级的格式上下文, 行级的格式化上下文, 相对定位的(position relative)的块级和inline-block</li>\n<li>Float: 这种情况脱离了文档流,但是会影响之后元素的content(环绕)</li>\n<li>绝对定位(position absolute): 脱离文档流, 不会影响之后元素的位置和内容</li>\n</ol>\n<h3>position</h3>\n<p>position相关属性及含义</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>absolute</td>\n<td align=\"center\">绝对定位,相对于static以外的第一个父元素进行定位</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td align=\"center\">绝对定位,相对于浏览器窗口进行定位</td>\n</tr>\n<tr>\n<td>relative</td>\n<td align=\"center\">相对定位,相对与正常位置进行定位</td>\n</tr>\n<tr>\n<td>static</td>\n<td align=\"center\">默认值\b,没有定位.</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td align=\"center\">粘性布局 可以认为是固定定位和相对定位的结合.元素在跨越特定阈值前为相对定位,之后为固定定位</td>\n</tr>\n</tbody>\n</table>\n<h3>float</h3>\n<p>浮动是一种脱离文档流，对之后或者之前的盒子中的content flow产生影响的一个属性(区别于定位  例如position absolute 也是脱离文档流 但是它不会对之后之前的盒子产生影响),\b浮动元素会产生一个块级框,即使它本身是一个行内元素</p>\n<h4>浮动规则</h4>\n<ol>\n<li>浮动元素的左右外边界不能超出其包含块的左右内边界</li>\n<li>浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动的(或右浮动)元素的右（或左)边界，除非后出现的浮动元素的顶端在先出现浮动元素的底端下面（防止浮动元素之间的覆盖）</li>\n<li>左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边 右浮动元素的左外边界不会在其左边左浮动元素的右外边界的左边</li>\n<li>一个浮动元素的顶端不能比其父元素的内顶端更高   浮动元素的顶端不能比之前所有的浮动元素的顶端或块级元素更高</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/46e51/float1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA10lEQVQY05WRzWrCYBBFP3BR9z5ki1YQmtRW81NR69JNgw/g+4jvkWzkm5EocU6JaaVdBNoLZzNwL/cyLh88omGIPAXtBCEyGiHvK+RwQFQR7xGRG6pKnue40jn4K50OlCVXVRVcLmDGt+pQx3SKLZfYfN7OYoGlb9hHdjPbT75C66bOBwEkCRZF7cQxNh7DZsNpv0f6fWw4xO4fsNkMO5+bQO9x1X8m93rYdssvz10XylMzuW6o4TOSpkgct5MkyMsrkmXIbodGUXObTJD1+vooPR4pioJPcH1oF5VRdrwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"float示例1\"\n        title=\"float示例1\"\n        src=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/00d43/float1.png\"\n        srcset=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/63868/float1.png 250w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/0b533/float1.png 500w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/00d43/float1.png 1000w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/46e51/float1.png 1003w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里例子中三个元素均为浮动元素,包含块的宽度固定,由于规则2 导致第二个浮动元素bbb移动到aaa下面.由于4的限制，浮动元素ccc的顶端是跟bbb一致的，不能超过bbb或者跟aaa平齐.<br>\n5. 如果源文档中一个浮动元素之前出现了另一个元素 浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高<br>\n6. 左浮动元素必须向左尽可能的远 右浮动元素必须向右尽可能的远 位置越高 就会向左或者向右尽可能的远<br>\n7. 浮动元素与正常内容流重叠的情况:\n1. 行内框与一个浮动元素重叠的时候，其边框 背景 和内容都在该浮动元素之上显示.\n2. 块框与一个浮动元素重叠时候 其边框和背景在该浮动之下显示 内容在浮动元素之上显示</p>\n<h2>居中</h2>\n<p>可以阅读下自己之前翻译的一篇文章<a href=\"https://www.cnblogs.com/tiantianwaigong/p/5291370.html\">CSS居中完全指南翻译</a></p>\n<h2>参考链接</h2>\n<p><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#4_1\">浏览器的工作原理:新式网络浏览器幕后揭幕</a>\n<a href=\"https://www.zhihu.com/question/24529373/answer/29135021\">css脱离文档流是什么意思</a>\nCSS权威指南\n<a href=\"https://www.w3.org/TR/CSS21/visuren.html\">Visual formatting model</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"CSS基础总结","date":"2018-10-18","tags":"CSS","path":"/css-basic","top":null,"summary":null},"title":"CSS基础总结","date":"2018-10-18","tags":"CSS","path":"/css-basic","top":null,"summary":null},{"id":"63290450-7688-5343-b1bc-e0bb0a56cced","html":"<h2>简介</h2>\n<p>事件循环是不同的宿主环境(浏览器或node)对javascript任务进行调度的一种机制,在讨论事件循环的时候首先应该区分node和浏览器(不同宿主环境实现的事件循环机制不同).下面通过介绍一些javascript的基础知识,进而简单的介绍浏览器中的事件循环和node中事件循环.</p>\n<h2>基本概念</h2>\n<ol>\n<li>javascript程序的执行机制是通过栈来\b管理的.当进入一个函数,就创建了这个函数的执行环境并将这个执行环境推入栈顶,执行完当前的函数后,从栈顶移除对应的执行环境,进入到外层的执行环境.\b</li>\n</ol>\n<p><img src=\"/blog/ee34151d44d3f796b1f1436e0926a2a7/stack.gif\" alt=\"stack\">\n2. javascript的执行是单线程的.但是由于整个事件循环的调度,赋予了javascript对异步任务的强大处理能力.对于异步任务(网络请求,按钮点击)javascript代码调用宿主环境提供的api,将异步任务交给其他的线程去完成.当对应的异步任务完成的时候,将回调函数添加到回调函数的队列中,由事件循环来实现会回调函数的\b调用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>marcotasks microtasks</h2>\n<p>将macrotasks和micortasks单拉出来讲解,是因为理解好这点能更好的理解浏览器或node的任务队列.在实际的实现环境中不同的任务可以放置在不同的任务队列中,然后通过对多个任务队列的调用来完成整个事件循环.</p>\n<ol>\n<li>macrotasks:</li>\n</ol>\n<ul>\n<li>定时器(timer) setTimeout setInterval setImmediate</li>\n<li>message channel  (message channel执行的优先级高于timer)</li>\n<li>I/O</li>\n<li>UI rendering</li>\n</ul>\n<ol start=\"2\">\n<li>microtasks:</li>\n</ol>\n<ul>\n<li>Promises</li>\n<li>MutationObserver(监听DOM)</li>\n</ul>\n<ol start=\"3\">\n<li>其他api</li>\n</ol>\n<ul>\n<li>\n<p>queueMicrotask(fn)\n将Fn推入微任务执行队列</p>\n</li>\n<li>\n<p>requestAnimationFrame<br>\n通知浏览器在下次重绘之前调用传入的回调函数，回调函数默认传入函数执行的时间戳.requestAnimationFrame不属于宏任务和微任务，在微任务执行之后执行</p>\n</li>\n<li>\n<p>process.nextTick\nprocess.nextTick是node上的api，具体的执行时机是在微任务之前执行。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVQ4y42T227aQBRF+QwItudqjw12bGyMuQQCCRENtE9VK7X//x+r8uSiRkmkPGwdzRnN1lkzewbKWHTeYos5dTujW9V0q4Z6XhPHCWEYEkXRO33WHyilUPGUpKjJ2xVuWpBVDWlRkkxywiB4o6Cvz2YfmQ6klBTJFCcNURgiTYxU2ktEEUJIdOzQxqJih4kdSsp3Zi9rP6GWirbdUa9vqfcn2rszy8svuvtHqs2B+eEbi/szy4fv1G1Hf+YjXG+otSYMxuTdlmb/SN4sqW6OlMs9Rbcju679lFJZpFSeIhj3+CFBEPrqFT5poLTyaPEkIy0zXJkxbUuS3CFtgHEC4xQ2lWgnsZnGpMrXF/X7QkZE4hlZCIGOIyYzTT43ZJUiKxVZZUgrS1Zb3LV+rUlumC4crrToRL2aSiN6ZEUQRtzXhr+nip93Bb+PBX+OBZdDQ96tmcwaqps7quWaOE3xVEr4Owv+R++Re8MoEuTOcbqcOP04s9jsKNuOax+jkrSYkbcbf7/5fIW1sY/PpznUShEnFmsVUghGwxHD4ZDRaMT46upJoyHjq5FX+GoWvovPoH+5fsrH84bLZcf2Zk5TF1jT9yVKPSkS4ms/pX+Q1CXcrjs22479w579ccf2sGW9W7FoSxZd47P3mcnbHBqNS1KcchibYLMCk05J8hk2nWKtJUliH62vGP4DF253f3L9M/QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nextTick\"\n        title=\"nextTick\"\n        src=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png\"\n        srcset=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/63868/nextTick.png 250w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/0b533/nextTick.png 500w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png 1000w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png 1150w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>setTimeout(function(){\n  console.log(1);\n});\nnew Promise(function(resolve){\n  console.log(2)\n  for( var i=100000 ; i>0 ; i-- ){\n      i==1 &#x26;&#x26; resolve()\n  }\n  console.log(3)\n}).then(function(){\n  console.log(4)\n});  \n\nconsole.log(5);\nprocess.nextTick(() => { console.log('nextTick'); })\n输出的顺序依次是 2 3 5 nextTick 4 1 \n</code></pre>\n</li>\n<li>\n<p>requestIdleCallback\nwindow.requestIdleCallback(callback[, options])</p>\n<ol>\n<li>callback是一个在事件循环空闲时即将被调用的函数的引用，接收一个IdleDeadline参数，通过该参数可以获取当前空闲时间(timeRemaining())以及回调是否在超时时间前已执行的状态(didTimeout)</li>\n<li>options 可选参数 可以配置timeout  表示超时毫秒数未调用回调函数，回调函数将在下一次空闲期间被强制执行。</li>\n</ol>\n</li>\n</ul>\n<p>在具体的实现中只会有一个microTasks队列,简单的理解事件循:</p>\n<ol>\n<li>浏览器或者node会按照顺序执行自己环境的多个macrotasks队列</li>\n<li>每执行完一个macrotask队列就会拿出micortasks队列的任务全部执行，然后继续执行下一个macrotask队列</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1CLID/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRR5Ef/aAAwDAQACAAMAAAAQ48//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAAAATFBEVEhcfD/2gAIAQEAAT8Qy3TXN2M1O2ZJuxz7aIH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runTask\"\n        title=\"runTask\"\n        src=\"/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg\"\n        srcset=\"/blog/static/9a253bb0db2af3498f93ce723c928568/0479a/runTask.jpg 250w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/41099/runTask.jpg 500w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg 1000w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg 1098w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in browser</h2>\n<p>其实通过对上面相关的知识的介绍,已经可以大致的了解浏览器中事件循环的任务队列 主要有以下几种macrotasks队列</p>\n<ol>\n<li>事件callback</li>\n<li>I/O(xhr)</li>\n<li>timers</li>\n<li>UI渲染</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in node</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAACzklEQVRIx5WVC0/qQBCF/f//RQMKUfAJCpIoAYxBBBGjEfABgkApbWFuviHbFCwpt8lkutvu2TMzZ2d3ZO1ZLBbqHceRwWAg39/fav1+X/3Pz498fX2ptyxL7NlM/505jsznc9kBYN14AMtmsxKLxdQODw/l4OBAfTKZlKOjI3l5eZHp1JbZbKbg0+l0CRjG0LZt+fz89BliMMN4//j4kNFo5K+DnQUgA8/zlLbruiugwYdv/LMpRa7rLQH56f39XVqtlry9vfm7MgcLE/7d3Z1cX18rw263K8/PzysbQ0oBf39/5fb2Vs7Pz6VQKMjr66tY1lR6vZ70en2ZTCZSq9UknU5r/vgX0E6nqyB/AAnl/v5erq6u5ObmRobD4Z+wmON7JpNR5ibHoYBGIhQANptyOB6P/RQsx5NwwE1VZhPySehojjySnuAYmYQyDNMhi4rFomru5ORE9vf3VXtYIpGQXC6nRQwFXAflQaxGc0Ed4mFJikjDRsD1cBuNhhYL//j4KA8PD9JsNrXiSIi5arXqy4zibgTkGCEhQj07O1N/enoqx8fH+h70aDISkI+Eg1F5NsB4pxDG+E5qVk5KGCALn56eVMQwoQCpVEouLy+VMYXh1BA2+YxkyO4AYuTM5NB4rF6v65i2FglIxdAZlUQ+sGBh0PONE2QaRmTI+Xze73tokJ5o+iHjvb09LRTAWxUFJrCEISckaMxjMKVYkYAc/E6no5Jot9tSKpWkUqlozsrlsrYuzjXfttIhIQOAAUB1MaqNUX3EzdE0DSOyKGiMpOON7sy9wYbMw24rHbKQ8Eg6zLis0OHFxYU2YpotY1j+tw7RmznPeIw5o0OKtlWVCcd0F3P7UXkKZW4/UrJVyOSHxKNDY/F4XEPd3d3VdzTJlWCagxPF0HTooPZgSUFgjzFnGIb2w033iXlY4HlzcT1PAXh3HFdBl0qw5R8VVUHLG1SyuAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node\"\n        title=\"node\"\n        src=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n        srcset=\"/blog/static/624c9768d8888b109a4649298c0cb091/63868/node.png 250w,\n/blog/static/624c9768d8888b109a4649298c0cb091/0b533/node.png 500w,\n/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>注意点</h2>\n<ol>\n<li>在浏览器或者node中某些代码的执行会导致event loop失效(停留在处理一个事件队列导致无法进入其他的事件队列的处理).比如浏览器中javascript的长时间执行会导致UI无法交互,node中process.nextTick的递归调用</li>\n</ol>\n<h2>相关资料</h2>\n<p><a href=\"https://tuobaye.com/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/\">通过microtasks和macrotasks看JavaScript异步任务执行顺序</a><br>\n<a href=\"http://docs.libuv.org/en/v1.x/design.html\">libuv Design overview</a>\n<a href=\"https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f\">How JavaScript works in browser and node?</a>\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&#x26;utm_medium=email\">Tasks, microtasks, queues and schedules</a><br>\n<a href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\">Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018</a>\n<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;t=55s\">菲利普·罗伯茨：到底什么是Event Loop呢？ | 欧洲 JSConf 2014</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null},"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null},{"id":"70c3382e-a071-5536-a147-725929d63e20","html":"<h2>简介</h2>\n<p>在不同的\b场景下,需要页面实现不同的滚动效果\b例如滚动到最底部、滚动到最顶部\b。以下首先对滚动的几个基本的属性进行\b总结并给出实现滚动的一些方案</p>\n<h2>基础属性简介</h2>\n<p>当元素的子元素比元素高且overflow=scroll时,元素会scroll.此时移动滚动条出触发本元素的scroll事件</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th align=\"center\">定义</th>\n<th align=\"right\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clientHeight</td>\n<td align=\"center\">与元素的高度有关,\b代表元素的高度加上padding(不包括border、水平滚动条的高度、margin),对于inline元素该属性的值为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>clientWidth</td>\n<td align=\"center\">与clientHeight相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetHeight</td>\n<td align=\"center\">与元素的高度有关,不同于clientHeight,它包括border、水平滚动条的高度,\b不包括margin.对于inline元素该属性为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetWidth</td>\n<td align=\"center\">与\boffsetWidth相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>\b\bscroll\bHeight</td>\n<td align=\"center\">\b当出现滚动时,scrollHeight代表元素内容的高度(包括在不在内容区域的内容)  当一个元素\b出现滚动, 它的相关属性 判读元素是否滚动到底部 scrollHeight - scrollTop === clientHeight</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>scrollTop</td>\n<td align=\"center\">当元素出现滚动的时候,scrollTop\b代表元素可见内容距离该元素顶部的高度.不存在滚动条的时候,scrollTop为0</td>\n<td align=\"right\">可读可写</td>\n</tr>\n<tr>\n<td>offsetTop</td>\n<td align=\"center\">获取当前元素跟\b\boffsetParent父元素顶部(position不为static的父元素)的距离</td>\n<td align=\"right\">只读</td>\n</tr>\n</tbody>\n</table>\n<h2>实现滚动\b的几种思路</h2>\n<p>在实现滚动上首先要确定的一个点是你需要知道\b此刻这个元素的子元素已经绘制完成(高度确定)。比如在\breact的项目\b中可以在didUpdate中触发元素的scroll事件,下面介绍下实现滚动的几种方法:</p>\n<ol>\n<li>锚点 通过在页面中设置锚点能在实现跳转到页面相应位置的目的,这种方式也比较好操作.缺点是需要在url中添加其他信息</li>\n<li>\boffsetTop, scrollTop</li>\n</ol>\n<ul>\n<li>offsetTop 可以在页面\b隐藏一个元素 通过获取这个元素的\boffsetTop来设置滚动元素的scrollTop</li>\n<li>scrollTop \b直接设置scrollTop来实现定位 当scrollTop设置\b的值超出元素的最大值(scrollHeight) 会被设置成\b最大值(定位到最底部)</li>\n</ul>\n<ol start=\"3\">\n<li>scrollIntoView(alignToTop)</li>\n</ol>\n<ul>\n<li>alignToTop\b默认是\btrue \b通过item.scrollIntoView()/item.scrollIntoView(true)会\b使元素的顶部跟可视区域的顶部对齐</li>\n<li>item.scrollIntoView(false)会使元素的底部跟可视区域的\b底部对齐 \u001e</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"页面滚动","date":"2018-08-26","tags":"JavaScript","path":"/js-scroll","top":null,"summary":null},"title":"页面滚动","date":"2018-08-26","tags":"JavaScript","path":"/js-scroll","top":null,"summary":null},{"id":"6d00a615-26fe-5d55-86fb-68b1514e2f14","html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收\b事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.\b下面从几个方面来拆分这个小例子来重新学习下\bXMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 \b启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受\b收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息\b,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合\b来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,\b\b顺序对应着请求的方法、地址、\b是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中\b增加query的方法进行数据的发送并且在调用send方法时必须\bsend(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, \b\b注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open\b之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error \b请求发生错误的时候的监听函数</li>\n<li>\bloadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>\bxhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载\b并且可以\b通过download\b进行文件名的设置.\b这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件\b名,这个时候可以通过设置\bresponseType为blob,\b生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的\b时数据\b上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress\b这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload\b.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么\b\b\b上传阶段完成是\bmock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的\b切分\b上传阶段和\b数据接收阶段的比例来完成\b对用户接受更合理的\b进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>\b作为一个web前端开发者\b离不开\bXMLHttpRequest的使用,以上通过\b对xhr基础的介绍和自己在项目中遇到的\b问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null},"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null},{"id":"ee07b2ad-54b7-5c32-bd80-53dd6ae5afc3","html":"<h2>简介</h2>\n<p>在看深入浅出node.js这本书的过程中,遇到了几个容易迷糊的\b概念,例如阻塞I/O、非阻塞I/O、同步、异步。下面主要从I/O模型上对上面的概念进行理解.</p>\n<h2>基本概念</h2>\n<p>I/O复用指的是内核具有当进程指定的I/O条件就位的时候通知进程的能力.</p>\n<h2>I/O模型</h2>\n<ol>\n<li>阻塞式I/O 在发生系统调用(I/O)的时候,对应的系统调用直到相应的操作完成或者错误时才返回.(例如在进行网络IO时,需要等待网络数据的就绪完成读取才会完成系统调用的返回)</li>\n<li>非阻塞式I/O 进程可以把一个套接字设置成非阻塞模式.这样当通过该套接字进行相关I/O操作并且需要进程进行等待的时候(例如通过网络读取数据,但是数据并没有就绪的时候), 内核不能将该进程投入睡眠而是返回一个错误标识(轮询)</li>\n<li>I/O复用模型 通过select或者poll来对多个相关的描述符进行监听(此时进程阻塞在select和 poll的调用上)),当描述符状态就绪的时候,返回可读条件然后在通过系统调用来完成对应的I/O操作</li>\n<li>信号驱动式I/O模型 通过开启套接字的信号驱动式I/O的功能并且添加相应的信号处理函数,当套接字准备好读取的时候,通过信号通知进程来完成响应的I/O操作.这种模式进程是不被阻塞的</li>\n<li>异步I/O模型  通告系统调用告知内核相应的操作,然后内核在完成相应的操作后会通知进程.这个过程中进程是不被阻塞的.</li>\n</ol>\n<h2>同步VS异步</h2>\n<p>同步,异步的概念区分上在于实际上发生系统I/O的时候,是否会阻塞进程.因此上面的前四种模式都是同步I/O,只有最后一种是异步I/O</p>\n<h2>select</h2>\n<p>int select(int maxfdpl, fd_set *readset, fd_set *writeset,fd_set *exceptset, const struct timeeval *timeout) 该函数允许进程指示内核等待多个事件中的任何一个发生,在其实一个或者多个事件发生后或者经历了一定时间后唤起进程.该函数的当有描述符就位的时候返回描述符的数目,超时返回0,若出错返回-1,下面对主要的参数进行分析</p>\n<ul>\n<li>timeout 告知内核等待所指定的描述符中任何一个就绪所花的时间.\n<ol>\n<li>当该timeout结构的代表的值均为0的时候,表示无需等待直接返回</li>\n<li>当设定一定时间的时候,表示当select返回的时候,不能超过该时间</li>\n<li>当设置为空指针的时候,表示select会一直等待直至有响应的描述符就绪</li>\n</ol>\n</li>\n<li>readset writeset  exceptset  表示让内核检测响应的读,写,异常描述符,当有响应的描述符就位时返回.</li>\n<li>maxfdpl 指定待测试的描述符的个数</li>\n</ul>\n<h2>node如何实现高性能的异步I/O</h2>\n<p>参考自己之前整理的一篇blog<a href=\"https://www.cnblogs.com/tiantianwaigong/p/6234961.html\">node的异步I/O</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null},"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null},{"id":"a9b0d541-f9ec-5cf4-93b7-812c9ac0b32f","html":"<h2>简介</h2>\n<p>网络套接字是应用层和传输层的桥梁。套接字提供了应用层与系统内核的交互的能力来完成数据的发送和接收.下面主要从套接字的几个基础api来介绍套接字并且结合tcp来理解网络应用对外提供服务的整体过程.</p>\n<h2>基础api\b</h2>\n<ol>\n<li>在使用套接字发送数据时将数据从应用进程的缓冲区写入到套接字的发送缓冲区，来完成数据的发送.</li>\n<li>通过对\b套接字函数的调用可以获取套接口的一个描述(一个套接口可以对应多个套接字描述),当内核中不存在套接字的描述符的引用的时候,内核会触发该套接字的close.</li>\n<li>基本TCP客户/服务器程序的套接字函数调用过程</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB6klEQVQ4y5VT25KiMBD1/z/MB6t884qgYhEFBJKQK52kmdJMMe7s1K5zHqhKyOk+fbp7Nr6Nvu/X6/Vut9Nax5vZm0xEFEKkaVqWpbX2/2REHMeRMZYkyel0EkJcLpeyLIdheDczPhFCkFKmaZrn+VuZXxFCMMYQQuq6BoBf18w53+/3RVF8NwwRlVKTnm9lRwDA4XAghEz3syipbdvdbne73SZJPzq3WCyWy6X3/iuz955SmiRJVVVCiBCC9x4RrbX3+905h4j+CSGE1nqSM4uBGWNpmrZtG9tojPHeE0Lm8/l2u7XWaq1jrCjtUzYitm3bNE2apk3TaK3DE7GllNJhGKZUxpjJrQfZOSelVEp1XSeltNYCgDGGMdZ1HWMMAIZh6Lquqqrz+VxVVV3XUsoHGQCcc+M4/m31q2HOOa11lmWEkBgdER/kWMY/yNOcZFlWVVV8HEL4JMduvZbHGMvz/HK5aK2998YYSunxeLxer5xzKeUjs3Ouf2K/30e3o7HGGCllLCp+h2EQQiil/hjPEELf95vN5n6/x3+ICACU0q7rXntjnvhyO5KVUnVdc86NMQBgreWcE0Ji8wGg73tKaVEUcWx+txha67Zt42JzzgHAez/7cQemNY6Ix7IsV6tVkiRFUcQR+AAp44e3Q8OxXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"套接字基础api\"\n        title=\"套接字基础api\"\n        src=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n        srcset=\"/blog/static/488016f75fa3e6b554b97157803a13e8/63868/api.png 250w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/0b533/api.png 500w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>socket(int family, int type, int protocal) 默认产生一个主动的套接字 其中family字段指明协议族如Ipv4\b,Ipv6等\b, type为套接字类型如SOCK_STREAM(字节流套接字), SOCK_DGRAM(数据报套接字) \b\bprotocal指的是由前两个参数决定的\b协议说明 例如tcp传输协议  UDP传输协议</li>\n<li>connect(int socket, const strcut *servaddr, socklen_t addrlen) 在TCP套接字\b状态下调用此方法会激发TCP的三次握手.几种常见的网络错误也是在这个阶段出现了\n<ul>\n<li>如果发送了SYN,在经过TCP的超时重试之后仍然没有收到对应的ACK,此时显示ETIMEOUT超时</li>\n<li>收到RST(复位) 通常对应的\b对方没有正在监听的服务器、TCP想断开一个已有的\b连接、TCP收到一个不存在连接上的分节</li>\n</ul>\n</li>\n<li>bind(int sockfd, const struct *myaddr, socklen_t addrlen)  将一个本地协议地址绑定到一个套接字\n<ul>\n<li>在\b绑定地址\b上,在服务端上的\b\b一般都绑定到特定的端口 对IP地址进行0.0.0.0(INADDR_ANY)绑定(为了处理服务器有多个网络接口), 最后由系统内核指定IP地址  在客户端一般有内核指定IP\b地址和端口 \b</li>\n</ul>\n</li>\n<li>listen(int sockfd, int backlog) 将一个从主动状态转为被动状态,指示内核接受指向该套接字的请求\n<ul>\n<li>backlog参数代表着未完成连接队列和已完成连接队列之和.在正常的三次握手的过程中,一个未完成连接的条目存活的时间是最后一次客户端对服务端ACK的确定(RTT)</li>\n<li>设置成\b较大的backlog是为了扩大为完成连接数目的队列.当为队列数目是满的时候,TCP会忽略该分组,这样TCP将重发SYN而不是显示连接错误等</li>\n</ul>\n</li>\n<li>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) \b从已完成队列中返回一个已完成的连接\n<ul>\n<li>\b区分监听套接字和已连接套接字  监听套接字在服务器的整个生命周期只存在一个,连接套接字是为每个接受的请求都会创建的\b</li>\n</ul>\n</li>\n<li>fork 创建自身进程的一个副本\n<ul>\n<li>fork的调用会在父进程和子进程中进行返回,通过区分返回值来区分父进程和子进程</li>\n<li>子进程共享共享父进程fork之前的所有描述符(注意在fork的时候\b关闭对应的\b描述符)</li>\n</ul>\n</li>\n<li>int shutdown(int sockfd, int howto) howto指明如何关闭改套接字是关闭读的部分还是写的部分,这样能防止关闭套接字时候无法处理到达的网路请求返回数据</li>\n</ol>\n<h2>相关参考链接</h2>\n<p><a href=\"http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html\">tcp backlog</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null},"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null},{"id":"b34d966c-2fd9-5dba-a9cc-0f796cfe9c0a","html":"<h2>简介</h2>\n<p>通过对运输层和网络层的基础知识的学习,了解到他们分别提供了基于主机进程间的通信和主机间的通信,这都基于数据链路层实现的上述功能,下面通过对数据链路层的学习来了解数据是如何通过相应的数据链路来实现传输和交付的</p>\n<h2>基础</h2>\n<p>1 在通信路径上连接相邻通信节点的通信信道称为链路。链路层协议将网络层的数据报封装成链路层帧来实现数据在链路节点间的移动。\n2 链路层主要提供的服务有数据报的成帧,链路的接入(无线链路,有线链路),可靠交付,差错检测和纠正.链路层的功能主要在网络适配器(NIC)上来实现相应的功能\n3 链路层通信通过MAC地址(LAN地址或者物理地址)来实现,所以一个通信的具体过程会涉及到三种地址:</p>\n<ol>\n<li>主机名</li>\n<li>IP地址</li>\n<li>MAC地址</li>\n</ol>\n<h2>地址解析协议(ARP)</h2>\n<h3>ARP的作用和寻址过程</h3>\n<p>ARP提供的是同一个子网和路由器的网络层地址到MAC地址的转换.主机会在内存中维护一个ARP表,这个表保存着一定时间内该子网内主机IP地址和MAC地址的映射.当目的主机的IP地址在ARP表中时,发送主机通过封装链路层帧目的MAC地址为保存的目的MAC地址将数据推送进数据链路层.当ARP表中没有响应的条目的时候,发送主机通过MAC广播地址发送APR广播分组,这样子网内所有的主机都会处理该分组,符合该IP地址的主机会发送ARP响应分组,将自己的MAC地址通知给请求发并且更新请求方的ARP表</p>\n<h2>以太网</h2>\n<h3>以太网基础</h3>\n<p>以太网是基于之前的各种协议实现的一种局域网技术,它提供给网络层无连接服务.</p>\n<h3>以太网帧结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 884px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVQY0z2LTUvbYACA80PEHzC9CLrLKlLGDuJgpTI3vzpE2EUZyHbRIt5kh6FsggeL2po0PSiryeL7NhVddVK1TWcjJbXWFisxpB9C0tqlJjbv0E0fntvDg5mmiRBSlUr27DyTzpbVa4RQWa2kkplqtYYQusv3mA8+gkmiVJALSkkVc2IumytIRVmSxXMpk8rqNf3fdFUsyZeyWf8/GrqRlwpaVcMOufhxIq1UtJKqXpXL+aKyuxdJZy5EOV+rm9c3xs2tKSTP4ryg6beabvwx6mpVi0bixZKCPaUTnZunjgDXQfNW6miQjVlgygZiL9bCr8FRZzBlBUL7hmBhEh0waYVCFys4AlzbOj8Vu8AmmajNz7W6wccNboyJWtxwiuXH/L/mNw+ee7efeMPTW8euHd61f7IQijsB1+zbf0kEvgR/fw6fYv1L4JkLNs3gvR7Y6wYts95hcntg0T9OMq1zqw1fqdHVkPP7Tye9N7G2NYSzjd+o9jlv9yL4BCNY1zLT5wuOkvQbAr4l4AhJ2wh2iPjhwKn3JDPgC3bj0L4C7B7GvgJ6cPiOhB981KtlaiYU/Qscvja2c8oD8QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"以太网帧结构\"\n        title=\"以太网帧结构\"\n        src=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n        srcset=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/63868/dataLink.png 250w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/0b533/dataLink.png 500w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png 884w\"\n        sizes=\"(max-width: 884px) 100vw, 884px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>前同步码 主要用于在发送方\b和接收方进行时钟的同步</li>\n<li>\b目的MAC地址 当接受方收到对应的链路层帧的时候,当该帧的目的MAC地址是本机的MAC或者是广播地址的时候,数据字段的内容就是向上传递给网络层进行处理</li>\n<li>源地址 发送方的\bMAC地址</li>\n<li>类型字段 用于与上一层的某协议相结合</li>\n<li>数据 网络层数据报</li>\n<li>CRC 循环\b\b\b\b冗余\b检测用于接受方检测是否存在差错</li>\n</ul>\n<h2>交换机</h2>\n<p>\b  链路层交换机主要提供转发和过滤的功能.过滤是\b\b指决定一个帧是否被转发到某个\b接口还是将其废弃的功能.转发指一个帧具体应该被转向那个接口.</p>\n<h3>交换机的转发过程</h3>\n<p>交换机通过自学习的特性定期的维护自身的交换机表.表的条目分别是\bMAC地址,接口,时间.当交换机收到\b一个\b帧的时候,会\b根据该帧的目的地址做出不同的\b行为</p>\n<ol>\n<li>如果交换表中没有该MAC地址的时候,交换机就会\b向它所有的\b端口转发该帧</li>\n<li>当交换机接受到该帧的端口MAC地址和目的地址\b相同的时候,丢弃该帧.</li>\n<li>当交换机表中存在相应的条目的时候,将该帧转发到相应的端口</li>\n</ol>\n<h2>web页面请求的详细过程</h2>\n<p>\b可以结合前两篇来\b理解这个过程(DHCP HTTP  UDP CIDR IP \bMAC(ARP))  里面涉及的编制 寻址 传输等相关协议</p>\n<h2>思考</h2>\n<ol>\n<li>网络协议虽然是分层的，但实际的实现上层与层之前的界限并没有那么清晰,不能割裂的去学习网络协议模型,要从整体上理解网络协议的\b\b整体过程</li>\n<li>在具体功能的实现上,例如数据链路层\b通过MAC\b地址进行通信而不是依赖网络层的IP地址,这样就能使\b数据链路层与其他种数据格式对接,增加独立性</li>\n<li>\b层与层之前的功能不具有强依赖关系,例如数据链路层是能\b够通过CRC循环冗余检测来实现\b\b\b差错检测和恢复的,网络层自己实现了本身的差错检测,在实现一个大型的系统的时候,功能到底是依赖于\b上层还是自己去维护(稳定性)都是值得考虑的点</li>\n</ol>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null},"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null},{"id":"c483d85a-973c-5c8d-a0d7-764a27b93895","html":"<h2>简介</h2>\n<p>\b在\b初学node的时候,都会在\b学习到下面的这个例子:</p>\n<pre><code>const http = require('http');\nconst server = http.createServer(function(req,res) {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('okay');\n});\nserver.listen(8080,function() {\n  console.log('server is on');\n});  \n</code></pre>\n<p>上面的例子就创建了一个最\b简单的web服务,当通过浏览器访问本地的8080端口的时候页面就会输出okay。下面主要从两个方面来理解node如何加载和运行这段代码来提供服务的。</p>\n<h2>nod\be代码结构(基于node V6.11.0)</h2>\n<p>\b下面就是node的代码结构,在lib中主要是\bnode提供的标准库(例如http等模块),在src模块主要是node的入口文件和node提供给lib的C++接口.在deps中主要包含了DNS解析,http解析,事件循环\b和跨平台的异步IO的\b实现等.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 932px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABB0lEQVQ4y62STU+EMBRFWasLE93KAKV8tDhAS9FAYTIMBtf+Aifj3v+/uqadxGh04XRcnDT9yMm779XLshxaa/S9RpKkoDRxgpAYnBfwzKaqakzTDmmaIQwj+yCOqcVJ2DQK2+0EISTW6/Ik0Q+hiVnXAsMwYlmeoVRrL8+KLIRA1/Uoy+oz7tfVKfI8P1mhi+yXCiXa9sH271+mrJSyMt9ffZuuc2QpGzsUrQfbS/N9zoicQsgGfT+AscJizmJT4R85CulRyLMMQ9fhnjOQIACNIiSEnEZMQKMQBcvh0eoRzWZBwCV8JrBy5C6vYVzezfyG9OUd19MBl+MrrjZ7Jy7GPW53B3wAKwuBpW1A2esAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node代码结构\"\n        title=\"node代码结构\"\n        src=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n        srcset=\"/blog/static/38795164842a3beb02db9ed01e44311f/63868/nodeSrc.png 250w,\n/blog/static/38795164842a3beb02db9ed01e44311f/0b533/nodeSrc.png 500w,\n/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png 932w\"\n        sizes=\"(max-width: 932px) 100vw, 932px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>node如何加载我们的代码</h2>\n<p>通过都是通过命令行 node server.js来启动一个简单的服务,下面来简单的看node如何\b加载和执行\b这个server.js文件<br>\n在node的启动文件src/node_main.cc中有如下\b这段代码,\b它调用了node.cc的node的\bStart方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABG0lEQVQY032QW27CMBBFs44SE+dhk4Q4YAenBIIoffFH1Q10/7s4VRxRqf3ox9Gdq5k7I00k1ZrWd4wnh2oc286z6yxp7ShbyzDs8d5TVRWJTEiSJctkOetyroOXs48SKZGFpNwW6HYip+4UK5MFKqso6hTVZKGnTY5a55RbxWpTUFqFbvKQV+uMSEqJdTV+aHF+y+PBU7Y1WbNBGYuqNafLkd3eYeyaXKXILCFTkrxMA2khg58IC5/OPa8vA+N45Pr2zqGzbPoL2p3RuuLjdmMcT3TeMc3HsUDEIui9vhPJVGK0waiWbmfoe8PX1fL53OH7R5qmYT/s0VoTx/H8t3+ITGlwtSVN0hAQQvCwECymi+I3U+Cv/iDmhd//Pa9jeahOZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"main\"\n        title=\"main\"\n        src=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n        srcset=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/63868/nodeMain.png 250w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/0b533/nodeMain.png 500w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在Start方法\b先对平台进行了初始化操作 主要关注下面的代码<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVQ4y5VUbY6bMBTMLbbi0wYCBtuYGBuyCWxIVlWlXqA/ev9zTGWTRNlmW2l/PD3LFuOZeYM3QgjM84TpeMDr64j9fodx7GCMhLUGfW8wDAP2+z2UUhisBWMMURQhSZKn2nBewfQSvS8BY1owVoGQFJTSe2VZBkKIX6dp+gEkjmNfHjDNKmRlg6auIYT0t2d5hjiKEIUBojBEGAYIgwBhGCKK1orjyLN0e4/Am4o1aLhE27a+hOCoawZabJGVa89LhrKskOcFsiz3ndIM2+0WVVVdGV4lZ5Si19p71XUdrLW+s1ZDmAMaPUDYA6Z5wvvlDafTEfN8wPnyhmEYvafOgrtk58ttw3W/ThIQv06QXqUYs8PhYNDUBRjL0ba19zMIgrvcO6A7cACPphNCr+v1Qr57RdPPyLlFKQxS1oFUClKPsMZgHEfkeX5lSCiSK6ADSh/AbwpcdKZpwnlZ/P4/Y0MoQUkT5CS+Azn6N6BVTgJrB5zeTricz56N1hrO/5vUW3Q2NKP4dZH4/dPi+48T5sni/f2I83LCspyxLG4QM5ZlRte1Po9uuq4/DuPO0B1yLiDlGp2iKPyU21aiU2uXkkGpGkoJb4nL3mOYH0E3Utbouhq7XQO949gWW7y8fPPTC32o1wCvIY6eGD0xdIykFF6OY8M5gxAMVVUiSdJPjf8b5EmyUh3cI+H+krZlnq37W1xk/vfxp4BN2WDgFoop/5qoTkP3wwewr4BuHLNxGH25x6HgGkwfkRelfwC+ws4B/gFXCsyHoBFOiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"init\"\n        title=\"init\"\n        src=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n        srcset=\"/blog/static/8b7bf7989faf13dade451e000d201e37/63868/init.png 250w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/0b533/init.png 500w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这创建了一个node的实例\b并且传递了一系列的参数(v8_thread_pool_size uv_default_loop 后续会对这些参数进行讲解) 最后\b调用StartNodeInstance开启了node的实例,然后顺着这个方法往下走发现node继续这行了LoadEnvironment()和下面这段代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmElEQVQoz22R227iMBRF+YtpCSQhsZ2LE99iQoBQOmj6/5+0RrhSpen0YWmf87C395E3tajx0RHPgbh4/GwJJ8dpPWKmnuXmmM+GMGviMnL7PRFPPs3LanFRU6kyIfuKTVVVtG1H23RIoRC1RIqGRikaJRh0g7WaQXeM4yezM1y8YXEj12Dxg0ZJRbbN2MhacD1feH9/436/8XisfHy8sa5HrutMCCPGarR+8gx/hvZpb5oGY0aC97Rty36/Z1MWJZdz4PHnwvV65BgNMfpkMMYyDCN5XqTXs2xHtt2RZVlit/t3zvP88+TyUFDJA/t8z6+XF16320S227LbZxRlTl7kSYuyoCjLZP5OaqiUYL1HjufAss4s68Tl7jldHPEUUJ1E9QLRVMiuTnslqmT+KXQjhCBOE8F/Yo2jazumEPAuMA6Wvu2wpqfvNc46pJDJXBTFf2zKQ4nqJY1WNMNTJbITiUYLulHSGYVsBVJUHA6HH5t9NazrCucdU5ywzuK8ZTQjve4xbiRMOv2yMZppGlBKfZ371O/8BY6zCINLY+oYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"exec\"\n        title=\"exec\"\n        src=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png\"\n        srcset=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/63868/execNode.png 250w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/0b533/execNode.png 500w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png 1000w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这段代码拿到lib/internal/bootstrap_node.js文件,将它编译解析并且转换成C++的函数最后执行。\b在lib/internal/bootstrap_node.js中其实就是一个匿名函数<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADBElEQVQ4y52U247bNhRF/RuJdaMkSryKulu+jO2ZuE3TvhT9/39ZhRV7ggkCFOjD1qEAYktrn0NuqlLSeY91Gjf1+MOC2020y4hpFKLMEGVCLhMKmRJtt0RRRBzHJEnyXp/aZGVFNR5pTm8080J/ONKeLoy3v+iWmet15HDes5vHVbVxlEXxS7PVUBQlOoyopke3A9Y5pDLodsR7RRsMJvSoZqD2HaZp0br+bpj8MHyab1JRkEqHChO6nZDKYoY9bn5B9Qest4yDwSrJqEqsLEjT7B07juIP+Js0u2ckyCvxyCtdVdSCLE/fJWRGIcWqUufr+33/fd+HPywyQRM62ssXmt2B7uVCd/nC8HYjHK+E3R7fNmscrg2r4d3s+aFcZj8hJzG5GZDtCeVa+tON/vqN+es/hN2Jy3ngeBgYrKaxlih6YiarogfyB8PCT9TDET8vDK9f2f3xN/3lhh8Xltcby+0bflgYx0DXGZwq6VVBWxfMtqbVFZWUjwzTlLyqkc6g+4Cd7h3XqNCRS0VdlTinMKYmBI31nsoFKutRLmCMJkvTH2OTpglCd6jhSDhcafdnwjhx/e3C8brnfB6YDgfm6xvLaWFsG8ZxRvmOQjtqVT/QoydygrQGN/fooLBjS7MfCYcdzRLwTU3fe3TTkusGpSTBVxhZUGcJeZqsgy6EeCCvhhbdt1RWrcMrTUCFkbI2aFXRd47aWIraonS9RqBKiSpyylxQ/GyoQqBZJtzQEE5nXOdY9h437fDzRCYSkmxLJrZE8ZY4jUjyiG30/VxHa92u6GuGubJUQ4scHfUc8NOE7nu0t/hlwc076qYhHF/QbYcd75Gc1uNZGY+oHMY1a3M294fpF9zhjWbsmI8TTdeTiZIsu5+eilzWJGm2dj0vK0Qu17UoJFlekGY5eVE+LgchEGlCsv1EGkfE289sP396INyHePu+jh6I8QMzfqzj+FljNmUpWE49tz9vvFwXTq9XjA/co/jV9fRf2lhl+P10w40H8tpQNQPKtwiR/S/DfwGj6A9fBUsu3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runCode\"\n        title=\"runCode\"\n        src=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png\"\n        srcset=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/63868/runOurJs.png 250w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/0b533/runOurJs.png 500w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png 1000w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png 1058w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里面先做一些挂载的操作(例如给js调用C++代码的挂载), 然后从命令行中获取到文件的名字并且读取文件进行warp,\b这个函数会被上面提到的\b位置去执行,这样node就加载并且执行了传入的server.js文件。</p>\n<h2>http.createServer()如何对网络请求提供服务</h2>\n<p>通过对上面代码的理解,node对网络请求提供\b服务其实是通过lib下的基础模块调用C++模块的代码来实现的,下面跟着http.createServer()来梳理下这个流程\nhttp.createServer(requestListener),它通过调用_http_server.js下的Server(requestListener)方法创建了一个net.Server(继承EventEmitter)并且将传入的构造函数绑定到request事件同时绑定了connection事件<br>\n上面的\b代码部分主要完成了一个server的创建.最后\b调用listen()方法的时候才能监听器对应的\b端口来对外提供服务.server.listen([port],[host],[backlog],[callback])其实调用的是net.Server的listen方法.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 895px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVQoz12Ry27bMAAE/R2NKPH9EEVKtBXbcdQmaeuc+/8/M0WMoKhzWOxtMNjdDcOAdZrDmpn3jTgf8ClRz9+Zt9+4OOK8xTtNLDPT44WyXrDWIISg7/t//ZGdUorRjyST8NphfELFivQTMUVicBjrkL6g4ox0GWstD113A32F7qSSjGGkhILXhtA20vYHt38hn35Sjm8sx43ltFHXjWU58LQUWnQEa2/wO0MpJZ3oEFLQdd/Q0x6/vqFiIZ7fcY9XyvHCus7MS+UwOq7HyuOcyVNGyuEeOAwSFwxln6gtUFogtcq0JlyWSPWAsgPK92gn6GWH8hIdFL4YpPkCFKKntcz79YkfrxdOL6/Mz7/I7YxPE6G02wEhV1I7MS4rxhhE97Fff0vfi8/+NNRakbMnpISJmUEZBu2xccTnijEalzKh7om1obW+s/rf8C9CdsvY254TIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen\"\n        title=\"listen\"\n        src=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n        srcset=\"/blog/static/ed775f0f74eb21887b354475a2e11427/63868/listen.png 250w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/0b533/listen.png 500w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png 895w\"\n        sizes=\"(max-width: 895px) 100vw, 895px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在net.Server的方法中主要对参数进行了判断,例如是否存在IP,port以及是否传出handle,通常的调用方法都是server.listen(port,callback) 这样会在特定的端口监听来自IPV4或者\u001cIPV6的网络请求,在listening事件触发的时候响应callback.下面在继续跟进listen\b方法.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVQoz5WS246bMBRF8xmTcLExBgMGnAAhhHQ6N0XtSJXax/7/j6wKMmmbTKRpH7bOkeWztbyPF3GSUjQDtukpMoN1DbYbKVyLlPIkIRAiJAxDhBBzDeeztz4815BFJCPSWJNaR5xXxIkhLdfEccy6NlQ2odAKZzQm0YRhQBD4BEFwU4tYKkxmyZseWzvc7oBtBxKTka9binYgL2uUUicqGSGEfJOYTc50M+H0nLo9MI4jPx8zjk8D7v5I2Wwpmh1lt8ftH7DdnqzaUEzRbHpM6UhNhu/7l4YqVmQqxeqMwFuxvLtjtVzOF33fI/C9uT+TXBBd0Z0MVYzUCVJF1HWJcyW5tajEEEXyYvhWZufzP0tRiu7lG/3LK8+vXzl+/0G3P6B0Om/3muBa7zKcgq36T1S7zxT9PTqv0HmJzibK9N3AR5oN3eGZ9uELxbohyS2m3mCqDUlWzF/kvwynnKrtSL0dkMLH91Z/yfv9rH8lXURSopOUKcvrL3Aro48MfwFwaTboCCOYlAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen2\"\n        title=\"listen2\"\n        src=\"/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png\"\n        srcset=\"/blog/static/5940d58735192e92131a71aab4c797d5/63868/listen2.png 250w,\n/blog/static/5940d58735192e92131a71aab4c797d5/0b533/listen2.png 500w,\n/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png 1000w,\n/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png 1116w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n继续跟进_listen2\b方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.39999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVRIx41VSXLjRhDkMzwigN53NDYCILhqGStCHvsL/v8z0tHNkUYaUbIOFQAOncjKyspe2bFFt5vxcNjix3nG7ejx748Ju7GB6g6w/R6buyf0pz9RjzvE+YTu8ID++B2+m2CbAX7YwtQtlDFYacURG4uNrXAKBYxREHUL6Tx0cFDWwsSYSzl/eXoPaRQYJyjLNYr1GmVR5FoRTkAVAXUca8NBDINwBMJTiMDALYVwFNwSSEehArtUzWEaCek4yrJCVV1qpbjEME2Iw4iH8w63uxHBaSjJ4LWElhxWCzgtwThDRSoQSnI9vyegsiwvgFpp3B8OmIceT02Fp44iaAmvBHqnEY1CNBLBKFBK88Fr9Qy6Yoxh6CNisLgPJe5qAiP5C2jnNIQQWCeNfh68Vi8MCWUgykO5GkwaEBVQlQWK9Q2KoshAN+sCxRtGFapXzF7XKrWhhYJretimRwgB0jUQNsKkSUuBxipYnabKfzH6gOmKEgLjasT5gGEecTxOmHdbLIctlv2UWx/6DZphA+M9XN1c2H0ESCiFoAxCaFTSg+oArgwEo2i1yAwrQrFOXntuufqflhnjGB/+Rnt8ROxnTG1EbTUUZ0gdEELeHvyMYQLkXKCdT2i2R7h2QPQ2MyuK97b4aMqvAAmkVNifntAvZ0idTC1RVeQNwFfAXgC5EKi3J8TlDN9P8N4h+fMrIOVv7a845xfjfvsD65tvKIp19t9X2Fxjv2KUIe2z8jWUNmDSgnKZQfPfiyL/5DlNytfvV/TNPtSuzq12bcB22WAzthiGGt0QEcZ9zjxTd9ChydnnhyUPz4aYXVCWxatdTpsiDYTrIHwLG9us4RA0pmhgnYWQAnlFqwpJomQzJiQoY0g+Jj9D44WhtBFh94A47THNHU63W5zujjjfHbA7LuiGHmGz5C0ZnIaRAi6ldLysq3EhS3DZFELgXcQy3SF4B+8EfLDQsYcKLZSPIMJCGA/t66vTfxNfydRcubxuyjcgLH3bLP4lcdY5fZ6/Xx++lomrZBnCVQbJEZZspA2qqrzE181Nrgz8icl/aSgMuPYwSYvYIQxb1Jsl69P0G5wff+D8+BeGeXnR6dNNYTpANzPa4wO6/T26w32+Hk07QxubB5EqefSjzXljbMIlmHb5vrCGo20sqPSQrobtRgjtYLsJ2vk3Zr52n1w0ZBI2tDA+QAqWbzbKOLiU4FLkPU+eS9omH1YpzijL4UEIfc+QMwHTLQj9iH7TY7ttcdx3mOcWm01A0zUQ2sJJhsZIaJ+2ZwcdInw3vrPRijAGUU+ol1uM3/9BN24wzNuckcVvN135TrP3OfkfVOAewXaWNUwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"handle\"\n        title=\"handle\"\n        src=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png\"\n        srcset=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/63868/handle.png 250w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/0b533/handle.png 500w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png 1000w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png 1171w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在这个方法中主要创建了一个server的handle并且绑定在之前传入的port并且在这个handle上添加\bonconnection的监听函数并且在nextTick\b的时候触发listening事件.createServerHandle其实做的是调用的\bC++层的接口,创建了一个TCP\b实例,并且将它监听到IPV4或者IPV6端口。\bnode处理网络请求实际是通过触发这个handle的connection事件实现的\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 944px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVQ4y4WUWXMaRxSF+RMJzAKzz3TPwizAsAmQwUJCyJJdseUtdvkhVXlO5Q/kn3+paWwsx0J5uNXT25nb59x7Wp7M8fM5opxyv+nz+SLm41rychkjspJAxKT1GcXZhny+Js1LbMui2+3S6/V+ipbt+vj5jHJ1yWDxjHxYUy4uyQZjoqzAdhx10LJsepb19WKXbrf3OKBlOziBJIhT/CAgSjLivERkBSKvsG1bZfPfaEC/gTzMtuU4NotlxbCQ3BVdPtY93g90bssevueqw5b1eDYP4xtoy7EdfMcnjBNCz8XtGThNWCam2UXXDTTNUGMTpqFjdrvoholhNmfMI1gzthzbJkkrqsWaejIgTSRJ6BN4LkKGlGXCYJhRlTF5kREmfbVXyIC+CIki8WOGPauHlBnTasGwLAhDHxl4+K6jvpMkIs2EGmUs8EWM6zjqp8L38Hwf6yiW4tBRB0xNw9B0tE4brdNB1zronQ7tdodOu1nT0Npt9Pavak/TNDRdV9+GutvB0DVaruMSeRGiUTavSAZT4mqMKGpEPiQvCpJyRJhkiHxAOpohqxrRzJMMWQxJBmOS0Yy4rGnZlo2Ufepn14zW1ww3N1TTGfPVjEE9URx5YROReq4vErwoxvUDvCYieViXqVpvWbaFCGPG/Slp3MdyXVV7nmth25ZS0TQMTNM4jI3Kam5+31Nrh1B16Ng9Ou1f0LX2YUM/8Glq+skWOxUt23FxZIG7eYN79QlPpATZCHdQENQVURQdfmIadE3zWCIne7npAlGMGN68J13tyGdrytWO6vme/OwcP4xw/BA3iHA8/wHQCcBe1yRIcsbbOxWT3W/k0xX9yYrybM3g2U6tTa5fUy0vVM09RUOrqcGqnij5D2oluI2qkUCkfcK0IEgygjhTih6ebP5kCkfARvr9/SdW272qv3K5JZAJ9WzB/v4zxWiKrCaq/oJQ4MYVfiiOfD7CoaV8zrLt76NyGBvb9bBth8biLMf56omHc6cN1nGUkfqRVJ3QdEfzfCljGn4f88KH7vIToB+E3P/5F7e//0F1fqVE6A/H1OsdIklVuXx7xY+XT2Toeh7bV+9Ybm8IkgJRjnE9n7A/xAslhq5jGIYyCl3Xnszu6NhVFVMWUnlfWcTUoz5lGTOblQwGKePJiMXFnsniHOsJsCPg9W7O7e2SzWbMze2KF7cr9i+WvH235XI74uWbO778/Q83r99jW/8D2IiyuTxne7Xg8nLOcl6xez5lvRxxdTHh+e6CVx/ecffhC9uX98g4VryeBGxEabhLs4Q0FUjfpR/5ZKGPb/eo5muW+zcImXzlsPckh/8C/oPY8Ao+dPAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"connection\"\n        title=\"connection\"\n        src=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n        srcset=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/63868/connection.png 250w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/0b533/connection.png 500w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png 944w\"\n        sizes=\"(max-width: 944px) 100vw, 944px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上面的代码中,底层的C++代码会在connetion的时候传入clientHandle,然后node会创建一个\bSocket实例并且在通过connection事件将这个Socket实例传入对应的回调函数。这样就用回到了lib/_http_server.js中对connection的监听函数中<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fed65a33502990495432004fc0039796/d0143/request.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB70lEQVQ4y32S2XLjIBRE5zOSCIRYBUKLLTlWvMUz8///dKakJK5yypmHBl5oDt33l1KKqqqwlaHdvDIc35nngctx5Hrccn7bMvcNb0NmHrfM24GubYlNpI41QgjKsrzp183QWjbDzOu0p8mB2lpab+mCo/UaYwyu6fBNR4gJURRIKVeTZf863wwX9bsTp8uZy2XkvBCeJoa+RbmAdh7rHLIoEKK4o/oyuzM0RuNyT+47NkOirQO7XBOMJuQel1rq3FGWCik/qYS8o7wZaq0Z8sAubdDG8VIIlFYIpVC6opQCXUq0FJhSrqqUWmNYYB4SLqX004Hp8ofjYcv7aeLvaeT3ceS4aXnfZg7jwDxNzLuJ9rMYt8Tw0NBatv3MbtyTkiM6y5ACXe3J3hKtRluPjRmXMsa6teGHX/4qpR0PnK8nrtdXDseRfuqxwfNcFBRLXkKs7Yri5W5cfiQ0dSJ3DW1OVOo+m0f6TrcaLsuSQwo1pZA8PT3z/FKsxQgpP2hWFcj1kvzvA6uh955pujDv9/RdJHvHNgWcNR+D3HTUKVN+DvBPuhF65/ExE2JcmwvWkGuLXWYzRlwd8XWNUiXlN6nqQzfCJcMUEmPosa5BNxPaGnSsMKHCpWVXuEZjo8bWGpfMeja+wrcWnw2VUavhP+s9cWr9hXq5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"request\"\n        title=\"request\"\n        src=\"/blog/static/fed65a33502990495432004fc0039796/00d43/request.png\"\n        srcset=\"/blog/static/fed65a33502990495432004fc0039796/63868/request.png 250w,\n/blog/static/fed65a33502990495432004fc0039796/0b533/request.png 500w,\n/blog/static/fed65a33502990495432004fc0039796/00d43/request.png 1000w,\n/blog/static/fed65a33502990495432004fc0039796/d0143/request.png 1025w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个方法主要对之前创建的\bSocket进行\b一些解析处理和方法绑定最后将生成的req,res通过request\b事件传入到回调函数中.这样就回到了http.createServer(requsestListener)中来完成特定业务的处理</p>\n<h2>总结</h2>\n<p>从以上的两部分，主要从两方面来整理了下node启动和执行服务代码,\b\bnode如何处理网络请求，但是node中还有很多有意思的东西还没有说清和弄明白.例如backlog 事件循环 v8_thread_pool_size(node的线程池)等等.\b</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null},"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null},{"id":"677560ca-a2b0-53d5-a873-d982f8f5b83e","html":"<h2>变量</h2>\n<p>在javascript中声明变量有下面的几种方式: var  / const(let)  下面来梳理下这几种声明变量方式的区别。</p>\n<table>\n<thead>\n<tr>\n<th>声明\b方式</th>\n<th>声明提升</th>\n<th>作用域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>let/const</td>\n<td>Temporal Dead Zone</td>\n<td>块级作用域</td>\n</tr>\n<tr>\n<td>var</td>\n<td>提升</td>\n<td>函数作用域, 进入到声明该变量的函数作用域分配空间并且初始化值为undefined,执行到赋值语句后进行赋值</td>\n</tr>\n</tbody>\n</table>\n<h3>var</h3>\n<p>在进入声明该变量的函数作用域的时候,会为其分配空间并且初始化值为undefined,在执行到对var赋值的语句的时候会对该变量进行赋值(如果没有赋值就是\bundefined)</p>\n<h3>let</h3>\n<p>在进入声明该变量的块级作用\b域的时候,会为其\b分配空间\b此时这个变量是未初始化的(引用一个未初始化的变量会导致引用\b错误),到达\b对该变量的赋值语句的时候\b进行变量的赋值(否则为undefined)。</p>\n<h3>const</h3>\n<p>跟let的行为类似,但是需要进行初始化的值(\b不允许修改指向)</p>\n<p>下面是一些简单的例子来帮助理解上面的点</p>\n<pre><code>let tmp = true;\nif (true) {\n    // 引用未初始化的变量引用错误\n    //  console.log(tmp); // ReferenceError\n\n    let tmp; // 初始化为undefined\n    console.log(tmp); // undefined\n\n    tmp = 123;\n    console.log(tmp); // 123\n}\nconsole.log(tmp);// true\n\nif (true) {\n  const func = function () {\n    console.log(myVar); // 3\n  };\n  let myVar = 3; \n  func();  \n}\n</code></pre>\n<p>在循环中var和let/const的表现</p>\n<pre><code>const arr = [];\nfor (var i=0; i &#x3C; 3; i++) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [3,3,3]  每个变量都指向一个绑定i 所以都为3\n\nconst arr = [];\nfor (var i of [0, 1, 2]) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [2,2,2]\n\nconst arr = [];\nfor (let i=0; i &#x3C; 3; i++) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [0,1,2]   每次为let创建一个当前值的绑定 所以为[0,1,2]\n\nconst arr = [];\nfor (const i of [0, 1, 2]) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [0,1,2]\n</code></pre>\n<h3>var和let声明变量对参数的影响</h3>\n<table>\n<thead>\n<tr>\n<th>声明方式</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>var</td>\n<td>声明的变量会覆盖函数的参数</td>\n</tr>\n<tr>\n<td>let/const</td>\n<td>重复定义</td>\n</tr>\n</tbody>\n</table>\n<h4>理解默认参数的行为</h4>\n<p>默认参数可以理解成let的行为  默认参数的访问范围是与函数体内部相隔离开的,只能访问到外部的变量</p>\n<pre><code>// OK: `y` accesses `x` after it has been declared\nfunction foo(x=1, y=x) {\n    return [x, y];\n}\nfoo(); // [1,1]\n\n// 在初始化x=y的时候 y处于TDZ 出现引用错误\nfunction bar(x=y, y=2) {\n    return [x, y];\n}\nbar(); // ReferenceError\n\n\nconst foo = 'outer';\nfunction bar(func = x => foo) {\n    const foo = 'inner';\n    console.log(func()); // outer\n}\nbar();  //  如果在这个例子的外部不存在foo 会引用错误\n\nfunction noParameter() {\n    throw new Error('no parameter');\n}\nfunction test(a = noParameter()) {\n    return a;\n}  // 使用默认参数来做参数的校验\n</code></pre>\n<h2>解构</h2>\n<p>解构是跟变量的操作关联到一起的,主要用于\b变量的声明,赋值,函数参数的定义\b以及提供默认\b值。对象解构的时候,会把右边的操作值转化成对象。数组解构的时候相当于调用数组的迭代器实现</p>\n<pre><code>const { length } = 'aaa';\nconsole.log(length) // 3\nconst [x, y] = new Set([1,2]);\nconsole.log(x,y); // 1 2  \n</code></pre>\n<p>在对数组进行解构的时候,还可以通过越过某些数组项或者\b\b通过剩余参数获取数组后面的值</p>\n<pre><code>const [,, x, y] = ['a', 'b', 'c', 'd']; // x = 'c'; y = 'd'\nconst [x,...y] = [1,2,3] // x 1 y [2,3]\n\nconst num = [1,2,3];\nconst b = [];\nb.push(...num); // 扩展符\n</code></pre>\n<p>也可以通过\b解构来进行赋值(解构的声明和赋值不能同步进行并且解构的赋值需要在外边包上括号)</p>\n<pre><code>const arr = [];\n({ bar: arr[0] } = { bar: true });\nconsole.log(arr); // [true]  \n</code></pre>\n<h2>\bES6 模块</h2>\n<p>ES6模块本质上是一种规定静态化的加载和导出代码的方式,通过编译时加载使基于代码的静态分析成为可能(webapck中的tree Shaking).CommonJs的模块(运行时加载)就是对象.</p>\n<h3>ES6模块的特点和CommonJs的对比</h3>\n<p>不能动态的引入并且引入是有提升的</p>\n<pre><code>// 不能动态的\b引入\nif (Math.random()) {\n  import 'foo'; // SyntaxError\n}  \n{\n  import 'foo'; // SyntaxError\n}\n// 引入的提升\nfoo();\nimport { foo } from 'my_module';\n</code></pre>\n<p>引入是只读的引用</p>\n<pre><code>// a.js \nexport let a = 100;\nexport const count = () => {\n  a++;\n}\n// b.js\nimport { a, count } from './a.js'\nconsole.log(a); // 100\ncount();\nconsole.log(a); // 101\na = 100; // error  a是只读的\n\n// CommonJs是值的\b复制,\b相当于修改一个值.\n</code></pre>\n<p>ES6的模块可以导出单个值,CommonJS必须导出一个对象.ES6的引入是只读的引用,CommonJs的引入对于基本类型是值的复制,复杂类型是引用.</p>\n<pre><code>// a.js  CommonJS值拷贝的例子\nlet a = 100;\nmodule.exports = { \n  a,\n  count: () => { a++ },\n};\n// b.js\nlet { a, count } = require('./a.js')\nconsole.log(a); //100\ncount();\nconsole.log(a); //100\na++; // 相当于对本模块的a变量进行了赋值\nconsole.log(a);  // 101\nconst b = require('./a.js'); // 会使用第一次require的结果\nconsole.log(b.a);  // 100\n\n// a.js  CommonJs 引用的例子\nlet a = {\n  name: 'haha',\n};\nmodule.exports = { \n  a,\n  setStr: (str) => { a.name = str; },\n};\n// b.js  \nlet { a, setStr } = require('./a.js')\nconsole.log(a); // { name: 'haha' }\nsetStr('ss');\nconsole.log(a); // { name: 'ss' }\na.name = 100;\nconsole.log(a);  // { name: 100 }\nconst b = require('./a.js');  // 仍然使用的是第一次的缓存结果 但是由于引用的设置 导致原来的值被修改了\nconsole.log(b);  // { a: { name: 100 }, setStr: function() {} }\n</code></pre>\n<p>CommonJs循环加载时\b,属于加载时执行.即脚本代码在require的时候,就会全部执行.一旦出现某个模块被循环加载,就只输出已经执行的部分,还未执行的部分不会输出.ES6模块属于动态只读引用. CommonJs在引用同一个模块的时候存在会使用第一次的缓存.</p>\n<pre><code>// b.js\nexports.done = false\nlet a = require('./a.js')\nconsole.log('b.js-1', a.done)\nexports.done = true\nconsole.log('b.js-2', '执行完毕')\n// a.js\nexports.done = false\nlet b = require('./b.js')\nconsole.log('a.js-1', b.done)\nexports.done = true\nconsole.log('a.js-2', '执行完毕')\n// c.js\nlet a = require('./a.js')\nlet b = require('./b.js')\nconsole.log('c.js-1', '执行完毕', a.done, b.done)\n\n输出:\nnode c.js\nb.js-1 false\nb.js-2 执行完毕\na.js-1 true\na.js-2 执行完毕\nc.js-1 执行完毕 true true\n\n// ES6 循环依赖 a.js\nimport { bar } from './b.js';\nbar(); // 'bar'\nexport function foo() {\n    console.log('foo');\n}\nbar(); // 'bar'\n\n// b.js\nimport {foo} from './a.js'; \nexport function bar() {\n   console.log('bar');\n}\n\n// CommonJs循环依赖  a.js\nconst { bar } = require('./b.js');\nmodule.exports = {\n  test: 1,\n}\n// b.js\nconst { test } = require('./a.js')\nconsole.log(test); // undefined\n</code></pre>\n<h3>动态引入</h3>\n<p>可以通过按需引入模块来优化首屏代体积</p>\n<pre><code>    import(\"module\").then(module => {\n        module.default();\n        module.namedExport();\n    });\n\n    // Or with async/await\n    (async () => {\n        const module = await import(\"module\");\n        module.default();\n        module.namedExport();\n    })();\n</code></pre>\n<h2>iterator(迭代器)</h2>\n<p>在ES6中的可以使用数组解构,for of等语句遍历数组、Map、Set是因为在ES6中默认为这些结构创建了[Symbol.iterator]方法.通过这个方法的调用返回一个可以遍历该数据结构的对象(iterator),通过这个对象来遍历数据结构的属性.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 883px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAy0lEQVQY05VQy4qEQAyc//8eb3rwrBcVRXwrKr4QFRVBxBoqyy64zGUCRSfV6UqnXgAwjiMcx0HTNCxx3/dHMKqqgud5WNf10Xtdl5wvksMwwDRN2LaNMAwRBAGSJEHf9/gfZVnCsiwRzrIMaZoK4jjGtm0/gl3XYZ5nHMch5L7vaNsW53liWRZ5QJ61YRjQdR1RFAnv+z7quv77rQiSVBRFGjVNg6qqcF1XBAgO4koEbaFQnucoikJyDn0I0g9ech2C+TRN+CZ+PX4DVbt5trPU9noAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iterator\"\n        title=\"iterator\"\n        src=\"/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png\"\n        srcset=\"/blog/static/0bcb228576a7ca1967151733aba51136/63868/iterator.png 250w,\n/blog/static/0bcb228576a7ca1967151733aba51136/0b533/iterator.png 500w,\n/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png 883w\"\n        sizes=\"(max-width: 883px) 100vw, 883px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>const iterable = {\n  [Symbol.iterator]() {\n      let step = 0;\n      const iterator = {\n          // iterators that are iterable\n          [Symbol.iterator]() {\n            return this;\n          }\n          next() {\n              if (step &#x3C;= 2) { step++;}\n              switch (step) {\n                  case 1:\n                      return { value: 'hello', done: false };\n                  case 2:\n                      return { value: 'world', done: false };\n                  default:\n                      // done\b表示是否到尾\n                      return { value: undefined, done: true };\n              }\n          }\n      };\n      return iterator;\n  }\n};\nconst iterator = iterable[Symbol.iterator]();\niterator.next();  // {  done: false, value: 'hello' }\niterator === iterator[Symbol.iterator]() // true\niterator.next();  // { done: false, value: 'world' }\n</code></pre>\n<h2>generator</h2>\n<p>生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。</p>\n<h3>generator方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Generator.prototype.next(value)</td>\n<td>返回一个{ done: true/false, value: 执行结果 }的对象,value是当次执行的入参</td>\n</tr>\n<tr>\n<td>Generator.prototype.return(value)</td>\n<td>返回给定的value值并结束生成器</td>\n</tr>\n<tr>\n<td>Generator.prototype.throw(exception)</td>\n<td>向生成器抛出异常，并恢复生成器的执行</td>\n</tr>\n</tbody>\n</table>\n<p>生成器函数有如下特性:</p>\n<ol>\n<li>\n<p>当一个generator函数被调用，函数体内代码并不立即执行。它返回一个遵循了迭代器协议的迭代器对象:它有next方法.</p>\n</li>\n<li>\n<p>执行生成器函数体内代码的唯一方法就是在返回的迭代器对象上调用next方法.每一次调用next，函数体内代码就执行到一个yield表达式处，这个表达式的右值赋值给迭代器。</p>\n</li>\n<li>\n<p>next方法也可以接受参数，使用参数调用将会用参数值替换上一条yield表达式的左值，然后执行并返回当前yield表达式的右值</p>\n<p>function* func() {\nconst y = yield 1;\nyield 2 + y;</p>\n<p>}\nconst generator = func();\ngenerator.next() // { value: 1, done: false }\ngenerator.next(100) // { value: 102, done: false }</p>\n</li>\n</ol>\n<h2>async function</h2>\n<p>async function是ES7提出的对异步调用的一种解决方案.通常可以通过下面的方式生成async function</p>\n<pre><code>async function foo() {\n}\nconst a = async function() {}\nlet obj = { async foo() { return 1; }}\nconst b = async () => { return 1 }\n</code></pre>\n<p>async函数执行结果返回<strong>promise</strong>.在async函数体内可以使用await来等待一个promise的状态变成settled(fulfilled or rejected)</p>\n<pre><code>async function foo() {\n  console.log('async func');\n  // await已经是一个微任务  \n  const ret = await 1\n  // const ret = await Promise.resove(1)\n  return ret;\n}\nfoo().then(value => {\n  console.log(value)\n})\nconsole.log('main')\n// 上面代码的输出是  async func  main 1\n</code></pre>\n<h3>async function实现原理</h3>\n<p>async function可以通过generator + promise来模拟。</p>\n<pre><code>function spawn(genF) {\n  return new Promise((resolve, reject) => {\n    const itr = genF()\n    function step(nextFn) {\n        let next;\n        try {\n            next = nextFn()\n        } catch(e) {\n            return reject(e)\n        }\n        if(next.done) {\n            return resolve(next.value)\n        }\n        Promise.resolve(next.value).then(function(v) {\n            step(function(){ return itr.next(v) });\n        }, function(v) {\n            step(function() { return itr.throw(v); })\n        })\n    }\n    step(function() { return itr.next(undefined); })\n  })\n}\n</code></pre>\n<h2>Reflect</h2>\n<p>Reflect是一个内置对象，提供了一些方法来完成javascript的操作。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Reflect.apply(target, thisArg, args )</td>\n<td>用户给函数绑定this并执行</td>\n</tr>\n<tr>\n<td>Reflect.get(target, name, receiver)</td>\n<td>返回target上的name属性，没有undefined，如果name在target上设置了getter，则读取函数的this绑定receiver</td>\n</tr>\n<tr>\n<td>Reflect.set(target, name, value, receiver)</td>\n<td>设置target对象的name属性的值为value, 如果name属性有setter函数，则setter函数的this绑定receiver</td>\n</tr>\n<tr>\n<td>Reflect.has(obj,name)</td>\n<td>判断对象上是否有对应的属性 相当于 name in obj</td>\n</tr>\n<tr>\n<td>Reflect.deleteProperty(obj,name)</td>\n<td>删除对象的属性 相当于 delete obj[name]</td>\n</tr>\n<tr>\n<td>Reflect.construct(target, args)</td>\n<td>target是对象的构造函数，args是参数数组，相当于new target(...args)</td>\n</tr>\n<tr>\n<td>Reflect.getPrototypeOf(obj)</td>\n<td>返回对象的__proto__属性, 相当于Object.getPrototypeof(obj)</td>\n</tr>\n<tr>\n<td>Reflect.setPrototypeOf(obj,newProto)</td>\n<td>设置对象的原型， 相当于Object.setPrototypeOf(obj, newProto)</td>\n</tr>\n<tr>\n<td>Reflect.defineProperty(target,propertyKey, attributes)</td>\n<td>相当于Object.defineProperty, 定义对象的属性</td>\n</tr>\n</tbody>\n</table>\n<pre><code>const myObject = {\n    foo: 1,\n    get name() {\n        return this.name\n    }\n}\nconst test = {\n    name: 'haha'\n}\nReflect.get(myObject, 'name', test) // haha \n</code></pre>\n<h2>Set和Map</h2>\n<h3>Set</h3>\n<p>Set对象是值的集合，可以按照拆入的顺序迭代它的元素且Set中的元素是唯一的。</p>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set.prototype.size</td>\n<td>返回Set对象中的值的个数</td>\n</tr>\n<tr>\n<td>Set.prototype.add(value)</td>\n<td>在set对象尾部添加一个元素，<strong>返回该set对象</strong></td>\n</tr>\n<tr>\n<td>Set.prototype.clear()</td>\n<td>移除set对象内的所有元素</td>\n</tr>\n<tr>\n<td>Set.prototype.delete(value)</td>\n<td>移除set中与这个值相等的元素</td>\n</tr>\n<tr>\n<td>Set.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在set中</td>\n</tr>\n<tr>\n<td>Set.prototype.keys()</td>\n<td>返回键值的遍历器 <strong>遍历顺序是插入顺序</strong></td>\n</tr>\n<tr>\n<td>Set.prototype.values()</td>\n<td>返回键值的遍历器</td>\n</tr>\n<tr>\n<td>Set.prototype.entries()</td>\n<td>返回键值对的遍历器</td>\n</tr>\n<tr>\n<td>Set.prototype.forEach()</td>\n<td>使用回调函数遍历每个成员</td>\n</tr>\n</tbody>\n</table>\n<h3>WeakSet</h3>\n<p>WeakSet与Set类似</p>\n<ol>\n<li>WeakSet的成员只能是对象不能是其他类型的值。</li>\n<li>WeakSet对对象的引用是弱引用,不能阻止垃圾回收机制。</li>\n<li>WeakSet不支持遍历</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WeakSet.prototype.add(value)</td>\n<td>在WeakSet对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>\n</tr>\n<tr>\n<td>WeakSet.prototype.delete(value)</td>\n<td>移除WeakSet对象内的所有元素</td>\n</tr>\n<tr>\n<td>WeakSet.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在WeakSet中</td>\n</tr>\n</tbody>\n</table>\n<h3>Map</h3>\n<p>Map对象可以保存键值对并且能够记住键的原始插入顺序，任何值(对象或者原始值)都可以作为Map的一个键或者值。在频繁删除键值或者对键值对的顺序有要求的场景，使用Map对象更加合适。</p>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map(new Map(args))</td>\n<td>构造函数, 具有Iterator接口且每个成员都是一个双元素数组的数据结构可以作为Map的构造函数参数</td>\n</tr>\n<tr>\n<td>Map.prototype.size</td>\n<td>返回Map对象中的值的个数</td>\n</tr>\n<tr>\n<td>Map.prototype.set(key,value)</td>\n<td>设置键名对应的键值为value(存在键名则更新键值), <strong>返回当前的Map对象</strong></td>\n</tr>\n<tr>\n<td>Map.prototype.get(key)</td>\n<td>读取对应key的键值，没有key返回undefined</td>\n</tr>\n<tr>\n<td>Map.prototype.has(key)</td>\n<td>返回布尔值，判断该键是否存在Map中</td>\n</tr>\n<tr>\n<td>Map.prototype.delete(key)</td>\n<td>如果Map对象中存在该元素，则移除它并返回true否则返回false</td>\n</tr>\n<tr>\n<td>Map.prototype.clear()</td>\n<td>移除Map对象内的所有元素</td>\n</tr>\n<tr>\n<td>Map.prototype.keys()</td>\n<td>返回键名的遍历器<strong>遍历顺序是插入顺序</strong></td>\n</tr>\n<tr>\n<td>Map.prototype.values()</td>\n<td>返回键值的遍历器</td>\n</tr>\n<tr>\n<td>Map.prototype.entries()</td>\n<td>返回键值对的遍历器</td>\n</tr>\n<tr>\n<td>Map.prototype.forEach()</td>\n<td>使用回调函数遍历每个成员</td>\n</tr>\n</tbody>\n</table>\n<h3>WeakMap</h3>\n<p>WeakMap与Map类似。</p>\n<ol>\n<li>WeakMap的键值只能是对象不能是其他类型的值。</li>\n<li>WeakMap对对象的引用是弱引用,不能阻止垃圾回收机制。</li>\n<li>WeakMap不支持遍历</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WeakMap.prototype.set(key,value)</td>\n<td>在WeakMap对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>\n</tr>\n<tr>\n<td>WeakMap.prototype.delete(value)</td>\n<td>移除WeakMap对象内的所有元素</td>\n</tr>\n<tr>\n<td>WeakMap.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在WeakMap中</td>\n</tr>\n<tr>\n<td>WeakMap.prototype.get(key)</td>\n<td>读取对应key的键值，没有key返回undefined</td>\n</tr>\n</tbody>\n</table>\n<h2>参考</h2>\n<p><a href=\"http://exploringjs.com/es2016-es2017/ch_async-functions.html\">Async functions</a>\n<a href=\"https://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">async函数的实现原理</a></p>","fields":{"readingTime":{"text":"17 min read"}},"frontmatter":{"title":"ES6基础语法","date":"2018-03-19","tags":"JavaScript","path":"/es6-basic","top":null,"summary":null},"title":"ES6基础语法","date":"2018-03-19","tags":"JavaScript","path":"/es6-basic","top":null,"summary":null},{"id":"7acf6bef-d171-5dc7-9fe9-3df0a659dc8d","html":"<h2>简介</h2>\n<p>运输层提供了运行在不同主机上的应用进程之间的逻辑通信，应用程序通过逻辑通信，运行在不同进程的主机好像直连一样(例如输出一个URI 就能找到对应主机的资源)。 运输层是直接与应用层打交道的网络层级。通过对运输层协议(TCP/UDP)的了解和传输机制的学习，能更好的帮助我们\b理解应用程序的行为。在阅读计算机网络自顶向下方法的运输层时整理了如下的笔记。</p>\n<h2>运输层基础</h2>\n<p>运输层通过多路复用与多路分解来实现将主机间的数据交付服务扩展成主机的进程间的交付服务。它对应用层提供了两种服务类型:</p>\n<ul>\n<li>基于连接的，可靠地服务(TCP)</li>\n<li>不基于连接的，不可靠的服务(UDP)</li>\n</ul>\n<h2>TCP</h2>\n<h3>TCP报文段结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 454px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABu0lEQVQoz22R646rIBRGff9XapM2fYEaTZpevBQUBKEgKBdltCdTck4mJ7N+7nxkf6ydVFU1jqMxZpqm8S9KqWEYmqa53+9SSmttnP/LTNNEKU0opeu6lmUJIeSc0w9a623blFKc82EYiqKglBJCMMaEEEqpEMJam3DOvfcIoThijAkh2rYFAFBKMcaU0izLuq4TQvR9zxjjnAshnHPfm733zjlrrfswjiMAoKoqAEBZlk3T1HVNCNFaG2NizHxI5AdrbQghtoAQXq9XQkhd1xDC2LmqKozxsixxk/d+nufkcrns9/s8zzHGp9Ppdrulabrb7Y7H4+FwiL2893VdAwAej0fbttZapZTWOun7PoTgnBNCZFn2fD4BAEVRCCGmadJaT9N0Pp/zPG+a5vF4RBfbti3LkjDGrLXxVIQQKeXr9YraIIRRct/3SikpZfxRNMIY+348z3PUMM9zLBlCkFKmaRqdjeMYM8MwMMaklAghKWUSpdsfGGO898aYuq4551LKZVmi5+jJex/NJV+/Mc8zQghCiBACAGit13UNP1iWJYSQvH9jXVfOedd1fd9jjJ1z7/d727b/Yn8AH0+bq1J7Cv0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP\"\n        title=\"TCP\"\n        src=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n        srcset=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/63868/fragment.png 250w,\n/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png 454w\"\n        sizes=\"(max-width: 454px) 100vw, 454px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>端口和目的端口用于TCP数据的\b多路复用和多路分解</li>\n<li>序号和确认号用于\b实现可靠数据传输</li>\n<li>TCP的连接状态保存在端系统中，这种链接的状态对网络层是不可见的。网络层只看到的数据报</li>\n<li>确认号可以理解成发送方期待接受方发送的下一段序列的初始字节编号。例如当A收到B发送的数据是500-600（不包括600）并且在累计确认下(前500的数据都得到确认) B在发送的报文中确认号就是600,A接收到报文后就会发送600之后的数据给B</li>\n<li>接收窗口用于实现拥塞控制(TCP慢启动)</li>\n<li>在6个标志字段中 ACK用于确认上一个已成功报文的确认 RST，SYN,FIN 用于连接的建立和拆除 PSH被设置的时候标志接受方应立即将数据交付给上层</li>\n</ul>\n<h3>流量控制</h3>\n<p>流量控制是发送方与接收方的一种速度匹配服务。在发送方与接收方都维持一个接收\b窗口的变量。假设该变量的值为rwnd，发送方必须保证\bLastByteSent - LastByteAcked &#x3C;= rwnd.\b假设接收方的缓存空间是RcvBuffer,必须保证 rwnd = RcvBuffer - [LastByteRcvd - LastByteRead].该窗口字段在接收端发送报文的时候会写到\bTCP报文的窗口字段。\b当接收端的窗口是0的时候，\b发送方接收到对应的\b报文将发送只有一个字节的数据报文段，此时接收端将接收这个报文并且清空自己的缓存空间(数据传送给上层)并且回复一个\brwnd大于0的报文段</p>\n<h3>TCP连接的建立与\b中断</h3>\n<h4>TCP连接的建立</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPElEQVQ4y21Ty07jMBSN+CF2iK/gQ/gdliyQumEkxKpUHakwmpRFxDNNUlJFQigPMrRJWgfHaRLH8R3BRaYwc1b29X2dc681AJBSAsBqtTo8PDw4OCCEKOMmbm9vj46OTNNUFk1KKYRo2xYAtre3d3Z2AKBtW7mBrusAIMuy3d3d8XisHDSsgM/7+/t7e3tFUaBFAVPbtr21taXrOgAIId4qA0BZloQQzvl8PnccJ89zQsi/bQshxuPx6+urIvUW7Pu+bduEEMbYYrFwHKff75v397913TTNNE2rqsLWOOcq11vbm7mbpqmqCs+r5fLx8XHqur90fTgcep6XJEkcx0j4g7MiJqWs67osSyVBJ2WZ56HjZL4/dd2zfv/6+poxZlnWdDrlnGuoR9u2Xdet12tKaVVVrCiuLi6GvV6/17MNw314iOM/nHNKKYqPxTQhBM4DJUmSZDQaDQeDn6enV4bhh2FZfxJWan0EA0CapsvlkjFGKR2NRufn51EUBVGE/HERmqbhnOd5jhaEhrtFCFmv13meB0Hw9PQ0dZwfx8eXl5e2bSdJ0jQNeuMKqCl+UZtzXtc1Tn4+nxuGMRgMTk5OdF2PojBN06Kgm/6a4oCjQrVV7rqugyC4ubmxLOvu7g5H9SnYt8rYIb5hRrUCcRy/vLxg8AfnzTUsy5JS+u1LoSsesiz7D2e8h2HoeR7OTH4FAFBKXddtmka843vbQghK6Ww2WywWz8/Pvu9PJpM4jr13WJbFGNv8sH8BdCuyVQ0e+JcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"三次握手\"\n        title=\"三次握手\"\n        src=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n        srcset=\"/blog/static/450ef929b273efe5395a856db3581d99/63868/connect.png 250w,\n/blog/static/450ef929b273efe5395a856db3581d99/0b533/connect.png 500w,\n/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>客户端在向服务端请求连接的时候，会向服务端发送\b一个SYN报文段。会随机选取一个client_isn\b作为序号字段放置在该SYN报文中。</li>\n<li>服务端在收到该报文后，会发送给客户端一个报文并且设置TCP的缓存和变量。该报文的ack字段是client_isn + 1,序号字段为server_isn,SYN比特为设置成1.代表当前服务器已经准备接收数据</li>\n<li>\b客户端在接收服务端的确认报文后会创建TCP的缓存和变量并且向服务端继续发送报文(此时的报文可以携带上\b上层的数据),其中ack字段是server_isn + 1,序号字段是client_isn + 1,SYN字段\b为0(此后的报文中SYN字段都为0).至此TCP连接建立成功。(三次握手是为了确定双方的序号)</li>\n</ol>\n<h4>TCP连接的中断</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACnUlEQVRIx4WVS2pyQRCF7+qyCFcgCK7AUYYhOnfgyEAgDl2BRIMKOjAPiCGaGI3vtyY+ovXzNZS0915/G5qr3V2nTlWdrnZERLbbrfz+/pr59/cn+/2e5cPXHqzp+m63k9lsJtPpVJbLpVl32Oj1elKr1eTj4+PI0A/M/gL49PQkLy8v0m63zZoDO4Cen5+lXC7L29ubrFYrDxs/wE6nI4+Pj5LP58232+2Ks9lsjIdMJiORSEQuLy8PTGHgN3Qd57lcTq6uriQcDsvd3Z04xWJREomExGIxSaVSZhK+bahMbcbNZlOSyaREo1G5vr6Wm5sbSafT4tze3kogEJBgMCj39/fy8PAgk8nEF4ipTkqlkoRCIbm4uJB4PC7ZbNakzcG4UCiYSg2HQ5nP53JquEFRRaVSOVpzKMB6vTZ/+v2+DAYDc3CxWJgvB1utlkm4eyAVdzSOfWA0GhkQNigWzgCGPY5+fn7MRBmcYQ/JHQHaiQYQA/cAkCIgYvYBYb6+vkqj0TgU0AM4Ho8PtwV2ypCQv7+/TX4JU3WKA1+GmlDU/vn5aUAxVPBTgzPk3Rb7EUPyBKNzVdbzhI8y7H0PIF7d1w4VEK4NCHNyXq/XTTo0DY5NlxyqhDQVGCIZDCkOwOSOdCCZ9/d3c1W1mI6CIRM2McQIcK2qtifN59mQVRp0DMIGiAkI4NxtioX+7IYBS9+iaCtCa3ZVMYY5QBQLcDtknGPnkQ2Di03IAJxqsLqOA5XZ19eXPyC5Y9pF8Zv2oLKaQw8gOaT8hOLuzu6urf/dwj4ChBkh24CnGJ4FBIRK8jb87z1xA9qyOWpfhFqtVs0L5s4hldZO4n6sqLz2SU/IDLqvPlCnQraZclP0/fF0G76wRMDnAN2ysn//Aw2QzK7dGbfNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP close\"\n        title=\"TCP close\"\n        src=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n        srcset=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/63868/close.png 250w,\n/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n(发送方和接受方都可以中断TCP连接)</p>\n<ol>\n<li>\b\b终止方向另一端发送一个TCP报文，其FIN比特位被\b设置成1</li>\n<li>接收方回复一个ACK报文并且发送一个FIN报文</li>\n<li>终止端回复一个ACK报文，至此两方为了维持TCP连接的缓存和变量都将\b清除(接受FIN端需要把自己剩余的信息发送完 才能发送FIN报文)</li>\n</ol>\n<h4>TCP客户端和服务端的状态转变</h4>\n<h5>TCP客户端客户端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB4klEQVQ4y42U144CMQxF5/8/CF54gDckiui9I3rvHa+OV4YwO0hrKcokE19fXzvxxLF2uy2ZTEaWy6Wuj8ejbDYbGQ6HMhgMZLfbyfV61X/M8XhcstmspNNpCYfD0mq1xHs+n2IDu1wuslqtFIQDs9lMarWaNBoNmU6nMh6PNeBisdAAj8dDwff7vc6eC3Y4HGS9Xr/WFoBxPp91NmMNaLValXq9rmvMc1OGmZkbyDV/Ntvt9uOfd7vdpNvtqhZEIiIsXWe/LMxkMxqNJJlMynw+V71fgFCnIKVSScVHK7QxZ5cBhg/aQoKRSqVU8/v9/k4ZkHK5/Ce9oDWAFIQBEPqx99KQqoVCIcnlcnI6nT6cgxhyHlaJREJisZj0+/23hnYYPYz2N0D/PkDNZvPDR9uGDRoY/aD+DcxfZc7Sn65pUahsPp+XSqWiTQywn6n7TcHoDDSnysw0PPvKEN0AAYy+oh/dKge1DekCVCwWtTsmk8kb0OgT9VuFg1K2m0UL0XofRbHOp4IuE+6nXb2gs0gDkV6v98sQ3SKRiD4EnU5HtSAag6qjbaFQUAfWFIF/3A4YIhfgprnHK8GTRQ8CaMyIxnWyFwbNACI9cwY8Go3q04WOfx6H/7SKewaGsCaYPRI/rcIZxDx6n2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"客户端状态变化\"\n        title=\"客户端状态变化\"\n        src=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n        srcset=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/63868/client-status.png 250w,\n/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>连接的建立 初始的时候TCP客户端处于CLOSED，\b当它需要与服务端建立TCP连接的时候，发送SYN字段，进入SYN_SENT状态. 当收到\b服务端对SYN报文的确认后，就进入ESTABLISHED状态，此刻TCP客户已经能发送和接收数据了</li>\n<li>连接的\b中断 客户端发送\bTCP报文(FIN字段被\b设置为1),进入FIN_WAIT_1,等待服务端的确认报文然后进入FIN_WAIT_2.等到服务端的FIN报文并且发送确认报文后，进入TIME_WAIT.最后进入CLOSED状态</li>\n</ol>\n<h5>TCP服务端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABxklEQVQ4y42Ux47DMAxE9f+flFOQ5JKDL+k9SO+9Vy4eASqCsIssAcGWRI9myLHc7XYTxuVykdPpJMfjUZ/MebdxOBzkfr9Lu92WdDotmUxGUqmUZLNZGQwGmk+Oq1ar0u12ZTabyfV6FeL5fHrw4XAo4/HYgz4eD1kul9JqtaRYLMp0OpUwXKPRkHK5LJVKRdbrtWe2WCxkv98r4Gg0UpDVaqV7rIfxfr/9cOEGySxavF4vncOYdwvmHGj7BqoMLdHkhCfGEa7vdjsvNwR1sEJ2s9nUuiCb4sdS7CMO3W63UqvVJEkS2Ww2OocYQxkCSqcmk4k2w1iHLO0dubCjppaPS3xT6C5dZJAcA8SSLVABMERo6Hw+FxzjWIQ2nUNOKO83hvYEEGXIxT44pd/vf7psgP9liBrA4j2HmZENdWTjtbDb8QfUF69SPxoJkfP5/Kkhk06no/rr9bomxvYJy2AeRGapVNJuw9QzNGRY2h8QA/1lH5jGJXFhovnpW5CDbcyvgFM6BaR2uVxOXW+mpXt0nxLQvUKhIL1eT+uL8dnHJvl8XnPssqAcDgD+FC4BYwcwtQWAmnI5kEdJ7EbCzBwCofDX+wGhXtIqR2SqKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"\b服务端变化\"\n        title=\"\b服务端变化\"\n        src=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n        srcset=\"/blog/static/884026a29f246f33aa0a88780176d2d5/63868/server-status.png 250w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/0b533/server-status.png 500w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>理解TIME_WAIT状态</h5>\n<ol>\n<li>可靠的实现TCP全双工连接的终止 主要close的一端 需要维持状态以防止最后一次的ACK对方收不到来进行网络重传</li>\n<li>TIME_WAIT阶段设置的超时时间会导致网络中迷失的分组丢失,这样在同样的端口创建新的TCP连接时候,不需要判断之前的数据.</li>\n</ol>\n<h3>拥塞控制</h3>\n<p>TCP使用的是端到端的拥塞控制，来防止网络拥塞时发生的各种问题(\b\b多余的分组,丢包\b等)。相比流量控制，拥塞控制是对网络拥塞的一种感知来控制发送的速度。流量控制是对接受方处理速度的一种速度调整。\n在TCP发送方维护一个拥塞\b窗口的变量来实现拥塞控制<br>\nLastByteSent - LastByteAcked &#x3C;= min { cwnd(接收窗口) , rwnd(拥塞窗口)}</p>\n<ul>\n<li>当发送\b方正确的收到确认报文的时候，他认为网络中无拥塞，不断的调整 cwnd</li>\n<li>当发送方超时\b未收到ack或者收到接收方三次\b\b\b冗余,需要降低发送速度</li>\n</ul>\n<h2>基础词汇解释</h2>\n<p>MSS 最大报文段长度<br>\n\b在不同的链路层协议上，其最大的传输\b单元(最大\b链路层帧长度)不同，这就导致了在\b封装到IP数据报的时候，需要适应底层的链路层长度。</p>\n<h2>TCP UDP 区别</h2>\n<ol>\n<li>TCP提供差错校验,重传等功能 UDP不提供对应的功能,UDP需要在应用程序中添加对应的逻辑来完成相应的功能</li>\n<li>UDP的数据报长度字段会随着数据发送给接收端,TCP是一种字节流协议,没有记录标记的长度(content-length) 主要是两者实现方式上的不同UDP是不面向连接的 也就是可以从一个套接字接受多个数据源 如果没有长度加以区分数据就会混乱.一个TCP套接字只对应着一个数据源,可以由应用层来决定数据的读取.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null},"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null},{"id":"5785a8e7-fb4f-52f2-975d-0390f116486d","html":"<h2>简介</h2>\n<p>在实际的工作中，发现自己对网络这方面的知识有些欠缺并且作为一个web开发者有必要了解网络中数据传输的基本过程，在阅读计算机网络自顶向下方法中把网络层的基础知识整理如下。主要分为三个方面网络层的基础，IP(网际协议)，相关协议简介来简单的学习下网络层。</p>\n<h2>基础</h2>\n<ul>\n<li>网络层提供的通信机制是多个协议族共同运行的结果。主要有以下三个组件：IP协议,路由选择协议,ICMP协议</li>\n<li>网络层提供的主要功能是提供分组的转发并且结合路由算法实现路由功能，也就是最终实现主机间的通信。运输层提供了主机上进程之间的通信。</li>\n<li>因特网的网络层提供的服务是一种尽力而为的服务，这样做能简化网络层的行为.当上层的服务需要对应的功能(例如运输层需要保证数据的按序接收等)时候，通过它自己去实现.</li>\n<li>网络层的有连接服务和无连接服务\n提供有连接服务和无连接服务的网络层形成了不同的网络体系。仅提供有连接服务计算机网络称为虚电路网络(ATM,帧中继)。仅提供无连接服务的网络称为数据报网络。</li>\n</ul>\n<h2>虚电路网络和数据报网络</h2>\n<h3>虚电路网络</h3>\n<ul>\n<li>连接建立 虚电路网络需要在路由器上维持连接信息，在虚电路建立阶段,需要在建立的路径上的路由器之间维持连接状态信息(对应连接的路径)，当连接建立后，这些路径信息存储在路由器的转发表中</li>\n<li>数据发送  发送对应的数据</li>\n<li>虚电路拆除 发送方通知网路层终止虚电路,在网络的路由器上就删除对应的路径信息</li>\n</ul>\n<h3>数据报网络</h3>\n<p>因特网是一种数据报网络，这种网络体系结构在发送数据的时候需要将目的端系统地址推进到网络中,通过逐个路由器的转发最终到达目的主机</p>\n<h2>网际协议</h2>\n<p>网际协议(IP)现在主要有两个版本：IPv4和IPv6<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 573px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABE0lEQVQY021Q2Y6DMAzk/39tW4ntwQIthENFCkkDCWlwnYNVG/Vpd2SNLM9Ylicp8nKa5uF2I6QxxsC6pml6znK0VmuN+HwXPh76cDiKafbeAwAizvOcMMalVFLKcRwpHZ1znHEhhPdeKTWOLFqfAH3XE9JM02StRUQpZbJtm3Nu28KyLPlPDgAhBO/8e1kWRTnNs7U2HjydzpSOIQRrrVIqqaqqKMq6rhm/L1pzxi7Xqm07pRSlVEoJAMMw7Hb78nKta8L4HQDWdRVCJMaYxwda68gAKyHN7mvftB0AxPlL+niMMZzzxDlnP0CMjN77vu2+0wNpWu89RuEtxdY59/r5FcYfAKxd12dZVtUEnv8gpv0LtNCK129tzhMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"数据报格式\"\n        title=\"数据报格式\"\n        src=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n        srcset=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/63868/IPv4.png 250w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/0b533/IPv4.png 500w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png 573w\"\n        sizes=\"(max-width: 573px) 100vw, 573px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>字段解释</h3>\n<ul>\n<li>版本号 \b指示当前数据报使用的\bIP协议版本</li>\n<li>首部长度  数据报长度  IP数据报可以提供可变数量的选项，可以通过这两个字段来确定数据报的首部和数据的长度</li>\n<li>标识、标志、片偏移  在\b数据报传输给链路层的时候，由于不同链路层协议的\b产生的链路层帧不同，通过这三个字段来完成数据报的分片与重组</li>\n<li>生存时间(TTL) 保证一个分组不会在网络之前循环的转发，数据报信息每通过一次路由TTL字段减1.为0的时候必须丢弃改该数据报。</li>\n<li>协议  与运输层的那种协议传输数据(TCP/UDP)</li>\n<li>首部校验和  每次到达路由器的时候，路由器都会对数据报的IP首部进行校验，丢弃出错的分组信息</li>\n<li>源IP地址和目的IP地址  实现主机间的通信</li>\n<li>数据  承载上层协议的数据(TCP/UDP(应用层 HTTP SMTP) ICMP )</li>\n</ul>\n<h2>网络编址</h2>\n<h3>IP地址</h3>\n<p>IP地址可以对应理解成主机与物理链路的接口，在每个子网中，子网中的主机的网络前缀相同为X,后面的32-X位决定该子网具体\b能容纳下多少台主机</p>\n<h4>地址获取(DHCP)</h4>\n<p>在一个子网中，需要为每个主机分配IP地址来实现通信，这个的通常实现是通过DHCP\b协议(也可以通过\b静态的配置)，通过DHCP获取IP地址主要有以下四个阶段</p>\n<ol>\n<li>新连接的主机广播DHCP发现报文</li>\n<li>DHCP 服务器收到发现报文，广播DHCP提供报文(在\b子网中存在多个DHCP服务器)</li>\n<li>\b主机根据DHCP提供报文发送对应的DHCP响应报文，将之前DHCP的\b提供报文的数据回显</li>\n<li>DHCP ACk DHCP服务器确定\b请求，主机可以进行通信.</li>\n</ol>\n<h4>地址转换(NAT)</h4>\n<p>NAT是一种地址管理策略的实现。他通过在NAT路由器中维护NAT转换表来实现对外界统一请求的转发和请求到外界的转发。\n实现 子网中的主机通过端口A连接NAT路由器，NAT在收到数据包的时候\b创建一个新的端口B并将数据的源端口改为B，IP地址改为改子网对外的统一IP地址,外部服务收到对应的报文，\b响应报文到NAT路由器，NAT路由器查找NAT\b转换表找到刚才转换的端口A和初始的请求主机IP地址将响应报文发送对请求的主机</p>\n<h2>相关协议简介</h2>\n<h3>因特网控制报文协议(ICMP)</h3>\n<p>ICMP用于主机与路由器之间沟通网络层信息，ICMP是运行在IP协议层之上的，也就是IP数据报的数据部分是包括ICMP的数据报文的内容的(跟IP承载TCP/UDP报文一样)</p>\n<h2>理解路由</h2>\n<ol>\n<li>当主机想发送一个IP数据报的时候,它会查看自己的路由表。如果目的IP地址就是在本地网络，就直接将数据进行封装发送给目的主机.如果目的IP地址\b不在本局域网中,数据被封装然后发送给路由器(此时\b在数据链路层的帧的目的地址是路由器的物理地址,IP报头的目的IP仍然为原来的目的IP地址).</li>\n<li>路由器接收到对应的数据\b传递给网络层,如果目的IP是自身则自己处理这个数据\b(用于更新路由表等)否则查询路由表将数据进行转发。</li>\n</ol>\n<h2>基础词汇解释</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>丢包</td>\n<td>在路由器中存在着缓存结构来缓存需要发送或者接受待转发的分组.<br>当这个缓存过大超出其内存空间的时候，路由器就会丢弃该分组，造成丢包</td>\n</tr>\n<tr>\n<td>IP数据报分片</td>\n<td>由于不同数据链路层所能承载的最大传输数据单元(MTU)不同.IP数据报在数据链路层会被进行分片和重组</td>\n</tr>\n<tr>\n<td>CIDR 无类别域间路由</td>\n<td>它通过扩展IP的网络位数来实现将一个IP\b地址对应成多个IP地址的行为</td>\n</tr>\n<tr>\n<td>ARP 地址解析协议</td>\n<td>在数据链路层提供将网络层的IP地址转换为物理地址</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null},"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null},{"id":"176af9de-3c8b-52dc-8632-c4c56c195417","html":"<h2>简介</h2>\n<p>node中的Stream模块在很多基础的模块都有使用下面就从官网的文档和源码上学习下Steam模块的基础知识</p>\n<h2>基础</h2>\n<ol>\n<li>node.js 中有四种形式的流 可读(Readable)  可写(Writable)  可读可写(Duplex)   转换流(Transform)</li>\n<li>流在内部维护了一个链表来完成缓存数据的读取,流继承了EventEmitter,通过事件的监听来完成数据的获取</li>\n<li>在进行流的初始化的时候通过设置highWaterMark来控制缓存区的大小 当读写速度出现差异，存储的数据到达highWaterMark的时候，就会出现背压。这样读写流就会停止读或者写入</li>\n</ol>\n<h2>可写流</h2>\n<p>可写流是可以写入数据的目的地的抽象</p>\n<h3>事件</h3>\n<p>drain  stream.write(chunk) 会返回true false来通知当前流是否可写。当它返回false的时候  当前流再次可用的时候 会触发drain事件<br>\nerror  读写数据出现error的时候会触发这个事件 但是不会关掉流<br>\nfinish  在stream.end(chunk,encoding,callback)的时候在数据发送完毕后会触发finish事件，传入的callback作为监听函数</p>\n<h3>方法</h3>\n<p>writable.cork()/writable.uncork()\nbuffer缓存和清除缓存 调用的次数必须一致,在使用writable.uncork()的时候 推荐使用process.nextTick()<br>\nwritable.write(chunk,encoding,callback)  返回的true /false 通知当前是否可写\n结合drain事件来完成持续的写入(即使return false 仍然能完成数据的写入造成内存的占用 给垃圾回收造成压力)<br>\nwritable.destory(error) 关掉这个流<br>\nwritable.end(chunk,encoding,callback) 通知不会在有其他的写入,callback会变成finish事件的回调函数</p>\n<h2>可读流</h2>\n<p>可读流是可以被消耗的数据源的抽象\n可读流有两种状态: flowing paused</p>\n<ol>\n<li>在flowing状态下通过对data事件的监听获取数据。</li>\n<li>在paused状态下通过对_read(size)方法的调用来完成数据的读取.</li>\n</ol>\n<p>在node的lib/_stream_readable.js中,在构造函数中会通过传入的options来初始化流的状态</p>\n<pre><code>  this.buffer = new BufferList(); //  链表 \n  this.length = 0;  // 存储的长度\n  this.pipes = null;  //  pipe 数组 目的地 (初始的时候是null) \n  this.pipesCount = 0; // pipe 长度\n  this.flowing = null;  //  state  null true false (flowing paused) \n  this.ended = false;   \n  this.endEmitted = false; // 是否发送end事件\n  this.reading = false;   // 是否正在读取  \n</code></pre>\n<p>在上面的代码中this.flowing就是控制stream的状态是否是flowing或者paused 通过pipe unpipe 或者data事件的监听能切换状态 (当this.flowing为false的时候通过data事件的监听不会造成this.flowing变成true 必须调用stream.resume())\n在实现可读流的时候,需要实现_read(size)方法触发底层数据的读取.可以使用size(size会根据背压动态变化)来完成读取的流量控制</p>\n<h3>事件</h3>\n<p>data  当流准备发送数据的时候会触发data事件( 切换成flowing 或者read() 方法的调用)\nend 当可读流的数据都被消费后会触发end事件 通知无数据可读取\nreadable  通知当前有数据可以读取或者流数据的结尾会触发 通过监听readable然后通过read事件来完成数据的读取</p>\n<h3>方法</h3>\n<p>readable.isPaused() 返回流当前的状态(对应上面的this.flowing)<br>\nreadable.pause() 切换this.flowing = false<br>\nreadable.pipe(dest)<br>\n(1)可以一个src多个dest(对应上面代码的this.pipes)<br>\n(2)返回dest支持链式调用  a.pipe(a).pipe(b)<br>\n(3)背压的控制 通过在src上注册drain事件并且在write的时候根据dest的状态来写入完成背压的控制</p>\n<pre><code>    src.on('data', ondata);\n    function ondata(chunk) {\n      increasedAwaitDrain = false;\n      var ret = dest.write(chunk);\n        if (false === ret &#x26;&#x26; !increasedAwaitDrain) {\n          // If the user unpiped during `dest.write()`, it is possible\n          // to get stuck in a permanently paused state if that write\n          // also returned false.\n          // => Check whether `dest` is still a piping destination.\n          if (((state.pipesCount === 1 &#x26;&#x26; state.pipes === dest) ||\n               (state.pipesCount > 1 &#x26;&#x26; state.pipes.indexOf(dest) !== -1)) &#x26;&#x26;\n              !cleanedUp) {\n            debug('false write response, pause', src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n          }\n          src.pause();\n      }\n    }\n</code></pre>\n<p>当src接受到drain事件后会触发drain事件的监听函数重新完成数据的写入</p>\n<pre><code>//  pipe  end flag\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 &#x26;&#x26; EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n</code></pre>\n<h3>实现一个可读流</h3>\n<pre><code>const { Readable } = require('stream');\n// Stream 实现\nclass MyReadable extends Readable {\n  constructor(dataSource, options) {\n    super(options);\n    this.dataSource = dataSource;\n  }\n  // 继承了 Readable 的类必须实现这个函数\n  // 触发系统底层对流的读取\n  _read() {\n    const data = this.dataSource.makeData();\n    this.push(data);\n  }\n}\n// 模拟资源池\nconst dataSource = {\n  data: ['1','2','3','4','5','6','7','8'],\n  // 每次读取时 pop 一个数据\n  makeData() {\n    if (!dataSource.data.length) return null;\n    return dataSource.data.pop();\n  }\n};\nconst myReadable = new MyReadable(dataSource);\nmyReadable.setEncoding('utf8');\nmyReadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n</code></pre>\n<h4>从源码上理解上面的例子</h4>\n<p>通过data事件的监听</p>\n<pre><code>    Readable.prototype.on = function(ev, fn) {\n        const res = Stream.prototype.on.call(this, ev, fn);\n\n        if (ev === 'data') {\n        if (this._readableState.flowing !== false)\n          this.resume();\n        } else if (ev === 'readable') {\n        const state = this._readableState;\n        if (!state.endEmitted &#x26;&#x26; !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.emittedReadable = false;\n          if (!state.reading) {\n            process.nextTick(nReadingNextTick, this);\n          } else if (state.length) {\n            emitReadable(this, state);\n          }\n        }\n      }\n      return res;\n    };\n</code></pre>\n<p>当注册data事件的时候,会调用this.resume() 最后调用flow(stream) 来完成数据的持续读取</p>\n<pre><code>    function flow(stream) {\n      const state = stream._readableState;\n      debug('flow', state.flowing);\n      while (state.flowing &#x26;&#x26; stream.read() !== null);\n    }  \n    \n</code></pre>\n<h2>总结</h2>\n<p>上面就简单的介绍了下node中stream模块的基础知识,通过对流模块的学习能更好的帮助我们理解node中数据的发送处理过程,也可以尝试着去阅读一些简单的模块(send)来加深对Stream的理解.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903588649500679\">Node.js可读流和可写流</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null},"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null},{"id":"c3047e98-87f7-59a6-bbba-9d1cef17bd99","html":"<h2>简介</h2>\n<p>koa利用生成器来解决回调函数的嵌套问题，实现的十分巧妙，下面跟着官网的例子逐步学习下koa的实现原理<br>\n官网 <a href=\"http://koa.bootcss.com/\">koa</a></p>\n<h2>使用</h2>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n});\r\napp.listen(8080);  \n</code></pre>\n<p>这个例子很像在Node中构建HTTP服务器的例子</p>\n<pre><code>var http = require('http');\r\nhttp.createServer(function(req,res){\r\n    res.writeHead(200,{'Content-Type':'text/plain'});\r\n    res.end('hello world');  \r\n}).listen(8080);  \n</code></pre>\n<p>通过app.use()设定中间件 app.listen()监听特定的端口这样整个web服务器就启动了 那我们的关注点就到了这句话 var app = koa();<br>\nkoa的源码lib下有四个文件 application.js context.js request.js response.js  在koa的package.json中main属性的值指向的是lib/application.js 也就是整个web服务器的生成过程都在这个js中 下面我们逐步的解读下application.js的部分源码</p>\n<pre><code>module.exports = Application;\r\nfunction Application() {\r\n    if (!(this instanceof Application)) return new Application;//确保不通过new调用构造函数的时候返回正确的值\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.subdomainOffset = 2;\r\n    this.middleware = [];//保存中间件的数组\r\n    this.proxy = false;\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);//通过指定的原型创建对象\r\n }  \n</code></pre>\n<p>通过上面这段代码，也就是在调用这句话的时候 var app = koa()实际上就是生成了一个Application实例 在实例上有一个数组用于保存中间件 三个属性 context request response</p>\n<pre><code>var app = Application.prototype;\r\napp.listen = function(){\r\n    debug('listen');\r\n    var server = http.createServer(this.callback());//this.callback()就是请求来的处理函数\r\n    return server.listen.apply(server, arguments);  \r\n    //这里上文中Node构建HTTP服务的例子 似曾相识 \r\n};  \n</code></pre>\n<p>在http.createServer(this.callback())中this.callback()就是请求来的处理函数也就是app.callback()这个函数 正是这个函数实现了koa的中间件机制</p>\n<h2>中间件</h2>\n<p>在介绍中间件的原理之前 先上一个例子</p>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(next){\r\n    console.log(1);\r\n    yield next;\r\n    console.log(2);\r\n});\r\napp.use(function *(next){\r\n    console.log(3);\r\n    yield next;\r\n    console.log(4);\r\n});\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n})；\r\napp.listen(3000);  \n</code></pre>\n<p>当对服务器发送一个请求的时候  会发现服务器的控制台log出的顺序是 1 3 4 2 下面我们来看一下这个神秘的app.callback()函数到底做了什么</p>\n<pre><code>app.use = function(fn){\r\n    if (!this.experimental) {\r\n      // es7 async functions are not allowed,\r\n      // so we have to make sure that `fn` is a generator function\r\n      assert(fn &#x26;&#x26; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);//将每次调用的生成器函数push到中间件数组\r\n    return this;//可以实现链式调用\r\n}; \n</code></pre>\n<p>app.use()就是收集所有设定的中间件，然后存储到数组中</p>\n<pre><code>app.callback = function(){\r\n  var fn = this.experimental\r\n    ? compose_es7(this.middleware)\r\n    : co.wrap(compose(this.middleware));\r\n  var self = this;  \r\n  return function handleRequest(req, res){\r\n    res.statusCode = 404;\r\n    var ctx = self.createContext(req, res);\r\n    onFinished(res, ctx.onerror);\r\n    fn.call(ctx).then(function handleResponse() {\r\n      respond.call(ctx);\r\n    }).catch(ctx.onerror);\r\n  }\r\n};  \n</code></pre>\n<p>app.callback()中的返回值 function handleRequest(req,res){}就是请求来的时候的处理函数 在这个处理函数中调用fn进行事件的处理 fn是什么呢？  我们只需要搞明白这句话 co.wrap(compose(this.middleware))</p>\n<p>第一步 compose对生成器函数数组进行了处理</p>\n<pre><code>function compose(middleware){\r\n  return function *(next){\r\n    if (!next) next = noop();\r\n    var i = middleware.length;\r\n    while (i--) {\r\n      next = middleware[i].call(this, next);//不断的获取后一个生成器对象 作为参数传入当前的生成器函数并且执行获得生成器对象\r\n    }\r\n    return yield *next;\r\n  }\r\n}\r\nfunction *noop(){}  \n</code></pre>\n<p>其实理解compose的作用要理解好通过app.use(function *(next) {}) 传递的生成器函数传递的next  整个compose的作用就是生成器函数的执行后进行从头到尾的串联 然后返回一个生成器<br>\n接下来就需要理解co的执行流程了</p>\n<h2>co源码解读</h2>\n<p>co是通过生成器避免了多个异步操作的回调嵌套</p>\n<pre><code>function *test() {\r\n  var a = yield readFile1();\r\n  var b = yield readFile2();\r\n}\n</code></pre>\n<p>简单理解co的作用就是首先获取之前执行的结果 保存下来当下次调用generator.next()的时候作为参数传入，这样就实现了异步操作的同步执行</p>\n<pre><code>function co(gen) {\r\n  var ctx = this;\r\n  var args = slice.call(arguments, 1)\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\r\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\r\n    onFulfilled();\r\n\r\n    function onFulfilled(res) {\r\n      var ret;\r\n      try {\r\n        ret = gen.next(res);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n\t}\r\n    function onRejected(err) {\r\n      var ret;\r\n      try {\r\n        ret = gen.throw(err);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n    }\r\n    function next(ret) {  //这里使用promise进行了封装 当之前的异步调用完成后 就会在调用onFullfilled将这次执行结果的返回值传入\r\n      if (ret.done) return resolve(ret.value);\r\n      var value = toPromise.call(ctx, ret.value);\r\n      if (value &#x26;&#x26; isPromise(value)) return value.then(onFulfilled, onRejected);\r\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\r\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\r\n    }\r\n  });\r\n}\n</code></pre>\n<p>通过上面的代码阶段我们就学习了koa的中间件机制 其实ES7的异步函数就是实现的co所做的事</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null},"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null}],"group":[{"node":{"id":"e3ace596-3e3b-503f-9749-e050e7ba90aa","html":"<p>在聊关于价值的一点想法之前，请让我介绍一部我喜欢的电影作为引子-Once upon a time in America(美国往事)。我微信的昵称是noodles，也是因为这部电影。</p>\n<p>美国往事是一部讲述美国20世纪60年代生活的犯罪电影，主角noodles(面条)在街区中结识了一群小伙伴，最开始过着调皮捣蛋的快乐生活，随着新搬来的邻居Max(麦克斯)的到来，大家逐渐去做一些犯罪和帮派的活动，在剧情不断发展中，跟随noodles经历了童年的欢乐、青涩的爱情、友情、遗憾、无奈。在'生意'逐渐做大的时候，他们一伙人想要铤而走险，noodles为了挽救他们的生命，选择了举报他们的行动，结果行动被破坏但是伙伴们都死于那次举报。noodles抱着悔恨远走他乡。多年以后，一封信把noodles叫回了故乡，此时的noodles已经头发发白，岁月在他身上有了明显的痕迹。这次他遇到了之前痛而不得的爱人，也遇到了自己的老友-Max.原来Max在之前的行动中做了个局，在那次行动中，Max并没有死而noodles被迫远走之后，Max占据了大家一起打拼的事业，‘一帆风顺’当上了部长。Max此时已经无法自保，他想向noodles坦白自己之前做的事，让noodles了结他的生命。印象中深刻的台词就这里发生了，当Max坦白，noodles却不愿意拿枪杀死他，画面切回了之前他们一起经历的快乐时光。noodles说: it`s just the way i see things(这是我对人生的看法)，I hava a story alse(我也有一个关于你说的故事)。在noodles讲述的故事中他因为自己的举报导致挚友去世感到悔恨一生，但是他们之间有真挚的友谊。最后nodles走之间对Max说希望调查的结果没有问题，否则一生的忙碌到最后没有结果很遗憾。最后Max自杀，电影闪回了noodles去烟管吸烟的场景，最后电影定格在noodles的笑容中。</p>\n<p>最近看了好几遍电影的后面部分，还是有些理解不好nooldes最后的笑容，不过渐渐地理解noodles的: I hava a story alse(我也有一个关于你说的故事).也许人生的价值或者意义就在于我们的看法。同样的人生也会因为看法不同导致感受。</p>\n<p>----一个长的引子的分割线----</p>\n<h2>什么是价值</h2>\n<p>亚里士多德将生活分为三类：动物式的生活，政治的生活和沉思的生活。</p>\n<ul>\n<li>动物式的生活指受到动物本能的指引，在缺少理智的参与下，过着无节制的生活</li>\n<li>政治的生活指人具有社会属性，可以放弃一些动物的本能去追求荣誉、善</li>\n<li>沉思的生活指通过思考达到精神的愉悦状态</li>\n</ul>\n<p>我理解在对这三种生活划分的时候，是没有贬义的，因为我们都或多或少的因为生活的阶段、能力的限制在间插似的体验不同的生活。在这个过程中不可避免的会对我们做的事，过的生活进行思考。这里其实就引入了价值的思考。如果生活的最终目的是幸福，当然这个幸福是相对的主观的。也许一个人的幸福是到老了回忆起年轻的一个蠢事或者儿孙满堂或者家缠万贯，幸福的定义虽有不同却大致相似。那价值就是那些拓宽我们关于幸福定义的事。</p>\n<h2>追求价值的方式</h2>\n<p>在去年开始相对集中的阅读，因为觉得自己在好像还看不明白一些事也想不明白。最近在看张维迎《经济学原理》一书中引发了我对价值这个问题的思考。在经济学中有个概念叫-生产可能性边界，用来表示经济社会在既定资源和技术条件下所能生产的各种商品最大数量的组合。这里可以用这个边界来类比幸福的范围.那我们生活的目标就集中在如何扩大幸福的边界和范围了。<br>\n我想年龄的焦虑一个主要的原因可能是在可见的未来能预测到幸福的边界会收缩，比如职场的35岁年龄焦虑，认为在未来年龄不在具有竞争力，那幸福的面积就可预测的缩小了。所以我理解追求幸福其实就是个逐步的拓宽边界的行为。这个行为可以很简单，比如早起、多运动、多陪伴家人。也可以相对复杂，比如创办一个家乡企业、写一本有意思的书。也可以比较抽象，比如在夏天的时候做个清凉的白日梦、在冬天的时候听听雪。</p>\n<h2>价值的相对性</h2>\n<p>说到底人生经历的事情还是自己和最亲密的人一起经历的，那价值就有很强的主观性，如果一直想让自己适应社会的价值想法会一直处于比较较劲的状态。不过关于价值这个问题自己也没有想的特别明白，也希望自己能一直想想这个问题。也希望跟看到这里的你一起想好这个问题，也许当有天有人带着鄙夷的语气问你生活的价值和意义的时候，你会告诉他: I hava a story alse(我对人生有不同的看法)</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"关于价值的一点想法","date":"2023-02-26","tags":"思考","path":"/thought-about-value","top":null,"summary":null}}},{"node":{"id":"4aeddc08-5bbe-5228-a3e4-90e1eae191bd","html":"<h2><a href=\"https://www.builder.io/blog/structured-clone\">Deep Cloning Objects in JavaScript, the Modern Way</a></h2>\n<p>structured-clone是在结构化克隆算法的基础上实现的克隆方案。结构化克隆算法会有一些限制:</p>\n<ul>\n<li>Function对象和DOM节点是不能被结构化克隆算法复制,会抛出DATA_CLONE_ERR</li>\n<li>对象的某些特定参数也不会被保留,比如RegExp 对象的 lastIndex 字段不会被保留、属性描述符、原型链上的属性等</li>\n</ul>\n<p>对比几种clone方案:</p>\n<ul>\n<li>对象扩展符和Object.assign不能实现深克隆</li>\n<li>JSON.parse(JSON.stringify(x))  JSON.stringify无法处理循环引用数据、丢失内置类型(Map/Set/Date/Symbol等)、无法复制函数</li>\n<li>cloneDeep是一个比较成熟的方案，但是它的包体积有点大材小用(在平时的使用中其实很少用到那么复杂结构的数据)</li>\n</ul>\n<h2><a href=\"https://jakearchibald.com/2023/unhandled-rejections/#unhandled-rejections-are-problematic\">The gotcha of unhandled promise rejections</a></h2>\n<p>这篇文章介绍for wait中unhandled promise的处理方式</p>\n<h2><a href=\"https://blog.codeminer42.com/everything-you-need-to-know-about-concurrent-react-with-a-little-bit-of-suspense/\">Everything you need to know about Concurrent React (with a little bit of Suspense)</a></h2>\n<p>这篇文章介绍React Concurrent mode.通过例子引入Concurrent mode中高优先级和低优先级任务的处理，比较生动。</p>\n<h2><a href=\"https://www.macarthur.me/posts/options-for-removing-event-listeners\">You’ve Got Options for Removing Event Listeners</a></h2>\n<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/axios-cancel\">axios的cancel功能源码解读</a>中axios已经AbortController来实现请求的终止，这篇文章中介绍了使用AbortController实现网页中元素绑定事件的移除</p>\n<h2><a href=\"https://deno.com/blog/the-future-of-web-is-on-the-edge\">The Future of the Web is on the Edge</a></h2>\n<p>这篇文章简单介绍Serverless的概念，可以结合<a href=\"https://juejin.cn/post/6996271746898722830\">为什么我不使用Serverless</a>，<a href=\"https://www.zhihu.com/question/506704568\">如何评价无服务器计算（serverless）的未来前景？你认为 serverless 有未来吗？</a>进一步了解Serverless</p>\n<h2>工具</h2>\n<h3><a href=\"https://mafs.dev/\">Mafs</a></h3>\n<p>实现可交互的数学视图的React库</p>\n<h3><a href=\"https://github.com/mswjs/msw\">msw</a></h3>\n<p>一个支持在浏览器和node环境中实现Mock Server的库，在浏览器中它通过Service Worker或者通过拦截原生的fetch实现mock，在node中通过拦截器封装原生的http模块实现mock.</p>\n<h3><a href=\"https://github.com/nolimits4web/swiper\">swiper</a></h3>\n<p>移动端的swiper组件，有比较多的动效支持</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/7044934738431180830\">最新HTML规范——structuredClone深拷贝函数，能取代JSON或者lodash吗？</a>\n<a href=\"https://stackoverflow.com/questions/59694309/for-await-of-vs-promise-all\">for await of VS Promise.all</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2023-2-1-前端快报","date":"2023-02-13","tags":"前端快报","path":"/2023-2-1","top":null,"summary":null}}},{"node":{"id":"240f03c5-3aa3-5133-a076-80d06778e48d","html":"<p>这里记录下2023读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2023年已阅读: 14本</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>张维迎寓言经济学 岑科 傅小永 邓新华</h2>\n<h3>推荐指数 4</h3>\n<p>通过寓言比喻的方式阐述了经济学,自由市场,国企等相关观点 一些观点难免有些激进 不过需要不同的观点来冲撞才有不同的视角来看世界,推动改革.张老师对于自由市场和国企改革的想法很多,也让我对大国企和自由市场有了一些简单的思考.改革是大题,需要慢慢答,特别是在人口超规模的中国,无论如何希望还是拥有改革开放时候的魄力,能积极改进</p>\n<h2>美丽新世界 4.5 奥尔德斯·赫胥黎</h2>\n<h3>推荐指数 4.5</h3>\n<p>读过《1984》里面塑造了一个可怕和压抑的社会,但这个社会还有一些美好就是有主人公一样的角色在思考,在试图反抗\n《动物农场》则是用童话故事去反映团体中成员的无助和统治者的行为\n《美丽新世界》里面塑界了一个高度塑造的社会,有些毛骨悚然.通过作者后面的论证和文中的一些场景,似乎这样社会的某些方面已经在现实生活中发生</p>\n<h2>叫魂: 1768年中国妖术大恐慌 孔飞力</h2>\n<h3>推荐指数 4.5</h3>\n<p>作者从叫魂的一个小案件开始叙述,从社会背景多方面讲述了那段历史.其中看到了官僚制度与帝王制度的抵抗、百姓对于未知恐惧、权力的恐慌与无助</p>\n<h2>约翰·克里斯多夫 罗曼·罗兰 许渊冲译</h2>\n<h3>推荐指数 5</h3>\n<p>在初高中有段时间比较喜欢看书，在书店总能看到这本《约翰·克里斯多夫》，印象中在书架上摆放了上中下三本，深灰色的包装。当时觉得这么长的书肯定不好看。这次鼓足了气翻开了这本书，一下子就被吸引住了。罗曼罗兰对于细腻情感的把握真的很好，比较能打动人。喜欢文中对自然景色，人物性格的描写都扣人心弦。在书中跟随着克里斯多夫走完了他的一生，从最开始莽莽撞撞的小伙子到最后老年的平静，在他身上似乎总有一种火在燃烧，那朵火并没有因为年龄或者阅历而熄灭。最开始喜欢克里斯多夫不断碰壁的莽撞的性格，从德国到巴黎，中间夹杂了很多对艺术的描写。现在的我也许还不能对这些艺术的描写有那么深的领悟，只能体会到艺术或者音乐在磨难中一直陪伴着克里斯多夫。克里斯多夫还有真诚的性格，他与奥利维的友谊一直延续到他人生的终点，从现实的生活中很难发现这样的友谊当然也很羡慕这种友谊。在爱情上似乎一直都有暗线在行进，后面与葛拉齐亚的故事是有克制的爱情，那种相知多年的爱人的感觉，读起来也很温馨，推荐这本书，也许等到在成长一些在看一遍这本书会有不同的感悟</p>\n<h2>经济学原理 张维迎</h2>\n<h3>推荐指数 4.5</h3>\n<p>一直没有仔细阅读过经济学原理方面的书籍都是相对概括介绍的读物。本书系统的介绍了微观经济学和宏观经济学中的相关概念，有些知识点自己之前只是简单了解或者理解的不对都在阅读的过程中得到了深化，特别是宏观经济学中观于经济周期与经济波动的部份读起来兴趣昂然。推荐</p>\n<h2>好好告别 凯瑟琳·曼尼克斯</h2>\n<h3>推荐指数 4</h3>\n<p>本书从临终的模式开始说起，讲到对待死亡的告别方式、态度、谈论死亡的时机、对生命的预期、对生命的看法。书中的故事很有趣也很感人，作者的叙事方式感觉就像在你身边跟你讲一件熟悉的事一样。推荐这本书，能激发一些思考，对死亡的准备和人生的意义</p>\n<h2>你是你吃出来的: 吃对少生病，病了这样吃 夏萌</h2>\n<h3>推荐指数 3.5</h3>\n<p>对饮食跟身体的关系有了全新的认识，书的内容不错从营养素的介绍到缺乏对应营养素身体的反应都讲解的通俗易懂。适合快速翻阅</p>\n<h2>理想国 柏拉图</h2>\n<h3>推荐指数 4</h3>\n<p>理想国是论证一个理想的城邦或者国家应有的样子，包括教育、统治者、人的行为等。通过对话辩论的方式阐释观点，其中会有些晦涩难懂或者绕的方式。不过并没有掩盖书中的一些重要的观点。</p>\n<ul>\n<li>要注重身体各部分的感受，感受身体和灵魂</li>\n<li>感受事物的真实，对观察思考</li>\n<li>要有求知欲，去看更广阔的世界</li>\n<li>精力有限，要追求更‘好’的欲望</li>\n</ul>\n<h2>芯片战争 余盛</h2>\n<h3>推荐指数 4</h3>\n<p>因为在A股有投资半导体企业所以通过这本书来了解半导体整个行业的背景和现状。书中详细的介绍全球半导体的发展过程。日本半导体的崛起和衰落、韩国半导体的崛起、荷兰的阿斯麦尔的发展过程读起来都饶有兴致。书中对于中国半导体行业的发展介绍的也很详细。让我了解到了一些中国半导体的至暗时刻，也看到国内半导体行业为突破技术封锁的尝试。作为一本介绍半导体行业的书本书通俗易懂，故事性强，推荐阅读。</p>\n<h2>农民笔记 候永禄</h2>\n<h3>推荐指数 3.5</h3>\n<p>跟着书读完作者的一生,经历了那些只在书本中的年代,书的名字是农民笔记。但是作者是一个有知识、思考、坚持的人,在那些年代很不容易.很感谢这本书让那些年代的记忆鲜活了，也让我意识到在自己的内心中有坚持也能过好一生</p>\n<h2>一个无政府主义者的意外的意外死亡 达里奥·福</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过剧本的方式呈现生动有趣的故事，描述的细节很精彩感觉人物栩栩如生，推荐</p>\n<h2>蛤蟆先生去看心理医生  罗伯特·戴博德</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过这本书跟着蛤蟆先生一起成长。成长的过程在于认识自己的内心，去理解自己的情绪，摆脱过去消极的思维模式。很有意思的故事。推荐</p>\n<h2>疯人说: 精神病院医生手记 穆戈</h2>\n<h3>推荐指数 4</h3>\n<p>书的内容是讲述在精神病院中病人的故事，精神病人的故事很有意思，通过对故事了解了精神病相关的背景知识。感受最深的一点就是家庭的因素对精神病人病情影响很大。比如索引病人，其实就是这个家庭成员状态的索引，需要调整好家庭的状态病人回归家庭才能好。小说有意思的是把几个精神病人的故事连成了一个故事，这个故事的命题</p>\n<ul>\n<li>你是相信世界是不好的但怀着热情生活</li>\n<li>你知道世界不好选择无视他或者逃避它生活下去</li>\n</ul>\n<p>很有意思的小说，虽然部分剧情比较牵强，但是不影响整体，推荐</p>\n<h2>百年孤独 加西亚·马尔克斯</h2>\n<h3>推荐指数 5</h3>\n<p>记不清是第几次准备看这本书了，每次都是被开头的人物名字弄迷糊然后就放下了。这次耐下心来一周就看完了。百年孤独有故事的魔幻性、历史的厚重和轮回。在书中见证了一家人从最开始的兴旺到没落。结尾中破解了羊皮卷发现内容就是预言整个家族的事的时候很震撼。</p>\n<ul>\n<li>似乎并没有理解好文中孤独的概念。孤独是不是就是上校重复制作的小金鱼(对生活失去了理想只是让自己有事可做)或者是不想织不完的寿衣(不想面对老去的现实)。</li>\n<li>有种空虚感，文中人物故事的轮回，我们自己的人生也是否是空欢喜一场，上校会被人忘记，事实也会被篡改</li>\n</ul>\n<p>推荐，是本值得反复品味的书</p>","fields":{"readingTime":{"text":"12 min read"}},"frontmatter":{"title":"读书目录-2023","date":"2023-01-28","tags":"读书目录","path":"/book-list-2023","top":null,"summary":null}}},{"node":{"id":"b554705e-f1cc-52f6-ab7b-0159784362a1","html":"<h2><a href=\"https://github.com/reactwg/react-18/discussions/37\">New Suspense SSR Architecture in React 18</a></h2>\n<p>这篇文章介绍react 18中流式渲染和Suspense的结合，实现更好的服务端渲染功能。相关文章还有<a href=\"https://juejin.cn/post/7064759195710521381\">浅析React 18 Streaming SSR</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍2022年热度比较高的React库</p>\n<h2><a href=\"https://developer.aliyun.com/article/781882\">一文详解 CSS-in-JS</a></h2>\n<p>这篇文章从CSS规范、CSS的设计模式说起，逐步覆盖到CSS-in-JS的细节，涉及的相关背景比较多，值得仔细阅读。</p>\n<h2><a href=\"https://weizman.github.io/page-what-is-a-realm-in-js/#identity-discontinuity\">What is a realm in JavaScript?</a></h2>\n<p>这篇文章介绍JavaScript中Realm的定义。也可以结合这篇<a href=\"https://2ality.com/2022/04/shadow-realms.html\">ShadowRealms – an ECMAScript proposal for a better eval()</a>介绍ShadowRealms API提议的文章一起了解。</p>\n<h2><a href=\"https://roadmap.sh/roadmaps/\">Developer Roadmaps</a></h2>\n<p>Developer Roadmaps收集了各个开发方向的技能路线图</p>\n<h2><a href=\"https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo\">How we configured pnpm and Turborepo for our monorepo</a></h2>\n<p>一篇比较详细的介绍monorepo技术方案选择工具的文章，从多项目开发的问题开始说起，逐步介绍<a href=\"https://github.com/pnpm/pnpm\">pnpm</a>(monorepo管理工具)和<a href=\"https://github.com/vercel/turbo\">Turborepo</a>(打包构建工具)</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart\">js-code-to-svg-flowchart</a></h3>\n<p>一个将JavaScript代码转化成svg图片的库。</p>\n<h3><a href=\"https://console-ninja.com/\">CONSOLE NINJA</a></h3>\n<p>一款VSCode插件，可以直接在代码中查看输入的console调试信息</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/shuding/react-wrap-balancer\">react-wrap-balancer</a></h3>\n<p>react-wrap-balancer能使文案比较智能的适应容器，占据容器的空间，达到比较好的展示效果，下面从源码上看它是如何实现的:\n<img src=\"/blog/9336733f998bb911bd52006bac3dd61b/blancer.gif\" alt=\"react-wrap-balancer\">\n通过简单的demo使用可以发现balancer在页面中注入了一段脚本并且为包裹的文本内容绑定的属性标识\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.399999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsklEQVQI1y3J3Y6CMBRFYd7/ySbjDx6BIkiZOjFWhFPUGAtXa6LOxUr2zpeYRYVvSqxpsbseDTNB72jfo/0V1cioAb2M+C5y6p4M44S/RI7+STdEumHi3Md3yXpZUpUtmQhbMUjWkhc7RIR0k1PbI3lh2EjB97omzR1iWpayZ7W1iHGkmeVrVVLZE0kunroJ1O5G1QSaw5Xa39mfH/zoxCFMOJ3/d+R3nHEa373s45//sj/d/dswZf2NSQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"balancer-show\"\n        title=\"balancer-show\"\n        src=\"/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png\"\n        srcset=\"/blog/static/209d5af74aebd83c377943dd2258a96b/63868/blancerShow.png 250w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/0b533/blancerShow.png 500w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png 1000w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png 1088w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>    // react-wrap-balancer的主体代码逻辑\n    const Balancer: React.FC&#x3C;BalancerProps> = ({\n        as: Wrapper = 'span',\n        ratio = 1,\n        children,\n        ...props\n    }) => {\n        // 利用useId为组件生成唯一标识，useId可以根据组件的层级结构生成唯一标识\n        const id = React.useId()\n        const wrapperRef = React.useRef&#x3C;WrapperElement>()\n        const hasProvider = React.useContext(BalancerContext)\n\n        // 监听函数执行\n        // useIsomorphicLayoutEffect这里对服务端和客户端做了区分 在服务端调用useEffect,在客户端调用useLayoutEffect 解决客户端的闪动问题\n        useIsomorphicLayoutEffect(() => {\n            if (wrapperRef.current) {\n            // 调用绑定self上绑定的动态调整函数 并传入当前的入参执行\n            // self可以指代全局的window https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n            // 主要计算逻辑都在relayout函数中\n            ;(self[SYMBOL_KEY] = relayout)(0, ratio, wrapperRef.current)\n            }\n        }, [children, ratio])\n\n        // 自己卸载的时候 终止监听函数\n        useIsomorphicLayoutEffect(() => {\n            return () => {\n                if (!wrapperRef.current) return\n\n                const resizeObserver = wrapperRef.current[SYMBOL_OBSERVER_KEY]\n                if (!resizeObserver) return\n\n                resizeObserver.disconnect()\n                delete wrapperRef.current[SYMBOL_OBSERVER_KEY]\n            }\n        }, [])\n\n        return (\n            &#x3C;>\n                &#x3C;Wrapper\n                    {...props}\n                    // 绑定的唯一标识\n                    data-br={id}\n                    data-brr={ratio}\n                    ref={wrapperRef}\n                    style={{\n                    display: 'inline-block',\n                    verticalAlign: 'top',\n                    textDecoration: 'inherit',\n                    }}\n                    suppressHydrationWarning\n                >\n                    {children}\n                &#x3C;/Wrapper>\n                {createScriptElement(hasProvider, `self.${SYMBOL_KEY}(\"${id}\",${ratio})`)}\n            &#x3C;/>\n        )\n    }\n</code></pre>\n<p>通过上面的源码分析，主要的动态计算逻辑都在relayout函数中</p>\n<pre><code>    const relayout: RelayoutFn = (id, ratio, wrapper) => {\n        // 根据id获取包裹的wrapper组件\n        wrapper =\n            wrapper || document.querySelector&#x3C;WrapperElement>(`[data-br=\"${id}\"]`)\n        // wrapper的父容器\n        const container = wrapper.parentElement\n        // 更新wrapper的最大宽度\n        const update = (width: number) => (wrapper.style.maxWidth = width + 'px')\n\n        // 重置wrapper的最大宽度\n        wrapper.style.maxWidth = ''\n\n        // 获取wrapper的父容器的宽高\n        const width = container.clientWidth\n        const height = container.clientHeight\n\n        // 二分查找的方式计算wrapper的宽度\n        let left: number = width / 2\n        let right: number = width\n        let middle: number\n\n        if (width) {\n            while (left + 1 &#x3C; right) {\n                middle = ~~((left + right) / 2)\n                update(middle)\n                if (container.clientHeight === height) {\n                    // 缩放后 高度没有变 那么right= middle\n                    right = middle\n                } else {\n                    // 否则right = middle\n                    left = middle\n                }\n            }\n\n            // 更新wrapper的宽度\n            update(right * ratio + width * (1 - ratio))\n        }\n\n        // 通过ResizeObserver去监听wrapper父容器的变化 执行relayout函数\n        if (!wrapper['__wrap_o']) {\n            ;(wrapper['__wrap_o'] = new ResizeObserver(() => {\n            self.__wrap_b(0, +wrapper.dataset.brr, wrapper)\n            })).observe(container)\n        }\n    }\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null}}},{"node":{"id":"284f1e7f-d1ea-5347-a1de-ee281477dfef","html":"<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/react-hooks\">React Hooks源码解读</a>中有对React hooks的实现原理进行分析，本文主要结合React hooks的发展过程聊下对hooks的理解。hooks的提出主要解决了以下的问题:</p>\n<ul>\n<li>为react带来通用的代码逻辑复用的方式。相对于render props/高阶组件(HOC)等，hooks在代码复杂度上都有一定降低。声明式的hooks使用方式也符合函数式编程的思想。</li>\n<li>解决类组件生命周期函数复杂度和在新的react架构中的一些问题</li>\n<li>规范react使用范式，通过hooks的接口能更好的组织组件与组件/组件与渲染的原生DOM/组件与外部依赖之间的关系</li>\n</ul>\n<h2>通用的代码复用方式</h2>\n<p>react中可以通过render props/高阶组件(HOC)实现代码的能力的复用(组合)。</p>\n<pre><code>// render props通过传入渲染函数的方式复用逻辑\nclass Cat extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = { name: 111 }\n        // 可复用的逻辑\n    }\n    render() {\n        // 通过调用渲染函数的方式实现共享\n        return this.props.render(this.state)\n    }\n}\nclass App extends Component {\n    render() {\n        return (\n            &#x3C;Cat render={params => (&#x3C;div>{params.name}&#x3C;/div>)} />\n        )\n    }\n}\n// 高阶组件\nfunction HOC(WrappedComponent) {\n  return class extends Component {\n    componentDidMount() {\n      // 通用的业务逻辑\n    }\n    render() {\n      return (&#x3C;WrappedComponent {...this.props} />)\n    }\n  }\n}\n</code></pre>\n<p>从render props和高阶组件的实现方式上看，两者都引入了新的组件结构来实现复用，增加了理解成本从而导致一些问题。笔者在最开始对高阶组件不熟悉的时候就遇到过一次bug。包裹的高阶组件没有将外层传递的属性透传给被包裹的组件从而导致子组件渲染异常。<br>\nhooks通过函数声明式的方式实现代码复用，理解上更符合可见可得的思想，减少了理解成本。</p>\n<h2>解决老的问题</h2>\n<p>类组件的生命周期问题导致代码逻辑的分离，比如事件的监听与解绑</p>\n<pre><code>// 类组件示例\nclass Test extends Component {\n    componentDidMount() {\n        // 监听\n        document.addEventListener()\n    }\n    componentWillUnmount() {\n        // 解绑\n        document.removeEventListener()\n    }\n    render() {}\n}\n// 函数式组件示例\nfunction Test(props) {\n    useEffect(() => {\n        // 监听\n        document.addEventListener()\n        return () => {\n            // 解绑\n            document.removeEventListener()\n        }\n    }, [])\n    return xxx;\n}\n</code></pre>\n<p>在Concurrent Mode中会导致生命周期函数的多次执行，hooks的提出在结构上是与Fiber结构绑定的，服务于新的架构的</p>\n<h2>规范使用范式</h2>\n<p>react开发者都需要用一些库(redux等)来组合应用，react通过hooks为react增加了状态管理、操作DOM的入口、父子组件调用方式等，丰富且规范了React开发者的开发模式。通过这种规范可以让React更好的与社区结合，比如相关的库<a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>、<a href=\"https://github.com/streamich/react-use\">react-use</a>。</p>\n<h2>hooks使用注意</h2>\n<ul>\n<li>避免hooks依赖，比如useMemo/useCallback等是否需要使用。使用多个useState的时候是否引入其他的管理库来解</li>\n<li>UI逻辑与业务逻辑合理拆分。hooks做过多的业务逻辑会导致业务逻辑不明晰，需要进行适当的拆分。</li>\n<li>hooks的依赖问题会导致业务中存在隐藏逻辑，需要控制代码中隐藏逻辑</li>\n<li>hooks更适合组件级别的代码复用和逻辑,跨组件逻辑需要仔细设计(比如是否需要useRef)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null}}},{"node":{"id":"fa80434f-17f1-5530-a3b5-0070b8a2482d","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\n    logMessage(user, message) {\n        const sender = user.getName();\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\n    }\n}\nclass User {\n    constructor(name, chatroom) {\n        this.name = name;\n        this.chatroom = chatroom;\n    }\n\n    getName() {\n        return this.name;\n    }\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\n    send(message) {\n        this.chatroom.logMessage(this, message);\n    }\n}\nconst chatroom = new ChatRoom();\nconst user1 = new User(\"John Doe\", chatroom);\nconst user2 = new User(\"Jane Doe\", chatroom);\nuser1.send(\"Hi there!\");\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\nconst books = new Map();\nconst createBook = (title, author, isbn) => {\n    const existingBook = books.has(isbn);\n    if (existingBook) {\n        // 已存在就查找返回\n        return books.get(isbn);\n    }\n    // 不存在新建返回\n    const book = new Book(title, author, isbn);\n    books.set(isbn, book);\n    return book;\n};\n//  存储书的列表\nconst bookList = [];\nconst addBook = (title, author, isbn, availability, sales) => {\n    const book = {\n        // 利用之前的共享对象创建新的实力\n        ...createBook(title, author, isbn),\n        sales,\n        availability,\n        isbn\n    };\n    bookList.push(book);\n    return book;\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\n    class OrderManager {\n        constructor() {\n            // 指令处理的对象\n            this.orders = [];\n        }\n\n        execute(command, ...args) {\n            // 匹配指令和指令处理的对象\n            return command.execute(this.orders, ...args);\n        }\n    }\n    // 指令创建类\n    class Command {\n        constructor(execute) {\n            this.execute = execute;\n        }\n    }\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\n    function PlaceOrderCommand(order, id) {\n        return new Command(orders => {\n            orders.push(id);\n            return `You have successfully ordered ${order} (${id})`;\n        });\n    }\n    const manager = new OrderManager();\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":2,"pageCount":15,"additionalContext":{"pageAllCount":90,"allPage":[{"id":"6b14bd4d-1cc8-57ef-b81a-bdbe405e6d96","html":"<h2>1.0 - 2017-02-25</h2>\n<blockquote>\n<p>在这里记录下学习前端的过程。最近在博客园写自己之前的博客的时候，发现自己不是很善于描述东西，也发现博客园的书写体验没那么好，之前一直想弄一个这样的博客，这就算成型了。<br>\n希望通过这个博客来锻炼自己表达的能力同时起到督促自己目的。</p>\n</blockquote>\n<h2>2.0 - 2021-04-08</h2>\n<p>看到这个文档上次的修改记录已经是三年之前了,个人的博客在三年中有一直保持更新(虽然频率上😢不高).应该在去年建了一个公众号-前端小板凳和掘金账号.\n小板凳的初衷是我能跟大家一起坐在板凳上一起学习进步(我要是在胖下去 小板凳要变成大板凳了➳♥゛扎心),最近重新理了下思路以后小板凳和这个博客会主要以如下的内容进行更新(虽然搞不好哪天就不更了).\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVQ4y4WTW27bMBBFvfkC/elG0gL96Bby0zU0sRtbUiQ/JFKkxJfEU4iObSmNWwIEyBnO697LFW8rxpj2tNpWUdc1LoDqHFVVkRcFzrnr2/cxl/vqYjw7IsbB/nAiz3M6C6I1PK/XlGVFCOFuosv9lvDNaf3s4dStNuz3e6x1DMNACMMiwbIhWL2v0jvIipL1ek3bR6qjZrPZIISkrhuU1peARZezkWEYIQyRYTwn9D7gncMH6I1HqXYRNHU6xsg4jmnPu12dB7tVcn5ZWXeGXZahdYcNUJZ7mkYyRJCtQgix7FCbyLfHyMNj5MfPiOwhL0q2ux2diXQmIKXAOo/1E2EHXssDjdDkecHLy5bT6cQwjmcMawWfHuDz18iX75FGwzAEvPcJiq63STbWj3Q2opRCa40xPcbYhOkks/GSkAWnERfmcoBWTSwfkmTOmC2J+ICUmACegqfzpL3itSLLdigDeSkTy00jrlqdS+Uv2dwM5yrGRYx1WGsSZrXoF8D/V9hz45R1+inGWpzzyS6k4tfTE1LKNLa19orX3a83d04jZ3nJ8+Y3ou2RsuV4PNI0TQK/ESIRdjfh0hETs3Uj2G53lFX1TwI+GvkP6qVFIVq+nLwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"技术路线\"\n        title=\"技术路线\"\n        src=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png\"\n        srcset=\"/blog/static/23113f1a1ccecdfec79664828aa645e9/63868/road.png 250w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/0b533/road.png 500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/00d43/road.png 1000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/aa440/road.png 1500w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/e8950/road.png 2000w,\n/blog/static/23113f1a1ccecdfec79664828aa645e9/ad1ae/road.png 2270w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>前端基础</h3>\n<ol>\n<li><a href=\"https://html.spec.whatwg.org/#toc-browsers\">HTML Standard</a> html标准</li>\n<li><a href=\"https://tc39.es/ecma262/\">javascript标准</a></li>\n<li>网络基础知识</li>\n</ol>\n<h3>前端框架</h3>\n<ol>\n<li>react</li>\n<li>前端状态管理(redux, hook, Mobx)</li>\n<li>next.js</li>\n<li>webpack</li>\n</ol>\n<h3>横向技术</h3>\n<ol>\n<li>跨端(端)技术</li>\n</ol>\n<ul>\n<li>跨端技术 flutter taro</li>\n<li>端技术 Android/ IOS</li>\n</ul>\n<ol start=\"2\">\n<li>服务端技术</li>\n</ol>\n<ul>\n<li>node.js egg.js(如何构建一个高可用的服务端系统)</li>\n<li>go</li>\n</ul>\n<h3>解决方案</h3>\n<ol>\n<li>微前端方案</li>\n<li>离线化(预加载)</li>\n<li>拆包</li>\n<li>骨架</li>\n<li>服务端渲染</li>\n</ol>\n<h3>工程化</h3>\n<ol>\n<li>服务部署运维(docker Kubernetes)</li>\n</ol>\n<h3>思考(做事方式)</h3>\n<p>这里会记录一些思考,会随着自己的认知定期修改这部分内容.一些内容会沉淀成记录\n要从把事做完到做好到做广.</p>\n<ol>\n<li>数据 => 业务</li>\n<li>做好监控(用户行为 异常监控)</li>\n<li>如何能做到业务技术两手抓</li>\n<li>探索推进业务的方式(往前看 多聊, 视角的切换(长期短期 用户视角))</li>\n<li>先想好在做 别急 这点不容易</li>\n</ol>\n<p>希望2.0版本能把我们的知识串成一个网,一起把事做好.希望事情会因你不同.</p>\n<h2>3.0-2022-04-12</h2>\n<p>距离上次更新这个文档差不多刚好一年的时间，博客的内容也大致按照之前2.0版本的内容在更新(万幸没有断更)。3.0版本的内容会在2.0的基础上更加<strong>系统化</strong>。这里对3.0版本的内容做下diff:</p>\n<ul>\n<li>形式上会结合做过的事或者看过的内容，结合自己的想法总结和输出(虽然有些想法比较基础和简单)，也是想在自己这边能把一些东西揉碎想明白的一种尝试，现在主要有以下两种方式:\n<ol>\n<li><a href=\"https://icantunderstand.cn/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\"><strong>前端快报</strong></a>收录近期阅读的前端技术类文章，月维度更新</li>\n<li><a href=\"https://icantunderstand.cn/%E8%AF%BB%E4%B9%A6%E7%9B%AE%E5%BD%95/\"><strong>读书目录</strong></a>收录自己读过的书和阅读过程中的一些想法，采取了打分推荐的方式(有个人喜好)，根据读书进度实时更新。</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"初心","date":"2019-07-10","tags":"思考","path":"/my-heart","top":true,"summary":null},"title":"初心","date":"2019-07-10","tags":"思考","path":"/my-heart","top":true,"summary":null},{"id":"01f5df8e-fe02-530b-b203-a191cd46eebf","html":"<ul>\n<li>要有刨根问底的精神</li>\n<li>多思考这件事为什么是这样</li>\n<li>提取事物相同的模式 从更上层或者多角度去看相似的问题</li>\n<li>有深度的刻意练习才能产生提高</li>\n<li>做技术 可以从技术角度去产生技术方案也可以从用户产品视角去思考技术 不要把这两个孤立开来</li>\n</ul>\n<h2>跨端的本质</h2>\n<p>一句话概括: 如何技术手段以较低成本和较高的稳定性实现端业务的快速发展\n在讨论具体的跨端方案时，先看几个在选择跨端方案的场景</p>\n<table>\n<thead>\n<tr>\n<th>目标</th>\n<th>考量点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>动态化</td>\n<td>1. 包体积问题是一个app发展到一定阶段必定要考量的问题，也是一些大厂在内部推动跨端方案的一个核心诉求 2. 业务动态化诉求(快速迭代/动态更新)</td>\n</tr>\n<tr>\n<td>人效</td>\n<td>跨端方案可以实现一次开发多端使用，提升人效 1. 原生能力需要端接入或者端技术能力，长期需要多端技术能力 2. 多端展现存在差异，需要开发中磨平 3. 通常说跨端都从h5(动态化技术)的视角切入，h5和native不是非此即彼的关系，事是大家的</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>技术方案存在性能瓶颈，通过其他技术方案可以解决性能问题，优化业务体验</td>\n</tr>\n<tr>\n<td>技术基建能力</td>\n<td>1. 技术储备 2. 业务在不同技术方案下探索(小程序)</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"想法片段总结","date":"2020-12-21","tags":"思考","path":"/idea","top":true,"summary":null},"title":"想法片段总结","date":"2020-12-21","tags":"思考","path":"/idea","top":true,"summary":null},{"id":"b291531c-f09d-5949-920b-5523a387a6ab","html":"<h2><a href=\"https://frontendmastery.com/posts/rethinking-react-best-practices/\">Rethinking React best practices</a></h2>\n<p>这篇文章介绍React发展的过程，从SPA的方式开始，讲述SPA存在的一些问题，然后React在服务端有一些尝试为了解决SPA的问题，引入Suspense、流式渲染、React Server Component等。在文章开头对软件开发中的问题的描述很有意思: 人的问题&#x26;技术的问题。非常不错的文章</p>\n<h2><a href=\"https://www.jvandemo.com/a-10-minute-primer-to-javascript-modules-module-formats-module-loaders-and-module-bundlers/\">A 10 minute primer to JavaScript modules, module formats, module loaders and module bundlers</a></h2>\n<p>这篇文章简要的介绍了JavaScript中模块的发展历史，包括IIFE、AMD、CMD、UMD、System.register、ES6模块等</p>\n<h2><a href=\"https://www.honeybadger.io/blog/javascript-regular-expressions/\">Regular expressions in JavaScript</a></h2>\n<p>这篇文章介绍JavaScript中的正则表法式，详细的介绍了正则表达式的创建、使用、匹配等</p>\n<h2><a href=\"https://www.bbss.dev/posts/eventloop/\">Practical Guide To Not Blocking The Event Loop</a></h2>\n<p>文章通过在node服务器中一个长时间执行任务阻断后续请求的例子来讲解如何防止阻塞时间循环，文中的配图通俗易懂\nwoqu</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/FormidableLabs/react-live\">react-live</a></h3>\n<p>一个实现预览react组件代码的库</p>\n<h3><a href=\"https://webcontainers.io/\">Dev environments.In your web app</a></h3>\n<p>可以在浏览器环境中运行node的工具</p>\n<h3><a href=\"https://shoelace.style/\">Shoelace</a></h3>\n<p>web components组件库</p>\n<h3><a href=\"https://github.com/typicode/lowdb\">lowdb</a></h3>\n<p>一个JSON存储数据库，支持在node/浏览器环境中使用</p>\n<h2><a href=\"https://github.com/hakimel/reveal.js\">reveal.js</a></h2>\n<p>一个实现网页演示文稿的工具</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2023-5-1-前端快报","date":"2023-05-01","tags":"前端快报","path":"/2023-5-1","top":null,"summary":null},"title":"2023-5-1-前端快报","date":"2023-05-01","tags":"前端快报","path":"/2023-5-1","top":null,"summary":null},{"id":"8e4245f7-613c-56fe-ba85-affb461a47c2","html":"<p>h5性能优化可以总结为如下的几个方向:</p>\n<ul>\n<li>将请求时间线上的行为提前执行</li>\n<li>将请求时间线上不紧急的后置</li>\n<li>将资源从最近的位置提供给页面</li>\n</ul>\n<p>在讨论h5加载性能的时候主要有以下角色:</p>\n<ul>\n<li>Native容器</li>\n<li>用户(开发的视角)</li>\n<li>服务端(数据 页面)</li>\n<li>h5页面</li>\n</ul>\n<p>本文会结合优化的方向从不同角色的角度总结h5优化的一些通用方案。</p>\n<h2>Native容器优化</h2>\n<ul>\n<li>Webview池 通过提前初始Webview和Webview复用降低Webview初始化时间</li>\n<li><a href=\"https://icantunderstand.cn/cross-platform-prefetch\">数据预取</a> 容器侧提供数据预取能力，提前数据加载</li>\n<li>DNS连接 容器提前建立与h5页面相同域名的DNS链接</li>\n<li><a href=\"https://icantunderstand.cn/cross-platform-offline\">离线包</a> 通过离线包可以直接加载提前下载好的本地资源展示</li>\n</ul>\n<h2>h5页面内优化</h2>\n<ul>\n<li>预连接 dns-prefetch, preconnect</li>\n<li>资源包拆分 框架和业务代码进行拆包，框架层使用更长的缓存策略来减少框架代码的请求</li>\n<li>页面资源加载 图片懒加载、路由懒加载、小图内联、模块动态加载</li>\n<li>js执行优化 缓存计算结果、WebWorker、GPU渲染、长列表优化</li>\n</ul>\n<h2>服务端优化</h2>\n<ul>\n<li>api聚合服务 前端侧可以通过一个请求聚合多个后端请求，后端在内网完成数据的聚合</li>\n<li>CDN容灾策略</li>\n<li>预渲染技术\n<ol>\n<li><a href=\"https://www.patterns.dev/posts/server-side-rendering\">SSR</a>(server-side rendering)服务端渲染,在服务端完成数据请求和html内容的生成返回给用户</li>\n<li><a href=\"https://www.patterns.dev/posts/static-rendering\">SSG</a>(static site generation)静态页面生成，SSG主要用于生成静态的网站比如博客等</li>\n<li><a href=\"https://www.patterns.dev/posts/incremental-static-rendering\">ISR</a>（Incremental Static Generation)渐进式静态内容生成，可以增量的方式在服务端生成新的内容和替换已有内容，对SSG的一种补充</li>\n<li><a href=\"https://www.patterns.dev/posts/react-selective-hydration\">Selective Hydration</a> 可选的注水 通过Suspense和pipeToNodeStream流式输入实现可选注水</li>\n<li><a href=\"https://www.patterns.dev/posts/islands-architecture\">Islands Architecture</a> 孤岛架构,可以实现静态和动态内容的分离渲染，可以对组件渲染更细粒度的控制</li>\n</ol>\n</li>\n</ul>\n<h2>用户</h2>\n<ul>\n<li>功能取舍 低端机放弃一些功能保证页面更流畅</li>\n<li>骨架屏 使用骨架屏在数据未返回时给用户更好的体验</li>\n<li><a href=\"https://blog.ihanai.com/2020/12/comparison-of-solution-for-same-layer-render.html\">同层渲染</a></li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://tech.meituan.com/2017/06/09/webviewperf.html\">WebView性能、体验分析与优化</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work\">渲染页面：浏览器的工作原理</a>\n<a href=\"https://blog.ihanai.com/2020/12/comparison-of-solution-for-same-layer-render.html\">同层渲染方案比较</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"web性能优化总结","date":"2023-03-15","tags":"跨端技术","path":"/h5-performance","top":null,"summary":null},"title":"web性能优化总结","date":"2023-03-15","tags":"跨端技术","path":"/h5-performance","top":null,"summary":null},{"id":"88a9e68d-ade0-51a0-ab18-73032ff76cd5","html":"<p>在维护大型项目的时候，随着项目功能的迭代会出现委会的一些痛点，比如</p>\n<ul>\n<li>页面打包、开发启动过程慢，模块间逻辑冗余，模块间功能依赖导致牵一发而动全身</li>\n<li>项目规范难以实行，不同模块同学开发的代码理解成本大</li>\n<li>功能和逻辑共享问题</li>\n</ul>\n<p>本文在以上问题的基础上，梳理自己对项目维护的一点思考</p>\n<h2>重新认识项目</h2>\n<p>不同的项目类型决定了项目不同的技术方案和业务发展模式，当前对项目维护上的一些决策是可以结合到当前的现状和未来的业务发展做提前规划的。比如在C端项目中会侧重于用户侧的性能和体验的探索，那么在技术方案上就会比较激进，要考虑好方案的回退等。在B端项目侧重于稳定性、功能流程的完善性，单个项目周期较长。长期项目和短期项目的思考点又有些不同。如果项目是作为服务模块提供给使用者，这个使用者可以是我们自身或者业务同事，那么就需要思考如何在不影响原有的架构模式上提供服务。</p>\n<h3>项目的组织方式</h3>\n<p>这里谈的是项目的拆分和聚合。可以通过monorepo的方式把依赖项目管理起来或者把不长维护的模块拆分出去。通用的模块拆出来进行维护，这里的拆可以是渐进的，先在项目维度进行拆分，防止过度拆分引起的后续维护问题.模块可以通过框架层面进行共享和注入。</p>\n<h3>模块之间的解耦(分层、共享)</h3>\n<p>代码不好维护有一定程度上跟模块的治理有关，模块间没有更好的做好分层，功能的拆分，就会导致业务逻辑分散，功能不聚合。\n在前端应用中，要思考业务、数据逻辑与视图逻辑的拆分</p>\n<h2>项目的规范(项目中的人)</h2>\n<p>项目中的规范是比较难实行的，比如设计到代码书写方式上的问题，不同人的理解真的很大不同，对于这部分应该要认可人之间的不同，在项目中建工具化的规范，通过工具去限制人的行为。比如lint 规范、大文件拆分、核心代码注释，尽可能通过框架去限制不合理的代码操作,这里举个例子比如项目中涉及到静态图片的展示，大图对用户的代码和体验都有损失，那么就可以通过编译时脚本来检查图片资源目录，当出现大图文件时中断编译或者通知。</p>\n<p>代码是与机器交互的语言,也是开发者之间交流的一种方式.之所以要提倡编写可维护的代码是希望在同一个团队中形成统一的方言.这种独特的方言要在一定程度上提高开发的效率(不好的方言有可能降低开发效率).也许团队这段时间会使用这种方言,过段时间会换另一种方言.自己的建议是多思考,多想想方言之间的不同,为什么这种模式会适应现在的场景,慢慢的你就会建立一种你自己的方言或者思考问题的方式.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.im/post/5b3ae175f265da63252c2f21\">代码质量与规范，那些年你欠下的技术债</a><br>\n<a href=\"https://www.zhihu.com/question/20017545\">好的提高代码质量的方法有哪些</a><br>\n<a href=\"https://overreacted.io/zh-hans/goodbye-clean-code/\">Goodbye, Clean Code</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"在聊维护项目的时候我们在聊什么","date":"2023-03-08","tags":"工程化","path":"/organize-code","top":null,"summary":null},"title":"在聊维护项目的时候我们在聊什么","date":"2023-03-08","tags":"工程化","path":"/organize-code","top":null,"summary":null},{"id":"1a5c275d-51a1-5b48-a911-e35eefd0ce40","html":"<h2><a href=\"https://dev.to/codux/experiments-with-the-javascript-garbage-collector-2ae3\">Experiments with the JavaScript Garbage Collector</a></h2>\n<p>这篇文章通过一些demo例子来理解JavaScript的垃圾回收</p>\n<h2><a href=\"https://martinfowler.com/articles/modularizing-react-apps.html\">Modularizing React Applications with Established UI Patterns</a></h2>\n<p>模块化、业务逻辑与视图分离是构建可维护性强应用的一些基础方式，这篇文章通过例子来说明模块化、抽象化的过程。仔细阅读有收获</p>\n<h2><a href=\"https://deno.com/blog/you-dont-need-a-build-step\">You Don't Need a Build Step</a></h2>\n<p>这篇文章通过前端代码的编译引出<a href=\"https://fresh.deno.dev/\">fresh</a>这个框架，fresh支持实时的编译和转换，现在已经有10k+的star,值得关注</p>\n<h2><a href=\"https://betterprogramming.pub/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42\">All JavaScript and TypeScript Features of the last 3 years</a></h2>\n<p>这篇文章介绍JavaScript和TypeScript最近三年的一些features,这里主要整理下avaScript的一些新features.\nES2020: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">可选链</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">空值合并运算符</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\">Promise.allSettled()</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\">globalThis</a><br>\nES2021: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\">String.replaceAll()</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\">Promise.any</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment\">逻辑空赋值</a><br>\nES2022: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await#%E5%9C%A8%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8_await\">Top level await</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn\">hasOwn</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-starter/\">How to start a React Project in 2023</a></h2>\n<p>之前关于react项目的starter工具引发了一波讨论，这篇文章介绍了(Vite)[<a href=\"https://vitejs.dev/%5D%E3%80%81(Next)%5Bhttps://nextjs.org/%5D%E3%80%81\">https://vitejs.dev/]、(Next)[https://nextjs.org/]、</a><a href=\"https://astro.build/\">Astro</a>作为React项目初始化的优点和缺点</p>\n<h2><a href=\"https://react.dev/\">React</a></h2>\n<p>react最新的文档站点，文档在入门的介绍上和api的查看上相对之前的文档站都有一定的提升</p>\n<h2>工具</h2>\n<h2><a href=\"https://github.com/vadimdemedes/ink\">ink</a></h2>\n<p>一个可以在命令行中写React代码的工具库</p>\n<h2><a href=\"https://github.com/lucaong/minisearch\">MiniSearch</a></h2>\n<p>MiniSearch是一个实现搜索功能的库,他运行在内存中，有模糊搜索等能力，在博客的站点上试用了一下感觉还不错</p>\n<h2><a href=\"https://github.com/rogchap/v8go\">v8go</a></h2>\n<p>用Go语言执行javascript</p>\n<h2><a href=\"https://github.com/microsoft/playwright\">playwright</a></h2>\n<p>Playwright是一个微软出品的web测试和自动化工具，github上的star已经49k</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2023-3-1-前端快报","date":"2023-03-01","tags":"前端快报","path":"/2023-3-1","top":null,"summary":null},"title":"2023-3-1-前端快报","date":"2023-03-01","tags":"前端快报","path":"/2023-3-1","top":null,"summary":null},{"id":"e3ace596-3e3b-503f-9749-e050e7ba90aa","html":"<p>在聊关于价值的一点想法之前，请让我介绍一部我喜欢的电影作为引子-Once upon a time in America(美国往事)。我微信的昵称是noodles，也是因为这部电影。</p>\n<p>美国往事是一部讲述美国20世纪60年代生活的犯罪电影，主角noodles(面条)在街区中结识了一群小伙伴，最开始过着调皮捣蛋的快乐生活，随着新搬来的邻居Max(麦克斯)的到来，大家逐渐去做一些犯罪和帮派的活动，在剧情不断发展中，跟随noodles经历了童年的欢乐、青涩的爱情、友情、遗憾、无奈。在'生意'逐渐做大的时候，他们一伙人想要铤而走险，noodles为了挽救他们的生命，选择了举报他们的行动，结果行动被破坏但是伙伴们都死于那次举报。noodles抱着悔恨远走他乡。多年以后，一封信把noodles叫回了故乡，此时的noodles已经头发发白，岁月在他身上有了明显的痕迹。这次他遇到了之前痛而不得的爱人，也遇到了自己的老友-Max.原来Max在之前的行动中做了个局，在那次行动中，Max并没有死而noodles被迫远走之后，Max占据了大家一起打拼的事业，‘一帆风顺’当上了部长。Max此时已经无法自保，他想向noodles坦白自己之前做的事，让noodles了结他的生命。印象中深刻的台词就这里发生了，当Max坦白，noodles却不愿意拿枪杀死他，画面切回了之前他们一起经历的快乐时光。noodles说: it`s just the way i see things(这是我对人生的看法)，I hava a story alse(我也有一个关于你说的故事)。在noodles讲述的故事中他因为自己的举报导致挚友去世感到悔恨一生，但是他们之间有真挚的友谊。最后nodles走之间对Max说希望调查的结果没有问题，否则一生的忙碌到最后没有结果很遗憾。最后Max自杀，电影闪回了noodles去烟管吸烟的场景，最后电影定格在noodles的笑容中。</p>\n<p>最近看了好几遍电影的后面部分，还是有些理解不好nooldes最后的笑容，不过渐渐地理解noodles的: I hava a story alse(我也有一个关于你说的故事).也许人生的价值或者意义就在于我们的看法。同样的人生也会因为看法不同导致感受。</p>\n<p>----一个长的引子的分割线----</p>\n<h2>什么是价值</h2>\n<p>亚里士多德将生活分为三类：动物式的生活，政治的生活和沉思的生活。</p>\n<ul>\n<li>动物式的生活指受到动物本能的指引，在缺少理智的参与下，过着无节制的生活</li>\n<li>政治的生活指人具有社会属性，可以放弃一些动物的本能去追求荣誉、善</li>\n<li>沉思的生活指通过思考达到精神的愉悦状态</li>\n</ul>\n<p>我理解在对这三种生活划分的时候，是没有贬义的，因为我们都或多或少的因为生活的阶段、能力的限制在间插似的体验不同的生活。在这个过程中不可避免的会对我们做的事，过的生活进行思考。这里其实就引入了价值的思考。如果生活的最终目的是幸福，当然这个幸福是相对的主观的。也许一个人的幸福是到老了回忆起年轻的一个蠢事或者儿孙满堂或者家缠万贯，幸福的定义虽有不同却大致相似。那价值就是那些拓宽我们关于幸福定义的事。</p>\n<h2>追求价值的方式</h2>\n<p>在去年开始相对集中的阅读，因为觉得自己在好像还看不明白一些事也想不明白。最近在看张维迎《经济学原理》一书中引发了我对价值这个问题的思考。在经济学中有个概念叫-生产可能性边界，用来表示经济社会在既定资源和技术条件下所能生产的各种商品最大数量的组合。这里可以用这个边界来类比幸福的范围.那我们生活的目标就集中在如何扩大幸福的边界和范围了。<br>\n我想年龄的焦虑一个主要的原因可能是在可见的未来能预测到幸福的边界会收缩，比如职场的35岁年龄焦虑，认为在未来年龄不在具有竞争力，那幸福的面积就可预测的缩小了。所以我理解追求幸福其实就是个逐步的拓宽边界的行为。这个行为可以很简单，比如早起、多运动、多陪伴家人。也可以相对复杂，比如创办一个家乡企业、写一本有意思的书。也可以比较抽象，比如在夏天的时候做个清凉的白日梦、在冬天的时候听听雪。</p>\n<h2>价值的相对性</h2>\n<p>说到底人生经历的事情还是自己和最亲密的人一起经历的，那价值就有很强的主观性，如果一直想让自己适应社会的价值想法会一直处于比较较劲的状态。不过关于价值这个问题自己也没有想的特别明白，也希望自己能一直想想这个问题。也希望跟看到这里的你一起想好这个问题，也许当有天有人带着鄙夷的语气问你生活的价值和意义的时候，你会告诉他: I hava a story alse(我对人生有不同的看法)</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"关于价值的一点想法","date":"2023-02-26","tags":"思考","path":"/thought-about-value","top":null,"summary":null},"title":"关于价值的一点想法","date":"2023-02-26","tags":"思考","path":"/thought-about-value","top":null,"summary":null},{"id":"4aeddc08-5bbe-5228-a3e4-90e1eae191bd","html":"<h2><a href=\"https://www.builder.io/blog/structured-clone\">Deep Cloning Objects in JavaScript, the Modern Way</a></h2>\n<p>structured-clone是在结构化克隆算法的基础上实现的克隆方案。结构化克隆算法会有一些限制:</p>\n<ul>\n<li>Function对象和DOM节点是不能被结构化克隆算法复制,会抛出DATA_CLONE_ERR</li>\n<li>对象的某些特定参数也不会被保留,比如RegExp 对象的 lastIndex 字段不会被保留、属性描述符、原型链上的属性等</li>\n</ul>\n<p>对比几种clone方案:</p>\n<ul>\n<li>对象扩展符和Object.assign不能实现深克隆</li>\n<li>JSON.parse(JSON.stringify(x))  JSON.stringify无法处理循环引用数据、丢失内置类型(Map/Set/Date/Symbol等)、无法复制函数</li>\n<li>cloneDeep是一个比较成熟的方案，但是它的包体积有点大材小用(在平时的使用中其实很少用到那么复杂结构的数据)</li>\n</ul>\n<h2><a href=\"https://jakearchibald.com/2023/unhandled-rejections/#unhandled-rejections-are-problematic\">The gotcha of unhandled promise rejections</a></h2>\n<p>这篇文章介绍for wait中unhandled promise的处理方式</p>\n<h2><a href=\"https://blog.codeminer42.com/everything-you-need-to-know-about-concurrent-react-with-a-little-bit-of-suspense/\">Everything you need to know about Concurrent React (with a little bit of Suspense)</a></h2>\n<p>这篇文章介绍React Concurrent mode.通过例子引入Concurrent mode中高优先级和低优先级任务的处理，比较生动。</p>\n<h2><a href=\"https://www.macarthur.me/posts/options-for-removing-event-listeners\">You’ve Got Options for Removing Event Listeners</a></h2>\n<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/axios-cancel\">axios的cancel功能源码解读</a>中axios已经AbortController来实现请求的终止，这篇文章中介绍了使用AbortController实现网页中元素绑定事件的移除</p>\n<h2><a href=\"https://deno.com/blog/the-future-of-web-is-on-the-edge\">The Future of the Web is on the Edge</a></h2>\n<p>这篇文章简单介绍Serverless的概念，可以结合<a href=\"https://juejin.cn/post/6996271746898722830\">为什么我不使用Serverless</a>，<a href=\"https://www.zhihu.com/question/506704568\">如何评价无服务器计算（serverless）的未来前景？你认为 serverless 有未来吗？</a>进一步了解Serverless</p>\n<h2>工具</h2>\n<h3><a href=\"https://mafs.dev/\">Mafs</a></h3>\n<p>实现可交互的数学视图的React库</p>\n<h3><a href=\"https://github.com/mswjs/msw\">msw</a></h3>\n<p>一个支持在浏览器和node环境中实现Mock Server的库，在浏览器中它通过Service Worker或者通过拦截原生的fetch实现mock，在node中通过拦截器封装原生的http模块实现mock.</p>\n<h3><a href=\"https://github.com/nolimits4web/swiper\">swiper</a></h3>\n<p>移动端的swiper组件，有比较多的动效支持</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/7044934738431180830\">最新HTML规范——structuredClone深拷贝函数，能取代JSON或者lodash吗？</a>\n<a href=\"https://stackoverflow.com/questions/59694309/for-await-of-vs-promise-all\">for await of VS Promise.all</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2023-2-1-前端快报","date":"2023-02-13","tags":"前端快报","path":"/2023-2-1","top":null,"summary":null},"title":"2023-2-1-前端快报","date":"2023-02-13","tags":"前端快报","path":"/2023-2-1","top":null,"summary":null},{"id":"240f03c5-3aa3-5133-a076-80d06778e48d","html":"<p>这里记录下2023读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2023年已阅读: 14本</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>张维迎寓言经济学 岑科 傅小永 邓新华</h2>\n<h3>推荐指数 4</h3>\n<p>通过寓言比喻的方式阐述了经济学,自由市场,国企等相关观点 一些观点难免有些激进 不过需要不同的观点来冲撞才有不同的视角来看世界,推动改革.张老师对于自由市场和国企改革的想法很多,也让我对大国企和自由市场有了一些简单的思考.改革是大题,需要慢慢答,特别是在人口超规模的中国,无论如何希望还是拥有改革开放时候的魄力,能积极改进</p>\n<h2>美丽新世界 4.5 奥尔德斯·赫胥黎</h2>\n<h3>推荐指数 4.5</h3>\n<p>读过《1984》里面塑造了一个可怕和压抑的社会,但这个社会还有一些美好就是有主人公一样的角色在思考,在试图反抗\n《动物农场》则是用童话故事去反映团体中成员的无助和统治者的行为\n《美丽新世界》里面塑界了一个高度塑造的社会,有些毛骨悚然.通过作者后面的论证和文中的一些场景,似乎这样社会的某些方面已经在现实生活中发生</p>\n<h2>叫魂: 1768年中国妖术大恐慌 孔飞力</h2>\n<h3>推荐指数 4.5</h3>\n<p>作者从叫魂的一个小案件开始叙述,从社会背景多方面讲述了那段历史.其中看到了官僚制度与帝王制度的抵抗、百姓对于未知恐惧、权力的恐慌与无助</p>\n<h2>约翰·克里斯多夫 罗曼·罗兰 许渊冲译</h2>\n<h3>推荐指数 5</h3>\n<p>在初高中有段时间比较喜欢看书，在书店总能看到这本《约翰·克里斯多夫》，印象中在书架上摆放了上中下三本，深灰色的包装。当时觉得这么长的书肯定不好看。这次鼓足了气翻开了这本书，一下子就被吸引住了。罗曼罗兰对于细腻情感的把握真的很好，比较能打动人。喜欢文中对自然景色，人物性格的描写都扣人心弦。在书中跟随着克里斯多夫走完了他的一生，从最开始莽莽撞撞的小伙子到最后老年的平静，在他身上似乎总有一种火在燃烧，那朵火并没有因为年龄或者阅历而熄灭。最开始喜欢克里斯多夫不断碰壁的莽撞的性格，从德国到巴黎，中间夹杂了很多对艺术的描写。现在的我也许还不能对这些艺术的描写有那么深的领悟，只能体会到艺术或者音乐在磨难中一直陪伴着克里斯多夫。克里斯多夫还有真诚的性格，他与奥利维的友谊一直延续到他人生的终点，从现实的生活中很难发现这样的友谊当然也很羡慕这种友谊。在爱情上似乎一直都有暗线在行进，后面与葛拉齐亚的故事是有克制的爱情，那种相知多年的爱人的感觉，读起来也很温馨，推荐这本书，也许等到在成长一些在看一遍这本书会有不同的感悟</p>\n<h2>经济学原理 张维迎</h2>\n<h3>推荐指数 4.5</h3>\n<p>一直没有仔细阅读过经济学原理方面的书籍都是相对概括介绍的读物。本书系统的介绍了微观经济学和宏观经济学中的相关概念，有些知识点自己之前只是简单了解或者理解的不对都在阅读的过程中得到了深化，特别是宏观经济学中观于经济周期与经济波动的部份读起来兴趣昂然。推荐</p>\n<h2>好好告别 凯瑟琳·曼尼克斯</h2>\n<h3>推荐指数 4</h3>\n<p>本书从临终的模式开始说起，讲到对待死亡的告别方式、态度、谈论死亡的时机、对生命的预期、对生命的看法。书中的故事很有趣也很感人，作者的叙事方式感觉就像在你身边跟你讲一件熟悉的事一样。推荐这本书，能激发一些思考，对死亡的准备和人生的意义</p>\n<h2>你是你吃出来的: 吃对少生病，病了这样吃 夏萌</h2>\n<h3>推荐指数 3.5</h3>\n<p>对饮食跟身体的关系有了全新的认识，书的内容不错从营养素的介绍到缺乏对应营养素身体的反应都讲解的通俗易懂。适合快速翻阅</p>\n<h2>理想国 柏拉图</h2>\n<h3>推荐指数 4</h3>\n<p>理想国是论证一个理想的城邦或者国家应有的样子，包括教育、统治者、人的行为等。通过对话辩论的方式阐释观点，其中会有些晦涩难懂或者绕的方式。不过并没有掩盖书中的一些重要的观点。</p>\n<ul>\n<li>要注重身体各部分的感受，感受身体和灵魂</li>\n<li>感受事物的真实，对观察思考</li>\n<li>要有求知欲，去看更广阔的世界</li>\n<li>精力有限，要追求更‘好’的欲望</li>\n</ul>\n<h2>芯片战争 余盛</h2>\n<h3>推荐指数 4</h3>\n<p>因为在A股有投资半导体企业所以通过这本书来了解半导体整个行业的背景和现状。书中详细的介绍全球半导体的发展过程。日本半导体的崛起和衰落、韩国半导体的崛起、荷兰的阿斯麦尔的发展过程读起来都饶有兴致。书中对于中国半导体行业的发展介绍的也很详细。让我了解到了一些中国半导体的至暗时刻，也看到国内半导体行业为突破技术封锁的尝试。作为一本介绍半导体行业的书本书通俗易懂，故事性强，推荐阅读。</p>\n<h2>农民笔记 候永禄</h2>\n<h3>推荐指数 3.5</h3>\n<p>跟着书读完作者的一生,经历了那些只在书本中的年代,书的名字是农民笔记。但是作者是一个有知识、思考、坚持的人,在那些年代很不容易.很感谢这本书让那些年代的记忆鲜活了，也让我意识到在自己的内心中有坚持也能过好一生</p>\n<h2>一个无政府主义者的意外的意外死亡 达里奥·福</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过剧本的方式呈现生动有趣的故事，描述的细节很精彩感觉人物栩栩如生，推荐</p>\n<h2>蛤蟆先生去看心理医生  罗伯特·戴博德</h2>\n<h3>推荐指数 4.5</h3>\n<p>通过这本书跟着蛤蟆先生一起成长。成长的过程在于认识自己的内心，去理解自己的情绪，摆脱过去消极的思维模式。很有意思的故事。推荐</p>\n<h2>疯人说: 精神病院医生手记 穆戈</h2>\n<h3>推荐指数 4</h3>\n<p>书的内容是讲述在精神病院中病人的故事，精神病人的故事很有意思，通过对故事了解了精神病相关的背景知识。感受最深的一点就是家庭的因素对精神病人病情影响很大。比如索引病人，其实就是这个家庭成员状态的索引，需要调整好家庭的状态病人回归家庭才能好。小说有意思的是把几个精神病人的故事连成了一个故事，这个故事的命题</p>\n<ul>\n<li>你是相信世界是不好的但怀着热情生活</li>\n<li>你知道世界不好选择无视他或者逃避它生活下去</li>\n</ul>\n<p>很有意思的小说，虽然部分剧情比较牵强，但是不影响整体，推荐</p>\n<h2>百年孤独 加西亚·马尔克斯</h2>\n<h3>推荐指数 5</h3>\n<p>记不清是第几次准备看这本书了，每次都是被开头的人物名字弄迷糊然后就放下了。这次耐下心来一周就看完了。百年孤独有故事的魔幻性、历史的厚重和轮回。在书中见证了一家人从最开始的兴旺到没落。结尾中破解了羊皮卷发现内容就是预言整个家族的事的时候很震撼。</p>\n<ul>\n<li>似乎并没有理解好文中孤独的概念。孤独是不是就是上校重复制作的小金鱼(对生活失去了理想只是让自己有事可做)或者是不想织不完的寿衣(不想面对老去的现实)。</li>\n<li>有种空虚感，文中人物故事的轮回，我们自己的人生也是否是空欢喜一场，上校会被人忘记，事实也会被篡改</li>\n</ul>\n<p>推荐，是本值得反复品味的书</p>","fields":{"readingTime":{"text":"12 min read"}},"frontmatter":{"title":"读书目录-2023","date":"2023-01-28","tags":"读书目录","path":"/book-list-2023","top":null,"summary":null},"title":"读书目录-2023","date":"2023-01-28","tags":"读书目录","path":"/book-list-2023","top":null,"summary":null},{"id":"b554705e-f1cc-52f6-ab7b-0159784362a1","html":"<h2><a href=\"https://github.com/reactwg/react-18/discussions/37\">New Suspense SSR Architecture in React 18</a></h2>\n<p>这篇文章介绍react 18中流式渲染和Suspense的结合，实现更好的服务端渲染功能。相关文章还有<a href=\"https://juejin.cn/post/7064759195710521381\">浅析React 18 Streaming SSR</a></p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍2022年热度比较高的React库</p>\n<h2><a href=\"https://developer.aliyun.com/article/781882\">一文详解 CSS-in-JS</a></h2>\n<p>这篇文章从CSS规范、CSS的设计模式说起，逐步覆盖到CSS-in-JS的细节，涉及的相关背景比较多，值得仔细阅读。</p>\n<h2><a href=\"https://weizman.github.io/page-what-is-a-realm-in-js/#identity-discontinuity\">What is a realm in JavaScript?</a></h2>\n<p>这篇文章介绍JavaScript中Realm的定义。也可以结合这篇<a href=\"https://2ality.com/2022/04/shadow-realms.html\">ShadowRealms – an ECMAScript proposal for a better eval()</a>介绍ShadowRealms API提议的文章一起了解。</p>\n<h2><a href=\"https://roadmap.sh/roadmaps/\">Developer Roadmaps</a></h2>\n<p>Developer Roadmaps收集了各个开发方向的技能路线图</p>\n<h2><a href=\"https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo\">How we configured pnpm and Turborepo for our monorepo</a></h2>\n<p>一篇比较详细的介绍monorepo技术方案选择工具的文章，从多项目开发的问题开始说起，逐步介绍<a href=\"https://github.com/pnpm/pnpm\">pnpm</a>(monorepo管理工具)和<a href=\"https://github.com/vercel/turbo\">Turborepo</a>(打包构建工具)</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart\">js-code-to-svg-flowchart</a></h3>\n<p>一个将JavaScript代码转化成svg图片的库。</p>\n<h3><a href=\"https://console-ninja.com/\">CONSOLE NINJA</a></h3>\n<p>一款VSCode插件，可以直接在代码中查看输入的console调试信息</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/shuding/react-wrap-balancer\">react-wrap-balancer</a></h3>\n<p>react-wrap-balancer能使文案比较智能的适应容器，占据容器的空间，达到比较好的展示效果，下面从源码上看它是如何实现的:\n<img src=\"/blog/9336733f998bb911bd52006bac3dd61b/blancer.gif\" alt=\"react-wrap-balancer\">\n通过简单的demo使用可以发现balancer在页面中注入了一段脚本并且为包裹的文本内容绑定的属性标识\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.399999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsklEQVQI1y3J3Y6CMBRFYd7/ySbjDx6BIkiZOjFWhFPUGAtXa6LOxUr2zpeYRYVvSqxpsbseDTNB72jfo/0V1cioAb2M+C5y6p4M44S/RI7+STdEumHi3Md3yXpZUpUtmQhbMUjWkhc7RIR0k1PbI3lh2EjB97omzR1iWpayZ7W1iHGkmeVrVVLZE0kunroJ1O5G1QSaw5Xa39mfH/zoxCFMOJ3/d+R3nHEa373s45//sj/d/dswZf2NSQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"balancer-show\"\n        title=\"balancer-show\"\n        src=\"/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png\"\n        srcset=\"/blog/static/209d5af74aebd83c377943dd2258a96b/63868/blancerShow.png 250w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/0b533/blancerShow.png 500w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/00d43/blancerShow.png 1000w,\n/blog/static/209d5af74aebd83c377943dd2258a96b/c6ff8/blancerShow.png 1088w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>    // react-wrap-balancer的主体代码逻辑\n    const Balancer: React.FC&#x3C;BalancerProps> = ({\n        as: Wrapper = 'span',\n        ratio = 1,\n        children,\n        ...props\n    }) => {\n        // 利用useId为组件生成唯一标识，useId可以根据组件的层级结构生成唯一标识\n        const id = React.useId()\n        const wrapperRef = React.useRef&#x3C;WrapperElement>()\n        const hasProvider = React.useContext(BalancerContext)\n\n        // 监听函数执行\n        // useIsomorphicLayoutEffect这里对服务端和客户端做了区分 在服务端调用useEffect,在客户端调用useLayoutEffect 解决客户端的闪动问题\n        useIsomorphicLayoutEffect(() => {\n            if (wrapperRef.current) {\n            // 调用绑定self上绑定的动态调整函数 并传入当前的入参执行\n            // self可以指代全局的window https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n            // 主要计算逻辑都在relayout函数中\n            ;(self[SYMBOL_KEY] = relayout)(0, ratio, wrapperRef.current)\n            }\n        }, [children, ratio])\n\n        // 自己卸载的时候 终止监听函数\n        useIsomorphicLayoutEffect(() => {\n            return () => {\n                if (!wrapperRef.current) return\n\n                const resizeObserver = wrapperRef.current[SYMBOL_OBSERVER_KEY]\n                if (!resizeObserver) return\n\n                resizeObserver.disconnect()\n                delete wrapperRef.current[SYMBOL_OBSERVER_KEY]\n            }\n        }, [])\n\n        return (\n            &#x3C;>\n                &#x3C;Wrapper\n                    {...props}\n                    // 绑定的唯一标识\n                    data-br={id}\n                    data-brr={ratio}\n                    ref={wrapperRef}\n                    style={{\n                    display: 'inline-block',\n                    verticalAlign: 'top',\n                    textDecoration: 'inherit',\n                    }}\n                    suppressHydrationWarning\n                >\n                    {children}\n                &#x3C;/Wrapper>\n                {createScriptElement(hasProvider, `self.${SYMBOL_KEY}(\"${id}\",${ratio})`)}\n            &#x3C;/>\n        )\n    }\n</code></pre>\n<p>通过上面的源码分析，主要的动态计算逻辑都在relayout函数中</p>\n<pre><code>    const relayout: RelayoutFn = (id, ratio, wrapper) => {\n        // 根据id获取包裹的wrapper组件\n        wrapper =\n            wrapper || document.querySelector&#x3C;WrapperElement>(`[data-br=\"${id}\"]`)\n        // wrapper的父容器\n        const container = wrapper.parentElement\n        // 更新wrapper的最大宽度\n        const update = (width: number) => (wrapper.style.maxWidth = width + 'px')\n\n        // 重置wrapper的最大宽度\n        wrapper.style.maxWidth = ''\n\n        // 获取wrapper的父容器的宽高\n        const width = container.clientWidth\n        const height = container.clientHeight\n\n        // 二分查找的方式计算wrapper的宽度\n        let left: number = width / 2\n        let right: number = width\n        let middle: number\n\n        if (width) {\n            while (left + 1 &#x3C; right) {\n                middle = ~~((left + right) / 2)\n                update(middle)\n                if (container.clientHeight === height) {\n                    // 缩放后 高度没有变 那么right= middle\n                    right = middle\n                } else {\n                    // 否则right = middle\n                    left = middle\n                }\n            }\n\n            // 更新wrapper的宽度\n            update(right * ratio + width * (1 - ratio))\n        }\n\n        // 通过ResizeObserver去监听wrapper父容器的变化 执行relayout函数\n        if (!wrapper['__wrap_o']) {\n            ;(wrapper['__wrap_o'] = new ResizeObserver(() => {\n            self.__wrap_b(0, +wrapper.dataset.brr, wrapper)\n            })).observe(container)\n        }\n    }\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null},"title":"2023-1-1-前端快报","date":"2023-01-04","tags":"前端快报","path":"/2023-1-1","top":null,"summary":null},{"id":"284f1e7f-d1ea-5347-a1de-ee281477dfef","html":"<p>在之前的文章<a href=\"https://icantunderstand.github.io/blog/react-hooks\">React Hooks源码解读</a>中有对React hooks的实现原理进行分析，本文主要结合React hooks的发展过程聊下对hooks的理解。hooks的提出主要解决了以下的问题:</p>\n<ul>\n<li>为react带来通用的代码逻辑复用的方式。相对于render props/高阶组件(HOC)等，hooks在代码复杂度上都有一定降低。声明式的hooks使用方式也符合函数式编程的思想。</li>\n<li>解决类组件生命周期函数复杂度和在新的react架构中的一些问题</li>\n<li>规范react使用范式，通过hooks的接口能更好的组织组件与组件/组件与渲染的原生DOM/组件与外部依赖之间的关系</li>\n</ul>\n<h2>通用的代码复用方式</h2>\n<p>react中可以通过render props/高阶组件(HOC)实现代码的能力的复用(组合)。</p>\n<pre><code>// render props通过传入渲染函数的方式复用逻辑\nclass Cat extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = { name: 111 }\n        // 可复用的逻辑\n    }\n    render() {\n        // 通过调用渲染函数的方式实现共享\n        return this.props.render(this.state)\n    }\n}\nclass App extends Component {\n    render() {\n        return (\n            &#x3C;Cat render={params => (&#x3C;div>{params.name}&#x3C;/div>)} />\n        )\n    }\n}\n// 高阶组件\nfunction HOC(WrappedComponent) {\n  return class extends Component {\n    componentDidMount() {\n      // 通用的业务逻辑\n    }\n    render() {\n      return (&#x3C;WrappedComponent {...this.props} />)\n    }\n  }\n}\n</code></pre>\n<p>从render props和高阶组件的实现方式上看，两者都引入了新的组件结构来实现复用，增加了理解成本从而导致一些问题。笔者在最开始对高阶组件不熟悉的时候就遇到过一次bug。包裹的高阶组件没有将外层传递的属性透传给被包裹的组件从而导致子组件渲染异常。<br>\nhooks通过函数声明式的方式实现代码复用，理解上更符合可见可得的思想，减少了理解成本。</p>\n<h2>解决老的问题</h2>\n<p>类组件的生命周期问题导致代码逻辑的分离，比如事件的监听与解绑</p>\n<pre><code>// 类组件示例\nclass Test extends Component {\n    componentDidMount() {\n        // 监听\n        document.addEventListener()\n    }\n    componentWillUnmount() {\n        // 解绑\n        document.removeEventListener()\n    }\n    render() {}\n}\n// 函数式组件示例\nfunction Test(props) {\n    useEffect(() => {\n        // 监听\n        document.addEventListener()\n        return () => {\n            // 解绑\n            document.removeEventListener()\n        }\n    }, [])\n    return xxx;\n}\n</code></pre>\n<p>在Concurrent Mode中会导致生命周期函数的多次执行，hooks的提出在结构上是与Fiber结构绑定的，服务于新的架构的</p>\n<h2>规范使用范式</h2>\n<p>react开发者都需要用一些库(redux等)来组合应用，react通过hooks为react增加了状态管理、操作DOM的入口、父子组件调用方式等，丰富且规范了React开发者的开发模式。通过这种规范可以让React更好的与社区结合，比如相关的库<a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>、<a href=\"https://github.com/streamich/react-use\">react-use</a>。</p>\n<h2>hooks使用注意</h2>\n<ul>\n<li>避免hooks依赖，比如useMemo/useCallback等是否需要使用。使用多个useState的时候是否引入其他的管理库来解</li>\n<li>UI逻辑与业务逻辑合理拆分。hooks做过多的业务逻辑会导致业务逻辑不明晰，需要进行适当的拆分。</li>\n<li>hooks的依赖问题会导致业务中存在隐藏逻辑，需要控制代码中隐藏逻辑</li>\n<li>hooks更适合组件级别的代码复用和逻辑,跨组件逻辑需要仔细设计(比如是否需要useRef)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null},"title":"聊聊我对React Hooks的理解","date":"2022-11-16","tags":"React","path":"/thinking-in-react","top":null,"summary":null},{"id":"fa80434f-17f1-5530-a3b5-0070b8a2482d","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\n    logMessage(user, message) {\n        const sender = user.getName();\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\n    }\n}\nclass User {\n    constructor(name, chatroom) {\n        this.name = name;\n        this.chatroom = chatroom;\n    }\n\n    getName() {\n        return this.name;\n    }\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\n    send(message) {\n        this.chatroom.logMessage(this, message);\n    }\n}\nconst chatroom = new ChatRoom();\nconst user1 = new User(\"John Doe\", chatroom);\nconst user2 = new User(\"Jane Doe\", chatroom);\nuser1.send(\"Hi there!\");\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\nconst books = new Map();\nconst createBook = (title, author, isbn) => {\n    const existingBook = books.has(isbn);\n    if (existingBook) {\n        // 已存在就查找返回\n        return books.get(isbn);\n    }\n    // 不存在新建返回\n    const book = new Book(title, author, isbn);\n    books.set(isbn, book);\n    return book;\n};\n//  存储书的列表\nconst bookList = [];\nconst addBook = (title, author, isbn, availability, sales) => {\n    const book = {\n        // 利用之前的共享对象创建新的实力\n        ...createBook(title, author, isbn),\n        sales,\n        availability,\n        isbn\n    };\n    bookList.push(book);\n    return book;\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\n    class OrderManager {\n        constructor() {\n            // 指令处理的对象\n            this.orders = [];\n        }\n\n        execute(command, ...args) {\n            // 匹配指令和指令处理的对象\n            return command.execute(this.orders, ...args);\n        }\n    }\n    // 指令创建类\n    class Command {\n        constructor(execute) {\n            this.execute = execute;\n        }\n    }\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\n    function PlaceOrderCommand(order, id) {\n        return new Command(orders => {\n            orders.push(id);\n            return `You have successfully ordered ${order} (${id})`;\n        });\n    }\n    const manager = new OrderManager();\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null},"title":"5分钟速读系列-中介模式/享元模式/指令模式","date":"2022-11-04","tags":"设计模式","path":"/2022-11-mediator","top":null,"summary":null},{"id":"7aa1bea5-0d00-517f-af8c-5522602188fe","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>观察者模式</h2>\n<p>观察者模式(发布订阅模式)是定义对象间一种一对多的依赖关系，使得当每一个被观察方改变状态，则所有依赖于它的观察者都会得到通知并自动更新。</p>\n<pre><code>// 被观察者提供观察者通知逻辑、订阅逻辑\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    // 观察者订阅入口\n    subscribe(func) {\n        this.observers.push(func);\n    }\n\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    // 通知观察者\n    notify(data) {\n        this.observers.forEach(observer => observer(data));\n    }\n}\nfunction logger(data) {\n    console.log(data)\n}\nconst observable = new Observable() \n// 订阅操作\nobservable.subscribe(logger);\n// 通知操作\nobservable.notify('this is a test!')\n</code></pre>\n<p>观察者模式的优点是可以做到逻辑的分离，做到单一职责。缺点是当观察者数目较多的时候会有性能的问题</p>\n<h2>Mixin模式</h2>\n<p>Mixin模式可以在不通过继承的方式实现为类(对象)增加复用的能力。当你需要将一个特定的feature添加到不同的类或者为类提供可插拔能力的时候可以考虑Mixin模式。</p>\n<pre><code>// 基础类 只有name能力\nclass Dog {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// mixin方法 可以为基础类提供复用的能力\nconst dogFunctionality = {\n    bark: () => console.log(\"Woof!\"),\n    wagTail: () => console.log(\"Wagging my tail!\"),\n    play: () => console.log(\"Playing!\")\n};\n// 通过方法的拷贝 在Dog的原型上就有了对象的方法\nObject.assign(Dog.prototype, dogFunctionality);\nconst pet1 = new Dog(\"Daisy\");\npet1.bark(); // Woof!\n</code></pre>\n<p>可以在mixin函数中通过指定__proto__实现mixin的继承能力</p>\n<pre><code>const sayMixin = {\n    say(phrase) {\n        alert(phrase);\n    }\n};\nconst sayHiMixin = {\n    // 设置原型 实现mixin的继承\n    __proto__: sayMixin, // (可以在这儿使用 Object.setPrototypeOf 来设置原型)\n    sayHi() {\n        // 调用父类方法\n        super.say(`Hello ${this.name}`); // (*)\n    },\n    sayBye() {\n        super.say(`Bye ${this.name}`); // (*)\n    }\n};\nclass User {\n    constructor(name) {\n        this.name = name;\n    }\n}\n// 拷贝方法\nObject.assign(User.prototype, sayHiMixin);\n\n// 现在 User 可以打招呼了\nnew User(\"Dude\").sayHi(); // Hello Dude!\n</code></pre>\n<p>mixin模式会存在覆盖功能和增加项目代码复杂度的问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"5分钟速读系列-观察者模式/Mixin模式","date":"2022-11-03","tags":"设计模式","path":"/2022-11-observable","top":null,"summary":null},"title":"5分钟速读系列-观察者模式/Mixin模式","date":"2022-11-03","tags":"设计模式","path":"/2022-11-observable","top":null,"summary":null},{"id":"0d7eb1a7-5d60-5e0b-9b6a-2c558a43344b","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>提供者模式</h2>\n<p>提供者模式通过封装方法给予应用订阅不同数据源的能力。react中通过外层的Provider来提供全局的store，在组件内部通过useContext来获取相关的Context值。</p>\n<pre><code>    // 根组件通过Provider的value绑定全局store\n    export const ThemeContext = React.createContext();\n    const themes = {\n        light: {\n            background: \"#fff\",\n            color: \"#000\"\n        },\n        dark: {\n            background: \"#171717\",\n            color: \"#fff\"\n        }\n    };\n    export default function App() {\n        const [theme, setTheme] = useState(\"dark\");\n        function toggleTheme() {\n            setTheme(theme === \"light\" ? \"dark\" : \"light\");\n        }\n        const providerValue = {\n            theme: themes[theme],\n            toggleTheme\n        };\n        return (\n            &#x3C;div className={`App theme-${theme}`}>\n                &#x3C;ThemeContext.Provider value={providerValue}>\n                    &#x3C;Toggle />\n                &#x3C;/ThemeContext.Provider>\n            &#x3C;/div>\n        );\n    }\n    // Toggle组件\n    import React, { useContext } from \"react\";\n    import { ThemeContext } from \"./App\";\n\n    export default function Toggle() {\n        const theme = useContext(ThemeContext);\n        return (\n            &#x3C;label className=\"switch\">\n                &#x3C;input type=\"checkbox\" onClick={theme.toggleTheme} />\n            &#x3C;/label>\n        );\n    }\n</code></pre>\n<p>在React应用中通过全局的context可以解决组件属性的传递问题，便于组件的设计。但是全局Context的更新会导致消费对应Context组件的更新，造成需要不必要的渲染。这里就需要对全局Context进行更细粒度的拆分。</p>\n<h2>原型模式</h2>\n<p>JavaScript通过原型完成对象间属性的共享。通过原型能减少相同属性或者方法的创建，相同类型的实例可以共享实例原型上的属性和方法。对于原型模式需要理解几下的几点:</p>\n<ul>\n<li>\n<p>实例对象的__proto__指向构造函数的prototype(实例与原型的关系).构造函数的prototype的constructor(构造函数与原型的关系).</p>\n<pre><code>  class Dog {\n      constructor(name) {\n          this.name = name;\n      }\n      bark() {\n          return `Woof!`;\n      }\n  }\n  const dog1 = new Dog(\"Daisy\");\n  dog1.__proto__ === Dog.prototype // true\n  Dog.prototype.constructor === Dog // true\n</code></pre>\n</li>\n<li>\n<p>对象属性的获取是顺着对象__proto__沿着原型链查找，会一直查找到Object.prototype(Object.prototype.__proto__是null)</p>\n</li>\n<li>\n<p>理解new关键字中原型的处理方式，new操作符主要做了如下的操作:</p>\n<ol>\n<li>\n<p>以构造器的原型为属性创建新对象</p>\n</li>\n<li>\n<p>将新对象作为this调用构造器</p>\n</li>\n<li>\n<p>如果构造器返回的是对象则返回否则返回第一步创建的对象</p>\n<pre><code> function myNew(Con, ...args) {\n     const obj = Object.create(Con.prototype);\n     const ret = Con.call(obj, args);\n     if(ret instanceof Object &#x26;&#x26; ret !== null) {\n         return ret;\n     }\n     return obj;\n }\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"5分钟速读系列-提供者模式/原型模式","date":"2022-11-02","tags":"设计模式","path":"/2022-11-provider","top":null,"summary":null},"title":"5分钟速读系列-提供者模式/原型模式","date":"2022-11-02","tags":"设计模式","path":"/2022-11-provider","top":null,"summary":null},{"id":"25508f8f-26d3-51b4-b8a9-a50cfd7f2c5f","html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>单例模式</h2>\n<p>单例模式通过全局维护一个实例的方式来达到全局属性的共享和减少内存的占用。单例的简单实现如下:</p>\n<pre><code>    let instance;\n    let counter = 0;\n    class Counter {\n        constructor() {\n            if (instance) {\n                throw new Error(\"You can only create one instance!\");\n            }\n            instance = this;\n        }\n        getInstance() {\n            return this;\n        }\n        getCount() {\n            return counter;\n        }\n        increment() {\n            return ++counter;\n        }\n        decrement() {\n            return --counter;\n        }\n    }\n    const singletonCounter = Object.freeze(new Counter());\n    // 暴露给外部的单一实例\n    export default singletonCounter;\n</code></pre>\n<p>单例模式的优点也恰恰是他的缺点，由于全局属性的共享导致改动的全局污染问题、测试用例写法问题等。在react中全局的redux\\context store就是应用中的单例，store通过单向的数据流来规避单例的一些问题。</p>\n<h2>Proxy(代理)模式</h2>\n<p>代理模式通过为对象提供占位符来控制对象的访问。代理对象相当于中间人角色，可以在不改变被代理对象的接口的情况下扩展功能。在JavaScript中可以使用Proxy来实现代理的功能。</p>\n<pre><code>    const person = {\n        name: \"John Doe\",\n        age: 42,\n        nationality: \"American\"\n    };\n    const personProxy = new Proxy(person, {\n        // handler的get/set方法代理了被代理对象属性的访问方法\n        get: (obj, prop) => {\n            console.log(`The value of ${prop} is ${obj[prop]}`);\n            // 可以用Reflect修改代理对象的属性\n            Reflect.set(obj, prop);\n        },\n        set: (obj, prop, value) => {\n            console.log(`Changed ${prop} from ${obj[prop]} to ${value}`);\n            obj[prop] = value;\n            return true;\n        }\n    });\n    personProxy.name;\n    personProxy.age = 43;\n</code></pre>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"5分钟速读系列-单例模式/代理模式","date":"2022-11-01","tags":"设计模式","path":"/2022-11-singleton","top":null,"summary":null},"title":"5分钟速读系列-单例模式/代理模式","date":"2022-11-01","tags":"设计模式","path":"/2022-11-singleton","top":null,"summary":null},{"id":"7a195122-2575-5d8d-af5a-826176974d22","html":"<p>偶然间想起2021竟然没有过来总结，恍然间发现时间过的好快。这次提前来总结下，希望年终总结能成为每年的一个思考和沉淀的习惯。</p>\n<h2>工作</h2>\n<p>近两年经历了两次工作的变动，从字节离开 => 短暂的教育行业经历(3个月) => 现在的公司(也经历过一次内部的部门调整)。仔细回想自己应该有半年多的迷茫期或者比较空闲的状态，那段时间感觉十分地缺少自信，也是循环播放Unstoppable的一段时间。</p>\n<ul>\n<li>从字节离开的时候，leader有对工作去向和内心的想法疏解，记忆最深的一句话就是不要跟系统内改变不了的东西对抗，比如架构调整之类. 现在再回头看当时自己的确没有想明白当时的问题或者自己想要什么。在离开字节之前没有好好跟合作的伙伴都打个招呼，现在想起来很不成熟。总是觉得要走就要一个人偷摸的走。如果有机会可以改之前飞书的签名，我会写: 有缘再见，不如加个V 哈哈。</li>\n<li>短暂的教育行业经历略过</li>\n<li>在当前的公司经历过一次内部的调整，有过一小段时间的“空闲”。这段时间想明白了一件事就是要让自己的状态跟环境匹配，从小事中逐步的找到做事的状态，甚至整理xlsx表格这种小事也相当认真。自己在这段\"空闲\"的时候做了一个组内前端报警的工具，自己从想法到功能设计完善了整个工具的功能，是这段时间比较有意思的事情。</li>\n</ul>\n<h3>技术能力</h3>\n<ol>\n<li>回归到B端业务的开发 自己从B端到C端又回到了B端感觉经历了一个圈。想起之前面试字节面试官问我B端业务和C端业务的区别是啥。我当时很懵(没有准备/思考过这个问题)，现在在重新尝试回答下这个问题，有可能还是比较浅显的认知，后续有新的认知在回来check</li>\n</ol>\n<ul>\n<li>面向的用户不同， 决定着同一个业务形式的在B端和C端是两套不同的技术架构和业务发展模式。在进行技术储备和规划上就需要做更多的考虑。比如广告业务，在C端侧业务是如何将广告与人结合，转化。从产品上会考虑如何原生化、样式多样性、结合转化流程的简单性、趣味性、品牌价值(平台如何给广告主带来价值)、平台价值等，业务形态上流程短、迭代节奏快。在B端上就需要为C端的业务提供完成的配套流程，业务形态上要简单好用（减轻用户的理解成本/操作成本）、功能完善等。</li>\n<li>业务形态决定技术方案的选择思考点不同。C端薄的业务可以快速的试错。新技术方案的尝试(跨端)或者欠考虑的技术实现后期都有比较大的空间可以进行业务迭代。B端由于系统是一以贯之的，需要前期相对于C端业务要更加充分的进行技术方案的对比，当然在B端和C端都会产生技术宅问题。</li>\n<li>B端和C端是可以进行良性互补。比如广告中的建站平台，就是客户侧对快，开发对效率有要求才产生的平台。</li>\n</ul>\n<ol start=\"2\">\n<li><a href=\"https://icantunderstand.cn/%E5%89%8D%E7%AB%AF%E5%BF%AB%E6%8A%A5/\">前端快报</a> 月维度收录一些阅读的比较好的前端文章，算是对自己的一个督促。仔细考虑这一年对技术方面的学习是落后的。</li>\n</ol>\n<h3>工作心态</h3>\n<p>工作上慢慢的变的不那么急躁。从最开始的被UI支配的控制到现在改UI的时候心态很相对平静(改UI真的容易心态炸裂)。学会注意到工作中双方的认知差异。比如在UI实现上设计师是领域专家，那在实现上基于成本的考虑就可以以设计师的想法为主。</p>\n<h2>生活</h2>\n<h3>读书</h3>\n<p>在2020的年终总结上说要多读书，今年才开始系统的读书了<a href=\"https://icantunderstand.cn/book-list-2022\">读书目录2022</a>。有一次突然觉得好多事好像还看不懂，不明白，就不管三七二十一的读起来了。希望能一直读下去。</p>\n<h3>投资</h3>\n<p>尝试进行投资理财。发现只有上交到家庭的固定工资部分是真的“理财”，其他都是负理财。后续规划上会进行一些系统知识的学习。</p>\n<h3>家庭</h3>\n<p>貌似懂得了陪伴，但是这些方面做的还远不够。国庆老妈来北京逛了一圈。我作为一个在北京10多年的老北漂家人第一次来北京溜达实属惭愧。</p>\n<h2>思考</h2>\n<p>转眼已经30出了个小头了。距离不惑虽然还有些年龄的距离，但是距离不惑的状态还是有些差距。有好多事还没想明白，有好多事甚至都没曾想过。不过一个简单的想法就是要注重自己的价值和心里状态。持续的读书是想保证内心的富足。这个博客也希望能坚持下去，后续会做其他别的分享带来其他的价值</p>\n<h2>番外</h2>\n<p>写到中间的时候，发现<a href=\"https://mp.weixin.qq.com/s?__biz=MzUwOTk5NDI3OA==&#x26;mid=2247484174&#x26;idx=1&#x26;sn=123f7a9b633c3c786519e24f3f4b0072&#x26;chksm=f908f747ce7f7e51785450e91d9aa8c68f411f63935b162d9f19b4fea1cb9184ef10b30f3e7f#rd\">2021的流水账</a>记录在微信的公众号上了，这个博客没有同步。看了下比上次或许有一点进步就算是安慰了。</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"2022年终总结","date":"2022-10-20","tags":"年度总结","path":"/2022-summary","top":null,"summary":"2022年总结-回顾了工作、生活和自身的一些思考"},"title":"2022年终总结","date":"2022-10-20","tags":"年度总结","path":"/2022-summary","top":null,"summary":"2022年总结-回顾了工作、生活和自身的一些思考"},{"id":"9867eee0-87d3-5eb8-901e-4886bc0cd7cd","html":"<h2><a href=\"https://legendapp.com/open-source/legend-state/\">Making React fast by default and truly reactive</a></h2>\n<p>这篇文章通过介绍React中组件渲染优化的问题引出类mobx的状态库方案<a href=\"https://github.com/LegendApp/legend-state\">legend-state</a>,在底层的技术方案上跟mobx是相似的，通过监听observable值的变化来运行渲染函数。</p>\n<h2><a href=\"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/\">A (Mostly) Complete Guide to React Rendering Behavior</a></h2>\n<p>这篇文章比较详细的介绍了React组件渲染的细节，包括渲染的阶段、Fiber、渲染优化等。</p>\n<h2><a href=\"https://prateeksurana.me/blog/future-of-rendering-in-react/\">The future of rendering in React</a></h2>\n<p>这篇文章主要介绍基于react的页面渲染流程和渲染方式的优缺点。</p>\n<ol>\n<li>CSR(Client-side rendering)- 客户端渲染。这种渲染方式通过在客户侧的浏览器执行脚本来完成整个页面内容的生成和数据的加载。 这种方式可以通过CDN去优化JS脚本的加载，能有效的提交TTFB(Time To First Byte),但是由于页面和数据都是在客户端组装和渲染会影响用户的首次可交互时间和不方便做SEO优化。</li>\n<li>SSR(Server-side rendering)- 服务端渲染。这种渲染方式通过react提供的api在服务端组装数据和渲染页面内容。服务端渲染的优势在于有利于SEO优化，能有效的提供FCP(First Contentful Paint)和LCP(Largest Contentful Paint),劣势是服务端渲染会降低TTFB,但是可以通过一些手段去优化，比如\n<ul>\n<li>SSG(Static site generation)- 静态页面生成  将不依赖数据的页面提前进行预编译，在访问的时候直接将已编译好的页面内容返回</li>\n<li>ISR (Incremental static site generation)- 增量式页面生层 ISR为了解决SSG的对动态数据依赖和构建规模问题，可以在运行时动态的生成页面内容并存储</li>\n<li>Streaming SSR- 流式服务端渲染 主要使用node中的stream实现流式的返回服务端渲染的内容，能有效的提高TTFB</li>\n</ul>\n</li>\n</ol>\n<h2><a href=\"https://alexkondov.com/half-hour-to-learn-js/\">A Half-Hour to Learn JavaScript</a></h2>\n<p>这篇文章介绍JavaScript中的基础知识点，包括变量声明、闭包、this、new关键字、原型链、继承、异步调用(async await,Promise)、事件循环等，适合复习基础的时候浏览查缺补漏。</p>\n<h2><a href=\"https://2ality.com/2022/10/javascript-decorators.html\">JavaScript metaprogramming with the 2022-03 decorators API</a></h2>\n<p>这篇文章详细的介绍了JavaScript中装饰器的细节</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/google/zx\">zx</a></h3>\n<p>google的一个脚本工具，可以在脚本中写javascript，值得一试</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/SortableJS/Sortable\">Sortable</a>源码解读</h3>\n<p>Sortable是一个实现可拖拽列表的库，它提供了丰富的功能比如共享列表的拖拽、多条目的拖拽等。以下主要从两方面对Sortable的源码进行简单的分析，希望对功能库的设计有所思考</p>\n<ol>\n<li>插件机制</li>\n<li>拖拽功能实现</li>\n</ol>\n<h4>插件机制</h4>\n<ul>\n<li>插件能很好的实现功能的隔离。插件内功能逻辑自治，</li>\n<li>通过统一的接口提供接入和调用能力。便于后续功能的扩展</li>\n<li>通过组合插件，可以提供多版本的库</li>\n</ul>\n<h5>插件注册</h5>\n<pre><code>    //  通过mount方法调用PluginManager的mount来注册插件\n    Sortable.mount = function(...plugins) {\n        if (plugins[0].constructor === Array) plugins = plugins[0];\n\n        plugins.forEach((plugin) => {\n            if (!plugin.prototype || !plugin.prototype.constructor) {\n                throw `Sortable: Mounted plugin must be a constructor function, not ${ {}.toString.call(plugin) }`;\n            }\n            if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n            PluginManager.mount(plugin);\n        });\n    };\n</code></pre>\n<h5>触发插件</h5>\n<p>通过调用pluginEvent来触发插件执行的逻辑</p>\n<pre><code>    pluginEvent(eventName, sortable, evt) {\n        this.eventCanceled = false;\n        evt.cancel = () => {\n            this.eventCanceled = true;\n        };\n        const eventNameGlobal = eventName + 'Global';\n        plugins.forEach(plugin => {\n            if (!sortable[plugin.pluginName]) return;\n            // Fire global events if it exists in this sortable\n            if (\n                sortable[plugin.pluginName][eventNameGlobal]\n            ) {\n                sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n            }\n\n            // 触发对应插件上对应eventName的处理函数\n            // 比如MultiDrag plugin的drop方法就是通过pluginEvent('drop', this, { evt })触发\n            if (\n                sortable.options[plugin.pluginName] &#x26;&#x26;\n                sortable[plugin.pluginName][eventName]\n            ) {\n                sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n            }\n        });\n    },\n</code></pre>\n<h4>拖拽能力实现</h4>\n<p>拖拽能力主要实现是:</p>\n<ul>\n<li>初始化绑定根元素拖拽的dom事件监听函数</li>\n<li>根据事件触发顺序添加动画处理逻辑、插件调用逻辑、元素替换逻辑、配置的回调函数触发逻辑等</li>\n</ul>\n<h4>绑定事件监听函数</h4>\n<p>在<a href=\"https://lotabout.me/2018/HTML-5-Drag-and-Drop/\">HTML 5 Drag and Drop 入门教程</a>中有对html5中拖拽函数介绍。</p>\n<pre><code>    // 事件监听\n    if (!this.nativeDraggable || touch) {\n\t\tif (this.options.supportPointer) {\n\t\t\ton(document, 'pointermove', this._onTouchMove);\n\t\t} else if (touch) {\n\t\t\ton(document, 'touchmove', this._onTouchMove);\n\t\t} else {\n\t\t\ton(document, 'mousemove', this._onTouchMove);\n\t\t}\n\t} else {\n        // 注意这里传入的是this\n\t\ton(dragEl, 'dragend', this);\n\t\ton(rootEl, 'dragstart', this._onDragStart);\n\t}\n</code></pre>\n<h4>事件触发</h4>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\">addEventListener</a>的第二个参数listener可以是一个函数或者是一个带handleEvent函数的对象。在绑定监听函数的时候listener传入的是this,在触发回调的时候就会走入到handleEvent处理拖拽结束的函数逻辑</p>\n<pre><code>    handleEvent: function (/**Event*/evt) {\n        switch (evt.type) {\n            case 'drop':\n            case 'dragend':\n                // 拖拽结束的时候 执行逻辑\n                this._onDrop(evt);\n                break;\n\n            case 'dragenter':\n            case 'dragover':\n                if (dragEl) {\n                    this._onDragOver(evt);\n                    _globalDragOver(evt);\n                }\n                break;\n\n            case 'selectstart':\n                evt.preventDefault();\n                break;\n        }\n    },\n</code></pre>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"2022-10-1-前端快报","date":"2022-10-08","tags":"前端快报","path":"/2022-10-1","top":null,"summary":null},"title":"2022-10-1-前端快报","date":"2022-10-08","tags":"前端快报","path":"/2022-10-1","top":null,"summary":null},{"id":"5138f9c7-1e45-5332-b7f5-477d54a56248","html":"<h2><a href=\"https://www.joshwcomeau.com/react/usememo-and-usecallback/\">Understanding useMemo and useCallback</a></h2>\n<p>这篇文章介绍useMemo和useCallback</p>\n<ul>\n<li>useMemo可以实现组件内计算逻辑的拆分缓存能力，减少页面渲染时的计算和子组件重复渲染.需要考虑的是是否可以通过组件拆分或者计算逻辑的拆分来实现计算逻辑的优化.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/eef642c6e58030017ad568bf488a4430/d14c1/useMemo.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAARD/2gAIAQEAAT8hHP/aAAwDAQACAAMAAAAQAA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAADAQEAAAAAAAAAAAAAAAAAAREhcf/aAAgBAQABPxDKJZrOH//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"useMemo\"\n        title=\"useMemo\"\n        src=\"/blog/static/eef642c6e58030017ad568bf488a4430/a2510/useMemo.jpg\"\n        srcset=\"/blog/static/eef642c6e58030017ad568bf488a4430/0479a/useMemo.jpg 250w,\n/blog/static/eef642c6e58030017ad568bf488a4430/41099/useMemo.jpg 500w,\n/blog/static/eef642c6e58030017ad568bf488a4430/a2510/useMemo.jpg 1000w,\n/blog/static/eef642c6e58030017ad568bf488a4430/d14c1/useMemo.jpg 1234w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>useCallback用于保存函数的引用，保证在依赖不变的情况下复用之前的函数</li>\n</ul>\n<p>需要注意的是在开发中不要对hook过度使用，在关键的位置做好优化比如:</p>\n<ol>\n<li>使用useState定制的hook，返回的setter函数通过useCallback缓存</li>\n<li>全局context使用useMemo缓存减少渲染</li>\n</ol>\n<h2><a href=\"https://thisweekinreact.com/articles/useSyncExternalStore-the-underrated-react-api\">useSyncExternalStore - The underrated React API</a></h2>\n<p>这篇文章介绍react useSyncExternalStore的使用场景</p>\n<h2><a href=\"https://github.com/pubkey/broadcast-channel\">broadcast-channel</a></h2>\n<p>在<a href=\"https://www.smashingmagazine.com/2022/09/javascript-api-guide/\">JavaScript APIs You Don’t Know About</a>中提及到BroadcastChannel来实现跨页面间的通信。<a href=\"https://github.com/pubkey/broadcast-channel\">broadcast-channel</a>这个库通过封装BroadcastChannel、localStorage、indexedDB、node的socket来实现跨运行时的通信。</p>\n<h2><a href=\"https://2ality.com/2022/09/nodejs-overview.html\">An overview of Node.js: architecture, APIs, event loop, concurrency</a></h2>\n<p>这篇文章介绍node的架构、同步异步的api风格、通过例子介绍node中事件循环的模型。</p>\n<h2><a href=\"https://marmelab.com/blog/2022/09/20/react-i-love-you.html\">React I Love You, But You're Bringing Me Down</a></h2>\n<p>这篇文章介绍作者长期使用react的一些感受和痛点，有点观点很有共鸣。比如：</p>\n<ul>\n<li>context的渲染问题 是否能像redux的useSelector一样来优化渲染</li>\n<li>react引入的一些规则倒是代码写起来比较‘别扭’，不支持条件effect、forwardRef、hook的依赖等</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/AykutSarac/jsoncrack.com\">JSON Crack</a></h3>\n<p>JSON校验和结构可视化工具</p>\n<h3><a href=\"https://pemistahl.github.io/grex-js/\">grex-js</a></h3>\n<p>在线生成正则表达式的工具</p>\n<h2><a href=\"https://engineering.fb.com/2022/09/12/open-source/memlab/\">MemLab: An open source framework for finding JavaScript memory leaks</a></h2>\n<p><a href=\"https://github.com/facebookincubator/memlab\">MemLab</a>是一个分析前端脚本内存泄露的工具，使用puppeteer来执行页面操作进而分析页面的内存状态。</p>\n<h2><a href=\"https://github.com/naptha/tesseract.js#tesseractjs\">tesseract.js</a></h2>\n<p>tesseracts是一个视频图片中文字的前端库，可以支持node和浏览器场景</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-9-1-前端快报","date":"2022-09-21","tags":"前端快报","path":"/2022-9-1","top":null,"summary":null},"title":"2022-9-1-前端快报","date":"2022-09-21","tags":"前端快报","path":"/2022-9-1","top":null,"summary":null},{"id":"fd92a9b2-6634-513c-b581-0c6d7a60cd38","html":"<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-0-61fea500b180\">Frontend Web Performance: The Essentials [0]</a></h2>\n<p>这篇文章介绍前端页面渲染的过程，包括渲染的流程，优化的手段等。通过例子结合chrome的开发者工具给出优化的过程。</p>\n<h2><a href=\"https://medium.com/@matthew.costello/frontend-web-performance-the-essentials-1-cb6513e1c3a1\">Frontend Web Performance: The Essentials [1]</a></h2>\n<p>这篇文章介绍浏览器的事件循环，包括宏任务，微任务等，通过将微任务与宏任务结合的方式可以实现宏任务的拆分。</p>\n<h2><a href=\"https://www.toptal.com/javascript/10-most-common-javascript-mistakes\">The 10 Most Common JavaScript Issues Developers Face</a></h2>\n<p>这篇文章介绍了javascript中几个常见的问题点。比如this的确定、内存泄露、原型链等.</p>\n<h2><a href=\"https://www.robinwieruch.de/typescript-react-useref/\">TypeScript: React useRef Hook</a></h2>\n<p>介绍React useRef Hook的文章.\nReact提供了useCallback, useMemo来实现memoization能力，减少重复的计算。应该避免对应hook的滥用，在缓存大量计算逻辑的时候使用<br>\nuseImperativeHandle可以实现父组件对子组件的方法调用。在使用useImperativeHandle的时候思考是否可以将逻辑抽离到store层处理<br>\nuseRef可以用于存储值，改变useRef的值不需要重新渲染组件</p>\n<h2>工具</h2>\n<h3><a href=\"https://react-svgr.com/docs/what-is-svgr/\">SVGR</a></h3>\n<p>SVGR通过svgo优化，svg内容解析将svg转化成React组件使用</p>\n<h3><a href=\"https://github.com/thebuilder/react-intersection-observer\">react-intersection-observer</a></h3>\n<p>react-intersection-observer通过对IntersectionObserver的封装提供了react hook的方式来监听元素在视口中的位置</p>\n<h3><a href=\"https://github.com/pmndrs/react-spring\">react-spring</a></h3>\n<p>react实现spring动画的库</p>\n<h2>想法</h2>\n<h3>关于前端store设计</h3>\n<p>在<a href=\"https://icantunderstand.cn/2022-7-1\">上期前端快报</a>中聊到了前端的页面设计，要从数据逻辑去思考页面，实现数据逻辑和渲染逻辑的分离。\n在对前端store(View-Model)的设计上，可以从页面的角度，去拆分通用模块，页面级别模块实现更好的数据逻辑与渲染逻辑的隔离.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpElEQVQ4y51Ty07DMBDM/wvxAUj8CwckxBmpouJE2zRJ82iSPvxMB80GN6EBVDiMvLuxx7MTb2StxRjGGAHj4/GIpmkEVVWdY6XUZG9ANCYab3LO4XA4YLfbCUmSJBITrPP7QEhoiaNLdVy5WWstB7fbrWC9Xp9j1vszTsiM8TDmJPlEIdsk4jhGURSiLqhs21bWzWaDPM+htYIxDl2XoeveoPUe0bhVrnVdiwoeoFfMWffeS04v+Y1o2wZFUaNpHpCmt1Bq3isMZDxEFSQJnjEPXVA5VQeFVVUiz2nBE5S6h3PzQSE94+3L5VIU8iBJCRKNvabHQYhzHt638D6DtZ8tcwO9IVFZlqKMJLyAOTF+AQNCjX+8kzUKN7JNqsqyDPv9/qw44HvCnrR/Nj0iGp2mqYBKQkzSy/Yuh+A7RGx1sViId1TJdTabYbVaTabhGtKIftG7uu7fW1FUSJJMaj+N16+EXwsOzvERrybTczXhYK6GtYDWz8jzOyj1DmtPUv+HwjHhI8ryBs69whjI0Pd/8I+EYci9jwG8wNpC8uFJXEf4ASte1qZJXzjwAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"store设计\"\n        title=\"store设计\"\n        src=\"/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png\"\n        srcset=\"/blog/static/e6385772916f35fe16003bf9eb93be77/63868/storeDesign.png 250w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/0b533/storeDesign.png 500w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/00d43/storeDesign.png 1000w,\n/blog/static/e6385772916f35fe16003bf9eb93be77/187fa/storeDesign.png 1194w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-8-1-前端快报","date":"2022-08-05","tags":"前端快报","path":"/2022-8-1","top":null,"summary":null},"title":"2022-8-1-前端快报","date":"2022-08-05","tags":"前端快报","path":"/2022-8-1","top":null,"summary":null},{"id":"bf1c7d29-cf60-5ac9-b56f-e0daabe2565e","html":"<h2><a href=\"https://h3manth.com/ES2022/\">ES2022 Features!</a></h2>\n<p>这篇文章介绍ES2022的Features。</p>\n<h2><a href=\"https://mikevdv.dev/blog/2022-06-23-stop-the-screen-going-to-sleep-with-javascript\">Stop The Screen Going To Sleep With JavaScript</a></h2>\n<p>这篇文章介绍WakeLock api的使用方法。WakeLock用于防止用户屏幕变暗或者锁屏。<a href=\"https://github.com/richtr/NoSleep.js/\">NoSleep.js</a>就是封装了WakeLock的能力来实现对应的功能.</p>\n<p>NoSleep功能实现:</p>\n<ul>\n<li>在支持wakeLock的设备上使用wakeLock</li>\n<li>在老的ios设备上  通过设置当前href和window.stop的定时器来激活页面</li>\n<li>其他情况通过设置一个循环播放的video标签来实现</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/wbkd/react-flow\">react-flow</a></h3>\n<p>react绘制图表和流程图的工具库</p>\n<h2>想法</h2>\n<h3>关于前端页面设计</h3>\n<ul>\n<li>作为前端开发似乎很容易直接从页面的角度去考虑实现，因为接触的UI就是最直观的图形输入。但是页面不光是简单的UI展示，后面还承载着数据的流动。从数据流去思考业务的逻辑和设计实现页面和业务逻辑的分离。数据承接逻辑，页面承接UI渲染组合能更好的服务于页面的扩展。</li>\n</ul>\n<h3>react hooks的理解</h3>\n<p>hooks是react暴露给外部的接口。这个是react增加hooks提供的一个比较重要的能力。比如react query通过hooks的能力桥接了queryClient.</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/pierpo/react-archer\">react-archer</a>源码分析</h3>\n<p>react-archer通过箭头线绘制React节点之间的关联关系。它的实现主要:</p>\n<ul>\n<li>维护全局的节点关联关系(逻辑抽象 封装)</li>\n<li>解耦节点渲染和箭头线渲染(解耦)</li>\n</ul>\n<h4>节点关系处理逻辑</h4>\n<pre><code>    // 子节点注册逻辑\n    const registerTransitions = (newRelations: Array&#x3C;RelationType>) => {\n        // 格式化节点配置\n        const newSourceToTarget = generateSourceToTarget(id, newRelations);\n        assertContextExists(context);\n        // 更新全局节点配置\n        context.registerTransitions(id, newSourceToTarget);\n    }\n\n    // 根节点更新逻辑\n    const _registerTransitions = useCallback(\n        (elementId: string, newSourceToTargets: SourceToTargetType[]): void => {\n            // 节点关系在根节点中通过useState进行更新维护 触发组件更新\n            setSourceToTargetsMap((previousValue) => ({\n                ...previousValue,\n                [elementId]: newSourceToTargets,\n            }));\n        },\n        [],\n    );\n</code></pre>\n<h4>箭头渲染逻辑</h4>\n<p>在根组件中通过SvgArrows渲染节点连接逻辑</p>\n<pre><code>// 遍历节点关系数据 依次渲染\n{getSourceToTargets(props.sourceToTargetsMap).map((currentRelation) => (\n    &#x3C;AdaptedArrow\n      key={JSON.stringify({\n        source: currentRelation.source,\n        target: currentRelation.target,\n      })}\n      source={currentRelation.source}\n      target={currentRelation.target}\n      label={currentRelation.label}\n      style={currentRelation.style || {}}\n      startMarker={props.startMarker}\n      endMarker={props.endMarker}\n      endShape={props.endShape}\n      strokeColor={props.strokeColor}\n      strokeWidth={props.strokeWidth}\n      strokeDasharray={props.strokeDasharray}\n      noCurves={props.noCurves}\n      lineStyle={props.lineStyle}\n      offset={props.offset}\n      parentCoordinates={parentCoordinates}\n      refs={props.refs}\n      uniqueId={props.uniqueId}\n    />\n))}\n\n// 使用getBoundingClientRect和配置项计算绘制箭头的位置 最后使用svg进行关联线的绘制\nexport const getPointCoordinatesFromAnchorPosition = (\n    position: AnchorPositionType,\n    index: string,\n    parentCoordinates: Vector2,\n    refs: Record&#x3C;string, HTMLElement>,\n): Vector2 => {\n    const rect = getRectFromElement(refs[index]);\n\n    if (!rect) {\n        return new Vector2(0, 0);\n    }\n\n    const absolutePosition = computeCoordinatesFromAnchorPosition(position, rect);\n    return absolutePosition.substract(parentCoordinates);\n};\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null},"title":"2022-7-1-前端快报","date":"2022-07-01","tags":"前端快报","path":"/2022-7-1","top":null,"summary":null},{"id":"d61957d7-be29-53c8-abf3-4974dbb8a1b8","html":"<p>本文梳理axios中使用CancelToken来实现中断请求的源码实现.\n(CancelToken已经是deprecated, axios已支持AbortController实现相应的功能)</p>\n<h2>简单使用</h2>\n<pre><code>    const CancelToken = axios.CancelToken;\n    // 创建cancelToken\n    const source = CancelToken.source();\n\n    axios.get('/user/12345', {\n        // 请求的时候 传入创建的cancelToken\n        cancelToken: source.token\n    }).catch(function (thrown) {\n        if (axios.isCancel(thrown)) {\n            console.log('Request canceled', thrown.message);\n        } else {\n            // handle error\n        }\n    });\n\n\n    // 调用cancelToken的cancel方法 取消请求\n    source.cancel('Operation canceled by the user.');\n</code></pre>\n<p>上面是axios官网的上使用CancelToken的例子，可以看到通过将创建的cancelToken传入对应的请求对象，就实现了请求控制能力暴露给外部的能力。</p>\n<h2>源码分析</h2>\n<p>XMLHttpRequest支持使用abort方法实现请求的终止，axios底层封装了XMLHttpRequest来实现请求的处理，通过将调用abort方法的能力暴露给外部就实现了请求中断的控制。axios引入了cancelToken来实现这个过程的解耦。下面从具体的源码来看实现的过程</p>\n<h3>创建cancelToken对象</h3>\n<pre><code>// 调用source方法 生成CancelToken 导出token和取消请求的cancel方法\nCancelToken.source = function source() {\n    var cancel;\n    var token = new CancelToken(function executor(c) {\n        cancel = c;\n    });\n    return {\n        token: token,\n        cancel: cancel\n    };\n};\n\nfunction CancelToken(executor) {\n    if (typeof executor !== 'function') {\n        throw new TypeError('executor must be a function.');\n    }\n\n    var resolvePromise;\n    // 设置CancelToken的promise函数\n    this.promise = new Promise(function promiseExecutor(resolve) {\n        resolvePromise = resolve;\n    });\n\n    var token = this;\n    // cancel函数的执行逻辑 在调用cancel接口的时候 执行下面的逻辑\n    executor(function cancel(message) {\n        if (token.reason) {\n            // Cancellation has already been requested\n            return;\n        }\n\n        token.reason = new Cancel(message);\n        resolvePromise(token.reason);\n    });\n}\n</code></pre>\n<h3>cancelToken与XMLHttpRequest绑定</h3>\n<pre><code>    // 代码是axios封装XMLHttpRequest的部分逻辑\n    if (config.cancelToken) {\n        // 如果传入的配置有cancelToken 就调用cancelToken的promise方法 \n        // 通过promise实现控制流的流转 调用cancelToken方法的时候 将resolve时机暴露给cancelToken\n        // 调用cancelToken的cancel方法时,resolve了当前的promise，控制流程回到当前的后续流程，执行request.abort()从而完成请求的终止\n        config.cancelToken.promise.then(function onCanceled(cancel) {\n            if (!request) {\n                return;\n            }\n\n            request.abort();\n            reject(cancel);\n            // Clean up request\n            request = null;\n        });\n    }\n\n    if (!requestData) {\n        requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n</code></pre>\n<p>通过对实现流程的源码梳理，在类似的功能中可以利用promise来完成流程的控制。</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"axios的cancel功能源码解读","date":"2022-06-22","tags":"JavaScript","path":"/axios-cancel","top":null,"summary":null},"title":"axios的cancel功能源码解读","date":"2022-06-22","tags":"JavaScript","path":"/axios-cancel","top":null,"summary":null},{"id":"bdbed110-909c-577e-9652-4e22fb148271","html":"<h2><a href=\"https://michel.codes/blogs/ui-as-an-afterthought\">UI AS AN AFTERTHOUGHT</a></h2>\n<p>这篇文章介绍作者对UI框架和状态管理的思考。在React中开发者通常会在组件中处理业务逻辑，这样导致UI和数据无法解耦。文章中的方式是让React做比较纯粹的渲染框架，业务逻辑组织在全局store中.</p>\n<h2><a href=\"https://mmazzarolo.com/blog/2022-02-16-track-down-the-javascript-code-responsible-for-polluting-the-global-scope/\">Track down the JavaScript code responsible for polluting the global scope</a></h2>\n<p>文章提供了基于ES6 proxy查找全局变量污染的方案</p>\n<h2><a href=\"https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md\">useEvent RFC</a></h2>\n<p>相关文章\n<a href=\"https://typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/\">What the useEvent React hook is (and isn't)</a><br>\nreact增加了useEvent提案，使用场景能帮我们缓存一个函数的回调。主要用于解决如下的问题:</p>\n<ol>\n<li>通常的场景在组件中声明中的函数会因为依赖项的问题导致在渲染的时候函数会新生成引用，这样在使用该函数的子组件就会触发重新渲染。</li>\n<li>react hooks的依赖解耦 比如在一个effect hook中有两段业务逻辑，这样就需要把两段业务逻辑的依赖都加入到effect hook的依赖中，导致effect执行不符合预期。</li>\n</ol>\n<p>useEvent简化实现如下:</p>\n<pre><code>    function useEvent(handler) {\n        const handlerRef = useRef(null);\n\n        // In a real implementation, this would run before layout effects\n        useLayoutEffect(() => {\n            handlerRef.current = handler;\n        });\n\n        return useCallback((...args) => {\n            // In a real implementation, this would throw if called during render\n            const fn = handlerRef.current;\n            return fn(...args);\n        }, []);\n    }\n</code></pre>\n<p>useEvent可以看出是官方的解决前面提到问题的方案，在往前走一会，有如下的一些思考:</p>\n<ol>\n<li>是否需要一个不变的callback => 性能 vs 代码复杂度</li>\n<li>组件是否做了组件该做的事 => 渲染和业务逻辑的设计</li>\n</ol>\n<h2><a href=\"https://www.youtube.com/watch?v=NZoRlVi3MjQ\">The Story of Concurrent React </a></h2>\n<p>视频介绍react Concurrent发展的过程</p>\n<h2><a href=\"https://www.developerway.com/posts/react-key-attribute\">React key attribute: best practices for performant lists</a></h2>\n<p>文章介绍React组件中key使用的注意事项</p>\n<h2><a href=\"https://www.robinwieruch.de/react-hook-detect-click-outside-component/\">React Hook: Detect Click outside of Component</a></h2>\n<p>文章介绍如何实现一个自定义的hook来监听组件外的点击</p>\n<h2><a href=\"https://www.robinwieruch.de/web-applications/\">Web Applications 101</a></h2>\n<p>文章介绍web应用前端技术的发展过程，从最开始的web1.0到web2.0娓娓道来。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/timc1/kbar\">kbar</a></h3>\n<p>kbar是一个给站点提供快捷操作的工具</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null},"title":"2022-6-1-前端快报","date":"2022-06-06","tags":"前端快报","path":"/2022-6-1","top":null,"summary":null},{"id":"e9263203-28a6-5ebd-9a58-365666024052","html":"<p>本文整体记录自己在优化项目代码的思路和实现过程，主要从以下的方面展开:</p>\n<ul>\n<li>项目背景(技术方案，迭代上遇到的问题)</li>\n<li>使用的优化方式</li>\n<li>过程的总结思考</li>\n</ul>\n<h2>项目背景</h2>\n<p>页面的整体结构可以简化成如下的结构:</p>\n<ul>\n<li>顶部数据筛选区, 筛选数据变化触发表格数据更新</li>\n<li>数据表格渲染区域</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/5112c/pageStruct.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB7cTRoF//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQES/9oACAEBAAEFAusdYqJiP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/AYf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARMVFh/9oACAEBAAE/IYCrwU0chIf/2gAMAwEAAgADAAAAENcf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EC4//8QAGxABAAICAwAAAAAAAAAAAAAAAQAhETFBwfD/2gAIAQEAAT8Qw07IZnkha0i69p4MKUT/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"页面结构\"\n        title=\"页面结构\"\n        src=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/a2510/pageStruct.jpg\"\n        srcset=\"/blog/static/c9e36ca5a25f71cb3578f66d35990fef/0479a/pageStruct.jpg 250w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/41099/pageStruct.jpg 500w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/a2510/pageStruct.jpg 1000w,\n/blog/static/c9e36ca5a25f71cb3578f66d35990fef/5112c/pageStruct.jpg 1149w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n数据渲染区域有比较复杂的渲染逻辑，需要根据顶部的筛选区域做数据条目的渲染，因此之前的方案通过useReducer引入全局的store做数据的存储和处理。useReducer的方案在当时看并没有问题，但是随着业务的发展遇到了如下的问题，对业务的迭代产生了一些限制:</p>\n<ol>\n<li>表格组件存在一对多问题，随着业务的发展顶部的筛选区域会产生更多业务类型的表格，导致单一组件中存在较多的\"非\"业务相关处理逻辑 => 页面渲染逻辑不清晰、组件渲染逻辑复用度低</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/aafa5a667beca13516314f38856d0a3d/5112c/tableProblem.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAduFlB//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQES/9oACAEBAAEFAq6xURH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPwGH/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBABAQEBAQAAAAAAAAAAAAAAEQABITH/2gAIAQEAAT8hKQb2O+QYbZi//9oADAMBAAIAAwAAABBPH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAQEBAAAAAAAAAAAAAAAAAAARIf/aAAgBAgEBPxCGP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESExQf/aAAgBAQABPxBzLXmHsaxJ5Sew1cRBIVfdj1F1hsKYT//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"表格组件渲染问题\"\n        title=\"表格组件渲染问题\"\n        src=\"/blog/static/aafa5a667beca13516314f38856d0a3d/a2510/tableProblem.jpg\"\n        srcset=\"/blog/static/aafa5a667beca13516314f38856d0a3d/0479a/tableProblem.jpg 250w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/41099/tableProblem.jpg 500w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/a2510/tableProblem.jpg 1000w,\n/blog/static/aafa5a667beca13516314f38856d0a3d/5112c/tableProblem.jpg 1149w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n2. 在业务迭代中引入了新的概念去实现业务功能，这些概念在业务迭代过程中变得不再适用或者很难维护 => 提前封装\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/61d5f/concept.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB7VTRpBf/xAAYEAADAQEAAAAAAAAAAAAAAAAAARESEP/aAAgBAQABBQKmlyGUQ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/AYf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAEBAQADAAAAAAAAAAAAAAABABEQITH/2gAIAQEAAT8hTEaPlnvgAX//2gAMAwEAAgADAAAAEITf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAECAQE/EIbH/8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFhcZH/2gAIAQEAAT8QO1ZfE0KnjDaiuptp3nZ7fYbRc//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"渲染逻辑问题\"\n        title=\"渲染逻辑问题\"\n        src=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/a2510/concept.jpg\"\n        srcset=\"/blog/static/f2b3e915ba292e3a27b4dfe936970489/0479a/concept.jpg 250w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/41099/concept.jpg 500w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/a2510/concept.jpg 1000w,\n/blog/static/f2b3e915ba292e3a27b4dfe936970489/61d5f/concept.jpg 1162w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上图中引入了一个统一的渲染处理逻辑,这个逻辑可以演化成字段、函数等，在业务的迭代中该业务逻辑可维护性差<br>\n3. 代码组织结构混乱。部分文件超过千行难以维护。useReducer相当于低配版的redux，新功能的增加需要添加更多的模板代码 => 功能&#x26;代码组织缺少梳理</p>\n<h2>优化思路&#x26;思考</h2>\n<h3>功能模块化&#x26;组件化</h3>\n<h4>组件化</h4>\n<p>在部分渲染逻辑上，依赖useReducer返回的全局store和dispatch方法触发action。这样有个问题是无法解耦业务组件与表格组件，表格组件和业务组件的逻辑不能有效地分离。代码缺少组件化，页面渲染逻辑不清晰\n对这部分的思考是引入useContext，通过组件内部获取到全局的store对象从而解耦了组件渲染和表格组件的绑定关系。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/82b8c/component.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB3IJQP//EABYQAAMAAAAAAAAAAAAAAAAAAAAQIf/aAAgBAQABBQIq/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAABAx/9oACAEBAAY/Air/xAAZEAABBQAAAAAAAAAAAAAAAAARAAEQMfH/2gAIAQEAAT8hYm0MI//aAAwDAQACAAMAAAAQh8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAGhAAAgIDAAAAAAAAAAAAAAAAABEBIUFRcf/aAAgBAQABPxDKguEspRez/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组件化\"\n        title=\"组件化\"\n        src=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/a2510/component.jpg\"\n        srcset=\"/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/0479a/component.jpg 250w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/41099/component.jpg 500w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/a2510/component.jpg 1000w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/c58a3/component.jpg 1500w,\n/blog/static/bf75d8fdc7a5715a636e06e7ec1913b1/82b8c/component.jpg 1960w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>功能模块化</h4>\n<p>useReducer函数因为模板代码的问题导致代码行数逐渐增多，这样就在修改代码和熟悉业务增加了成本，降低的维护性。这里引入了combineReducers的概念，在实现新业务的时候，将对应的useReducer处理逻辑封装成独立的模块，在主useRefucer函数中引入从而使实现逻辑模块化。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/01ab0/reducer.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuzUAT/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAQABPyHR1z//2gAMAwEAAgADAAAAEOg//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQETFx/9oACAEBAAE/ENYNd6KEt9Ej/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reducer逻辑分离\"\n        title=\"reducer逻辑分离\"\n        src=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/a2510/reducer.jpg\"\n        srcset=\"/blog/static/f9641cd2a22d8edbe1729274fbb45d19/0479a/reducer.jpg 250w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/41099/reducer.jpg 500w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/a2510/reducer.jpg 1000w,\n/blog/static/f9641cd2a22d8edbe1729274fbb45d19/01ab0/reducer.jpg 1300w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n随着业务迭代，应该适当地对组件进行隔离维持好组件单一职责的本心，如果多个模块都有类似的能力但是业务逻辑不一致就不要在一个组件中维护过多的能力。可以在上层收口再实现层分离。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/01ab0/single.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7NQA//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAABEBEg/9oACAEBAAE/Ibgr/9oADAMBAAIAAwAAABDoL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAICAwAAAAAAAAAAAAAAAAABEXEQITH/2gAIAQEAAT8QoNzPcpuxI//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组件逻辑拆分\"\n        title=\"组件逻辑拆分\"\n        src=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/a2510/single.jpg\"\n        srcset=\"/blog/static/0494c1399b6b049ff25e0794a20eec64/0479a/single.jpg 250w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/41099/single.jpg 500w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/a2510/single.jpg 1000w,\n/blog/static/0494c1399b6b049ff25e0794a20eec64/01ab0/single.jpg 1300w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>引入新的技术方案降低模板代码</h3>\n<p>useReducer可以通过action的合理设计来减少模板代码，但是在增加新功能的时候，需要声明action、reducer处理逻辑，随着业务的迭代这些模板类代码会越来越重，这里引入的mobx方案去解决这个问题</p>\n<h3>对封装的思考</h3>\n<p>在业务迭代比较频繁的模块，可以通过封装简单的util函数来达到代码的复用能力。随着业务迭代，直接对整体业务模块的封装会导致代码的可理解性、可维护性下降。（这里讨论的问题并不是降低封装而是延迟封装）<br>\n在下图中，有多个业务处理模块都有使用A处理逻辑，但是在后续的模块中对A逻辑的能力都有限制和修改。如果在初期就抽离出A逻辑就会导致A逻辑中引入了后续模块的特定逻辑进而降低该模块的可维护性。在进行业务修改的时候覆盖的范围也是扩大的。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 612px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 128%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt2E0FikKX/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQABBQJP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwJP/8QAGhAAAwADAQAAAAAAAAAAAAAAAAEREFFhcf/aAAgBAQABPyG9PcVlfgil4Ii0Rax//9oADAMBAAIAAwAAABC8I8D/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAeEAEAAgEFAQEAAAAAAAAAAAABABEhMUFRYXGRof/aAAgBAQABPxB1YeXBc2OqYPcbnO/M5P1dxXebzFW4fYK3I9qJz0zepfks1HyAGgE//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"封装\"\n        title=\"封装\"\n        src=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg\"\n        srcset=\"/blog/static/bd72f3db3c4c906ece570c5b72b785c1/0479a/module.jpg 250w,\n/blog/static/bd72f3db3c4c906ece570c5b72b785c1/41099/module.jpg 500w,\n/blog/static/bd72f3db3c4c906ece570c5b72b785c1/a18e1/module.jpg 612w\"\n        sizes=\"(max-width: 612px) 100vw, 612px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n比较好的思路是在业务比较稳定的时候再对A逻辑进行区分，在组织逻辑上通过入口划分不同的业务细节。</p>\n<p>以上就是自己在业务代码优化上的一些实践和思考。代码的优化并不是一蹴而就的，是渐进式的。最开始的设计相当于建筑的地基，这个地基的好坏能一定程度上为项目保驾护航。代码的优化则是自身对业务理解梳理，对功能实现的总结思考，相当于对建筑的添砖加瓦，是个有意思的过程。</p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"记一次项目代码优化","date":"2022-04-06","tags":"工程化","path":"/code-refactor","top":null,"summary":null},"title":"记一次项目代码优化","date":"2022-04-06","tags":"工程化","path":"/code-refactor","top":null,"summary":null},{"id":"b1129eb4-7e02-5c11-a5be-9651c06a747d","html":"<h2><a href=\"https://timothygu.me/es-howto/\">How to Read the ECMAScript Specification</a></h2>\n<p>这篇文章介绍如何阅读ECMAScript规范的一些思路，文章中有对规范章节内容的整体划分和规范写法的例子解读.规范比较难啃，可以通过例子熟悉规范的写法，在自己需要了解相关内容的时候去阅读规范</p>\n<h2><a href=\"https://dev.to/this-is-learning/conquering-javascript-hydration-a9f\">Conquering JavaScript Hydration</a></h2>\n<p>前端框架的服务端渲染可以在服务端输出组件的内容(html, data-fetch)，一定程度上加快FCP(First Contentful Paint).在用户侧浏览器根据服务端提供的内容执行前端脚本完成事件的绑定和组件相关逻辑的执行，这个过程称为Hydration(注水)。在Hydration过程中页面仍然是不可交互的，造成了页面可交互的假象。所以尽量减少在Hydration中执行的逻辑是优化性能的一个方向。这篇文章给出了这个方面的一些思考。</p>\n<h2><a href=\"https://www.chakshunyu.com/blog/a-fundamental-guide-to-react-suspense/\">A Fundamental Guide To React Suspense</a></h2>\n<p>这篇文章详细地介绍的React中使用Suspense解决问题的背景和优点。</p>\n<h2><a href=\"https://www.robinwieruch.de/react-libraries/\">React Libraries for 2022</a></h2>\n<p>这篇文章介绍列举了React中一些通用的解决方案和工具库，包括状态管理、项目结构、代码规范等。</p>\n<h2><a href=\"https://uniqname.medium.com/why-i-avoid-async-await-7be98014b73e\">Why I avoid async/await</a></h2>\n<p>这篇文章介绍了作者对使用async/await的一些思考，主要的观点心智的转换和写法上的比较。async/await表面上将异步代码转换成同步代码的写法一定程度上改变了代码的运转模式。</p>\n<h2>ECMAScript规范</h2>\n<h3><a href=\"https://2ality.com/2022/03/properties-of-primitives.html\">How do primitive values get their properties?</a></h3>\n<p>这篇文章介绍ECMAScript语法层面上对初值的封装逻辑、属性的获取逻辑、方法的调用逻辑。</p>\n<h3><a href=\"https://github.com/tc39/proposal-type-annotations\">proposal-type-annotations</a></h3>\n<p>tc39新增Type Annotations的proposal,现在处于stage 1阶段。未来有可能javascript直接支持类型定义，可以理解ECMAScript在吸收javascript超集的优点。</p>\n<h3><a href=\"https://2ality.com/2022/04/shadow-realms.html#shadowrealm.evaluate()\">ShadowRealms – an ECMAScript proposal for a better eval()</a></h3>\n<p>这篇文章对ShadowRealms proposal进行了详细的介绍，现在处于stage 3阶段。</p>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/nolimits4web/atropos\">atropos</a></h3>\n<p>atropos是一个做3D触摸特效的动画库</p>\n<h3><a href=\"https://stuk.github.io/jszip/\">JSZip</a></h3>\n<p>JSZip是一个JavaScript操作zip文件的库</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null},"title":"2022-4-1-前端快报","date":"2022-04-01","tags":"前端快报","path":"/2022-4-1","top":null,"summary":null},{"id":"4c1cd05d-9c62-5dd4-ab31-4f1ca0a7aee3","html":"<h2><a href=\"https://monorepo.tools/\">Understanding Monorepos</a></h2>\n<p>这篇文章通过对Monorepo/Polyrepo(多仓库模式)、实现Monorepo的工具进行对比，对使用Monorepo模式进行开发有参考价值。</p>\n<ol>\n<li>Monorepo是什么: Monorepo在主体仓库中组合了多个子仓库并且这些子仓库的功能是相关联的,对应的例子可以参考<a href=\"https://github.com/facebook/react\">react</a>项目的仓库</li>\n<li>为什么使用Monorepo: Monorepo在组织关联业务代码上有优势，能减少代码复用、技术统一、开发调试中的问题</li>\n</ol>\n<p>关于Monorepos和Polyrepo的思考可以参考这篇文章<a href=\"https://earthly.dev/blog/monorepo-vs-polyrepo/\">Monorepo vs Polyrepo</a></p>\n<h2><a href=\"https://www.modularmanagement.com/blog/what-is-a-good-modular-system\">What is a Good Modular System?</a></h2>\n<p>这篇文章介绍了系统设计的思考点</p>\n<ul>\n<li>模块的功能界定  通过引入模块系统可以降低系统的复杂性，提高系统的灵活性,但是对于引入的模块功能的界定划分需要考量。如果功能没有界限好会导致功能代码从一个位置移动到另一个位置增加了模块维护的复杂度。比如之前的中台概念，需要划分好中台的功能才能更好的实现中台的能力，拆分出模块系统一方面做得更多去帮助系统更好，一方面也要思考如果做得更少去实现最初的目标</li>\n<li>生命周期 功能的稳定和灵活性能提高模块的生命周期</li>\n<li>模块收益的衡量标准</li>\n</ul>\n<p><img src=\"weeklyReport22/modular-value.png\" alt=\"模块收益衡量标准\"></p>\n<p>通过模块衡量的公式，在进行模块系统设计的时候可以有以下的考虑:</p>\n<ol>\n<li>平台的功能边界考量\n<ol>\n<li>不是越少越好，前期的投入能力后期带来收益</li>\n<li>前期的忽视需要后续弥补，要仔细思考</li>\n<li>用小范围的能力边界限制实现整体的灵活扩展</li>\n</ol>\n</li>\n<li>整体和部分的考量\n<ol>\n<li>不用一步到位，部分功能提升到独立的系统也能产生比较大的价值，后期再进行统一</li>\n<li>在资源可能的情况下，相关的依赖系统要统一升级</li>\n</ol>\n</li>\n<li>从长期的视角去看系统的模块设计 从现在的能力出发结合系统未来的发展诉求去做系统设计(能力建设)，这个角度的考虑也是在为未来打地基</li>\n</ol>\n<p>对于模块系统的介绍可以参考这篇文章<a href=\"https://www.modularmanagement.com/blog/all-you-need-to-know-about-modularization\">All You Need to Know About Modularization</a>,模块的实现应该在部分能力抽象的情况下实现系统整体的灵活性</p>\n<p><img src=\"weeklyReport22/modular-define.png\" alt=\"模块化系统的定义\"><br>\n模块化系统能带来效率、灵活度、敏捷的特点。</p>\n<ol>\n<li>效率 模块的复用/功能的组装  这里可以通过比喻装配式建筑来理解,通过对预制模块在工地快速的组装就快速完成了建筑的装配。</li>\n<li>灵活性 基础模块能快速的组装出新的功能模块/通过统一的接口设计能快速的实现模块的功能替换</li>\n<li>敏捷性 由于基础模块的拆分，通过基础模块的改变就可以快速地影响整个系统</li>\n</ol>\n<h2><a href=\"https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd\">Deep dive into React Native’s New Architecture</a></h2>\n<p>这篇文章通过React Native前后架构的对比对新旧架构进行了介绍</p>\n<h2><a href=\"https://kentcdodds.com/blog/javascript-to-know-for-react\">JavaScript to Know for React</a></h2>\n<p>这篇文章介绍了React中JavaScript的一些常用的语法，比如模板字符串、可选链、空值合并预算符等</p>\n<h2><a href=\"https://blog.bitsrc.io/some-reasons-for-disliking-react-hooks-80f1e18eb9b3\">Some reasons for disliking React hooks</a></h2>\n<p>这篇文章作者介绍了使用react hooks的优缺点</p>\n<ul>\n<li>优点 hooks可以更好实现代码的复用组合/逻辑集中</li>\n<li>缺点 hooks的写法上有上手成本和调试成本，容易引发一些bug，还有不要过于过度使用hooks.hooks的调用方式是通过数组的方式调用函数，过多或者依赖关系复杂的hooks会降低页面的性能</li>\n</ul>\n<h2><a href=\"https://blog.bitsrc.io/inversion-of-control-with-react-584533e49245\">Build Decoupled React Components with Inversion of Control</a></h2>\n<p>这篇通过例子的方式介绍通过反转控制的方式解耦组件的实现来应对未来逻辑的变更</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"2022-3-1-前端快报","date":"2022-03-07","tags":"前端快报","path":"/2022-3-7","top":null,"summary":null},"title":"2022-3-1-前端快报","date":"2022-03-07","tags":"前端快报","path":"/2022-3-7","top":null,"summary":null},{"id":"983124c1-808b-5e13-bea1-17907d6cd08f","html":"<p>这里记录下2022读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2022年已阅读: 40本</p>\n<p>2022读书感悟:\n最开始以为读书能看懂世界，觉得能增加所谓的阅历，其实发现多个看世界的视角就好</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\n4  推荐 看后感觉不错，有内容收获\n4.5 很推荐 收获很多或者内容精彩\n5 极力推荐  佳作</p>\n<h2>《半小时漫画历史系列》- 陈磊</h2>\n<h3>推荐指数 5</h3>\n<p>原来发现历史是这么有趣，原来晦涩的朝代故事在笔者轻松的表达下竟然那么引人入胜，非常适合在闲暇的时候当历史简版读物来看。</p>\n<h2>《动物农场》- 乔治·奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>经典之作。这本书描写了动物农场的一场反抗活动，对现实社会有影射意义，思考我们是不是也在一个农场中，只是压迫的程度大小，要跳出来看自己的生活。</p>\n<h2>《1984》- 乔治.奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>是看完动物农场才看的《1984》. 书中塑造了一种恐怖绝望的氛围会跟着主人公体验到从拥有希望到绝望的过程，在小说的故事中文明、历史似乎都可以被改写。读完会有疑惑就是书中描绘的社会是否会在现实中呈现，如果生活在那样的社会应该是十分的压抑的。</p>\n<h2>《为什么是中国》- 金一南</h2>\n<h3>推荐指数 4</h3>\n<p>这本书主要介绍中国近代以来的发展历史，其实作为中国人会感觉到自豪，中国在社会实践上走的是一条充满实践的道路</p>\n<h2>《胜者思维》- 金一南</h2>\n<h3>推荐指数 4.5</h3>\n<p>本书中金一南通过对中国历史发展从军事的角度进行总结，一些思路在其他的领域也很有价值，比如领导者的领导作用、权力的下放与担责</p>\n<h2>《认知觉醒: 开启自我改变的原动力》- 周岭</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中的对思维方式表达改变了我之前对思维方式的思考，思维是可以训练，我们对自己也不应该固步自封，很推荐看这本。</p>\n<h2>《柳林风声》- 肯尼斯·格雷厄姆</h2>\n<h3>推荐指数 4.5</h3>\n<p>这是一本适合大人和孩子一起看的童话书，书中的小动物形象跃然纸上，有的时候你会为书中的蛤蟆扼腕叹息，认为它罪有应得，会喜欢上对人和善的鼹鼠。在阅读的过程中仿佛你就进入了这个童话的世界，跟着动物们一起探索，历险。</p>\n<h2>《时间的形状:相对论史话》- 汪洁</h2>\n<h3>推荐指数 5</h3>\n<p>非常通俗易懂的科普读物 作者通过讲故事的方式把比较硬核的理论通俗易懂地讲出来。了解到相对论等理论的发展过程,发现人类的探索欲也觉得人类很渺小.这是一本充满科学内核的科普“小说”。称它为小说是因为你会被一个个故事所吸引。非常推荐</p>\n<h2>《宇宙的琴弦》- 格林</h2>\n<h3>推荐指数 3.5</h3>\n<p>弦论的科普读物。书中的论证的过程和思考的方式有一定的启发作用</p>\n<h2>《中国新基建：未来布局与行动路线》</h2>\n<h3>推荐指数 3.5</h3>\n<p>这本书比较全面地介绍了新基建的方向、图谱、路径。需要意识到与别人的差距也要切实的看到中国的进度，建立中国自信</p>\n<h2>《花猫三丫上房了》 - 叶广岑</h2>\n<h2>《土狗老哥闯祸了》 - 叶广岑</h2>\n<h2>《耗子大爷起晚了》- 叶广岑</h2>\n<h3>推荐指数 4.5</h3>\n<p>非常生动的童年故事，读起来会有很多温馨的瞬间。不是童话却有童话的感觉</p>\n<h2>《这就是中国: 走向世界的力量》 - 张维为</h2>\n<h3>推荐指数 4.5</h3>\n<p>这本书的内容很多，值得反复阅读。主要包括我们是怎么崛起的、我们为什么会崛起、我们的制度优势、需要建立中国自信(有自己的视角看问题和解读问题，建立自己的话语体系)等。在开始阅读的时候会觉得鸡血貌似多了一点，在逐渐阅读大部分后发现自己之前的一些想法不够成熟。书中的视角是从国家的角度来阐释发展，其实映射到个人也有一定的价值。非常推荐。</p>\n<h2>《超越期待：松浦弥太郎的人生经营原则》- 松浦弥太郎</h2>\n<h3>推荐指数 2</h3>\n<p>书的内容围绕着作者的人生态度和处事原则的细致总结，读起来相对来说缺少面的陈述，不推荐</p>\n<h2>《献给阿尔吉侬的花束》 - 丹尼尔·凯斯</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完有些伤感，小说通过日记的方式叙述查理从不聪明到聪明又回归到愚钝的状态，作者对心理变化的描述入微，读起来感觉在跟查理经历着这一切。这本书有许多的现实反射，比如</p>\n<ul>\n<li>查理的妈妈小时候对查理的不认同，导致查理性格上的讨好和迫切的希望获得别人的认可，可见在孩子幼年的时候塑造一个健全的人格的重要性</li>\n<li>如何接受和认识自身的问题 在没变聪明之前查理过得很开心，在经历了变聪明又变不聪明之后查理的心态无法回到之前的状态，这里也情有可原。文中有两个查理体现在聪明程度的差异，在我们自身上是否在其他方面也有另一个查理呢，在暗处观察着自己。</li>\n</ul>\n<h2>《西方哲学史:从古希腊到当下》- 奎纳尔·希尔贝克 尼尔斯·吉列尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>整本书比较详细的描写了人类历史发展阶段的哲学思考过程.我们现在的社会发展成当前的模式是在前人的思考基础上的,从这个角度去阅读和理解本书是一个不错的角度</p>\n<h2>哪有没时间这回事(白金版) - 纪元</h2>\n<h3>推荐指数 3</h3>\n<p>对时间的管理上有一定的启发</p>\n<h2>聪明的投资者(第四版) - 本杰明·格雷格姆 贾森·兹威格</h2>\n<h3>推荐指数 4.5</h3>\n<p>价值投资的观点并不过时。书中主要介绍格雷厄姆对价值，对投资的一些思考。</p>\n<h2>股票大作手回忆录 埃德温·勒菲弗</h2>\n<h3>推荐指数 3.5</h3>\n<p>作为利弗莫尔一生在”投机“生涯的回忆录，记录视角上会感觉一个经历了大起大落的人在你耳边叙述他的一生。</p>\n<h2>时间尽头的咖啡馆 约翰·史崔勒基</h2>\n<h3>推荐指数 4</h3>\n<p>一本简短的小说，通过故事的方式引领你的思考-关于生命的意义。找到问题的答案仍然需要自己的积极思考</p>\n<h2>斯坦福极简经济学 蒂莫西·泰勒</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中通过简单的例子阐述宏观和微观经济学的基本概念，读起来兴趣盎然。经济学有助于我们改变对世界的认识，推荐这本。</p>\n<h2>养育你内心的小孩 丛非从</h2>\n<h3>推荐指数 4</h3>\n<p>这本书从心理学的角度上介绍了安全、自由、价值、意义、亲密等对行为产生的影响。我们对于外界的行为起因是我们的内心有一定的冲突，要不停的认识自己。</p>\n<h2>火星编年史 雷·布拉德伯里</h2>\n<h3>推荐指数 4.5</h3>\n<p>很喜欢作者对人类文明发展的克制表达，是一本有诗意却有些悲凉色彩的科幻小说</p>\n<h2>邓小平时代 傅高义</h2>\n<h3>推荐指数 4.5</h3>\n<p>对历史的细节有了更多的了解。邓爷爷一辈子起起伏伏，一直在为中国发展贡献着力量，阅读过程中会感觉一个亲切而坚定的人跃然纸上，作者在写作本书的时候对历史的细节有足够的求证力图还原真实的历史。阅读本书了解到了什么是中国特色社会主义制度，为什么会有经济特区，发展才是硬道理等等，祖国的今天得来不易，以史为鉴才能走得更好，感恩前人。</p>\n<h2>法治的细节</h2>\n<h2>圆圈正义: 作为自由前提的信念  罗翔</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完这两边书让我对法治的概念有了基本的思考，也了解到要接受自己的局限性，多思考。</p>\n<h2>李光耀观天下 李光耀</h2>\n<h3>推荐指数 4</h3>\n<p>跟随李光耀先生的视角看了一次世界.在看待中国问题上还是存在一些西方的视角不过也的确看到了发展中出现的问题。在其他区域的发展上从政治经济上看的很广,有全局的视野</p>\n<h2>鼠疫 加缪</h2>\n<h3>推荐指数 4.5</h3>\n<p>在新冠疫情的背景下看这本书更加有感触。书中散发着作者对于生活坚定的力量。</p>\n<h2>用经济思维看懂世界格局·亚欧大陆经济整合--新体系伟大力量的源泉 徐伯赢</h2>\n<h3>推荐指数 5</h3>\n<p>本书从经济学的角度来探讨世界格局，覆盖了美、欧、中东、东南亚、日本、中国在经济领域的历史，读起来兴趣盎然。在探讨的视角是也比较宏观。</p>\n<ul>\n<li>日本和东南亚就像今天中国发展的镜子，如何解决房地产泡沫问题、如何寻找经济发展替换地产经济的问题，发展方式的选择问题(合作共赢还是胜者通吃)、金融领域的开放问题等，有不错的借鉴意义</li>\n<li>欧债危机暴露了很多问题，看似表面团结的欧盟(英国与欧洲大陆国家，欧洲大陆核心国与非核心国)由于国家经济政策不同和整个欧盟产业结问题容易产生一些隐藏的问题。欧盟似乎应该在更加统一的财政政策和独立于美国的政策上发力</li>\n<li>对比其他国家和区域，我们的发展路线是在全球化背景下实践一条合作发展，互利共赢的道路，虽然我们现在也面临很多的问题(法制的建设等)，希望这些问题会越来越好，附上这本书结尾的话: 士不可以不弘毅，任总而道远</li>\n</ul>\n<h2>PDCA循环工作法 冈村拓郎</h2>\n<h3>推荐指数 3.5</h3>\n<p>PDCA循环工作法的实践书籍，对于一些细节和思考上有收获。适合快读</p>\n<h2>纳闷集 匡扶</h2>\n<h3>推荐指数 3</h3>\n<p>漫画集，通过漫画和搞笑的表达方式叙述了温暖的故事</p>\n<h2>战胜华尔街 彼得·林奇 约翰·罗瑟查尔德</h2>\n<h3>推荐指数 4</h3>\n<p>之前读过股票大作手回忆录-利弗莫尔的回忆录，是第三方视角记录的有些内容就会存在失真，收获有限。这本书是彼得·林奇个人写的自传，本书从头到尾都在基于他投资选股的内容进行阐述，在对周期股的概念、长期价值投资的坚定、选股思考的逻辑都有不错的收获</p>\n<h2>自洽: 在不确定的日子里向内看 史欣悦</h2>\n<h3>推荐指数 3.5</h3>\n<p>自洽是一个向内沟通的过程，自己之前有段时间工作相对忙碌，在那段时间里很少的考虑到自己本身的一些想法，被一件一件推着往前走。比较缺少对做的事情的一些思考。最近时常会蹦出来一些想法当时如果这么做会更好。在快的节奏里面如果保持自己的节奏(内心)很重要，需要不断的跟自己沟通，丰富自己的认知。</p>\n<h2>看懂世界格局的第一本书 王伟</h2>\n<h3>推荐指数 4</h3>\n<p>通过本书了解到了很多历史的细节和全面的视角,对了解世界格局和经济很有帮助.比如日本、苏联、东南亚国家的发展都对现在有借鉴价值</p>\n<h2>认知世界的经济学 珍大户</h2>\n<h3>推荐指数 4</h3>\n<p>作为入门读物,在需求供给、弹性、利率等方面通过例子讲解的很清晰.书中有些例子有些刻意为之但是瑕不掩瑜</p>\n<h2>随风去野 白关</h2>\n<h3>推荐指数 4</h3>\n<p>跟随生动的插画与作者一起经历了骑行过程中的人、事、景色，是一次不错的体验</p>\n<h2>海龟交易法则 柯蒂斯·费思</h2>\n<h3>推荐指数 3</h3>\n<p>本书是作者个人的经历介绍.海龟交易法阐述了在市场中交易的基本原则,控制风险、控制仓位、止损、止盈等.从书中的收获是在市场中要掌握自己的优势，发挥自己的优势。 建议关键章节详细看</p>\n<h2>中国近代通史(全10册) - 中国社会科学院近代史研究所</h2>\n<h3>推荐指数 5</h3>\n<p>从鸦片战争到中华人民共和国成立，这本书详细的介绍了中国近代史的细节。在阅读的过程中会有历史在眼前重演的错觉，会有遗憾、不解、叹息等情绪。历史仿佛能启发人的思考，以史为鉴可以正衣冠应该说的就是这个道理，对近代史感兴趣的话推荐这本书</p>\n<h2>荒原狼 赫尔曼·黑塞/涂媛媛译</h2>\n<h3>推荐指数 3.5</h3>\n<p>书中的荒原狼可以理解是黑塞本人或者自我抗争的一种表现，书中有很多光怪陆离的表达手法读起来还不错</p>\n<h2>局外人 加缪</h2>\n<h3>推荐指数 4</h3>\n<p>加缪的小说很像有人在你身边讲故事，通过平淡且扎实的叙事方式推进故事的演进</p>","fields":{"readingTime":{"text":"19 min read"}},"frontmatter":{"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null},"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null},{"id":"e88dde7e-fd25-5606-b4a9-8cd74b7e55be","html":"<h2><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/\">JavaScript. The Core: 2nd Edition</a></h2>\n<p>这篇文章介绍JavaScript的一些核心概念，包括对象、原型链、闭包、this、执行上下文等，适合温故知新</p>\n<h2><a href=\"http://www.ayqy.net/blog/%E7%90%86%E8%A7%A3git-submodules/\">理解Git Submodules</a></h2>\n<p>这篇文章介绍了包管理通用的几种方式: npm packages/monorepo/git submodules.\nnpm packages的管理方式基于npm的版本控制方式实现子模块更新，更适合管理底层库、基础依赖。这类代码的变更相对较少，主repo更多使用的是子repo编译后的代码产物<br>\nmonorepo 适用于服务于同一功能的多个模块的组合方式，模块之间功能划分清晰，依赖清晰。解决方案有<a href=\"https://github.com/lerna/lerna\">lerna</a>和yarn的<a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">workspaces</a>.monorepo的优势是可以在一个仓库内完成不同包模块功能的测试，不需要关注子repo的版本问题。劣势是需要解决node_module的依赖问题、编译流程、主repo体积问题等。业务不相关的模块建议直接拆仓维护，自治的成本反而更低。<br>\ngit submodules跟monorepo的理念相近，都直接依赖子repo的源码进行开发。git submodules优势是可以实现子repo的共享源码能力(相对于编译后产物的优势)，可以实现功能的复用(npm packages/微前端)。</p>\n<h2><a href=\"https://blog.plasmic.app/posts/how-react-server-components-work/\">How React server components work: an in-depth guide</a></h2>\n<p>这篇文章详细的介绍了React Server Components的实现机制，通过React Server Components可以更好的实现bundle体积的减少，渲染时间的加快,值得后续的关注</p>\n<h2><a href=\"https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/\">Improving JavaScript Bundle Performance With Code-Splitting</a></h2>\n<p>这篇文章详细的介绍了使用Code Split的细节和关注点</p>\n<h2><a href=\"https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html\">Use Streams to Build High-Performing Node.js Applications</a></h2>\n<p>这篇文章详细的介绍了node中stream流的使用细节，通过例子的方式讲解了流的状态，背压等概念。</p>\n<h2><a href=\"https://www.developerway.com/posts/how-to-write-performant-react-code\">How to write performant React code: rules, patterns, do's and don'ts</a></h2>\n<p>这篇文章通过例子的方式介绍react代码的优化方式，阅读过后能发现出平时一些不注意的点</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null},"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null},{"id":"f93c19b6-9fb0-5f4d-84d1-c3e05c285d4e","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#single-spa\">single-spa简单用法</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#\">子应用配置</a></li>\n<li>1.2. <a href=\"#-1\">主应用配置</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#single-spa-1\">single-spa源码分析</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">启动</a></li>\n<li>2.2. <a href=\"#-1\">子应用挂载/切换</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">关于微前端的一些总结思考</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>微前端是应用组装的一种模式,本文从single-spa的使用方式入手逐步深入到single-spa的源码实现了解微前端的实现方式</p>\n<h2>1. <a name='single-spa'></a>single-spa简单用法</h2>\n<p>single-spa通过子应用与主应用约定交互协议实现微前端应用,在具体的交互中:</p>\n<ul>\n<li>子应用需要暴露应用生命周期方法,例如bootstrap、mount、unmount</li>\n<li>主应用与子应用约定激活规则</li>\n<li>主应用根据挂载规则动态的切换应用状态并且执行对应子应用的生命周期方法</li>\n</ul>\n<p>下面的例子分别从子/主应用的角度梳理下single-spa实现微前端方案的配置方式,在例子中定义了一个主应用(baseapp), 两个子应用(app1, app2).</p>\n<h3>1.1. <a name=''></a>子应用配置</h3>\n<p>single-spa基于js Entry的方式实现微前端方案,在子应用导出的js模块中需要包含子应用的生命周期函数方法，这里的两个子应用都以create-react-app创建的react应用举例,实例代码已上传到<a href=\"https://github.com/icantunderstand/microappdemo\">微前端demo</a></p>\n<ol>\n<li>使用create-react-app创建子应用 npx create-react-app app1</li>\n<li>进入到对应的目录\nnpm run eject // 将创建项目的配置弹出\nnpm install single-spa-react -S</li>\n<li>修改项目的webpack配置,修改输出文件(这里仅为测试使用)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAADEUlEQVQ4y32U647bNhSE/RqpLV51sShS94stW7K3mwDdogX6/i/zFdJuNkh+5MeAJETMGZ3hmUNd1wghUFKQlTXl/YHrO4oqR5kIqU4oc0LqiCiK9ru/w6Gqqn2jtUZrRVYGsqog7yqKqSNva8p1prj0aBtzOkVEJ7GTR5Eg2s8fiASHT4VKYa2lGCfyvsL1LUXXU15H2peVom9J8wSbChJvMalGJ4rYWWxuiJ3BJJpDWZafhMYaimGivN/w44g6nzmOM9F9JeonjuOCfHwlLh1KC5RRmGwj1nsBZSSHpml+Uph4R9YUnLuA9Sm6dNjGY+qC5FJjm4I0pJhU7cqS8K42Lt7X/ZellO8KjcGPV9r1T+rLTP94pb3eMaFCTStivCOmB2JcUO2EkRHGaJSSe/+lkhxCCD8RGq1J0pSmrmi6jqqu2Yybhp6hqehCwb0JzLVnrgoupWMMOUvtaV3GwTmHEN8JLanzZMMd8/wX8/IP+vqKff0PtbxRNR1j8Fx9zmMjLQsmn/M2NgzuzL0sOHjvfyi0lnxTtdxonnfCNOKHjjBNlPOFNLf0bU4VMlqfMTSOpj5z6QuCT+ma/FfCzXpJ7CRZpUnDBoPZn4oiqxPSJib2BlsYTGGIgyUu32GD/ZlQG4PMDNpZjI9JugxTxpgyQTlL3CTYKtm/ZcMZnW0FLWmIsWez45NQKkVuLev1xnpfea4v3IaBZZx4Lg9uXc9jWblfLizzzMvzhbafUPbd3Q1Cih8uC6WZE8M8Tiyv33j+9Ubnc/6eKr72gbUOBGvxRlNoTakkV6uJpEJ+zPHGcxi3idgqaM010SQuIxsDbi5w45lm8fg5J68dUhsipVDW7k9sjjUmjkmSZD9vg7ErVB8KL1YRmoZyvuGGlrKw3PyZxBj+OB53JVsqbasRgl6eOP2aNt97KJTiEivSEEjHHncbcesVWZRIqQjnlJOQfDlFfIkEp0jQRkeOxwixJc3xPXH2cNh7oDQ3K3nUnnVqWfqadehYx5q1ivlWp9y8ZTxL+lRySQSLk9jN4Ux/JtD/HNz2qyS1fusAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wepack修改配置\"\n        title=\"wepack修改配置\"\n        src=\"/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png\"\n        srcset=\"/blog/static/0b818be146d1f3df7220cfad8a318320/63868/webpackConfig.png 250w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/0b533/webpackConfig.png 500w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png 1000w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png 1186w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n4. 修改子应用代码</p>\n<pre><code>    import React from 'react';\n    import ReactDOM from 'react-dom';\n    import './index.css';\n    import singleSpaReact from 'single-spa-react'\n    import App from './App'; // App是子应用的入口 \n\n    // 使用single-spa-react产生子应用的生命周期方法\n    const reactLifecycles = singleSpaReact({\n        React,\n        ReactDOM,\n        rootComponent: App,\n        errorBoundary(err, info, props) {\n            // https://reactjs.org/docs/error-boundaries.html\n            return (\n            &#x3C;div>This renders when a catastrophic error occurs&#x3C;/div>\n            );\n        },\n    });\n\n    export const bootstrap = reactLifecycles.bootstrap;\n    export const mount = reactLifecycles.mount;\n    export const unmount = reactLifecycles.unmount;  \n</code></pre>\n<ol start=\"4\">\n<li>\n<p>构建子应用,生成入口文件，这里通过serve提供静态服务的方式提供入口js Entry的访问，在实际中可以使用nginx或者cdn的形式提供访问</p>\n<pre><code> npm run build\n serve -s -l 3001 build // 指定端口 \n</code></pre>\n</li>\n</ol>\n<h3>1.2. <a name='-1'></a>主应用配置</h3>\n<ol>\n<li>\n<p>使用create-react-app创建主应用 npx create-react-app baseapp</p>\n</li>\n<li>\n<p>安装微前端依赖</p>\n<p>npm install single-spa react-router-dom -S</p>\n</li>\n<li>\n<p>主应用增加与子应用配置代码</p>\n<pre><code> import React from 'react';\n import ReactDOM from 'react-dom';\n import { BrowserRouter as Router, Link } from 'react-router-dom'\n import history from 'history/browser';\n import './index.css';\n import { registerApplication, start } from 'single-spa'\n\n async function loadApp(libraryUrl, libraryName) {\n     // 打包的webpack配置是umd模式 直接挂载在window上\n     if(window[libraryName]) {\n         return window[libraryName]\n     }\n     // 加载并且等待js执行\n     await new Promise((resolve, reject) => {\n         const script = document.createElement('script')\n         script.src = libraryUrl\n         script.onload = resolve\n         script.onerror = reject\n         document.body.appendChild(script)\n     })\n     return window[libraryName]\n }\n\n // 子应用可以通过走服务端下发配置 \n const apps = [\n     {\n         name: 'app1',\n         // 子应用加载方法，加载对应的js Entry\n         app: () => loadApp('http://localhost:3001/app1.js', 'app1'),\n         // 子应用激活方法\n         activeWhen: location => location.pathname.startsWith('/app1'),\n         // 共享属性\n         customProps: {}\n     },\n     {\n         name: 'app2',\n         app: () => loadApp('http://localhost:3002/app2.js', 'app2'),\n         activeWhen: location => location.pathname.startsWith('/app2'),\n         customProps: {}\n     }\n ]\n // 注册子应用\n for(let i = 0; i &#x3C; apps.length; i++) {\n     registerApplication(apps[i])\n }\n // 启动single-spa提供微服务能力\n start()\n // 渲染主应用\n ReactDOM.render(\n     &#x3C;div>\n         this is base app\n         &#x3C;Router history={history}>\n         // 子应用入口\n         &#x3C;div>&#x3C;Link to=\"app2\"  >app2&#x3C;/Link>&#x3C;/div>\n         &#x3C;div>&#x3C;Link to=\"app1\" >app1&#x3C;/Link>&#x3C;/div>\n     &#x3C;/Router>\n     &#x3C;/div>,\n     document.getElementById('root')\n );\n</code></pre>\n</li>\n<li>\n<p>启动主应用，就能看到两个子应用聚合成一个应用，点击对应的调整也能正常切换</p>\n</li>\n</ol>\n<p><img src=\"/blog/35257e241336dfb4aa08e94db8b4aec4/run.gif\" alt=\"引用切换\"></p>\n<h2>2. <a name='single-spa-1'></a>single-spa源码分析</h2>\n<p>single-spa的源码可以分成两个阶段来看: 启动阶段和子应用挂载(切换)阶段.下面就分别从这两个阶段看single-spa的执行过程</p>\n<h3>2.1. <a name='-1'></a>启动</h3>\n<p>在启动主应用的时候，通过registerApplication注册子应用和start方法启动微前端\n在registerApplication中主要对子应用的入参进行了格式化处理然后将子应用推入全局的数据保存，然后执行应用切换的主函数reroute做首次应用的加载逻辑</p>\n<pre><code>export function registerApplication(\n    appNameOrConfig,\n    /** 子应用异步加载函数 需要返回带有生命周期的模块导出 */\n    appOrLoadApp,\n    /** 应用激活函数 */\n    activeWhen,\n    /** 共享属性 */\n    customProps\n    ) {\n    // 子应用入参格式化处理\n    const registration = sanitizeArguments(\n        appNameOrConfig,\n        appOrLoadApp,\n        activeWhen,\n        customProps\n    );\n    /** 推入全局的子应用数组 */\n    apps.push(\n        assign(\n        {\n            loadErrorTime: null,\n            /** 应用状态 */\n            status: NOT_LOADED,\n            parcels: {},\n            devtools: {\n            overlays: {\n                options: {},\n                selectors: [],\n            },\n            },\n        },\n        registration\n        )\n    );\n    if (isInBrowser) {\n        ensureJQuerySupport();\n        /** 执行应用切换的主函数 */\n        reroute();\n    }\n}\n</code></pre>\n<p>在reroute中会对子应用加载状态进行分类(appsToUnload\\appsToUnmount\\appsToLoad\\appsToMount)然后根据是否运行过start函数走不同触发逻辑:</p>\n<ol>\n<li>\n<p>未运行过start函数,走app初始化加载逻辑(js Entry下载)</p>\n</li>\n<li>\n<p>运行过start函数,走app挂载/切换逻辑</p>\n<pre><code> export function start(opts) {\n     // start控住通过全局变量控住整个应用挂载状态\n     // 二次调用start 触发对应的子应用挂载\n     started = true;\n     if (opts &#x26;&#x26; opts.urlRerouteOnly) {\n         setUrlRerouteOnly(opts.urlRerouteOnly);\n     }\n     if (isInBrowser) {\n         reroute();\n     }\n }\n /** 执行应用切换的主函数 */\n export function reroute(pendingPromises = [], eventArguments) { \n     /** 应用处于切换状态中,推入到待处理的peopleWaitingOnAppChange 等待后续统一处理 */\n     if (appChangeUnderway) {\n         return new Promise((resolve, reject) => {\n         peopleWaitingOnAppChange.push({\n             resolve,\n             reject,\n             eventArguments,\n         });\n         });\n     }\n     /** 获取当前子应用的状态数组 */\n     /** 在getAppChanges中根据传入的activeWhen进行判断 首次应用应该处于appsToLoad数组中 */\n     const {\n         /** 移除状态 */\n         appsToUnload,\n         /** 卸载状态 */\n         appsToUnmount,\n         /** 加载状态 */\n         appsToLoad,\n         /** 即将挂载状态 */\n         appsToMount,\n     } = getAppChanges();\n     let appsThatChanged,\n         navigationIsCanceled = false,\n         oldUrl = currentUrl,\n         newUrl = (currentUrl = window.location.href);\n     // 是否运行过start函数 走应用切换逻辑\n     if (isStarted()) {\n         appChangeUnderway = true;\n         appsThatChanged = appsToUnload.concat(\n         appsToLoad,\n         appsToUnmount,\n         appsToMount\n         );\n         return performAppChanges();\n     } else {\n         // 未运行过start函数走app初始化加载逻辑\n         appsThatChanged = appsToLoad;\n         return loadApps();\n     }\n     /** 省略若干代码 */\n }\n</code></pre>\n</li>\n</ol>\n<p>loadApps通过微任务的方式加载js Entry然后在对应的app对象设置子应用的生命周期函数</p>\n<pre><code>/** 加载子应用js Entry */\nfunction loadApps() {\n    return Promise.resolve().then(() => {\n        /** 通过微任务的方式加载appsToLoad 在加载完毕后在\n        * 对应的app对象上设置暴露的生命周期方法\n        */\n        const loadPromises = appsToLoad.map(toLoadPromise);\n\n        return (\n        Promise.all(loadPromises)\n        /** 触发路由事件 首次加载可忽略这里 */\n            .then(callAllEventListeners)\n            // there are no mounted apps, before start() is called, so we always return []\n            .then(() => [])\n            .catch((err) => {\n            callAllEventListeners();\n            throw err;\n            })\n        );\n    });\n}\n</code></pre>\n<h3>2.2. <a name='-1'></a>子应用挂载/切换</h3>\n<p>在single-spa启动的时候,会监听路由事件然后再触发路由事件和执行reroute方法</p>\n<pre><code>/** 路由事件监听 */\nwindow.addEventListener(\"hashchange\", urlReroute);\nwindow.addEventListener(\"popstate\", urlReroute);\n/** patchedUpdateState也会触发urlReroute */patchedUpdateState\nwindow.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    \"pushState\"\n);\nwindow.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    \"replaceState\"\n);\n\nfunction urlReroute() {\n    reroute([], arguments);\n}\n</code></pre>\n<p>所以app挂载切换的主逻辑都在reroute的performAppChanges中,主要做了:</p>\n<ul>\n<li>\n<p>派发single-spa自定义事件</p>\n</li>\n<li>\n<p>执行移除/卸载状态应用的生命周期函数</p>\n</li>\n<li>\n<p>执行挂载应用的生命周期函数(依赖卸载/移除的执行tryToBootstrapAndMount)</p>\n<p>function performAppChanges() {</p>\n<pre><code>  return Promise.resolve().then(() => {\n      /** 派发single-spa自定义事件 */\n      /** 省略若干代码 */\n      // 执行需要移除/卸载状态应用的生命周期函数并且删除对应的生命周期函数\n      // 重置应用状态\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      const unmountUnloadPromises = appsToUnmount\n          .map(toUnmountPromise)\n          .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n      unmountAllPromise.then(() => {\n      window.dispatchEvent(\n          new CustomEvent(\n          \"single-spa:before-mount-routing-event\",\n          getCustomEventDetail(true)\n          )\n      );\n      });\n\n      // 子应用的加载和bootstrap生命周期函数执行\n      const loadThenMountPromises = appsToLoad.map((app) => {\n          return toLoadPromise(app).then((app) =>\n              tryToBootstrapAndMount(app, unmountAllPromise)\n          );\n      });\n      // 子应用挂载和mount生命周期函数的执行\n      const mountPromises = appsToMount\n          .filter((appToMount) => appsToLoad.indexOf(appToMount) &#x3C; 0)\n          .map((appToMount) => {\n              return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n      });\n      /** 省略若干代码 */\n  });\n  }\n  // tryToBootstrapAndMount依赖之前需要unLoad和unMount的应用周期函数执行完毕\n  function tryToBootstrapAndMount(app, unmountAllPromise) {\n      if (shouldBeActive(app)) {\n          return toBootstrapPromise(app).then((app) =>\n          unmountAllPromise.then(() =>\n              shouldBeActive(app) ? toMountPromise(app) : app\n          )\n          );\n      } else {\n          return unmountAllPromise.then(() => app);\n      }\n  }\n</code></pre>\n</li>\n</ul>\n<p>以上梳理了single-spa实现微前端的主体流程</p>\n<h2>3. <a name='-1'></a>关于微前端的一些总结思考</h2>\n<p>在讨论使用一个技术方案的时候,主要考虑点这项技术方案是否能解决当前或者未来项目中遇到的问题,微前端的优势在于项目的组合(新老项目平滑过渡\\项目功能共享\\应用拆分\\流程解耦)等但同时也增加了项目维护的一些成本,需要结合项目和业务发展方向进行探索使用</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://juejin.cn/post/6862661545592111111\">微前端框架 之 single-spa 从入门到精通</a><br>\n<a href=\"https://blog.yuanziwen.cn/2019/12/18/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E8%90%BD%E5%9C%B0%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF\">微前端时代思考与实践</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/fy3qri\">你可能并不需要微前端</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/rhduwc\">微前端的核心价值</a></p>","fields":{"readingTime":{"text":"11 min read"}},"frontmatter":{"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null},"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null},{"id":"6364b3fd-5475-525c-b92d-3a8dbc96d96d","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#\">前置概念</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#-1\">沙盒</a></li>\n<li>1.2. <a href=\"#Proxy\">Proxy</a></li>\n<li>1.3. <a href=\"#with\">with</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#-1\">沙盒的实现方式</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#ProxySandbox\">ProxySandbox(单实例沙盒)</a></li>\n<li>2.2. <a href=\"#snapshotSandbox\">snapshotSandbox(单实例沙盒)</a></li>\n<li>2.3. <a href=\"#-1\">多实例沙盒</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">附录</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>不同的微前端框架会提供沙盒环境来实现不同微前端应用的隔离.本文梳理JavaScript中沙盒的实现方式，有助于学习微前端方案的技术细节.</p>\n<h2>1. <a name=''></a>前置概念</h2>\n<h3>1.1. <a name='-1'></a>沙盒</h3>\n<p>沙盒是一种安全机制可以为程序提供隔离的执行环境，沙盒中提供用后即回收的磁盘及内存空间，在沙盒中对网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是被严格限制的.JavaScript沙盒是通过语法层面的限制来实现代码执行的隔离.</p>\n<h3>1.2. <a name='Proxy'></a>Proxy</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>可以实现对对象属性访问的代理，通过Proxy的使用可以实现JavaScript代码执行的沙盒模式</p>\n<h3>1.3. <a name='with'></a>with</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with\">with</a>语句可以扩展当前的执行上下文</p>\n<pre><code>const a = { name: 1111 }\nwith(a) {\n    console.log(name) // 1111\n}\n</code></pre>\n<h2>2. <a name='-1'></a>沙盒的实现方式</h2>\n<p>沙盒的实现方式上主要分为:</p>\n<ul>\n<li>单实例沙盒: 同一个时刻只有一个微应用实例存在，当前资源被这个应用独占，需要解决的主要问题是应用切换的时候变量污染清理和再次启动时的变量恢复</li>\n<li>多实例沙盒: 资源不是应用独占，需要解决资源共享、通信等问题</li>\n</ul>\n<h3>2.1. <a name='ProxySandbox'></a>ProxySandbox(单实例沙盒)</h3>\n<p>基于Proxy的拦截和设置功能，通过Proxy拦截对全局对象的修改记录，在应用切换的时候还原全局对象</p>\n<pre><code>    /** 设置全局对象属性 */\n    const setWindowProp = (prop, value) => {\n        window[prop] = value\n    }\n\n    class SandBox {\n        name;\n        /** 代理对象 需要通过该对象操作沙盒 */\n        proxy = null;\n        /** 新增的修改 */\n        addedPropsMap = new Map();\n        /** 沙盒期间更新的修改 */\n        modifiedOriginValueProps = new Map();\n        /** 当前沙盒所做的修改 用于还原当前的沙盒 */\n        currentUpdatedProps = new Map();\n        /** 激活沙盒 */\n        active() {  \n            this.currentUpdatedProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n        }\n        /** 沙箱卸载 */\n        inactive() {\n            /** 修改的属性还原 */\n            this.modifiedOriginValueProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n            /** 增加的属性清空 */\n            this.addedPropsMap.forEach((_, p) => {\n                setWindowProp(p, undefined)\n            })\n        }\n        constructor(name) {\n            this.name = name;\n            const fakeWindow = Object.create(null)\n            const {\n                addedPropsMap,\n                modifiedOriginValueProps,\n                currentUpdatedProps,\n            } = this\n            const proxy = new Proxy(fakeWindow, {\n                get(target, prop) {\n                    return window[prop]\n                },\n                set(_, prop, value) {\n                    if(!window.hasOwnProperty(prop)) {\n                        /** window上没有该属性 新增 */\n                        addedPropsMap.set(prop, value)\n                    } else if(!modifiedOriginValueProps.hasOwnProperty(prop)) {\n                        /** window上有该属性且未更新,记录 */\n                        const originValue = window[prop] \n                        modifiedOriginValueProps(prop, originValue)\n                    }\n                    /** 记录当前沙盒的更新 */\n                    currentUpdatedProps.set(prop, value)\n                    /** 更新全局属性 */\n                    setWindowProp(prop, value)\n                    return true\n                }\n            })\n            this.proxy = proxy\n        }\n    }\n\n    const newSandBox = new SandBox('app')\n    const proxyWindow = newSandBox.proxy\n    proxyWindow.appName = 'app'\n    console.log(window.appName, proxyWindow.appName) // app app\n    newSandBox.inactive()\n    console.log(window.appName, proxyWindow.appName) // undefined undefined\n    newSandBox.active()\n    console.log(window.appName, proxyWindow.appName) // app app\n</code></pre>\n<h3>2.2. <a name='snapshotSandbox'></a>snapshotSandbox(单实例沙盒)</h3>\n<p>快照沙盒是在不支持Proxy的环境下，通过将window对象属性都复制到快照对象上然后再激活和卸载的时候对激活期间的diff进行添加或者回退.这个方案的对比方案较复杂，比如考虑到原型链的修改与还原问题，一般不作为沙盒方案的首选.</p>\n<pre><code>class SnapshotSandbox {\n    constructor(name) {\n        this.name = name;\n        this.proxy = window;\n        this.type = 'Snapshot';\n        this.sandboxRunning = true;\n        this.windowSnapshot = {};\n        this.modifyPropsMap = {};\n        this.active();\n    }\n    //激活\n    active() {\n        // 记录当前快照\n        this.windowSnapshot = {};\n        iter(window, (prop) => {\n            this.windowSnapshot[prop] = window[prop];\n        });\n\n        // 恢复之前的变更\n        Object.keys(this.modifyPropsMap).forEach((p) => {\n            window[p] = this.modifyPropsMap[p];\n        });\n\n        this.sandboxRunning = true;\n    }\n    //还原\n    inactive() {\n        iter(window, (prop) => {\n            if (window[prop] !== this.windowSnapshot[prop]) {\n                // 记录变更，恢复环境\n                this.modifyPropsMap[prop] = window[prop];\n            \n                window[prop] = this.windowSnapshot[prop];\n            }\n        });\n        this.sandboxRunning = false;\n    }\n}\n\nconst sandbox = new SnapshotSandbox();\nconst proxyWindow = sandbox.proxy\nsandbox.active();\nproxyWindow.appName = 'app'\nconsole.log(proxyWindow.appName, window.appName) // app app\nsandbox.inactive();\nconsole.log(proxyWindow.appName, window.appName) // undefined undefined\n</code></pre>\n<h3>2.3. <a name='-1'></a>多实例沙盒</h3>\n<p>多实例沙盒是Proxy实现的单实例的变种版，在Proxy实现的单实例沙盒中，Proxy的handler的get/set是直接操作的全局对象,多实例版本在handler的get/set中操作沙盒自己维护的对象，从而实现多实例模式</p>\n<pre><code>class MultiProxySandbox {\n    name;\n    proxy = null;\n    /** context 传入多实例沙盒共享数据 */\n    constructor(name, context={}){\n        this.name = name;\n        const fakeWindow = Object.create({});\n        const proxy =  new Proxy(fakeWindow,{\n        set(target, name, value){\n            /** 返回共享属性  */\n            if(Object.keys(context).includes(name)){\n                context[name] = value;\n            }\n            target[name] = value;\n        },\n        get(target,name){\n            // 优先使用共享对象\n            if(Object.keys(context).includes(name)){\n                return context[name];\n            }\n            if( typeof target[ name ] === 'function' &#x26;&#x26; /^[a-z]/.test(name)){\n            return target[ name ].bind &#x26;&#x26; target[ name ].bind( target );\n            } else {\n            return target[ name ];\n            }\n        }\n        })\n        this.proxy = proxy\n        return proxy\n    }\n}\n\nconst context = { document: window.document, globalData:'abc'};\nconst newSandBox1 = new MultiProxySandbox('app1',context);\nconst newSandBox2 = new MultiProxySandbox('app2',context);\nnewSandBox1.appName = 'app1'\nnewSandBox2.appName = 'app2'\nconsole.log(newSandBox1.appName, newSandBox2.appName, window.appName) // app1 app2 undefined\nconsole.log(newSandBox1.globalData, newSandBox2.globalData) // abc abc\n</code></pre>\n<h2>3. <a name='-1'></a>附录</h2>\n<p><a href=\"https://juejin.cn/post/6844904066225537037\">字节跳动的微前端沙盒实践</a><br>\n<a href=\"https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg\">前端微服务在字节跳动的打磨与应用</a><br>\n<a href=\"https://cloud.tencent.com/developer/article/1748172\">谈谈微前端领域的js沙箱实现机制</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null},"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null},{"id":"323785b4-f7d7-591d-a250-aee7abdc366b","html":"<h3><a href=\"https://alexkondov.com/tao-of-react/\">Tao of React - Software Design, Architecture &#x26; Best Practices</a></h3>\n<p>这篇文章介绍了React开发中的一些‘最佳’实践,比如组件逻辑拆分、项目的目录设计、react常见的写法等，可以将其中的一些点作为code review时候的一些参考点</p>\n<h3><a href=\"https://blog.tericcabrel.com/implement-server-sent-event-in-node-js/\">Implement Server-Sent Events in Node.js and React</a></h3>\n<p>这篇文章介绍nodejs中server-sent events的实现服务端推送，看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventSource#browser_compatibility\">兼容性</a>上还可以。在有node中间层的服务可以尝试这种方案</p>\n<h3><a href=\"https://blog.molecule.dev/the-only-custom-react-hooks-we-use/\">The only two custom React hooks we ever really use</a></h3>\n<p>这篇文章介绍了两个自定义的hooks,可以在项目中尝试下</p>\n<ul>\n<li>useAsyncExtendedState  实现state的部分更新，更新state的时候只需要传入需要更新的属性即可.</li>\n<li>userPromise 异步事件的管理(cancal, reset)</li>\n</ul>\n<h3><a href=\"https://thoughtspile.github.io/2021/11/15/unintentional-layout-effect/\">useEffect sometimes fires before paint</a></h3>\n<p>这篇文章介绍了react hook-useEffect和useLayoutEffect触发时机和结合使用的一些注意事项</p>\n<h3><a href=\"https://thoughtspile.github.io/2022/01/17/jsx-conditionals/\">Good advice on JSX conditionals</a></h3>\n<p>这篇文章介绍在React中写JSX的一些建议写法，有利于规范的形成，比如禁止嵌套三元运算符也能防止代码出现不可预知的错误</p>\n<h3><a href=\"https://blog.saeloun.com/2022/01/13/react-18-usedefferedvalue-hook\">Sneak peek into React 18 useDeferredValue hook</a></h3>\n<p>这篇文章介绍React 18中useDeferredValue hook.通过useDeferredValue可以实现指定优先级的渲染任务.</p>\n<h3><a href=\"https://www.robinwieruch.de/react-event-bubbling-capturing/\">React: Event Bubbling and Capturing</a></h3>\n<p>这篇文章通过图解和例子的方式比较生动的介绍了React中事件的处理机制，可以作为温习</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null},"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null},{"id":"cc4079ca-b1c7-595d-8587-228c1e489fd6","html":"<h2><a href=\"https://web.dev/aspect-ratio/\">aspect-ratio CSS property</a></h2>\n<p>通过aspect-ratio可以直接为容器设置宽高比</p>\n<h2>React</h2>\n<h3><a href=\"https://www.joshfinnie.com/blog/using-webassembly-created-in-rust-for-fast-react-components/\">Using WebAssembly (created in Rust) for Fast React Components</a></h3>\n<p>一篇React结合WebAssembly的介绍文章</p>\n<h3><a href=\"https://alexsidorenko.com/\">A Visual Guide to React Rendering -xxx</a></h3>\n<p>很不错的介绍react相关api和基本概念的文档</p>\n<h3><a href=\"https://joshcollinsworth.com/blog/introducing-svelte-comparing-with-react-vue\">Introducing Svelte, and Comparing Svelte with React and Vue</a></h3>\n<p>一篇介绍Svelte与react和vue的对比文章，通过这篇文章发现Svelte的确在某些情况较react/vue有一定优势，可以保持关注度</p>\n<h3><a href=\"https://devtrium.com/posts/react-typescript-using-generics-in-react\">React &#x26; TypeScript: use generics to improve your types</a></h3>\n<p>这篇文章结合useState的例子介绍react中泛型的使用</p>\n<h2>项目设计</h2>\n<h3><a href=\"https://dev.to/mbarzeev/creating-a-react-component-with-tdd-2jn8\">Creating a React component with TDD</a></h3>\n<p>在react项目中引入TDD的案例文章</p>\n<h3><a href=\"https://engineering.udacity.com/react-folder-structure-for-enterprise-level-applications-f8384eff162b\">React folder structure for enterprise level applications</a></h3>\n<p>React项目文件组织的推荐方式，文件的组织、文档、技术方案都是项目整体架构的一部分，需要给予关注</p>\n<h2>前端库</h2>\n<h3><a href=\"https://github.com/breejs/bree\">Bree</a></h3>\n<p>Bree is the best job scheduler for Node.js and JavaScript with cron, dates, ms, later, and human-friendly support</p>\n<h3><a href=\"https://github.com/DominicTobias/react-image-crop\">React Image Crop</a></h3>\n<p>An image cropping tool for React with no dependencies</p>\n<h3><a href=\"https://github.com/pubkey/rxdb\">RxDB</a></h3>\n<p>RxDB是基于PouchDB的一套响应式数据库存储方案</p>\n<h3><a href=\"https://github.com/dexie/Dexie.js\">Dexie.js</a></h3>\n<p>在IndexedDB基础上进行封装，提供更好用的查询api和降低IndexedDB的使用成本</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null},"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null},{"id":"78fb9a8d-a295-5d20-8c43-9a4a98d296ef","html":"<h2>1. <a name=''></a>跨端相关</h2>\n<h3>1.1. <a name='Flipperhttps:fbflipper.com'></a><a href=\"https://fbflipper.com/\">Flipper</a></h3>\n<p>Flipper是调试react native的桌面工具，相对于之前的远程调试(模拟JS运行在本地浏览器)，Flipper的调试都基于当前react native的运行环境，使用体验上也比远程调试的方式好一些.</p>\n<h3>1.2. <a name='Elecruehttps:github.comRajvirSingh1313Elecrue'></a><a href=\"https://github.com/RajvirSingh1313/Elecrue\">Elecrue</a></h3>\n<p>Elecrue是一个生成Electron模板应用的工具，做一些辅助的Electron应用可以尝试使用这个工具</p>\n<h2>2. <a name='React'></a>React相关</h2>\n<h3>2.1. <a name='whatsnewinreact18https:yagmurcetintas.comjournalwhats-new-in-react-18'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-react-18\">what's new in react 18?</a></h3>\n<p>这篇文章介绍了React 18的新特性，其中<a href=\"https://github.com/reactwg/react-18/discussions/21\">Automatic batching</a>值得关注</p>\n<h3>2.2. <a name='react-usehttps:github.comstreamichreact-use'></a><a href=\"https://github.com/streamich/react-use\">react-use</a></h3>\n<p>react-use是一个hooks的工具函数库，需要对应的hooks实现的时候可以参考</p>\n<h3>2.3. <a name='react-loadablehttps:github.comjamiebuildsreact-loadable'></a><a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a></h3>\n<p>react-loadable是基于webpack dynamic import实现的动态加载组件的库，看它的实现其实不难，感悟是要到通用的问题要学会抽象的提取并且设计解决方案，比如loadable的loading设置时间，超时时间等，都是在解决开发中的问题。webpack还有splitChunk实现chunk的拆分。</p>\n<h3>2.4. <a name='react-queryhttps:react-query.tanstack.comoverview'></a><a href=\"https://react-query.tanstack.com/overview\">react-query</a></h3>\n<p>相对于Redux，react-query减少了很多模板代码的编写，减少了代码的理解成本。能让你falling into the pit of success.<a href=\"https://tkdodo.eu/blog/react-query-as-a-state-manager\">React Query as a State Manager</a>这篇是在官网上看到的react-query做状态管理的例子。</p>\n<h2>3. <a name='Javascript'></a>Javascript相关</h2>\n<h3>3.1. <a name='whatsnewines2022https:yagmurcetintas.comjournalwhats-new-in-es2022'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-es2022\">what's new in es2022?</a></h3>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null},"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null},{"id":"7175f7aa-a470-5777-9d30-b1181240a447","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#\">背景知识</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#RN\">RN项目初始化</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">依赖安装</a></li>\n<li>2.2. <a href=\"#cli\">cli初始项目</a></li>\n<li>2.3. <a href=\"#typescript\">使用typescript模板初始项目</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#RN-1\">RN项目启动&#x26;调试</a></li>\n</ol>\n<ul>\n<li>3.1. <a href=\"#metro\">启动metro</a></li>\n<li>3.2. <a href=\"#-1\">启动项目</a>\n<ul>\n<li>3.2.1. <a href=\"#-1\">正常模式启动项目</a></li>\n<li>3.2.2. <a href=\"#debug\">debug模式启动项目</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>在<a href=\"https://icantunderstand.cn/2021-11-03\">11月的前端快报</a>中有系列文章介绍了React Native新架构的相关概念，笔者也有一定的React Native开发经验，但是总感觉没有深入到React Native的细节实现停留到用的层面偏多，这个深入浅出React Native系列注重从源码的角度梳理RN的实现细节，希望通过这个系列能熟悉RN的细节拓展端知识，希望能跟你一起有所收获。</p>\n<h2>1. <a name=''></a>背景知识</h2>\n<p>本系列基于Android代码的基础上进行源码分析，涉及到Android相关的基础知识，可以参考之前的笔记<a href=\"https://icantunderstand.cn/android-basic\">第一行代码-Android读书笔记</a>和<a href=\"https://icantunderstand.cn/%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/\">跨端技术</a></p>\n<p>在系列文章中使用RN来指代React Native</p>\n<h2>2. <a name='RN'></a>RN项目初始化</h2>\n<h3>2.1. <a name='-1'></a>依赖安装</h3>\n<ul>\n<li>\n<p>Android Studio</p>\n</li>\n<li>\n<p><a href=\"https://developer.android.com/studio/run/emulator\">创建Android虚拟机</a></p>\n</li>\n<li>\n<p>JDK 这里推荐自己手动<a href=\"https://www.oracle.com/java/technologies/java8.html\">下载JDK</a>进行安装并且在控制台的启动配置上配置Android和JDK配置</p>\n<pre><code>  // Android\n  export ANDROID_HOME=$HOME/Library/Android/sdk\n  export PATH=$PATH:$ANDROID_HOME/emulator\n  export PATH=$PATH:$ANDROID_HOME/tools\n  export PATH=$PATH:$ANDROID_HOME/tools/bin\n  export PATH=$PATH:$ANDROID_HOME/platform-tools\n  // Java\n  export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home\n  export PATH=$JAVA_HOME/bin:$PATH\n  export CLASS_PATH=$JAVA_HOME/lib  \n</code></pre>\n</li>\n<li>\n<p>node watchman\nnode推荐使用<a href=\"https://github.com/nvm-sh/nvm\">nvm</a>进行安装\nwatchman使用<a href=\"https://brew.sh/\">Homebrew</a></p>\n</li>\n</ul>\n<h3>2.2. <a name='cli'></a>cli初始项目</h3>\n<p>按照<a href=\"https://reactnative.dev/docs/environment-setup\">官方文档</a>的步骤选择配置条件，这里使用Cli初始项目<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5UlEQVQoz62Q22rEMAxE/f9/WHp72Gazvmrt2Epjh0yRQqH0dVcwyB7BGSFDdEeMEaUx3meL12nG23TDy+UK7gPHcWDs+6kxsGs/3/8lM2OdQyKCdR4uJtxChA1nvzkP7z1yLmBesSwLWmO01pBz1r+o1qb+UitMiFGHKSWEEHRbgdyJ1PM+oJSCWquCRAJh5tNj1rmGMcNYa+GcAxEpTEASIkrp9H7P8teTMOkxyiIR1jqs6wrzOc2YrcO2bRgHUPuOR8p8BULrO1ju8t1xzQ39eAD4Mc1Y+8CzykxUdLO+bU8B/gA2hG4JYWmz4wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cli配置\"\n        title=\"cli配置\"\n        src=\"/blog/static/34c810777b55c962d15e1c6a1593e3af/00d43/cliConfig.png\"\n        srcset=\"/blog/static/34c810777b55c962d15e1c6a1593e3af/63868/cliConfig.png 250w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/0b533/cliConfig.png 500w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/00d43/cliConfig.png 1000w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/aa440/cliConfig.png 1500w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/e8950/cliConfig.png 2000w,\n/blog/static/34c810777b55c962d15e1c6a1593e3af/b75f8/cliConfig.png 2124w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>2.3. <a name='typescript'></a>使用typescript模板初始项目</h3>\n<p>使用typescript初始化项目</p>\n<pre><code>npx react-native init AwesomeTSProject --template react-native-template-typescript  \n</code></pre>\n<p>项目目录如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 736px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ef5f8a4e4b272b12658513416b29ba6e/f941f/projectCategory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 244.79999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAxCAYAAADa6ImIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAE20lEQVRIx51X6W7bZhD0W/RHEVkHKV7iLfEmJUqyZFmSryRFEyRtUfT9X2GKWZpOgqAW2R+LTyE/b2Z3Zg9e+b4Pw7BgWTYcx0MSZwjDBTTNkOd97Wo+XyBNVyjLLY7HJ3z58jc+f/4Lnz79gSyrkSTLXnYVBAFs24fnzTGfx8iyEmW5wnK5lme27cn7rnbleR7G4wkMw4CuG6iqCofDAff3D3BdF6PRCIqiYDLpZuJQUVSYJnNgIklS1PUaljWTC6qqQVWnne3VIZ3RoijG7e0Bvh8I8j7OfnI4m9lYLlfI8wKj0bi3s58RmpY4K8tK8snn/z9k3YBjzbDZbHE+3+Ph4VEuDIejl1x2duhDmSjQbRdWVCCOY8RxgiAIwXfMKVPBy9Op1sGh70MdDqFWO6jHj6iyDLeHOyFmv78V+dD5u3cDjIZjKMoFh77n4VpRsdZMfFZNBFEsxFTVUpCmaSZ5Xa1qZFkuf/SWU3E4UlTkmomTbqOqa2zWGyGGjne7PW5uduKQxrAbst4ghUk3ZzMs0gSrZS1OjsejiJyhXl8PhRzaW86+I2UCywsRFDWiRSShFUUpuTMNSyREZP1IWe0x/u0f7LeNbEgGQ316ekYYzjEYXHeTTZvDjDk0HURphjiKRS60lhj+/ib2SyyrU2xUDV8VA3FZYl2vhRg2CUqH5Gy3N7Bt56LIm5BZt2mF4faMLE6w3mxFNswl0bF6yHqXihGHyngMI8phZDWyJBFElAhRrV+Q5kUBpU8tm5qOPKaoawxepEIixN4NXiVzya44pDTDhGU7cP0AcZrB8Xz5t8d6DkJ5blgzuXfJrvwggGE7sP0ASVHi8cMH3J3vsdntcf/0jNPjEz7+/glhnECzZjAdV+7/lzWkqBrC+QJ+ECLLCyEkL0pUy5UIfKKomGr6q7jfstfSo3hZGSSDjNIRTxLSjoJOOXRdD5puYF6UcBwXx+PpVSY8T6cTbMft3GQFIaH6PhupI8ha/bE6ePJ5Z4eu50LXTLwv/0QUJrg9HHA6nUWLDJeX+gwsQcgfumnLbsKWtVhEUsM8mVfuOZdq+EeHZMhyhBgOp91uh/1+L2ezQXidZ/QLQg36zIHjejgc7iRUhsz8Mdyu6H4IWdVngqSua3FGYriZ9Rmh37E8RVUNEAQuttsd7u6O0rY4nNgcdM3oF7KmTeH7Y+l3JKWVDUlp5zLfNQPqkmxcD4ahIs+HYKNo0O2x2WxEPhxYPN+//9BpgRKHuj5FOB+DaImMbBNpu9JNJqqg0zT98ghoHUaLgawhRNi2fL5rSWlrtRvLmoGhX2CRZNjd7IQIEtKX4W8dW9VgByaCMJCmQCIomfZSz+2rkc3N9lcURYLz+UG6DFGy8zw/P+N4d/xuRe4omyAYC8ur1VrqmCjphHnkdnFpp/kJYZIMEccLETSlwtA5mLjbcFD17IdTzOcjeJ6LZdWUHUVNthk+eyTF3QthFI3ku6RZ2nMJm47a+cyQifhyg5VKmSJNr191yCWJhNAhf/M/4XrHLtRJ2FLLwURIYbgkhMgoHYbOk8aZ0wGh39Ry9AvSJJG6JarHx0chiOHSGTeJbrJxXai6Ce3mHkGUIEkSJGkmLDdfqpl8tnUfAa6LqTnD9PARizSXD8dmfJ4ln+zgDHUy7iabfwGst+EamUEFEAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"项目目录\"\n        title=\"项目目录\"\n        src=\"/blog/static/ef5f8a4e4b272b12658513416b29ba6e/f941f/projectCategory.png\"\n        srcset=\"/blog/static/ef5f8a4e4b272b12658513416b29ba6e/63868/projectCategory.png 250w,\n/blog/static/ef5f8a4e4b272b12658513416b29ba6e/0b533/projectCategory.png 500w,\n/blog/static/ef5f8a4e4b272b12658513416b29ba6e/f941f/projectCategory.png 736w\"\n        sizes=\"(max-width: 736px) 100vw, 736px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>android目录对应当前项目安卓代码的位置</li>\n<li>index.js是项目RN的入口文件(在MainApplication的ReactNativeHost的getJSMainModuleName方法关联指定入口)</li>\n</ul>\n<h2>3. <a name='RN-1'></a>RN项目启动&#x26;调试</h2>\n<h3>3.1. <a name='metro'></a>启动metro</h3>\n<p><a href=\"https://developer.android.com/studio/run/emulator\">metro</a>是react native的打包,通过启动metro server才能在项目中访问对应打包好的入口文件</p>\n<pre><code>npx react-native start\n</code></pre>\n<h3>3.2. <a name='-1'></a>启动项目</h3>\n<p>在Android Studio导入刚才初始化项目的android目录，</p>\n<h4>3.2.1. <a name='-1'></a>正常模式启动项目</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/09ae1afd35f64c13097b4c4898839eef/f4281/normalStart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAb0lEQVQI12XDQQ6CMBBAUU5lTAQybdMpdDotrFBX3v8S37XxJW9aF+HnLKwiSAqEWjB3csqkmOk+qNW5lpmP3Hg97ogkZIvEEFlzY8q78bca2hrqnTpOijmld+w42fzg2grvXXkWRaujo6HWyDb4Aqk4SS61U1qpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"正常启动\"\n        title=\"正常启动\"\n        src=\"/blog/static/09ae1afd35f64c13097b4c4898839eef/00d43/normalStart.png\"\n        srcset=\"/blog/static/09ae1afd35f64c13097b4c4898839eef/63868/normalStart.png 250w,\n/blog/static/09ae1afd35f64c13097b4c4898839eef/0b533/normalStart.png 500w,\n/blog/static/09ae1afd35f64c13097b4c4898839eef/00d43/normalStart.png 1000w,\n/blog/static/09ae1afd35f64c13097b4c4898839eef/f4281/normalStart.png 1016w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>3.2.2. <a name='debug'></a>debug模式启动项目</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ca8ec696ea59c20a4013243dd038753f/ddb6a/debugStart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 6.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAN0lEQVQI14XDwQ3AIAwEwXSGhMFnwOEN/ReyKSEjzVPN+e2O9kuMJFayclMl1J3bCqcbmpOm4AOivyRtdwx38gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"debug启动\"\n        title=\"debug启动\"\n        src=\"/blog/static/ca8ec696ea59c20a4013243dd038753f/00d43/debugStart.png\"\n        srcset=\"/blog/static/ca8ec696ea59c20a4013243dd038753f/63868/debugStart.png 250w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/0b533/debugStart.png 500w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/00d43/debugStart.png 1000w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/aa440/debugStart.png 1500w,\n/blog/static/ca8ec696ea59c20a4013243dd038753f/ddb6a/debugStart.png 1592w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 812px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c44eb22046aa719f25cbd994e0300adf/63ec5/startPage.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 175.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAACU9ioYAAAACXBIWXMAABYlAAAWJQFJUiTwAAAFkUlEQVRIx62W228cVRLG5w3xtruPIXGcoH0HXmD/gYg3tA+8REICCZTYZmzP2Oa2gBASYmIrQIIgCFggCBI2Cw5RDIm8Hl+xPbZjJ2bjOOP4kvE1vva959I9/YM64551tIqU7KalUp2uOufrqvqqzkxkz+49/PEPf2Jf5X72VlSyb9/DPLz/z1RUVFKxZ2/JVrmfyr371LvInlB2V5RtDzzwIJW7dhN57JFHeTEapbaujpqaGmKxGE2NTTQ2NtLU1FReK2lqUlKyl/z19fXU1tby16eeYteuh4gcPHiQhvp6aqoO88LzzyvwhoYGBRyPx4jF4sTicRriMRrjO2zKH6euro5Dhw5RVV3NE4//hUhtXT1vH32PNxNHaGlu5uiRI7ybSJBIJJRu2Za3Egn+9u4R3kkkaN72h9Lc3ExLSwsHDjxJ5ESyl8F8QMemRbdmM2tYuKaJaZpKrxgWv2gOSc2hV3Po1BzWTAt7e4+IYRhk3SyHD1cR+bqrDz8IMEyTacshaWQZNV1c22bKcmk3skyYLrptk7NtxkyXS6ZL3raxbBtbtGWRz+eprqoh8nNXDxSL6is520K3LFK6Q1J36dFdViybvG2pQ1nLYsG06dVdbKtkE5Eoc7lcCfBiVw9BUEQ3DIztw2nDpnXLZUh3VNoSvW6a2KbBomHRozml9x2gCrC6hkhbZzcERWzDIG9ZZCyXvmwR2/cZcT0m80XwfYq+DwSsFXyG8gGe55XTLQNKhN919uAUA+Y0g0y2wMlfJ3mm8WU++uokb3/yGe+0tfPt+Ta+/aGV06dPc6a7l5ZT/6Cv418lMNu+PeUPheUCdG9aXHR8kpklPv7qJO/9/Us++PwLPm89xysnT/Fxeyevn/iUoxeTJM79zGetP2LZjqq7ae6I8P2OXvRiwKxmkMoFtLa2cnlkmPXVVZYX5pmanOSH0XG+aU8yl5nnRGcfP02kOTud4cKqxozl4lg7IjzR0U3ah+SGyVoRPjp2jGdjcZ577Q0OvfY6x44f55/ff88zL73KCy+/ytM1UY5/8D6vNDXS8+tVVe9RzcILSTmf7KKrACmtxPBN26VNczm/YXJ23WLccErM21la10zSuknOcVRXZC0Tw7bp0l0WswWiAtie7FSA45qJZ5n823A4q2f5Sc/xo56j33ApbPffOT3HouXghmSo3jRJ6TaTbp66qmoiXX2/sAEsuzn8QgErXyCT81jM+8znfbYKHkXPQyt4ZPI+esHD9zwKnqdaR/RS3iMP1L4YJZIaHOR+PbXROiJjo6NcT6dpa2tjbGyM/oEB+vv7cRxHbQruAigIQsBaIsNDQ2qwJyYmmJ+fZ3Nzk0wmQ6FQ+B8iVIDDOK6jQK5du8bU1BQ3b95keXlZyezsLDMzMywsLCgJbaIlgK2trdsBR4ZH2NjYUEAhqADKuxwUkHQ6zeLiovILiKZpCkBIKRaLtwOGpIgzCAK1QcSXC2Fbi4g/XAdBcOeUU4Mp9SIbpW7hF7PZrLLdcw1HR0eZnplRMyzEdHR0MDIygtgvXLhAMpnkzJkzDAwM3B3gUGoIz/dZX19X95vUR9a6rqtrSVgXAkRL1CLSUnIZhOswkzLLAiQkTE9PMzc3p9Y3btxgdXWVpaUlBSYEiU9IuXXrVpllsYctVu5DN+sqpxy+fv16uReF/Xuu4eDA/Rw9iXB4WF3lku7Kyor69SuNU1Buj536Ti3zH5YvXVLpyiwLw6lU6v+LMAQQRoU1mQiJVOooUyJsCwHCvmiZorW1NZWV67q3ZVBmWcAmJycVuzJ6V69eVeRcuXJFsXj58mUFND4+rvpR+lX8MuPSPv9VQwEUIGFZvioDLxGF/1ukL0VLtMK8rGWPtE9Yc3mipcYupSzO8A681ydMOXq/2yb6+0/Ab1SVgdzXLCJlAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"页面展示\"\n        title=\"页面展示\"\n        src=\"/blog/static/c44eb22046aa719f25cbd994e0300adf/63ec5/startPage.png\"\n        srcset=\"/blog/static/c44eb22046aa719f25cbd994e0300adf/63868/startPage.png 250w,\n/blog/static/c44eb22046aa719f25cbd994e0300adf/0b533/startPage.png 500w,\n/blog/static/c44eb22046aa719f25cbd994e0300adf/63ec5/startPage.png 812w\"\n        sizes=\"(max-width: 812px) 100vw, 812px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这样我们基于官方的教程就完成了RN项目的初始化和启动过程了，接下来就可以进入的源码来看RN的加载流程了！！！</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://reactnative.dev/docs/environment-setup\">Setting up the development environment</a>\n<a href=\"https://developer.android.com/studio/debug\">调试应用</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"深入浅出RN之项目初始化&调试","date":"2021-11-04","tags":"跨端技术","path":"/react-native-start","top":null,"summary":null},"title":"深入浅出RN之项目初始化&调试","date":"2021-11-04","tags":"跨端技术","path":"/react-native-start","top":null,"summary":null},{"id":"62a7a7d2-f5ec-51df-83b0-19a8a7911608","html":"<h2><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction</a></h2>\n<p>在项目中需要根据配置生成Async Function来保证配置的串行执行，Async Function在创建的时候只能访问到全局作用域的变量，需要注意。在node中可以通过<a href=\"https://github.com/nodejs/node/issues/9474\">vm.runInNewContext</a>来解决。</p>","fields":{"readingTime":{"text":"1 min read"}},"frontmatter":{"title":"前端小知识","date":"2021-11-03","tags":"JavaScript","path":"/know-little-more","top":null,"summary":null},"title":"前端小知识","date":"2021-11-03","tags":"JavaScript","path":"/know-little-more","top":null,"summary":null},{"id":"f8414df6-bcbe-5abe-af66-071c3b4aa351","html":"<h3>基础知识</h3>\n<h2><a href=\"https://jakearchibald.com/2021/cors/\">How to win at CORS</a></h2>\n<p>CROS看这篇就够了</p>\n<h2>React Native相关</h2>\n<p><a href=\"https://formidable.com/blog/2019/react-codegen-part-1/\">The New React Native Architecture Explained</a>这个系列文章介绍了React Native架构升级的一些核心概念，包括Turbo Modules,Fabric, JSI等，可以快速的了解架构升级背后的原理。可以结合<a href=\"https://www.cnblogs.com/ludashi/p/15381067.html\">React Native之新架构中的Turbo Module实现原理分析</a>来深入到原理部分。</p>\n<h2>项目管理&#x26;设计</h2>\n<h3><a href=\"https://blog.codinghorror.com/falling-into-the-pit-of-success/\">Falling Into The Pit of Success</a></h3>\n<p>一篇关于系统设计的文章，在进行系统设计的时候我们要思考在使用系统的时候如何让用户获得使用上的收益而不是通过一些手段去弥补系统的漏洞</p>\n<h3><a href=\"https://yonigoldberg.medium.com/fighting-javascript-tests-complexity-with-the-basic-principles-87b7622eac9a\">Writing clean JavaScript tests with the BASIC principles</a></h3>\n<p>在业务开发中，会因为业务的压力导致单测执行粒度不够，KPI式的单测覆盖率目标并不能保证有效的单测。比如前端做单测，在哪些维度做单测的尝试是值得考虑的(基础组件，核心api处理逻辑等)，这边文章讨论了单测执行过程中的一些问题并且给出了如何写单测的原则建议，很有意义。在附一个<a href=\"https://www.zhihu.com/question/27081528/answer/1872155062\">知乎关于单测的讨论</a></p>\n<h3><a href=\"https://mp.weixin.qq.com/s/g5ZjQt9F1UUryisEW1csSA\">这可能是大型复杂项目下数据流的最佳实践</a></h3>\n<p>这篇是关于项目治理的文档，数据流的设计与拆分，领域模块的隔离都有借鉴意义值得学习。项目的治理要早否则根深蒂固就积重难返了。</p>\n<h2>React</h2>\n<h3>hooks实践</h3>\n<p><a href=\"https://devtrium.com/posts/react-typescript-how-to-type-hooks\">React &#x26; TypeScript: how to type hooks (a complete guide)</a><br>\n<a href=\"https://thoughtspile.github.io/2021/10/18/non-react-state/\">How to replace useState with useRef and be a winner</a></p>\n<h3><a href=\"https://www.zhihu.com/question/468249924/answer/1968728853\">知乎上关于hooks的讨论</a></h3>\n<p>其中beeplin的回答有很多借鉴意义，思考到项目的设计问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-11-1-前端快报","date":"2021-11-03","tags":"前端快报","path":"/2021-11-03","top":null,"summary":null},"title":"2021-11-1-前端快报","date":"2021-11-03","tags":"前端快报","path":"/2021-11-03","top":null,"summary":null},{"id":"ea186f12-6741-57d1-9751-230edd265c28","html":"<h2><a href=\"https://blog.openreplay.com/using-recoil-instead-of-redux-for-state-management-in-react-applications\">Recoil</a></h2>\n<p><a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>是facebook出品的react状态管理库,这篇文章介绍了Recoil的简单使用。Recoil的特点是它通过写react的方式完成了状态管理，不像redux会在代码中引入更多的概念，值得一试</p>\n<h2><a href=\"http://www.ayqy.net/blog/cross-platform-pains/\">跨端方案的三大困境</a></h2>\n<p>跨端开发是主流app都会采用的方案，跨端的方式在短时间内可以尽快的试错跑通流程，相对于纯h5方案也有一定的性能优势，这篇文档主要介绍跨端开发中的一些思考点，对这些问题深入的思考能帮助更好的发展跨端技术。</p>\n<h2><a href=\"https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838\">React Native at Airbnb: The Technology</a></h2>\n<p>Airbnb关于React Native实践的系列文章，从中也能启发出很多跨端开发的思考点</p>\n<h2><a href=\"https://dev.to/adamdbradley/introducing-partytown-run-third-party-scripts-from-a-web-worker-2cnp\">Introducing Partytown 🎉: Run Third-Party Scripts From a Web Worker</a></h2>\n<p>现在的web开发通常需要引入很多第三方sdk来统计业务信息等，这些sdk的执行会增长用户的可交互时间，<a href=\"https://github.com/BuilderIO/partytown\">partytown</a>可以通过worker来运行第三方sdk来减少主页面js的执行时间，现阶段partytown还处于实验阶段，值得后续关注</p>\n<h2><a href=\"https://calibreapp.com/blog/bundle-size-optimization#lazy-load-third-party-resources-with-facades\">Small Bundles, Fast Pages: What To Do With Too Much JavaScript</a></h2>\n<p>这篇文章介绍系统的介绍了优化js包体积大小的方式，其实对momentjs使用的例子很有意思，优化其实不是一蹴而就的，废弃项目这个的momentjs可以从禁止momentjs使用的提示开始</p>\n<h2><a href=\"https://prateeksurana.me/blog/javascript-developer-guide-to-browser-cookies/\">A JavaScript developer’s guide to browser cookies</a></h2>\n<p>cookie拿来吧你</p>\n<h2><a href=\"https://github.com/mithi/react-philosophies\">https://github.com/mithi/react-philosophies</a></h2>\n<p>这篇文章介绍react中组件设计，性能优化的一些最佳实践方式，很有借鉴意义的文章。相关的文档还有<a href=\"https://kentcdodds.com/blog/dont-sync-state-derive-it\">Don't Sync State. Derive It!</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null},"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null},{"id":"b1d5f00b-e601-50c5-ae20-7db96b03404b","html":"<p>责任链模式将多个处理对象连成一条链并且沿着链传递该请求，直到有一个对象处理它为止。它实现了请求的发送者和接收者之间的解耦合。</p>\n<h2>结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVQ4y42TWauFMAyE/f+/0PMiiPu+70IPXyDi8Va4D0PbNB0nk+js+24U27Zd6xu4P89TwHmapp93zp3wTnochxXzPJskSUxZliZNU9M0zV/CuwIejeNoiqKQZBQAiPI8N1VVGd/3hTCOY1F6F+LoRoMQdl0nKiDt+14wDIMJw9BEUSSAjDj5PwqVgAf3SwUx9Y078rIsE7I7kbXkt8ZABkHbtrJSLiuWLMtyfcxa8vMD67qKh5RY17V4yR0+4ym2EPuXQiX0PE/guq4QaOzz+QjwVu2yEj7PkOAbjVLv6DYKAVZcCm0l24hts2qLvSp8DveT4C0uY0O3KEv3lKejAZg7yuXPwC9ytSlBEEguOayXQoxmz5zRTXyhe4A9MXzTkWFcyCXGHXHyvvBK7ODndxtOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"责任链结构\"\n        title=\"责任链结构\"\n        src=\"/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png\"\n        srcset=\"/blog/static/cd8a720c52b440ad2410037748a084bd/63868/chainstruct.png 250w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/0b533/chainstruct.png 500w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/00d43/chainstruct.png 1000w,\n/blog/static/cd8a720c52b440ad2410037748a084bd/85053/chainstruct.png 1225w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Handler</li>\n</ul>\n<p>定义一个处理请求的接口，实现后继链</p>\n<ul>\n<li>ConcreteHandler</li>\n</ul>\n<p>实现Handler接口，如果可以处理该请求就处理否则将该请求转发给它的后继者</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>向链上的具体ConcreteHandler提交请求</p>\n<h2>适用性</h2>\n<ul>\n<li>当多个对象都可以处理请求且哪个对象处理请求是运行时刻动态确定的</li>\n<li>在不想明确指定接收者的情况下，向多个对象的中的一个提交请求</li>\n<li>可处理一个请求的对象集合应是动态指定的</li>\n</ul>\n<h2>优缺点</h2>\n<ul>\n<li>降低耦合度 请求对象无需知道是其他哪个对象在处理其请求</li>\n<li>增强了给对象指派职责的灵活性  可以在运行中动态的对责任链中的对象进行添加或删除</li>\n<li>不保证被接受</li>\n</ul>\n<h2>实现</h2>\n<ul>\n<li>\n<p>实现后继者链</p>\n</li>\n<li>\n<p>连接后继者</p>\n</li>\n<li>\n<p>表示请求</p>\n<pre><code>  class Handler {\n  public:\n      virtual void handleRequest(Request* theRequest)\n      // _successor 实现后继链\n      Handler(Handler* s) : _successor(s) {}\n  private:\n      Handler*  _successor\n  }\n\n  class ConcreteHandler: public Handler {\n      public:\n      handleRequest(Request* theRequest) {\n          case:\n          /* 省略若干判断*/\n          default:\n          /*转发给后继处理*/    \n      }\n  }\n</code></pre>\n</li>\n</ul>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"10分钟设计模式-责任链","date":"2021-09-06","tags":"设计模式","path":"/chain-responsibility","top":null,"summary":null},"title":"10分钟设计模式-责任链","date":"2021-09-06","tags":"设计模式","path":"/chain-responsibility","top":null,"summary":null},{"id":"60b720c4-53b8-5d91-88c7-7ac6f0eb90d6","html":"<p>页面开发中数据在组件之间共享和同步是一个比较常见的问题，通过状态管理可以实现清晰的数据流和组件状态同步能一定程度上减少业务的复杂度。本文主要对比Redux和Mobx的实现细节来深入状态管理的技术实现，这样在做技术选型的时候能有一定的考量</p>\n<h2>1. <a name='reduxhttps:github.comreduxjsredux'></a><a href=\"https://github.com/reduxjs/redux\">redux</a></h2>\n<h3>1.1. <a name='redux'></a>redux的思路</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQ4y32U666CQAyEef9HxIAxBgLeuIqCQs3XZMjKufxolu2205l2l6jrOsPatrX7/W7P59Pqura+761pGpumyb85ZyUW3ziOvm4tqqrKbrebsRIM4OVycYDr9Wqv18v9fFOIuH8BYQUABiP2RVFYlmUOwB7wsiwdjH0IuAWOYIBT0gEF7Hg8OivA8COXBOKV/BvLSE4C3++3PR4PZwI7gCVfclnxhUxD4Ch0Yurh6XRaexqeU1ispe6L4Zb+PM9eHel8S6LOUUBB2qE2hAWjMBggXRekDcPgbGCptuhc/d7KXgEJBoQrxETp3/l8XpPFlCK0gxj5Zc4wRAcARkx4t9t5InuGwcCIow0Uwdjv93s7HA6WJIkTcoZIIgBASV2WxRloQJKOAvpHEXLCFqw9DK8KRjISSJZPzzHPcy8sUJhL8tc9hJVMPhgBgJw4jtenyPCIg8iPKf/1JvFTHWZpmnqv9GPYxoX38ANpAjjKavX2CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"redux实现思路\"\n        title=\"redux实现思路\"\n        src=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png\"\n        srcset=\"/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/63868/redux.png 250w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/0b533/redux.png 500w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/00d43/redux.png 1000w,\n/blog/static/b7ea0da79e329fa308d78e40c7d6b31c/1790f/redux.png 1189w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>redux通过全局的store来统一管理数据，通过订阅机制实现数据变更的通知</li>\n<li>redux引入函数式编程的概念，约定通过action来触发全局store的更新，单向数据流能一定程度上降低业务的复杂度</li>\n</ol>\n<h3>1.2. <a name='redux-1'></a>redux简单使用</h3>\n<pre><code>import { createStore } from 'redux';\nconst action_type = 'test';\nconst init = {\n  count : 1,\n}\nconst reducer = (state = init, action) => {\n  switch(action.type) {\n    case action_type: {\n      return { count: state.count + 1  }; \n    }\n    default: {\n      return state;\n    }\n  }\n}\nconst store = createStore(reducer);\nstore.subscribe(() => {\n  console.log(store.getState()); // { count: 2 }\n})\nstore.dispatch({\n  type: action_type,\n})\n</code></pre>\n<ul>\n<li>redux通过createStore(reducer, preloadState, storeEnhancer)函数来\b生成状态管理的store.</li>\n<li>store提供getState()来获取当前\b的状态</li>\n<li>dispath(action)更新应用的状态</li>\n<li>subscribe(listener)来订阅状态变更时触发的事件.</li>\n</ul>\n<p>通过上面的分析可以看出redux\b实现了一套发布订阅的机制来实现\b状态的变更和通知,下面将深入redux的源码来了解redux的具体实现</p>\n<h3>1.3. <a name='redux-1'></a>redux源码解析</h3>\n<p>以下源码部分基于<a href=\"mailto:redux@4.0.1\">redux@4.0.1</a>,为了整体介绍redux的整体流程,只保留了关键的部分并且进行了一部分修改.</p>\n<h4>1.3.1. <a name='createStore'></a>createStore</h4>\n<p>createStore(reducer, preloadedState, enhancer)\b接受reducer,状态初始值,store增强函数来生成应用的store</p>\n<pre><code>export default function createStore(reducer,preloadedState, enhancer) { \n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  // 如果存在enhancer函数,通过enhancer函数创建store\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  // 获取当前应用的状态\n  \bfunction getState() {\n    return currentState;\n  }\n  \n  // \b订阅当\b状态更新的监听函数.\n  // 返回取消当前监听函数的方法,用于取消订阅对应监听函数\n  function subscribe(listener) {\n    \bnextListeners.push(listener);\n    return () {\n      const index = \bnextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    }\n  }\n\n  // 执行action的变更并且执行监听函数\n  function dispatch(action) {\n    currentState = currentReducer(currenState, action);\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i &#x3C; listeners.length; i++) {\n      const listener = listeners[i]\n      listener();\n    }\n    return action;\n  }\n\n  return {\n    getState,\n    cubscribe,\n    dispatch,\n  }\n}\n</code></pre>\n<h4>1.3.2. <a name='combineReducer'></a>combineReducer</h4>\n<p>combineReucer(reducer)\b\b可以将多个reducer函数组合起来,接受action并改变状态.combineReducer\b解决了将所有的更新逻辑写到一个文件的问题</p>\n<pre><code>export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  // 生成finalReducers\n  for (let i = 0; i &#x3C; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  //  \b返回的函数是实际调用creaStore()的第一个入参,这样就能接受action来改变应用的状态了\n  return function combination(state = {}, action) {\n\n    let hasChanged = false;\n    const nextState = {};\n    // 对action执行所有的传入的reducer函数\n    for (let i = 0; i &#x3C; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]  // 对应reducer之前的state\n      const nextStateForKey = reducer(previousStateForKey, action) // 对应reducer接受\baction之后的状态\n      nextState[key] = nextStateForKey  // \b将\b\b处理过后的值存储\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 如果改变返回nextState, 否则返回之前的状态\n    return hasChanged ? nextState : state\n  }\n}\n</code></pre>\n<h4>1.3.3. <a name='applyMiddleware'></a>applyMiddleware</h4>\n<p>applyMiddleware是redux提供对外部进行扩展的\b途径,通常情况下\bdispacth只能接受一个对象来对状态进行修改,通过添加不同的中间件,对dispatch进行增强,可以使它接受更多的类型(function, promise)和实现更多的功能, 下面先从一个使用\b中间件的实例来\b了解appleMiddleware到底做了什么.</p>\n<pre><code>function thunkMiddleware({ dispatch, getState }) {\n  return  next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState);\n    }\n\n    return next(action);\n  };\n}\nconst store = createStore(reducer, { count: 1 }, applyMiddleware(thunkMiddleware))\nstore.subscribe(() => {\n  console.log(store.getState());\n})\nstore.dispatch(() => {\n  console.log(1);\n  return { type: action_type };\n});\n</code></pre>\n<p>通过上面的例子,dispatch就能接受函数类型\b并且执行对应的函数,下面来了解appleMiddleware的源码是怎样实现的.applyMiddleware返回的是store的enhancer,在createStore的代码部,在\b传入enhancer的时候,执行的是enhancer(createStore)(reducer, preloadedState).</p>\n<pre><code>function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    // ..args 是\b传入的reducer, proloadedState 来生成\bstore\n    const store = createStore(...args);\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n\n    // 将\bmiddlewareAPI注入到每个middleware\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    // next的注入,将多个中间件关联,返回的dispatch已经被增强\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre>\n<h4>1.3.4. <a name='reduxreact'></a>redux结合react</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 430px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 148%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTklEQVRIx6WVV4sCMRSF5///GNFnH0QRFLtYsVes2HvL8l24wyi6zuwGws1kkpNzy0msy+VivvXz+Sz2drt9XHO9XmWd5QZMAbvdrmm1WqbdbovVcbPZNJPJREAtt+yOx6MA0O73u9jH4yFjOqCs8wQIQwXUeW0wde2yAnY6Hdm82WxMpVKxWcH0T4DK8F0jHJ4AsY1Gw/R6PTMcDk2xWJTvwWAgBzHvOikKejgczHK5lPLx+/0mlUrJv9VqZa+x3NShkyksaLAjlsSPOV3jiSH2dDpJluv1ugBqQT8x1IlvXdfCigxvt1tbPbrG0oUqLU6k61itbtrtduJyIBAwpVJJwImtYtgM9/u9WSwW4gZBpjNmToNerVal3shoOp2Wb6cc7SwDxmQ0GpWF8XjcJJNJCXwikTD5fF7cc1WHuDSfz00oFBLAcDhsYrGYiUQiJpfLiSI4HUCY4fJsNrPZsxcgVGRnmRhQoADAKJPJCNNCoSAH4BrrAKQOYYodjUYyZj/WToomBiZszmazwhBXx+OxbEB6ZPZdo4wIjyRFAQmo0w3uN1zjH2HBavCRnh6IZzr3JD0FZTNd77lXlcCUFgwGJb40il1Ly3ot2t8KWjsHwZYEOWv0X9JTLb+VntvLQdnQyuWyZPpflwMu6vXl8/mkzPT6Uvl5umDRLlmlE0Pqst/vi63Vat5fPTZ+an9+U/jWax+XYUocsZ6fUYBo6/VaMowA9Dp70rIbQMqFhwklkRg6wFgURZF7fqSm06lIUq1zzEGe61Dl+K6r3n8A1lgA1sQPbKMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-redux\"\n        title=\"react-redux\"\n        src=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png\"\n        srcset=\"/blog/static/d1552ca37f9759e99431875c3d31cc06/63868/reactRedux.png 250w,\n/blog/static/d1552ca37f9759e99431875c3d31cc06/05ed2/reactRedux.png 430w\"\n        sizes=\"(max-width: 430px) 100vw, 430px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact-Redux的作用是将React组件和Redux绑定，React组件可以通过react-reudx完成数据的获取和更新。其中connect函数就是这个功能，通过下面的代码可以看出connect主要是从redux或者context中获取属性通过高阶组件的方式返回包裹组件。</p>\n<pre><code>const Connect = _Connect as ConnectedComponent&#x3C;\n  typeof WrappedComponent,\n  WrappedComponentProps\n>\nConnect.WrappedComponent = WrappedComponent\nConnect.displayName = ConnectFunction.displayName = displayName\n\nif (forwardRef) {\n  const _forwarded = React.forwardRef(function forwardConnectRef(\n    props,\n    ref\n  ) {\n    // @ts-ignore\n    return &#x3C;Connect {...props} reactReduxForwardedRef={ref} />\n  })\n\n  const forwarded = _forwarded as ConnectedWrapperComponent\n  forwarded.displayName = displayName\n  forwarded.WrappedComponent = WrappedComponent\n  return hoistStatics(forwarded, WrappedComponent)\n}\n</code></pre>\n<h2>2. <a name='Mobx'></a>Mobx</h2>\n<p>mobx将响应式编程的概念引入到状态管理的实现上，通过观察者模式实现组件的更新。相比redux他的优势在于:</p>\n<ol>\n<li>在组件更新上性能更好 redux通过发布订阅的模式会在所有的组件上进行Prop的脏检查，mbox通过proxy依赖收集能更精确的控制组件的更新</li>\n<li>长期维护上存在一定优势 mbox基于proxy内部维护了更新的机制，redux需要通过mapStateTpProps来主动告知订阅的属性存在一定维护成本</li>\n</ol>\n<h3>mobx背景介绍</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQY00WQ3UrDQBSE8/6PIPgcuRItBqEgXpSQWqvGRpsfgrvFppvdPdl8ktTiwDA383M4Udu2KK05VVsOmwd+ioyyLFHqm7us4ermheW2pakrlFK8lk8ss5ha5RTFF9VuR54kpHFMk6ZE3ntOxtDtn9HZArNfIyI4a0k2Lde3bzy+K8Ig9H3PZ7sm/bhHH2tEBkzXcchz6tWKY10T8QcJI1prvARkGBjHERhhDEAghDPFD3gnZ/V+9joRhtkP0RS8hKdF5yzW2vkaYwzG9PTWMr1mHvQe59w/rZ310vMLZFMvcH+PNUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx\"\n        title=\"mobx\"\n        src=\"/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png\"\n        srcset=\"/blog/static/1f17685984e130f52da0a236b2dcae30/63868/mobx.png 250w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/0b533/mobx.png 500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/00d43/mobx.png 1000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/aa440/mobx.png 1500w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/e8950/mobx.png 2000w,\n/blog/static/1f17685984e130f52da0a236b2dcae30/2c3b8/mobx.png 3445w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Observable  定义可观察的值，当observable值变化的时候会触发Derivations</li>\n<li>Derivations Derivations主要为Computed values和Reactions，可观察值的改变会触发对应的Derivations触发</li>\n<li>Actions actions触发Observable值的更改进而触发Derivations</li>\n</ul>\n<h3>mobx简单使用</h3>\n<pre><code>import { observable } from \"mobx\";\nimport { observer } from 'mobx-react'\n// 定义一个可观察的值\nvar timerData = observable({\n  secondsPassed: 0\n});\n// 定义了观察者 当secondsPassed发生变化的时候会触发组件更新\nconst Timer = observer(({ timerData }) =>\n    &#x3C;span>Seconds passed: { timerData.secondsPassed } &#x3C;/span>\n);\nsetTimeout(() => { timerData.secondsPassed = 33 }, 2000)\n\nfunction App() {\n  return &#x3C;Timer timerData={timerData} />\n}\n</code></pre>\n<h3>mobx源码解析</h3>\n<p>使用mobx实现组件更新的方式如下:</p>\n<ul>\n<li>mobx实现创建Observable值和触发Derivations</li>\n<li>mobx-react实现对react组件的封装，创建基于组件的Derivations从而在对应的Observable值修改的时候完成组件的更新</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 852px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVQ4y62Ta8uCQBCF/f9/rehD+EEysjAzKtO8ZdeJZ2CkZHkvkDDMMmf3nDM7q3e9XuWb4X2d8HK5iCtsw38xp0PX4b9gfcvn8/kjDLzdbtJ13QdGzTBI27bVOlkdNk0ju91O8jzXsDVEdV1LHMeSZZnW0jSV/X6vWFVVstlstH48HmW73ep+ryxLgfR+v6sySuv1Wk6nk+bFYtE7OBwOEgSBFEUhq9VKoiiS5/OpROxBxGOBA4IDZGoIPB4PVccFAmDU7cOMYXSGMc8uGjJaGk6N9tiIQw4ul0t1RiRJoqRgRP9sTA0VPtckGQKt+b4vk8lEptOphGGoRHZdOhRzhxoOyabmcouz+XyumaE43yEXPxqNZDwey2w20xaN8P39kc0Njt+d9e8QAEdMDWLaYqOL7Ke/yrI3vKchwW+kQ4cvCws6rZketdUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mobx原理\"\n        title=\"mobx原理\"\n        src=\"/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png\"\n        srcset=\"/blog/static/28f13754dd42663bf2a3b517779e126f/63868/mobxlogic.png 250w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/0b533/mobxlogic.png 500w,\n/blog/static/28f13754dd42663bf2a3b517779e126f/47ff6/mobxlogic.png 852w\"\n        sizes=\"(max-width: 852px) 100vw, 852px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>mobx生成Observable</h4>\n<p>Observable会根据传入的值类型包装生成代理，在对观察值获取和设置的时候都是调用代理的方法</p>\n<pre><code>// mobx暴露的observable调用的入口函数 \nfunction createObservable(v: any, arg2?: any, arg3?: any) {\n  // @observable someProp;\n  if (isStringish(arg2)) {\n      storeAnnotation(v, arg2, observableAnnotation)\n      return\n  }\n  // 如果已经是可观察值忽略\n  if (isObservable(v)) return v\n  if (isPlainObject(v)) return observable.object(v, arg2, arg3)\n  // 这里省略了其他数据类型的包装 \n  // 调用工厂方法对不同类型的值包装成可观察值\n  if (typeof v === \"object\" &#x26;&#x26; v !== null) return v\n  // anything else\n  return observable.box(v, arg2)\n}\n// 观察值封装的工厂方法\n// 省略若干其他类型的封装\nobject&#x3C;T = any>(\n    props: T,\n    decorators?: AnnotationsMap&#x3C;T, never>,\n    options?: CreateObservableOptions\n): T {\n    return extendObservable(\n        globalState.useProxies === false || options?.proxy === false\n            ? asObservableObject({}, options)\n            : asDynamicObservableObject({}, options),\n        props,\n        decorators\n    )\n},\n//extendObservable通过创建一个代理(管家)来代理属性的访问和设置，这里关注在没有proxy设置的场景asObservableObject在内部创建了代理\nconst adm = new ObservableObjectAdministration(\n    target,\n    new Map(),\n    String(name),\n    getAnnotationFromOptions(options)\n)\n在ObservableObjectAdministration内部维护了维护了获取属性的get和set方法\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAChElEQVQ4y5WT3Y7bNhCF/RjdtSj+ir+iJEv22t6sHaQ3RZs0RVr0/R/lK6RNFynaAu3FhyGH4JkZ4nB3mArHy51yeSbeboT7jXK9ki4X6vkZF8tG5wMpBvo+4ENE2rjlrY8Yt+YSsm3ZiabFGktZFsbzvJEPI2ka6E8zaR7Jy0ide4Y5M86JXBN+6CnHiVDXWOnnni4ZdkopWiVpfaYOgToVQt/T7L9DiD1t29DKFYGQgkYIRCuQUmxnQjRIJbZzqVp2RhvGUAku0bpMGGbiMJOnhS5ERLNear8iaN/W7V/yf8adlBItFVoZpDJo614xFqnUq0jb/md2xmuEVAgpt9GFbDek1v9L6E3QlZ5uesEMI3oZ6E4Ldp7oco9Smv3DA83jI83+kaYRiK80e/G2X9dbfh25Gw7E60fc0wX7ciLf78TrFTMNmKkSDzN5edre1SWLdop1Kt9bXDLYqOnyGtfnUuxsrvjle8w4Y5+P6MtMvFwoL3fK+UQ6ROKU8H2gK5YwuE0gTo44uk14ZS2ktGTnS8KWBR16dM2Yw4CqBRU8Nlh0pzCdwiWH6V47McFgNxzWG1y22GwxnWZXa6AcJnQOtH3CTBlXI6FUQh2QqSPUcRu7zAu6JPRUMd6j/YDzaWtEDT3Gd+yUVNRauLxMPF0raZnpzwvjuyuhFsbriTJlfLa4aFBGbZ5r23+206sPlab0kTwVfC3EqRJKxjqP85m16P5hz+PDnmYzuvhXNsEVZzr8MDJcjkz3Zw6nnvPtyPzuiX6MxNqRJ4+xGrF2s937u/HfBNdN7xNDqsiQuX+48+W3j3z6/AM///Ijn7/8xK+/f+L24T1dGUjjQhqm7Wt+K/gHXJGxoBKDACIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setAndGet\"\n        title=\"setAndGet\"\n        src=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png\"\n        srcset=\"/blog/static/fa544a06a7eb56008b5833e08d10ba1a/63868/setAndGet.png 250w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/0b533/setAndGet.png 500w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/00d43/setAndGet.png 1000w,\n/blog/static/fa544a06a7eb56008b5833e08d10ba1a/203d3/setAndGet.png 1322w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子对观察值进行修改的时候，会最终走入observablevalue的更新值并且触发Derivations</p>\n<pre><code>setNewValue_(newValue: T) {\n  const oldValue = this.value_\n  this.value_ = newValue\n  this.reportChanged()\n  if (hasListeners(this)) {\n      notifyListeners(this, {\n          type: UPDATE,\n          object: this,\n          newValue,\n          oldValue\n      })\n  }\n}\nexport function endBatch() {\n  if (--globalState.inBatch === 0) {\n      // 触发Derivations\n      runReactions()\n      // 省略若干逻辑\n      globalState.pendingUnobservations = []\n  }\n}\n</code></pre>\n<h4>mobx-react生成Derivations</h4>\n<p>这里主要从包装函数式组件来看Derivations的生成过程，函数式组件的封装方法主要做了:</p>\n<ul>\n<li>\n<p>定义更新逻辑并与生成的Reaction绑定</p>\n</li>\n<li>\n<p>通过运行函数 将observable值与Reaction绑定</p>\n<pre><code>export function useObserver&#x3C;T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    const [, setState] = React.useState()\n    // 定义刷新组件逻辑\n    const forceUpdate = () => setState([] as any)\n    const reactionTrackingRef = React.useRef&#x3C;IReactionTracking | null>(null)\n    if (!reactionTrackingRef.current) {\n        // 创建Derivations 在设置observable的时候会触发相应的newReaction\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n          if (trackingData.mounted) {\n            forceUpdate()\n          } else {\n              trackingData.changedBeforeMount = true\n          }\n        })\n    }\n    const { reaction } = reactionTrackingRef.current!\n    let rendering!: T\n    let exception\n    // track通过运行组件 走入组件的get方法 将reaction跟observable值关联起来\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n    return rendering\n}\n</code></pre>\n</li>\n</ul>\n<p>这样当observable更改的时候会触发对应的Reaction执行从而达到组件刷新的目的</p>\n<p>在业务开发中最开始引入状态管理是为了实现组件之间的状态共享，而使用Redux或者Mobx是引入不同的编程范式来实现这种共享的行为。不同的编程范式能给予项目一定的约束从而实现业务开发的规范。但是范式的引入也一定程度上增加了项目的复杂度，比如redux的依赖管理、中间件概念、mobx跟踪性较弱的更新逻辑等。在考虑引入具体方案的时候应该考虑整个项目的现状和成本，是不是有更轻量化的实现，比如React Hooks。</p>\n<h2>3. <a name=''></a>参考</h2>\n<p><a href=\"https://tech.youzan.com/mobx_vs_redux/\">我为什么从Redux迁移到了Mobx</a><br>\n<a href=\"https://github.com/reduxjs/react-redux\">react-redux</a><br>\n<a href=\"https://github.com/reduxjs/redux\">redux</a><br>\n<a href=\"https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\">Becoming fully reactive: an in-depth explanation of MobX</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/85720939\">mobx 源码解读（一）：从零到 observable 一个 object 如何</a></p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null},"title":"当我们聊状态管理的时候我们在聊什么","date":"2021-08-31","tags":"React","path":"/state-control","top":null,"summary":null},{"id":"9cf87650-c261-51d7-b150-77bfa90feef5","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#-\">深度思考-不断逼近问题的本质</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#12\">大败局(1 2)</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#--1\">增长黑客-如何低成本实现爆发式成长</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#\">看不见的心</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li><a href=\"#-1\">思考，快与慢</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li><a href=\"#--1\">结构性改革-中国经济的问题与对策</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>这里记录下自己读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>推荐指数0 - 5</p>\n<h2>1. <a name='-'></a>深度思考-不断逼近问题的本质</h2>\n<p>推荐指数 0.5<br>\n书名与内容严重不符的一本书，内容是作者的个人自传性质，在陈述的过程中并没有很好的结合书名进行深度解读，作为自传的话推荐指数很一般</p>\n<h2>2. <a name='12'></a>大败局(1 2)</h2>\n<p>推荐指数 4.5<br>\n大败局记录了多个企业的发展历史，从中能看到许多的无奈，作者的叙述也比较引人入胜，商业的发展历史很有意思，有机缘巧合也充满着时代的背景。</p>\n<h2>3. <a name='--1'></a>增长黑客-如何低成本实现爆发式成长</h2>\n<p>推荐指数 4<br>\n增长黑客主要介绍一个产品实现快速增长的方式，可以从多个角度去了解产品生命周期的一些行为，本书整体大纲如下:<br>\n<img src=\"./readBook/increase.png\" alt=\"增长黑客\"></p>\n<h2>4. <a name=''></a>看不见的心</h2>\n<p>推荐指数 4<br>\n通过两个人的爱情故事阐述了很多经济学的视角，很有意思的一本经济学读物</p>\n<h2>5. <a name='-1'></a>思考，快与慢</h2>\n<p>推荐指数 4<br>\n虽然有些中文翻译增加了阅读上的困难但整体上还是值得阅读的一本书，书中介绍了思维的快思考方式和慢思考方式、常见的思维误区等，阅读之后还是有一定的启发</p>\n<h2>6. <a name='--1'></a>结构性改革-中国经济的问题与对策</h2>\n<p>推荐指数 4.5<br>\n可以结合分析与思考一起阅读，这两本书总结了黄齐帆对中国经济问题的一些长远的思考，对于中国的一些问题通过结构性的方式去优化。黄奇帆通过结构性的梳理问题并且比较创造性的提出解决方案都体现出他对中国特色社会主义制度的深入思考，书读起来特别引人入胜</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null},"title":"读书目录-2021","date":"2021-08-20","tags":"读书目录","path":"/book-list-2021","top":null,"summary":null},{"id":"dc973b58-df85-506e-a262-d0a27a00f560","html":"<p>写这个主题是比较忐忑的，自己有一段时间会规划小组内下个阶段的工作目标，现在看当时做的阶段目标其实谈不上技术规划，本文主要结合自身的一些案例总结做技术规划上的一些思考。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVQoz2VSQW6DMBD0/w+9VVXUa/qQ9AFRq36ghyRSMZhgSIzXJlONiYlpkUbgnfXsLLtKRBBCwDAM6LoOfd/De79gHMf0Zl4Z5zmj5NXlcsH1eoXWGlVVoWmaVTILlZdKYRb7yyu6MsbgdDolMZ6ZZK1Nbgl+szDjLE4451KMHOMZigQTKEpQMItmMX5P04QYA+pao+vOS1GC9/mwgKLNGGMi6rpeBCnetu0dBt4LnAvQ+gxjLIyZOXbFu9ShAZV7Z5Akk+h6DQ/nWoi8A9ghhF06Mz6Oc07+DctQOBAOhoLlUERYMCLGM/p+i8PhGU2zgUgFkdudf+Sr3OLxeExidFqux4yQBLV+w37/hO/vlyTo/fQvV+W22G6ecrkadOB9RAgthmELrTew9hUiP4vgymFebDorF/uxW7NDEU76C8AnbrcPiNh7fC34C+UwAiFBmhIuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png\"\n        srcset=\"/blog/static/19e59b526f6f15361b687635a5717660/63868/plan.png 250w,\n/blog/static/19e59b526f6f15361b687635a5717660/0b533/plan.png 500w,\n/blog/static/19e59b526f6f15361b687635a5717660/00d43/plan.png 1000w,\n/blog/static/19e59b526f6f15361b687635a5717660/aa440/plan.png 1500w,\n/blog/static/19e59b526f6f15361b687635a5717660/2643c/plan.png 1747w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>自身案例分析</h2>\n<p>在做下个阶段目标的时候经常会有如下的一些疑问:</p>\n<ol>\n<li>下个阶段做什么(来源)</li>\n<li>怎么做(过程)</li>\n<li>完成的总结</li>\n</ol>\n<p>在反思自己之前的制定目标的时候有以下的问题:</p>\n<ol>\n<li>多数在关注1阶段而弱化了2，3阶段的思考，这样会导致在下一次做规划的时候还是很挣扎跳不出这个圈。</li>\n<li>没有一个完整的全局视角 这个导致我的一个疑问是业务侧做这个为啥，看着很分散</li>\n<li>没有一个长期的视角，导致阶段性目标不明确</li>\n</ol>\n<h3>下个阶段做什么(来源)</h3>\n<p>在这个阶段我的思路是关注业务侧的规划文档，但是在看业务侧的文档会存在以下的\"问题\":</p>\n<ul>\n<li>某些目标比较泛并不能准确的落实到技术目标上 比如收入增加XXX</li>\n<li>可以收集到下个阶段的业务目标比如需求A，需求B，需求C，但是A，B，C有可能之间关联性不大，当然这可能跟当前的业务现状有关</li>\n</ul>\n<p>虽然通过看业务侧文档可以整理出下个阶段的业务目标，但是每次都感觉没有所谓的抓手，有种隔靴搔痒的感觉，其实从现在来看之前的我，可以看出很多思考上不足的点，才导致每次都很痛苦的想下个阶段要做啥。\n在思考上可以有两个思路:</p>\n<ol>\n<li>从上往下视角 从全局视角看不同模块的关系，建立联系和目标</li>\n<li>从下往上视角 为什么会有这样的关系，基于已有的关系是否会衍生出新的关系，在新的模块上能做什么</li>\n</ol>\n<h4>下个阶段业务目标</h4>\n<p>在梳理业务目标的时候可以从以下几点考虑:</p>\n<ol>\n<li>熟悉业务的现状  熟悉业务现状才能有目的性的查看业务侧的规划来反推出更多的思路来推动业务目标，比如\n<ul>\n<li>后续会发力营销但是现有的营销页面并不支持配置化那是否可以尝试推动业务侧一起建立配置平台</li>\n<li>业务侧要对存量的业务有一系列的优化，存量的业务还是老旧的技术栈，那么提前对技术栈进行迁移和统一</li>\n</ul>\n</li>\n<li>多与业务侧沟通，建立正向的连接  可以跟业务侧一起建立双向的规划分享，这样互相都比较了解对方做事的思路，团队每人也更有全局的意识</li>\n<li>数据思维 关注产品数据，业务数据促进对业务的反思，可以养成一个思维习惯就是产品的数据怎么能映射到我当前开发的具体业务上</li>\n</ol>\n<h4>下个阶段技术目标</h4>\n<p>在梳理技术目标可以从以下几点考虑:</p>\n<ol>\n<li>流程优化 梳理业务开发的流程针对性解决，比如:\n<ul>\n<li>规范 技术栈统一，代码规范，开发上线流程，Code Review(思考中，如何建立有效的Code Review)</li>\n<li>质量 性能，监控</li>\n<li>效率 通过工具、库来实现提效，已有业务的抽象组合</li>\n</ul>\n</li>\n<li>了解团队成员能力和诉求 可以针对不同阶段的团队成员制定不同的规划，比如工作年限相对短的可以多从一些复杂的业务中成长，年限久的赋予更多的自由度，实现自治</li>\n<li>技术储备(分享输出等) 技术储备可以为团队输入新的血液，分享和输出可以建立团队的整体意识和对外的口碑</li>\n</ol>\n<h3>怎么做(过程)</h3>\n<ul>\n<li>里程碑 每个目标阶段要有里程碑，比如做页面性能监控:\n<ol>\n<li>已有业务接入性能监控</li>\n<li>主要业务首屏优化达到XXX</li>\n<li>性能优化总结，推动上下游进行优化，新技术探索</li>\n</ol>\n</li>\n<li>可调整 在具体实现上因为优先级或者当前目标实现的结果不理想及时调整当前或者下个阶段目标</li>\n<li>多阶段完成 一个大的目标可以拆分成多个子目标在规划的多个阶段落实，需要建立多个目标之间的关系，保证规划的整体性</li>\n</ul>\n<h3>完成的总结</h3>\n<p>这个阶段可以结合上面的两个阶段来看:</p>\n<ul>\n<li>完成了哪些业务目标，技术目标，产生了哪些收益</li>\n<li>过程中产生了哪些问题，是否在下个阶段可以进行优化和避免(下个阶段目标)</li>\n<li>下个阶段目标调整</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844904201160491016\">技术管理- 怎样做好技术规划</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null},"title":"做技术规划的一些思考与总结","date":"2021-07-31","tags":"思考","path":"/how-to-manage-skill","top":null,"summary":null},{"id":"b336e8ac-e502-5c89-83d4-431579baadac","html":"<p>使用<a href=\"https://icantunderstand.cn/webview-store\">缓存</a>和<a href=\"https://icantunderstand.cn/cross-platform-offline\">离线包</a>可以一定程度上提前页面展示的时间，但是页面的展示依赖具体的数据加载，Webview在加载h5的时间线可以做如下简化:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAa0lEQVQY05WPSwrAIAxEvf9RjSL4w7hJmcAUkW66eEw+JhmDqtrJ3tvGGJZztlqr03u3UoqTUvKaiFhrzXXO6XOYDwhu1lq+FA9O5bG7TiMgfDnEQrhCDmWOHlyhTmX/dUjb+OJJjPGXMn4AApw0UHe2ZIsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png\"\n        srcset=\"/blog/static/0ce30849a4870d72a825560fed237688/63868/timeLine.png 250w,\n/blog/static/0ce30849a4870d72a825560fed237688/0b533/timeLine.png 500w,\n/blog/static/0ce30849a4870d72a825560fed237688/00d43/timeLine.png 1000w,\n/blog/static/0ce30849a4870d72a825560fed237688/aa440/timeLine.png 1500w,\n/blog/static/0ce30849a4870d72a825560fed237688/fd8a5/timeLine.png 1659w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Webview初始化 Webview在首次初始化会占用相对长的时间进行初始化(可以通过Webview池的方式来优化)</li>\n<li>DNS TCP TLS 建立与服务器的连接，可以通过html的预加载标签来优化(dns-prefetch, preconnect)</li>\n<li>数据请求响应阶段 在解析响应的html的时候会解析到js代码下载并执行发起数据请求(可以通过服务端渲染方案优化但是也增加了服务端成本需要考量)</li>\n</ul>\n<p>从上面的分析可以看出在发起数据请求之前通过Native并行提前完成数据的读取就能换取页面提前展示给用户的时间，下面介绍一种可能的预取方案。</p>\n<h2>实现方案</h2>\n<p>本方案通过配置维护了对应url下需要预取的配置，在初始Webview的时候客户端并行完成数据获取，最后通过jsbridge获取数据。</p>\n<h3>预取配置</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 775px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA60lEQVQoz3WRx6rFMAxE8/8/l1VIyCINQnrvVZcjMOQt3mKwNZJmBts6jkPAdV1ynqfeOQ1M/4v/eGAhtO+7FEUh8zzLfd9/lujDGXxNvzxzKrhtm4zjKHVdyzAMKvpNOE2TdF0nfd8rMIdnz3AADXiL4SiKJMsyieNYkiSRdV3VETGMlmVRIwzLstRE8OzCA3jmLNR93xfXdcXzPHEcR+8MB0Ggok3TSBiG8jyP2LYtaZqqMTV30hGCWattW8nzXIVIiBNNUuBcVZUKmkTU7/tq/eX5A01o3hARBHD5/qbhOJlj3rwhtembvR/OZxjL3yVM2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"时间线\"\n        title=\"时间线\"\n        src=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png\"\n        srcset=\"/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/63868/config.png 250w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0b533/config.png 500w,\n/blog/static/441b33eb2b2d3c8a3def8721c4aa2d2a/0098c/config.png 775w\"\n        sizes=\"(max-width: 775px) 100vw, 775px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>配置侧 提供配置能力，需要对配置有准入审核，管理(下线，上线)</li>\n<li>服务侧 根据配置提供获取配置服务</li>\n<li>Native 动态拉取配置更新本地数据</li>\n</ul>\n<h3>加载流程</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 923px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 115.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y42VV47DMAxEff/T5Su9996c3hg8AmPIJWUBQo5EDodDShvdbjcL7Xq9Jutms7HdbudrHMd2v9+T808WZcEUcDqdbL1e236/dwM0m7AIPCpi9ng87HK5OBAMD4eDf79er5xvDrAoIyCLxcKGw6F1Oh3r9Xo2m81sPp/b+Xz+WnqUzcQfAJSr0o/Hoy2XS2s2mw4M20+gCUNK3G63zqrRaHgwbCifFQ1hiA/2E5AgAgaDgYPV63X/DSAsp9OpJ+r3+w7+FZBDhF+tVg4MS8oMk6EpySaTyW+GHNIIldRutxOtxJBvZhHD9y8NYQi7VqvloLASIAnYH41Gv0sOy6KbdBlgAkNAtO12uynArEXhzZCGBAHMHoHscYaGJPu7y4AgOkwomd9iCEi5XLbxeOw6sq84WYqhACm7Vqu5Xgy3mLAPczRkItQcpIC9GporGSfAYMI3TFgrlYpVq1VnSdn44ocMpVLJ9/BLdZnssIQZAWKoc5Jwzh6JYIoP7NhntCJ1Byc9Agx1eMWQg2B0pft86w0gEYBIkHscyBo+qhpggjSf2bEhBpYkLXy+cAxNDdPQMwXhTWEFkB7kGBYNavgSUTKPBJJobMQwBfjJwpECCK0wWOqd1A1LSv4HUBrSZZrGM4YEaAk7JCj8J/UNkJLpLivsns9nTmtuyhvVnukgKd1z8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载流程\"\n        title=\"加载流程\"\n        src=\"/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png\"\n        srcset=\"/blog/static/b70892349e045d91bae6d4a918265e42/63868/prefetch.png 250w,\n/blog/static/b70892349e045d91bae6d4a918265e42/0b533/prefetch.png 500w,\n/blog/static/b70892349e045d91bae6d4a918265e42/23266/prefetch.png 923w\"\n        sizes=\"(max-width: 923px) 100vw, 923px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在加载h5的时候</p>\n<ul>\n<li>Native会在初始化Webview的时候并行的根据配置加载数据(动态参数根据页面url和配置完成映射)</li>\n<li>Webview展示的时候触发jsbridge请求，普通请求jsb与prefetch jsb的区别在于prefetch有一层从本地获取数据的步骤和数据的重置操作。</li>\n</ul>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null},"title":"一起学跨端技术-数据预取","date":"2021-07-23","tags":"跨端技术","path":"/cross-platform-prefetch","top":null,"summary":null},{"id":"95eed3a5-97d9-529a-8e3f-8b118507e82a","html":"<p>在<a href=\"https://icantunderstand.cn/webview-store\">一起学跨端技术-Webview缓存</a>中介绍了几种常用的缓存实现方案，几种方案都各有优缺点。其实h5的展示可以类比成CPU在运行的过程中动态获取数据，从寄存器中读取数据和从磁盘中读取数据的时间是相差极大的。那在h5展示的时候有没有一种方案可以绕过耗时较大的网络获取数据阶段直接加载内容展示呢？离线化就是这种解决方案。通过离线包的动态下发可以让用户在打开页面的时候直接加载已经在app中存储的离线化资源从而加速页面的展示。本文从以下两个方面介绍离线包的实现过程:</p>\n<ul>\n<li>离线包分发过程</li>\n<li>端内加载离线包过程</li>\n</ul>\n<h2>离线包分发过程</h2>\n<p>离线包的分发流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 907px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnElEQVQ4y4WS167CQAxE8/8/h0QEQfReQk0oSSjy1RnJuStA4sFa72Z9PONNVFWV3e93ez6fCvLj8Whpmtput7PtdluH71n3+319Tr7ZbOx8PlsEoCgKW6/XOjydTrqwWq2053w+n6sB++l0aqPRyLrdro3HY+v3+4rZbGaLxeIfyGWKALJOJhMVAGClgBUYZwBpxNlwOJQAzqNvlh36btWDbx4uBCey7MDH46Eoy1JFXAzDQRR6E/YoY0ScHw4Hi4DwCFhEMuoAYKXVaqmAvNPpyCb3yOM4ltVer2fNZlPfGEs9wzzPJfl6varbcrnUBeAMm2IaMjdyoP4YQJktdR+WyS+Xi2VZpias3ogcheS32033uOMrwqQQaBgOJl6vl2aGdVQnSSLV5ED8Ib0m8kKHkaMACwyZi1hpNBqyyYzb7bZs8yh8D8XUwBAc7ilA0WAwUBNy/xe9YVgTfYOFagms8Sfwe2CZWQJjZu8iPoAhlMGzAvJHAETOWH4qDLtRhD1UUMjwUQocGHvyn8AQ6i8HkOBBPIDxO71b/gMnvXNQcp6IjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"分发\"\n        title=\"分发\"\n        src=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n        srcset=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/63868/broadcast.png 250w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/0b533/broadcast.png 500w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png 907w\"\n        sizes=\"(max-width: 907px) 100vw, 907px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n分发流程中主要涉及4种角色:</p>\n<ul>\n<li>离线配置平台 配置平台可以提供离线配置能力、离线包管理(上传、禁用、清空)、离线包使用统计、离线包准入审核(自动(包大小限制)+人工(解决特殊case))</li>\n<li>离线配置服务 配置服务主要提供服务层能力，实现离线配置服务，离线包更新服务，离线资源长传下载服务、离线资源使用统计服务</li>\n<li>离线SDK 端内接入离线SDK，SDK主要与离线配置服务进行交互，完成离线资源的管理和接入配置能力</li>\n<li>Native侧  实现拦截请求在特定的协议下接入离线资源</li>\n</ul>\n<h2>离线包加载过程</h2>\n<p>离线包的加载流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQ4y32UWa+CQAyF5///Mx95IMYouKOouOKGS83XpDfDON6HpjDLOaenBdc0jRD3+/0vn89n8df9PTL7l8ultWbhwksc3G63crvdvojIrC+XS6mq6ouwBWiHZ7OZ5Hku4/G4BUY8Hg85HA6yXq8V1Fdp4XwGAKfTqSRJoqAxwLquZT6fa3CeNc5YdiaVBfOvKAo5Ho8S8/f1eklZlrLb7RQQxfv9Xm2CzAHACwAc4BJlxzyElPP9fl+yLFPi4XAok8lEA3AHOhssrFYr6fV6qgDQ0B/zEDsABJx3BKGYd3e9XlUdGZM3m40SLBYLXQtVvt9vbQpdhoA7NIjQks0/gjJRl6apmh5TCDkKKRWQ0WgknU5HgwpbXUYRyiiHHHaZZ5QNBgMFPJ1O2hDsYTrUQ78kACmZC7CHgDYFANgcovr5fGpEBxvmbrf7s9MoZA+facTXYIcKMZwL5BggJeIVwDarPz89AGFlhCg95iEkNhHhd94CtKFFgeXwjxL+Wf792xg7CukWOabQ9yum8AMub8+9QkzZbwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载\"\n        title=\"加载\"\n        src=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png\"\n        srcset=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/63868/load.png 250w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/0b533/load.png 500w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png 1000w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png 1113w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在端加载离线资源的过程中可以分为两个方面:</p>\n<ul>\n<li>离线SDK更新离线配置和离线资源 离线SDK通过与离线配置服务交互完成离线配置和离线包资源更新</li>\n<li>Web容器加载离线资源</li>\n</ul>\n<p>下面从代码层面简单介绍下加载离线资源的实现</p>\n<h3>离线配置</h3>\n<p>离线需要有一定的配置能力，比如禁用、特定的前缀支持离线化等。通过对离线配置的解析，Web容器就知道在打开对应页面是否的具体行为。这个过程是约定协议的过程。</p>\n<h3>加载离线资源</h3>\n<p>在<a href=\"https://icantunderstand.cn/jsbridge\">Hybrid开发-JSBridge原理</a>中通过拦截请求在特定的协议下可以实现javascript和Native的通信，那么在特定的协议下其实也可以实现离线包的加载能力。</p>\n<pre><code>// 定义请求资源类型映射\nprivate HashMap&#x3C;String, String > resourceMimeTypeMap  = new HashMap&#x3C;String, String>();\npublic CustomWebViewClient() {\n    super();\n    resourceMimeTypeMap.put(\"html\", \"text/html\");\n    resourceMimeTypeMap.put(\"js\", \"application/javascript\");\n}\n@Override\npublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n    Uri uri = request.getUrl();\n    String scheme = uri.getScheme();\n    String host = uri.getHost();\n    String path = uri.getPath();\n    // 处理资源加载离线包场景\n    // 协定 域名为www.test.com 且 path是local的走加载离线包逻辑\n    if(host.equals(new String(\"www.test.com\")) &#x26;&#x26; path.startsWith(\"/local\")) {\n        InputStream in = null;\n        String pageNamePath = path.split(\"/\")[2];\n        String type = pageNamePath.split(\"\\\\.\")[1];\n        String mimeType = \"text/plain\";\n        if(resourceMimeTypeMap.containsKey(type)) {\n            mimeType = resourceMimeTypeMap.get(type);\n        }\n        try {\n            // 加载本地离线资源\n            in = view.getContext().getAssets().open(pageNamePath);\n        } catch(IOException e) {\n          // 处理处理本地无离线资源 请求网络\n          return super.shouldInterceptRequest(view, request);\n        }\n        // 将本地读取的的内容进行类型映射后通过WebResourceResponse返回\n        WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", in);\n        return response;\n    }\n    return super.shouldInterceptRequest(view, request);\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADg0lEQVRIx+WWXUybZRTHn5WvQaFv2/ft2kIFRqgbHWbqHGGBTnEujdNIBpRBgjcmBo0yJ4lZskggfBhCsuxiiUYIXHJrwsW80HhhHBfTzGnQaLYJLZJsYx/EOIW29Geep5Z0fExJXhONJ/nl/J9zzvPvafopXnz5JH7/XoqLSzAMVwo9I+sGum6ovNbP6LndHnwlj1Bbe4ipqSmEXSvAphXgLXbj9rhw6DZ0w47T0NANDaeuUbbbh6c43fuzLrPLjlO3Y+xyICyCUCiE8Bi78Tqq8BkBfK4AXseeDfiMfRTrVZv2Sj1VlBgBnNZSGhqOIJ4ofIeOskuEfZ/S+eRFXj84zWFxgWd3fEyDSPGMuLCm08i+nOs88AVdh76iY/9HPBc8jjiaf54uEeNVscgbOXfp2nmPTnGH13b8TSy3ObXzPh1ihiO1xxEhyyhn98C5g79z7qkY5+tivC1W6BIrvKWIZeSNnBTLnBJJXhFRHq88jHjJMcpIBQwHYgxVxnjPn+BdI64441jhtO03TmsP4z5ntDhvFs2xr7wWcXbwfeau/MqXn8zy/fRNLn8WYWZ6gSufR7j+9V3u/JTk1rU4i9cTm3LrapylKHx7MUro6POID0c/4ObtBS5/c4kbiz/z47Xv+OGqZIZ7vyySiiRbR6q3cCNKuDWMmJiY4GGxmkiSXE2yugWJ+Kqam5uN0NbWhhgfH1eFeDxOMimHVlVOo3ZIbr2hnJcRiawzTCQSDxiZZrjd+EcNT5wwe0MzDaPRKOFw2FzDlpYWsw1N3rCpqen/Zmj6q9zc3PwvNzT9KZtqKD/LphrOz8/T2Nj4X3wfbpcN3zZjY2OqsLy8rH6otkssFlP3Z2dnU4aTk5OYEUtLS7S2tiLk8x4ZGaG/v5+hoSH6+vro7e1VenBwUNHT06P66bPUsib1wMAAw8PDdHd3p/4fCiHIpLCwkIqKigdqdXV1ZGdnr52lbm9vZ/3dmpoahNVqVQO5ublYLBYcDgcej0dpWcvKyqK8vJyioiKlJVJXV1erezk5OeTl5SnD+vp6hK7rOJ1OhdSapmGz2UjXZZZb2+12pSVSFxQUrN0zDIP8/HyCwSBCNwxcLpcqpvmr8/qa2+3Gai1MGe4ydOyatrZNJnJ4K515luTl5vLCsWOIygNPszdQTVlpqXqkzbZZb5S5pdfrxe9/FH9gPyWPBfkD9GZ9jWzUPEsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"成功加载离线资源\"\n        title=\"成功加载离线资源\"\n        src=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n        srcset=\"/blog/static/2a4c23295151170c16b9a53887eda09b/63868/loadsuccess.png 250w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/0b533/loadsuccess.png 500w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null},"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null},{"id":"def07bfd-8fd5-597b-9010-98ac2289a06c","html":"<p>跨端开发中h5加载性能优化是一个老生常谈的问题。h5在开发上有着迭代快、试错成本低的优势，但是h5的性能问题也是一个无法绕过的问题。加载慢、体验差是通常在考虑技术选型时候的一个顾虑点。本系列会以Webview性能优化为切入点尝试了解跨端开发中的技术方案来更好的辅助业务的开发。</p>\n<p>充分利用Webview的缓存(存储)机制能有效的提升h5的加载速度,通常有如下的方案可以实现缓存的过程:</p>\n<ul>\n<li>h5缓存机制</li>\n<li>Application Cache</li>\n<li>浏览器存储</li>\n</ul>\n<h2>h5缓存机制</h2>\n<p>h5缓存是指浏览器根据文件网络传输中的一些字段来确认是否使用已经缓存的文件，具体可以参考<a href=\"https://icantunderstand.cn/web-store\">缓存那些事</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVQoz22SzY6bMBSF8/zddNF1q64rtX2ESO2imheYdFPRhAwJJJAQfgwG+6uOgUwqjSXLNvfy3XOuvfIewGPtjnEscQ68t1h7wLkG5zxlWdL3HSHTt3i/A/Z4H4epPexwLmc1AR1dF2FMxvF4pq5PdN0T45hQ14YoiqjrKgCdE+wzxnwiit7z/PyOOP4AfMT7NSup8xOVYfAcj0eapp3PjtPpxO1243VcgSe8/8XttqYs1zTND+An8HtSOAFluw+ApmlmNY7z+UxVVfR9jzEtbWvIsoKyrJl1zK2Y1pVg3rsZaEmS5K5IMQHrusYYQ57nYf/ysqco8iBgGOyCDPmrBy/BooBStAyBlDgMA1mWhXMcx2GvAloVk5tZ4Y4k+UaSfMeYiDg+UFWvPZNVAbuu43A40LZtgFwul9AeQfVN8QB07i/7/RfS9CvW/iFJ0vuNqvLSAv2w2WyC5fv1XK8hplVFxnH837K1Y6isigswTdOgQla32214k+q1zuqvYppFUUzAx0sZxyEokM3HoRwVkUX1Vz8KqlVz6V+wLNDjW3yELHNRq+ek9a2x5P4Dh85Sl/bdd+YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"h5缓存机制\"\n        title=\"h5缓存机制\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/63868/cache.png 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/0b533/cache.png 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/0f529/cache.png 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Application Cache</h2>\n<p>Application Cache主要是做应用的离线化配置，它跟h5通过缓存头实现的缓存机制相对独立。通过在html中引入manifest属性开启Application Cache.</p>\n<pre><code>&#x3C;html manifest=\"example.appcache\">\n...\n&#x3C;/html>\n\nCACHE MANIFEST\n# Version 1\n// CACHE下声明的文件将在首次加载后进行缓存\nCACHE:\nscript/scriptfilename1.js\ncss/cssfilename.css\nimages/imagename1.png\nimages/imagename2.jpg\nimages/imagename3.png\n// FALLBACK定义离线状态下的规则 \nFALLBACK:\n// images下的资源都将使用images/imagename4.png替代\nimages/ images/imagename4.png\n// 缓存白名单 应用对Network下的请求都会绕过缓存请求服务器\nNETWORK:\nimages/imagename5.png\n\n// 端侧在初始化Webview的时候开启Application Cache \nWebSettings webSettings = webView.getSettings();\n// 允许执行JS\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n</code></pre>\n<p>在使用Application Cache需要注意以下几点:</p>\n<ul>\n<li>有同源限制，缓存大小限制(5MB)</li>\n<li>需要更新缓存文件的时候，需要同步更新manifest文件</li>\n<li>manifest声明中的文件无法下载时会导致无法更新到最新的缓存，浏览器将使用旧的缓存文件(推荐一些几乎不更新的文件使用Application Cache)</li>\n<li>可以在业务代码中通过window.applicationCache相关api实现缓存资源的手动触发更新</li>\n</ul>\n<h2>浏览器存储</h2>\n<p>通过浏览器提供的api实现数据的存储和缓存功能。</p>\n<h3>Dom Storage</h3>\n<p>Dom Storage指的是LocalStorage和SessionStorage。LocalStorage是持久存储，SessionStorage是会话存储。他们都通过key-value的方式来对简单的数据进行存储。Dom Storage存储空间为5MB有同源限制。</p>\n<pre><code>WebSettings webSettings = webView.getSettings();\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n// Webview初始化开启Dom Storage\nwebSettings.setDomStorageEnabled(true);\n\n// javascript\n// 设置键值\nwindow.localStorage.setItem('name', 'haha')\n// 读取键值\nwindow.localStorage.getItem('name')  // 返回\"haha\"\n</code></pre>\n<h3>IndexedDB</h3>\n<p>IndexedDB可以通过数据库的方式对数据进行存储，它的存储空间相对于Dom Storage大很多。通常可以基于封装IndexedDB的库来实现数据的存储。IndexedDB的使用方式可以参考<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<h2>参考</h2>\n<p><a href=\"https://webplatform.github.io/docs/apis/appcache/ApplicationCache/\">ApplicationCache</a><br>\n<a href=\"https://www.html5rocks.com/zh/tutorials/appcache/beginner/\">应用缓存初级使用指南</a><br>\n<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null},"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null},{"id":"c299ca54-40f9-5fa4-8614-d9513c8b13d1","html":"<p>Android中可以使用异步消息处理机制来完成主线程和子线程任务调度，本文主要介绍使用Handler实现消息通信的过程。</p>\n<h2>Handler</h2>\n<h3>基本概念</h3>\n<p>使用Handler实现异步消息需要以下的组件:</p>\n<ul>\n<li>Message\n发送消息传递的数据对象</li>\n<li>Handler\n负责消息的传递和处理</li>\n<li>MessageQueue\n负责保存当前线程中的发送的Message，每个线程只能有一个MessageQueue</li>\n<li>Looper\n负责管理线程中的MessageQueue，将MessageQueue中的Message不停的取出给Handler处理。每个线程只有一个Looper</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 814px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxzQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAQABBQJp/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQESExQf/aAAgBAQABPyG2301CwGUf/9oADAMBAAIAAwAAABAjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExcYGRsf/aAAgBAQABPxAoWhxEaUveYagcl+RXQfIANVP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Handler实现结构\"\n        title=\"Handler实现结构\"\n        src=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n        srcset=\"/blog/static/86b2a15f43db42534948074b87746b3e/0479a/Handler.jpg 250w,\n/blog/static/86b2a15f43db42534948074b87746b3e/41099/Handler.jpg 500w,\n/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg 814w\"\n        sizes=\"(max-width: 814px) 100vw, 814px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>例子实现</h3>\n<p>下面的例子中布局文件中定义了一个TextView和Button，在Button点击的时候通过发送Message来实现TextView内容的更新。 使用Handler处理异步消息主要有如下的步骤:</p>\n<ul>\n<li>\n<p>初始化Looper(Looper.prepare)和MessageQueue(Looper.loop)</p>\n</li>\n<li>\n<p>根据当前的Looper创建Handler并重写handleMessage方法</p>\n</li>\n<li>\n<p>在子线程中通过Handler发送Message传递数据</p>\n</li>\n<li>\n<p>主线程处理数据(UI显示)</p>\n</li>\n<li>\n<p>主线程退出后清除Handler的任务/关闭Looper</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n  // 定义更新按钮文旦的标识\n  public static  final  int UPDATE_TEXT = 1;\n  private TextView textView;\n  private Handler handler;\n  private Runnable runnable;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    textView = (TextView) findViewById(R.id.textView);\n    Button button = (Button) findViewById(R.id.button);\n    if(Looper.myLooper() == null) {\n      // 初始化当前线程的Looper 通过判断保证当前线程只有一个Looper\n      Looper.prepare();\n      // 开始线程中的MessageQueue\n      Looper.loop();\n    }\n    // 创建Handler  创建Handler必须执行Looper\n    handler = new Handler(Looper.myLooper()) {\n      @Override\n      public void handleMessage(@NonNull Message msg) {\n        // 重写消息处理方法\n        switch (msg.what) {\n          case UPDATE_TEXT:\n            // 获取传递的数据\n            String content = msg.getData().getString(\"content\");\n            textView.setText(content);\n            break;\n        }\n        super.handleMessage(msg);\n      }\n    };\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n          // 在子线程中通过Handler发送Message\n          runnable = new Runnable() {\n            @Override\n            public void run() {\n              // 这里可以做一些耗时操作\n              Message message = new Message();\n              Bundle bundle = new Bundle();\n              bundle.putString(\"content\", \"you click me!!!\");\n              message.setData(bundle);\n              message.what = UPDATE_TEXT;\n              handler.sendMessage(message);\n            }\n          };\n          runnable.run();\n        }\n    });\n  }\n  @Override\n  protected void onDestroy() {\n    // 可以在这里清除runnable/终止消息的处理\n    handler.removeCallbacks(runnable);\n    Looper.myLooper().quit();\n    super.onDestroy();\n  }\n}\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/blog/54c35e9eba49d7862bdca4f06c052160/showHandler.gif\" alt=\"使用Handler\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null},"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null},{"id":"840245e1-c990-5965-b1ee-b408fa76777c","html":"<p>Hybrid混合开发相对于单一的客户端开发有着开发周期短，迭代快的优势，但是Hybrid模式开发的页面存在着一定的缺陷，比如性能问题、缺乏客户端能力等。通过JSBridge这个桥梁可以实现客户端能力的打通，赋予了Hybrid应用更强的端能力。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 838px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcElEQVQ4y42U2Y7CMAxF+/8/SJ8qSksXukJXKNSjY8lVBmZEI0W249wb23HiDcMgZVlKVVVSFIX0fS+Px0Pn7XbT9bqudaKz3/xd121Y5DiO4qHgZCABLssi9/tdzuezbmY2TbPZz+dT/WDXdVUsNj7PNjAgAggxG06nk8zzLFEUSdu2moFLiG7DglFCiN4JIcqyTNI0VcnkAPxuhLsJAcRxLFZj6nm5XD5S/kpIagDQIbTakS4S+/V6bQT/ElJcZJ7neltERJqskT4AOgD/NE2qUw4G2A9CUiMy3/cVFIahBEGgAFKjRYjscDhs0aIzOByOj5St9wBatNfrVcuANNuyIf2vNWTRLuV4PCoZkZI+NSVaMqEMu2/Z6kZE2OyB2Ozdt8yi2zbUyYjQqes7ob2UX4TUjIF0Ce2FJEmipDQ2oL9eCmsbIRdBqwC2t2wp2+fAQdguoX0mdIhhPYAQ2qTH7DfhENoFEBP93e9i4foBsVCB7aDDCl4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"JS\"\n        title=\"JS\"\n        src=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n        srcset=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/63868/JSBridge.png 250w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/0b533/JSBridge.png 500w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png 838w\"\n        sizes=\"(max-width: 838px) 100vw, 838px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nJSBridge作为客户端和H5的通信的桥梁，可以承接如下的能力:</p>\n<ul>\n<li>鉴权能力 JSBridge调用能力鉴权，白名单，黑名单等</li>\n<li>胶水能力 JSBridge兼容代码，做版本控制等调用透明</li>\n<li>测试能力 提供测试方法，方便测试</li>\n<li>Scope(配置)能力 能基于配置产出精简版、目标版本JSBridge</li>\n</ul>\n<p>下面以Android代码为例，介绍JSBridge的实现方式。</p>\n<h2>Js调用Native</h2>\n<p>Js调用Native通常有如下的方案:</p>\n<ul>\n<li>拦截请求(shouldOverrideUrlLoading/shouldInterceptRequest)</li>\n<li>拦截特定方法(prompt/alert/confirm)</li>\n<li>客户端注入JSBridge(addJavascriptInterface)</li>\n</ul>\n<h3>拦截请求</h3>\n<p>在安卓初始化Wevview的时候可以设定WebViewClient，WebViewClient主要功能是处理Webview加载时的通知和请求事件等。通过重写WebViewClient的shouldOverrideUrlLoading/shouldInterceptRequest就可以实现拦截h5的请求从而实现端能力调用。\n实现思路如下:</p>\n<ul>\n<li>定义JSBridge实现Jsb方法</li>\n<li>定义JSBManager管理Jsb的调用</li>\n<li>实现拦截方法的重写</li>\n<li>H5侧调用</li>\n</ul>\n<h4>定义JSBridge方法类</h4>\n<pre><code>// 以下例子均省略import语句 \npublic class JSBridge {\n  // 需要考虑callback和入参一致性问题\n  public void showToast(JSONObject jsonObject) {\n      try {\n          Toast.makeText(MainActivity.context, jsonObject.getString(\"content\"), Toast.LENGTH_LONG).show();\n      } catch(Exception e) {\n      }\n  }\n}\n</code></pre>\n<h4>定义JSBManager管理Jsb的调用</h4>\n<pre><code>public class JsbManager {\n  // 通过HashMap获取JSBridge定义的所有方法\n  public static Map&#x3C;String, Method> methodMap = new HashMap&#x3C;>();\n  public void init() {\n      Method[] methods = JSBridge.class.getDeclaredMethods();\n      for(Method method : methods) {\n          methodMap.put(method.getName(), method);\n      }\n  }\n}\n</code></pre>\n<h4>实现拦截方法的重写</h4>\n<p>以下以shouldOverrideUrlLoading方法的重写为例子。在例子中定义的通信协议是myjsb://method?params。通过在拦截方法中对请求进行解析就可以实现调用对应客户端method的逻辑。</p>\n<pre><code>public class CustomWebViewClient extends WebViewClient {\n    private JsbManager jsbManager = new JsbManager();\n    private JSBridge jsBridge = new JSBridge();\n    public void initJsb() {\n        // 初始jsbManager和jsBridge实例\n        jsbManager.init();\n        jsBridge = new JSBridge();\n    }\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n        Uri uri = request.getUrl();\n        String scheme = uri.getScheme();\n        if(scheme.equals(new String(\"myjsb\"))) {\n            // 获取方法名 入参\n            String methodName = uri.getAuthority();\n            String query = uri.getQuery();\n            try {\n                JSONObject jsonObject = new JSONObject(query);\n                Method method = jsbManager.methodMap.get(methodName);\n                // 调用对应的客户端逻辑\n                method.invoke(jsBridge,jsonObject);\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n}\n// 主活动代码逻辑\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建WebViewClient\n        CustomWebViewClient webViewClient = new CustomWebViewClient();\n        // 调用JSBridge初始逻辑\n        webViewClient.initJsb();\n        WebView webView = (WebView) findViewById(R.id.webView);\n        // 设置WebViewClient处理webviewt通知，请求等\n        webView.setWebViewClient(webViewClient);\n        // 开启调试功能\n        webView.setWebContentsDebuggingEnabled(true);\n        WebSettings webSettings = webView.getSettings();\n        // 允许执行JS\n        webSettings.setJavaScriptEnabled(true);\n        // 这里加载项目本地的html文件方便调试\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n}\n</code></pre>\n<h4>H5侧调用</h4>\n<pre><code>    &#x3C;body>\n        &#x3C;div>this page test JSB&#x3C;/div>\n        &#x3C;script>\n          // 通过创建iframe发起JSBridge调用\n          function iframeCall(url) {\n            let iframe = document.createElement('iframe')\n            iframe.src = url\n            iframe.style.display = 'none'\n            document.documentElement.appendChild(iframe)\n            setTimeout(() => { document.documentElement.removeChild(iframe) })\n          }\n          function callJsb(method, params) {\n            let url = `myjsb://`\n            if(!method) {\n              return\n            }\n            url += `${method}`\n            if(!!params) {\n              url += `?${encodeURIComponent(JSON.stringify(params))}`\n            }\n            iframeCall(url)\n          }\n          callJsb('showToast', { content: 'xiaohong' })\n        &#x3C;/script>\n    &#x3C;/body>\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 196.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAnCAYAAAAPZ2gOAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+1US09TQRQeGwh90Pb29kFppQ9BVAghGjfqQorFaNyZCCt3CBSoMa6IhkRiDCYmBqMxRU34ObSEFlalYCIkbuTRCra29N62n5nR2/SF1IorPMmXc+Y7c89jZs4lOl4DTq+AoUmL5pNGaHRyaHkldAYleKOS+ZpbeLQ4TeAMCuiMyiLwRhXbr9UrwPFqEDN/Gm36PrTqXWhvuoZzVjfOWtxw6lywq3tg1/TAoXHBoXUxuxA2dQ/aDL3otLlxpqkPdlM3SLuqH/dsn3DXGoK3O8zwuPcj7nBB9BE/bpIAblQA5am/nwth4moEE5c+w+2YArmoHsQDkoOH7GCUfIW3fpfpMbKLcdkuxk/8QqFdwNF9w2QH94kIt3wG5Hz9MJ5bgVeXU3h5QcSHWxk84gSMkTS8VWKcJPGQANfr34JcMQ/hRTvwrCOO6c4UpjtSeNqaxJQjiSlndXjijGP6FHDb+gZkaNADiMDulzTi21nEd7JIRLP4Hqse37YFQABez/hARsdGQSVLo9YoOWSYfvd+FsTj8bCFIIjIZXM1QRR+FjPrKwgoiiJyuVxNFdJvWcDZ/wGPacBS5B/vb5JVDJjJZA6ehEMqrxgwlUpBEASk02kGuml/fz8frOoKR0ZGsLm5iXA4jOXlZaytrWF1dRXr6+uMq7llqSrp7LLZ7N+1LJGlZ/fHLf+zWz7mo1eoDzrXwuSHXkrpDR80OZKuusJq7aqejfTYY7EYtra2GKLRKJLJZFkHZaNHhc4t/UEUIpFIYGNjA0tLSwyRSAR7e3tl+2hiKj6fD8Tr9eKoZG5uDmRgYID9DBYWFhAMBrG4uAi/389silAoxHyBQIDZEjc/P5//huqVlRVMTk6CKJVKEEKKwHFc0Voul0Or1RZxFosFKpWqiKurqwNpbGwsIx0ORxFnMplgs9mYLZPJmO7q6oLZbC5LTHQ6HdRqdR40AXVIa41GA4VCwThqS1xDQwNodxJHwTozGAwwGo1FoBUdxlXaQ2MRvV6PowSx2+3geZ5Fp5Ac0rqUK/UX8rTKH4LefgGruMzUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"拦截请求实现调用\"\n        title=\"拦截请求实现调用\"\n        src=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n        srcset=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/63868/overrideUrlCall.png 250w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/0b533/overrideUrlCall.png 500w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>使用iframe发送消息的方式会存在消息丢失，参数限制等问题，可以通过消息队列和拦截shouldInterceptRequest方法来实现。</p>\n<h3>拦截特定方法</h3>\n<p>在初始化WebView的时候可以同步设置WebChromeClient，WebChromeClient主要是辅助WebView处理Js对话框，标题等操作，通过拦截WebChromeClient相应的方法同样可以实现调用端能力。</p>\n<h4>实现WebChromeClient</h4>\n<pre><code>public class CustomWebChromeClient extends WebChromeClient {\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 此处举例为主 直接弹端toast\n        // 实现上跟拦截url一致\n        Log.d(\"mesage\", message.startsWith(\"myjsb\")+ \"\");\n        if(message.startsWith(\"myjsb\")) {\n            Toast.makeText(MainActivity.context, \"PropmtCall\", Toast.LENGTH_LONG).show();\n            // 此时js调起了 需要JsPromptResult.confirm(result)\n            return true;\n        } else {\n            return super.onJsPrompt(view, url, message, defaultValue, result);\n        }\n    }\n}\n// 在初始化WebView的时候设置WebChromeClient\nCustomWebChromeClient webChromeClient = new CustomWebChromeClient();\nwebView.setWebChromeClient(webChromeClient);\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.prompt('myjsb://')\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 199.60000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+2U309bVRzAD9BCgdv23tt7ewsKq6nIBnWLcWYJ0RfjlLin6UzmHjQLyWYcbcfMKsZkPvrj0YRAoegMITz45xAShiYGWGIMIUQEWlrbjzmnu3jpHIPFx57kk/P9fs/3+znn9qGipydOxLSJOd040S5sK4ptOVgRBzviYJlRumLPKWSsah5kb9SOKceLiT6EbnYSMv3YsTCmrdEZ8qOFW9GtNoxogLDVSnevTlePrmLDDih0+9F5JIAWaqUz7Cesa4g+4xIX7HFes8d486XPuTj4BW+dGedccIyBtgzJ9tsMtKUVycBtBgMZhayf8acZev4ub788zjsDX5FwhhCva99yvf0PPgr+Sjr+kNHeh2STv3PV9wvviQdcESsHvO9B5pfFA64bv3E3uc6XyR1etUYQ77ZPcS8E48ZfZLVd7nXvkRK7jDXtcaelcDS+Ahmxx6fiT+4IuKDdQlwUOb4+Bd+d3eOb0/t8P7RPShS5KQp8cmx2yAg43zaKuPFGjoVrMPvBLvevFvnhSpGfrp2MHz/c4eeP4dK5UcT9uVlqqwxUH8XVE1JWU2OfZRD5fE1YKpWpVDg5f1cp7deE6XQGMTtbE5bLZarV6jMhZ+XKZOqEz7IawoawIWwIG8JjCt1/YW9cT/3ZU4Xe/Umv8kqf+snuQKVSOUDW3Lhe+kSh95Pk4NbWFqurq6ytral9fX2d7e3to184MzOjkmKxqA5KpZLaZb6xscHKygqLi4ssLS2xvLzM5ubmQY9LoVBQjlQqhVhYWOD/WtlsFjEyMsLc3BzT09Pk83lyuRyTk5MqlsifROZTU1MqdusTExOHZubn5xkeHkYIIahH07RDeTAYxOfzHaolEonH5lRPR0cHLS0tKmlublYyx3FoamrC7/erPRaLYZqmimWfpL+/X/XKGZlLh7xYyEZd1xWGYRAOh9WBjN2aHAyFQgc1iXyI7PXWpEtYto1t21iWpbDr8uPW3FiYeu2WSCRyJLL5v2IX5TANxOmz54mf6sWy/r3NHfLiFdWfSV6Ix+kbfIV/AHs5ocTNraY7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"重写Prompt方法调用\"\n        title=\"重写Prompt方法调用\"\n        src=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n        srcset=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/63868/overridePrompt.png 250w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/0b533/overridePrompt.png 500w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>客户端注入JSBridge</h3>\n<p>通过<a href=\"https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String)\">addJavascriptInterface</a>可以在初始化WebView的时候将客户端的调用逻辑暴露给H5。</p>\n<h4>实现JSInterface</h4>\n<pre><code>    public class JsInterface {\n        private Context context;\n        public JsInterface(Context context) {\n            this.context = context;\n        }\n        // JsInterface需要用@JavascriptInterface注解才可以被调用\n        @JavascriptInterface\n        public void showToast(String content) {\n            Toast.makeText(this.context, content, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    // 在初始WebView的时候注入interface\n    webView.addJavascriptInterface(new JsInterface(context), \"myjsb\");\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.myjsb.showToast(\"Interface\")  \n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 200.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADaklEQVRIx+2Vy09TQRTGB+jDK9D29j76UEyJIo9gfGCqJmowrtwQaMHIxoWJ8rJaCUaif4EL3oSFqAs3rliZCBFiXLKHiCECoRASiLzEtpT29jMz9dbyqoXgSif5Zc75euabczt3cslZ52UIvABZssJqOQJJlCGJFoYoUGTIkg1221EWx7Tf0DpZis1Wiw3EaMqEwawDL3Gw2HlkGjXIMupgEHTgZT2Mog6SPQs5uQJMkp7Bb5oPsfoskxYGEwdi54vhtD1AidyAi8fuo7TAi2uFXpRIDcjX16DocC0KuRoUHKpBIVcbp4irRYG+Bqf5elwv9uLq8Uacc1SBnDDcwF3Rh9vZX1F/bBqeXB+enJnDHWECZeQzXOTLrpSTMdzSj6Pp1AyeFH9DleMtyCmDC03aEJpNfjRxP/BM8sOr+YEHxI9GTQCPMnanMSMAb1oA9eQ7HpII3BnvQAp0LjRnRtB+IYTnRSF0X9nAUz6EeySIOhJEbQrUkQA8BKgg70Eu5bnwuiKMF2VBvCwPorcsiN7yIF651vGqIpgSvRUBvKkEHpe+B6m6WYnYUABE90mEOXz8NAhS6Y4ZKpEoFCWKqII9EwkrzOPDB2pY+cuQmkX3RyQS63BwMMFQ/XE/47/hP2uoKApjp/dM3XBPhsnGnzrfZri6uspYXFzE0tISVlZWWL6wsMC6TrXDvr4+ELfbjdnZWUxPT2NkZASTk5Ms9/l8GB8fjxenYtjf33+wjzw0NPQXD+X/TTlYw8Q52SGpcVLDVE51a82eOqTF6uukxls3/GOHanEoFML8/DympqbYDZqbm8Pa2lryjxS9elTc2NjYRDgcht/vx8zMDMbGxjA6OoqJiQksLy9vq11fX2eGAwMDINXV1TioMTw8DOJ0OtHd3Y2Ojg50dnayuaWlJZ53dXWhra2NaTSmGoXmra2tLG5vb0dPTw88Hg8Ix3EghGyC5/ltmiAIm3Kr1QqDwbCtjhiNRmg0mjharRYWiwV6vZ7l6enpbKHNZmOxTqdDWloacnJyWB2N6Rpay5qjO9OOEsnOzo7HZrMZdFOq0VjVaE43UjVVJ4IgQpIkiKIYZ2u+k0bzRI3FkgRilUWYTEaYzQL7n3aDLkqWsw55E0je+VLknczHEbt9x85UEo22IssyHA4HjucX4yfjfpxnxqZHBAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"interface调用\"\n        title=\"interface调用\"\n        src=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n        srcset=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/63868/callInterface.png 250w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/0b533/callInterface.png 500w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>Native调用Js</h2>\n<p>Nativa调用Js通常有如下的方案:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></li>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></li>\n</ul>\n<p>以下例子在H5中都定义了全局函数供Native调用</p>\n<pre><code>    function testNativeCall() {\n      console.log(\"nativeCallJs\")\n      return 'nativeCallJs'\n    }\n</code></pre>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></h3>\n<p>可以通过webView.loadUrl(\"javascript: testNativeCall()\")发起调用(需要等待Js执行完成)。loadUrl的方式会刷新页面且无法获取js的回调。</p>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></h3>\n<pre><code>webView.evaluateJavascript(\"javascript: testNativeCall()\", new ValueCallback&#x3C;String>() {\n    @Override\n    public void onReceiveValue(String value) {\n        return;\n    }\n});\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADPUlEQVRIx+1US08TURi9hSK0DG3n1SkEgRYlKAoGVoqPhZqwAF0pJi6MC9EIGoGFBlpRsRF5FAqJEH6AUXGlfwVIWFgKBASBYELaTqFwzL3N1PIqj7AwkZucfI97vnPPdOaW5OblQ+BF2JQs2GxZkCQrZFmBJFoZREFGVmY2A821vgbKtcoKREGC3e4AsQgcMiypkBQzRNkMznQMnCkNFskAQTayaMvmkXmcZzkvG2Ng+6KR8TlzGkxmDqSAv4GrOe9RrrSg4pQbVefaUFXchjLuJYpTnChJdbGo5fEoSmrGlew3uFn6DpVFnTiTUwFSzr1GLf8b9wx+1Np+4rF1Bs8Lf+Gu3o/bxIfqBLhFfuA+N4mG/Bm8OLmMi0oDyHWDBy1mwKkE4FJCeJsfwjNdEPW6EBr1KhqTE0Cvop6EUEeW0UCAS8YmkMvEg1YFaC8Jwn0ijPbiMJ6SEGpICA/3jADqCHBe3wRSc82Db0+Ajw8C+PxIxacaFUO1Kr7WqRiqi8ZEoJwvtUF8rwfulDeDfBjoRXRFcPAVnX3V6gLxeqOCK+EI1iLrB8JqOCrocrpAenujgpFIBOvr6wcCnWWCrm0E97uOBP9rwdXV1W2/MW1op8O2CPb19e3qYF8OOzs7EQwGsbi4iLm5ORaXlpawsLDAsG+HHR0dbHB8fBzDw8OYmprC9PQ0/H4/Jicn/4FHPvSXcnRTDl9w84vYCfGcXR3uxWk8d88ON39Ka2trsd6eHWrkcDiM+fl5+Hy+GCYmJtjVXFlZ2Vmwp6eHFaqqstMpKCEQCGB2dhajo6MMIyMjGBsbY/ed3n3K0fj0cLqcTifI4OAgDmu53W6Q6upqDAwMoLu7G16vl8Wuri7Qn4LWNNLa4/HEehT0T0WboU/Z39+PyspKEEIINsNisWyozWYzDAbDhl5hYeGWueTkZJD09HSW6PV6JCUlwWg0wmq1spz2dDodZFmGIAgsT0lJYXsOhwMZGRkxHtXgOA6EEnmej4G6o0Stpvu0NplMiOdSI9R5/CzdJ5IkMweSJMWwXb1bT8uJKFBXPERRTAhKTrRHn4xqkdOlF2DPy91wmkaKx3a9v3sSHHY7Cs6W4Q880qCTlgwo4gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"evaluate调用js\"\n        title=\"evaluate调用js\"\n        src=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n        srcset=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/63868/evaluateJS.png 250w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/0b533/evaluateJS.png 500w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a>\n<a href=\"https://juejin.cn/post/6844903840588759048\">跨端技能必备之JSBridge</a>\n<a href=\"https://juejin.cn/post/6844903856418062350\">从零开始写一个 JSBridge</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null},"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null},{"id":"a13a2570-fa88-5f20-a625-6102f0ddd286","html":"<p>在前端页面开发中，通常会将数据层和UI层进行隔离，这样能更好的做到职责的分离。在安卓开发中ViewModel可以实现UI的数据管理能力，结合LiveData的观察通知能力可以做到页面与数据视图的更新绑定，更有效的组织页面逻辑。</p>\n<h2>ViewModel</h2>\n<p>View能有效的做到视图和数据的分离，数据共享能力。\n<img src=\"./AndroidViewModel/viewmodel.png\" alt=\"ViewModel作用\"></p>\n<h3>ViewModel生命周期</h3>\n<p>ViewModel对象存在的时间范围是获取ViewModel时传递给ViewModelProvider的生命周期。ViewModel将一直留在内存中，直到限定其存在时间范围的Lifecycle永久消失：对于Activity，是在Activity完成时；而对于 Fragment，是在 Fragment 分离时。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkklEQVQ4y6WU208TQRTG+a99Uh/UGH3VaIgvPvkEGMGAPICXekVDsS3UloJZe9n7dtu9X2Z+ZhdbDdZC4yYnZ2Zy5ttz+b5ZklLmUkpx3sTECymyXIg8F6UXM2J/WREcLxUL/vObYEgpkylglmXSNE05GAxK3x8M5Nh1ZK3ry+WXinz86kQ+evVDtvVIQi6jNJJxFslc5MX9EkMI8RuwKGY8HmPbNqPRCMuyiUOfphpy53mH26tVbm8c0xhEuJHGoXZAU//KKBpOk5wCTjKeVY6XCHYbGk8rh2wf9NDHOXagcjQPsDhJ01SqqoqiKPT7/dLrukaYZHTtgO+qg2J6xBmY/iUAix5aloWmaZimia7r2I6DzGIyt8ew3yZ1FMhjDF+jeRHgv0qWgU3QfEF/b41RbQM8DSMwOFKrNLU5gJNeTk2Isz+MFKLXdxls3sTfuQFGHSOyaZk12lZjAUApygx9R+Pd+iN2Vh7yZu0BTu8Yw9fZa1f4cvIeN3QuByjEWQdOrIRr6wpXV5pcWTlhv5cyDAZsfVjn5f4249hdjDa2n/HsS48nO3VWP/2g56Q4oUbLrM8vuZhyEAQU5HZdF8/ziMKAIBE0ui4fDxWqpxZeDNaENvOGkiSJHA6HdLtd2u12SZ+h65LGIalnEboGiWeCyDB89WLa/Hot/hQ85S4ZE3QqnH7awP22C6GN7uscadVFpXe2laMe4cdltN37jCv3QKtjRQ4tvUbbaODFo9kZFo9DlmVF6aWlSUImQA4VzO1bKBs3MDavk7W2UH2davc9tf4eTmD+W8vFIIredTqdUnq+75PneRFeBE+5+fn0LVv7a2ztr9LS6otJ7y8pznlgL1DKbGP2+WKAk6mfX88C/AlUyUhxrEpdmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ViewModel生命周期\"\n        title=\"ViewModel生命周期\"\n        src=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n        srcset=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/63868/cycle.png 250w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/0b533/cycle.png 500w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>LiveData</h2>\n<p>LiveData是一种可观察的数据存储类，它具有生命周期感知能力，可以遵循其他应用组件(如Activity、Fragment、Service)的生命周期进行数据的更新通知。使用LiveData有通常有以下的三个步骤:</p>\n<ul>\n<li>在ViewModel中创建LiveData实例保存数据</li>\n<li>创建可以定义OnChange()方法的<a href=\"https://developer.android.com/reference/androidx/lifecycle/Observer?hl=zh-cn\">Observer</a>对象</li>\n<li>在界面控制器中使用<a href=\"https://developer.android.com/reference/androidx/lifecycle/LiveData?hl=zh-cn#observe(android.arch.lifecycle.LifecycleOwner,%0Aandroid.arch.lifecycle.Observer%3CT%3E)\">observe()</a>方法将创建的Observer对象附加到LiveData对象</li>\n</ul>\n<h3>添加依赖</h3>\n<p>使用LiveData需要引入ViewModel</p>\n<pre><code>dependencies {\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.lifecycle:lifecycle-viewmodel:2.3.1\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>在ViewModel中创建LiveData对象</h3>\n<pre><code>public class MyViewModel extends ViewModel {\n    private MutableLiveData&#x3C;String> title;\n    public MutableLiveData&#x3C;String> getTitle() {\n        if (title == null) {\n            // 网络请求、读取文件etc\n            title = new MutableLiveData&#x3C;String>(\"哈哈\");\n        }\n        return title;\n    }\n} \n</code></pre>\n<h3>在界面中使用LiveData数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyViewModel myViewModel;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        TextView textView = (TextView) findViewById(R.id.textView);\n        // 获取ViewModel\n        myViewModel = new ViewModelProvider(this).get(MyViewModel.class);\n        // 创建Observer\n        final Observer&#x3C;String> titleObserver = new Observer&#x3C;String>() {\n            @Override\n            public void onChanged(String s) {\n                textView.setText(s);\n            }\n        };\n        myViewModel.getTitle().observe(this, titleObserver);\n        Button button = (Button) findViewById(R.id.button);\n        // 定义button的点击事件 更改ViewModel的数据\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                myViewModel.getTitle().setValue(\"我变了\");\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/d9632f4d22fc8dd9b600386ab2ade7dc/showLiveData.gif\" alt=\"使用LiveData\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-页面数据管理(ViewModel&LiveData)","date":"2021-07-02","tags":"跨端技术","path":"/android-view-model","top":null,"summary":null},"title":"一起学Android-页面数据管理(ViewModel&LiveData)","date":"2021-07-02","tags":"跨端技术","path":"/android-view-model","top":null,"summary":null},{"id":"94b4b3b7-46cb-5f27-b003-34911da0a665","html":"<p>应用程序在运行时需要占用系统的存储空间来实现加载代码运行、存储运行时数据等功能。理解内存空间的管理策略能让我们更好的理解代码在系统中运行的机制。本文从代码运行时存储开始逐步介绍V8的垃圾回收机制。</p>\n<h2>运行时存储</h2>\n<h3>堆存储</h3>\n<ul>\n<li>主要存储全局变量,引用类型</li>\n<li>动态分配，可分配动态空间，有垃圾回收机制参与空间管理</li>\n<li>总存储空间大(通常分配给应用的空间有限制)，查找效率低</li>\n<li>堆空间被应用的线程间共享</li>\n</ul>\n<h3>栈存储</h3>\n<ul>\n<li>主要存储局部变量(基础数据类型)、指针、函数执行片段(function frames)</li>\n<li>由系统分配，通常存储限定大小的数据，栈片段弹出后空间释放</li>\n<li>栈结构后进先出(LIFO),访问效率高</li>\n<li>多线程应用每个线程都有一个栈存储空间</li>\n</ul>\n<h2>内存管理</h2>\n<p>通常说的内存管理都是指对堆内存空间的管理，以下介绍V8中的内存管理方式。<br>\n在V8中运行的程序会被分配如下的内存空间(Resident Set)\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACd0lEQVQoz23LX0wSARwH8HvoqYde22o91kubbj20zH8Tpw+ZpjMn1ioLzywljAORSRqKcIIgJ3hcd7RQ1OafkNWdoilq2siMXeLBwTEOway57EXsvaHV1tb22Xe/73f7AYEoH5lf5qa93ExaxLN4dHAzXnbOS8+s0qSPpj7Q076N2VXm0KZnNbiwshmNAdEQS7UZJI80cjncItV2NmpkkE4mg6HmLnejqRPSK4wPlYYmlRYSVdvzq7ECoS2rHBuV2mMhBoiHwg51X5bGXGLGi7qRcjks6LGUIHie1mhvtLZo2qQLZTJPlWysJrccO37DdlJEHKtEUYkjHg4CXDgyK9XratRIQw8CwqgINoM6MwjrhWoX2Ce+7RTVD4gluESMP7jzWnhrqvrmq+KrEy+kozzLACE2wnYY/A3tAah747EmAHUzrYZgh4GGoI12pVuud0mNnnaUUo0Mgl3D9RonqEUqlHNyPceyQJDldp6oEuC9xKOmhLhpq+7udotyF1d8s2bsolk/iJzvaMYemr2D6KyZpy0Xztjzz/eeO/G2tjLK8ennpLqLF0u2FMotRSvf3JxQdX61Pd02F3+xlG2j15PIlR1rVbyv11F02XmtcKSiiBBcnL9fy0ViQIhh9wkshVn3bWkpzJrC0RSOHjxHDwafHTiwFDHw047u9RuHLp0dFWROlmbjmafe1wljXAxYD/PU1DLpWiJdR/kb5V6hKB9F+kj3O9K19GbSO0yMO/ExJzE+hL2cGCY/hXnAE4gLetfzej7m6/+RA6+VWfyl/f5ceC29GNYFJvpIgYkuNPmpzzzg55OLTPz/gof+VO9m7K9FhvfzyV+uIZYSosOVRgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"V8内存结构\"\n        title=\"V8内存结构\"\n        src=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n        srcset=\"/blog/static/51d594675e95270d44f2ba31e0459f30/63868/V8.png 250w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/0b533/V8.png 500w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png 960w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>V8堆内存结构</h3>\n<ul>\n<li>(New Space)新生区</li>\n</ul>\n<p>新分配对象或者存活期较短的对象都会存储到新生区</p>\n<ul>\n<li>(Old Space)老生区</li>\n</ul>\n<p>新生区经过垃圾回收会晋升到老生区</p>\n<ul>\n<li>Old pointer space 保存有指向其他对象的对象</li>\n<li>Old data space 存放只包含原始数据对象(无指向其他对象指针)、字符串、封箱的数字以及未封箱的双精度数字数组</li>\n<li>(Large object space)大对象区</li>\n</ul>\n<p>存储超过超过1MB大小的对象，垃圾回收不会处理大对象区。</p>\n<ul>\n<li>(Code-space)代码区</li>\n</ul>\n<p>存储代码，唯一有运行权限的存储空间</p>\n<ul>\n<li>Cell space, property cell space, and map space</li>\n</ul>\n<p>这些空间保存大小一致的对象</p>\n<h3>V8垃圾回收</h3>\n<p>V8的垃圾回收机制只作用于内存空间的新生区和老生区，由于在新生区和老生区存储数据的类型(大小，存活时间)等不同，垃圾回收在新生区和老生区使用不同的策略实现。</p>\n<h3>新生区垃圾回收</h3>\n<p>新生使用Scavenger算法</p>\n<ul>\n<li>新生区内存一分为二,每部分空间称为semispace. 在运行时只有一个semispace处于使用中,使用状态的semispace称为From空间,空闲状态的semispace称为To空间</li>\n<li>在分配对象的时候会先从From空间分配对象，当From空间无法存储没有足够的空间存储新对象的时候触发垃圾回收</li>\n<li>在进行垃圾回收的时候会检查From空间的存活对象将存活对象复制到To空间,完成复制后From空间和To空间会进行角色互换</li>\n</ul>\n<h4>新生区晋升到老生区</h4>\n<p>在新生区的垃圾回收中满足以下两个条件，可以移动到老生区存储。</p>\n<ul>\n<li>当对象从From空间复制到To空间的时候,如果它经历过一次Scavenge回收会把该对象从From空间复制到老生区</li>\n<li>当对象从From空间复制到To空间的时候如果To空间使用超过25%则这个对象直接复制到老生区</li>\n</ul>\n<h3>老生区垃圾回收</h3>\n<p>老生区由于存活占比较大,使用Scavenge算法并不科学。在老生区使用Mark-Sweep-Compact来实现垃圾回收。</p>\n<ul>\n<li>Mark</li>\n</ul>\n<p>只标记存活的对象，如果循环引用但是无法被标也会被清除(解决循环引用问题)</p>\n<ul>\n<li>垃圾回收器会在内部创建一个根列表(全局对象,本地函数的局部变量和参数,当前嵌套调用链上的其他函数的变量和参数),用于从根节点出发去寻找可以被访问的变量</li>\n<li>垃圾回收器从所有根节点出发遍历其可以访问到的子节点标记为活动节点,不能到达的节点为非活动节点</li>\n<li>Sweep 释放非活动节点空间</li>\n<li>Compact 整理内存空间，将存活对象占用的空间移动到一起，减少内存间隙</li>\n</ul>\n<p>由于垃圾回收会暂停应用的执行，V8的垃圾回收机制又通过增量回收(incremental GC)、并行标记(Concurrent marking)、并行清除整理(Concurrent sweeping/compacting)、(懒整理)Lazy sweeping等手段结合优化回收效率。</p>\n<h2>参考</h2>\n<p><a href=\"https://deepu.tech/memory-management-in-programming/\">Demystifying memory management in modern programming languages</a><br>\n<a href=\"https://deepu.tech/memory-management-in-v8/\">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a><br>\n<a href=\"https://juejin.cn/post/6844904016325902344\">一文搞懂V8引擎的垃圾回收</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"聊聊Node的内存管理","date":"2021-07-01","tags":"Node","path":"/node-memory","top":null,"summary":null},"title":"聊聊Node的内存管理","date":"2021-07-01","tags":"Node","path":"/node-memory","top":null,"summary":null},{"id":"faf195c1-4597-5185-a794-521bff83c69b","html":"<p>Android使用的文件系统提供了以下几种保存应用数据的选项:</p>\n<ul>\n<li>应用专属存储空间 存储仅供应用使用的文件 存储在/data/data/package_name目录</li>\n<li>共享存储 存储应用打算与其他应用共享的文件</li>\n<li>偏好设置 以键值对的形式存储私有原始数据</li>\n<li>数据库 将结构化数据存储到专用数据库中</li>\n</ul>\n<p>下面介绍几种常用的存储方式:</p>\n<ol>\n<li>文件存储</li>\n<li>键值存储(SharedPreferences)</li>\n<li>数据库存储(ROOM)</li>\n</ol>\n<h2>文件存储</h2>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileOutput(java.lang.String,%20int)\">openFileOutput(String name, int mode)</a></td>\n<td>用于文件写入，返回FileOutputStream。mode有MODE_PRIVATE/MODE_APPEND,MODE_APPEND模式会在已有文件的尾部追加内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileInput(java.lang.String)\">openFileInput(String name)</a></td>\n<td>用于文件的读取，返回FileInputStream</td>\n</tr>\n</tbody>\n</table>\n<p>以下通过一个输入框存储和读取输入内容的例子来梳理文件存储的实现方式。</p>\n<h3>存储文件</h3>\n<pre><code>// 布局文件 定义一个居中显示的EditText \n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n    &#x3C;EditText\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:width=\"200dp\"\n        android:id=\"@+id/editText\"\n        android:lines=\"2\"\n    />\n&#x3C;/androidx.constraintlayout.widget.ConstraintLayout>\n// 活动文件\npublic class MainActivity extends AppCompatActivity {\n    private EditText editText;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 读取对应id EditText中的输入\n        editText = (EditText) findViewById(R.id.editText);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        String  inputText = editText.getText().toString();\n        // 在活动destroy时候 获取editText的内容写入文件\n        save(inputText);\n    }\n    public void save(String inputText) {\n        FileOutputStream out = null;\n        BufferedWriter writer = null;\n        try {\n          // 写入data文件 返回FileOutputStream\n          out = openFileOutput(\"data\", Context.MODE_PRIVATE);\n          // 转换成字符输入流\n          writer = new BufferedWriter(new OutputStreamWriter(out));\n          // 写入文件\n          writer.write(inputText);\n        } catch(IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if(writer != null) {\n                  // 关闭写入流 \n                  writer.close();\n                }\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}  \n</code></pre>\n<p>在模拟器中启动程序，在输入框中输入内容test save file然后退出应用。通过Android Studio提供的Device File Explorer查下对应app下的目录文件内容已经正常写入。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/acd79/saveData.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAu0lEQVQY032OSU7DQBBFfRx6gDhBgILBdnf1YHcmR8n9r/KQexGJBSyeVE/6VfWbNBdciMRproQ8V69IxIf08JAnfM6MEhgk0Ivw7T3Orx6ZT2ea17d32naLtRZjDMbaOv/mGW00gxPK8UIuB3zMOEmENCFpYpTI6APNy6ZFKYXW+k/WR0o90fUDy+3O9Xav7ddj5XjivFxre4mZZtNuH0v/sWZ2Hx1SFvZDYLfv+XSJPs7Ew4Uvn+lc5Ae/ZIZnhB7+6gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"保存数据\"\n        title=\"保存数据\"\n        src=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/00d43/saveData.png\"\n        srcset=\"/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/63868/saveData.png 250w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/0b533/saveData.png 500w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/00d43/saveData.png 1000w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/aa440/saveData.png 1500w,\n/blog/static/0f1aed81a99a8473dd37fff2af75dcb4/acd79/saveData.png 1543w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>读取文件</h3>\n<p>在存储文件的基础上，在Activiy创建的时候读取存储文件，实现填写恢复功能。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText editText;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        editText = (EditText) findViewById(R.id.editText);\n        // 读取文件内容 在存在内容的情况下直接设置内容\n        String existText = load();\n        editText.setText(existText);\n        if(!TextUtils.isEmpty(existText)) {\n            editText.setText(existText);\n            editText.setSelection(existText.length());\n        }\n    }\n    public String load() {\n        FileInputStream in = null;\n        BufferedReader reader = null;\n        StringBuilder content = new StringBuilder();\n        try {\n            // 获取FileInputStream\n            in = openFileInput(\"data\");\n            // 转换成读取流\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            // 分行读取文件内容写入\n            while((line = reader.readLine()) != null) {\n                content.append(line);\n            }\n        } catch(IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if(reader != null) {\n                try {\n                  reader.close();\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        // 返回读取内容\n        return content.toString();\n    }\n}\n</code></pre>\n<p>再次重启应用，输入框内已经默认填写的内容。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 670px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 170.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAABYlAAAWJQFJUiTwAAACD0lEQVRIx+2Vy2sTURSHL4rNo5ImJn1IrUWFKjYp6kKxgWzFRbsVFzWNBNGosU0ibUwQhEB01YX9s1zYgiQQyCoLIQkkwcwk6WQ+mcmjtdg0DnXVHvg4c8699zdnLvfcEXanGZtjhOmrE9hdFhzjJuzjZhxd7C4TM9dcTF6xMeYy7ef7cyyMOc1ctI/gcNoQbucKdyeD3JsKcGfiOXNmP7dGV7lp9feZszzrPq8e8n48jgALrgDeGyGuTz1APHV+I3g5x4vZHCuXsjwW31kWuyyLHZbEju478a4eL/XznfjJ6A+CM1k+LpZ4OP0G8fr8T6ImmajlFxu2Ou+tEpELEmvnJNYH0Bt/J+q8FTXWBXitG4iQKLLtVfjqbbHta7F1v8kHe4OXQiY0FA1eiTprAhZNm4hP80W+eFqk52XSt2U+e7q4hyftrrO1AI9mNxGVSgXN2opCu902RKvV0jUSiQSiVqvpgYqKUVMURffJZBJRrVY7gm0VVTXG3p6yX2FfUDVWobauV+GZ4KkVPOqsHRQ4EcGD40MLHvfZR71oYIXFYpFsNkuhUCCXy5HP58lkMvolYGgPJUmiVCqh3UKauObL5TKyLNNsNnUajYbuj63wb5vf89qiw/yT4H8/NoM4a71TLWiUPwS1ttIS2s/aKFpbahaPxxGcoKVSKUQ4HCYWixGNRg0TiUT06nw+H78BU6xYVu/6WoMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"保存数据\"\n        title=\"保存数据\"\n        src=\"/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png\"\n        srcset=\"/blog/static/1380de4785f0d92cefda9699479135b6/63868/readData.png 250w,\n/blog/static/1380de4785f0d92cefda9699479135b6/0b533/readData.png 500w,\n/blog/static/1380de4785f0d92cefda9699479135b6/d67fd/readData.png 670w\"\n        sizes=\"(max-width: 670px) 100vw, 670px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>键值存储</h2>\n<h3>SharedPreferences</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/Context#getSharedPreferences(java.lang.String,%20int)\">getSharedPreferences(String name, int mode)</a>)</td>\n<td>获取共享偏好设置文件 mode默认为MODE_PRIVATE</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/app/Activity#getPreferences(int)\">getPreferences()</a></td>\n<td>获取活动的偏好设置文件</td>\n</tr>\n</tbody>\n</table>\n<p>以下通过一个按钮触发存储和读取偏好设置文件来梳理键值存储的实现方式。</p>\n<h4>存储键值</h4>\n<p>通过获取到的SharedPreferences的edit方法获取到SharedPreferences.Editor，主要通过调用SharedPreferences.Editor相关方法完成</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#putInt(java.lang.String,%20int)\">Editor.putInt</a></td>\n<td>指定key写入数字内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#putString(java.lang.String,%20java.lang.String)\">Editor.putString</a></td>\n<td>指定key写入字符内容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#apply()\">Editor.apply</a></td>\n<td>立即更改内存中的SharedPreferences对象，异步写入磁盘</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/content/SharedPreferences.Editor#commit()\">Editor.commit</a></td>\n<td>更改SharedPreferences对象同步写入磁盘</td>\n</tr>\n</tbody>\n</table>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.buttonTest);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n              // 获取SharedPreferences\n              SharedPreferences.Editor editor = getSharedPreferences(\"test\", MODE_PRIVATE).edit();\n              editor.putString(\"toastStr\", \"hello you click me\");\n              // apply完成写入\n              editor.apply();\n            }\n        });\n    } \n}  \n</code></pre>\n<p>通过查看对用应用的shared_prefs目录已经完成了写入\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/6569d/writeSharedPerference.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA20lEQVQY00WNWW6DQBAFOU7osWMFLwHGbD3AMCy2SZT7H6Uim0j5KJX0PupF6kd6H1jmkW4YsGVNXlbYYiMvKopKcd7jwkClLXXbUTqlUOXaKLUqTdtTd54ozT45p2cym5HmGbm9kmcnko8D+/07ZmfIrGW6rQzjTDeMuH4LP+26gab125F2REYEMYI8LQZjDDsjvHYR4jgmSY6EaWH9/mGaF3wINOqYlxthmljudx7rF7U6olfkDxH5x2xxIzFyOHKwLTo+SMqet1OBXCouTeBYevJ2pgor+7ThF5+Wh7cLoqijAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"写入SharedPreferences\"\n        title=\"写入SharedPreferences\"\n        src=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/00d43/writeSharedPerference.png\"\n        srcset=\"/blog/static/d70c94ae4a52ac5661434b818725c3ed/63868/writeSharedPerference.png 250w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/0b533/writeSharedPerference.png 500w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/00d43/writeSharedPerference.png 1000w,\n/blog/static/d70c94ae4a52ac5661434b818725c3ed/6569d/writeSharedPerference.png 1328w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>读取键值</h4>\n<p>在上面的基础上按钮点击立即读取内容完成Toast提示。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.buttonTest);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                SharedPreferences.Editor editor = getSharedPreferences(\"test\", MODE_PRIVATE).edit();\n                editor.putString(\"toastStr\", \"hello you click me\");\n                editor.apply();\n                showSaveSharedPreference();\n            }\n        });\n    }\n    public void showSaveSharedPreference() {\n        // 指定名称获取SharedPreferences\n        SharedPreferences pref = getSharedPreferences(\"test\", MODE_PRIVATE);\n        // 通过getString/getInt读取存储内容\n        String toastStr = pref.getString(\"toastStr\", \"\");\n        Toast.makeText(this, toastStr, Toast.LENGTH_LONG).show();\n    }\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 682px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADd0lEQVRIx+2U7WtbdRTHf05mkramSe69ydIHDekDzeoiU6qIQ/piIG7q3OpbH5CsD5MJ7SKj0zrBgbKC+G5ziiC+UNgLGfrSf0Ba2VpJW1vUYhF8I31McpObm4/87u3N0rR1TRio4IUP93fO75zvOed3H4SmBpEcCDUR1EKoSnALSkCjpfkBDoTCKIq2bV9TQ1aeElB5MBJF+JR6vH43obCCX23Ar3nwa3UWAa0On+qhNaIRbGq01s5eCbUOr99Dg9eNP+BFHNYGONI0xlORUZ5sHuXg/nMc8iRt3Pa92zXCQ+5ztl1G931JHlPOc6RllOPxS7SFnkD0NX5HwvsHCWWRV+9f5IT4iVNigRfEPCfFAifFvGVL+sQCL5bRJ+Z5qe4XzrQscqF7jcPqy4jX3DcZ88MFJc3FcJaxoM47IZ1LUZ2LYZ13m3XGNJvRxiwj+7KM3Hub4XsynBXrDAvoaTiNeGXfLca7YDye5aPHc1yO5xh/OMeHj+Z4P2bbHxzMcflQjreDOqdFloFtpDkr4BFXP+K9o7f47Dm4cizD1Wd0Pj5uc+VpnavHbBzftWd1Pj2h80kF155P88UpOBrrR/z82wz2VQCKNWJYCq+/MYhI/WgLGjkT06Am8rmCpTE4MIiYmbEFTdOkWCzWRKGwKThYIVjL9b/gf1FQBjj33aiM27OgaRQxC2UYRYrm9oJ3HNkR3XVMs1j9yJmVIjfezPP1sMGNpME35w2un8mT+tZOlh3vqUOn+p+/mgyIDMn9WZKuLG8FdMv+qj9n/0ryexXc7DCfKXLzep7JL/P8sMn3n+f5fbpQKvzPnqEVaGzHrPYp3/X38N/96e1l3MqxqxKs7KR8XfW3/HedVu7fsUMZsL6+bpFOpy2c9cbGBtlsdnfBVCpVEnFEZcLS0hITExNMT08jY6ampqz17Owsq6urVrz1RzJNDMO4LTg3N7fj03O6Wltbs+6yM6drR6DyfIeGhhCTk5NWgKzqCEikgEQKl4s6wsvLy6UCKysrlmAikUBEIhHa29tpa2sjGo3S1dVFLBaz1o4vHo/T2dlZ8sn4np4eOjo6LNvxhcNhhBCCclRVJRAIbPHJAm63e4uvt7eXylyPx4Oor6+3gqUhcblcW+zdfDvZPp8PoWkadws5nVAUhVqQyTv5hdwopzyhmj157q2trfwFQwS6D7Ui69MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"读取SharedPreferences\"\n        title=\"读取SharedPreferences\"\n        src=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png\"\n        srcset=\"/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/63868/readSharedPerference.png 250w,\n/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/0b533/readSharedPerference.png 500w,\n/blog/static/9c0c1eba5de814dc6b35c31ee83869d8/160a3/readSharedPerference.png 682w\"\n        sizes=\"(max-width: 682px) 100vw, 682px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>数据库存储</h2>\n<p>ROOM是SQLite上的抽象层，通过ROOM可以完成对数据库的存储。<br>\n应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。<br>\n<img src=\"roomStruct.png\" alt=\"ROOM结构\"></p>\n<p>在build.gradle中引入room依赖</p>\n<pre><code>dependencies {\n    def room_version = \"2.3.0\"\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.room:room-runtime:$room_version\"\n    annotationProcessor \"androidx.room:room-compiler:$room_version\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>定义实体</h3>\n<pre><code>// 实体会在数据库中创建对应的表\n@Entity()\npublic class User {\n    // 主键id自增\n    @PrimaryKey(autoGenerate = true)\n    public int id;\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    // 定义列\n    @ColumnInfo()\n    public String name;\n    @ColumnInfo()\n    public int age;\n}\n</code></pre>\n<h3>定义Dao</h3>\n<pre><code>// Dao封装数据查询操作\n@Dao\npublic interface UserDao {\n    @Insert\n    void insertUser(User user);\n\n    @Query(\"SELECT * FROM User\")\n    List&#x3C;User> getAll();\n};\n</code></pre>\n<h3>定义数据库文件</h3>\n<pre><code>// 指定实体 版本\n@Database(entities = { User.class }, version = 2)\npublic abstract class AppDataBase extends RoomDatabase {\n    // 指定Dao\n    public abstract UserDao userDao();\n}\n</code></pre>\n<h3>访问数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建db\n        AppDataBase db = Room.databaseBuilder(getApplicationContext(), AppDataBase.class, \"dbTest\").allowMainThreadQueries().build();\n        // 插入数据\n        db.userDao().insertUser(new User(\"xiaohong\", 19));\n        db.userDao().insertUser(new User(\"dawang\", 19));\n    }\n}  \n</code></pre>\n<p>通过Android Studio的Database Inspector查看已经在数据表中插入了对应的数据<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/f69df/showDataBase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAASUlEQVQI142JQQ6AIAwEeZUmRovtFgvE/39njd7g5GEyO9lk0SnmfO315onCPetvjqnThsZFnKuAiMZsPiAKWgki6rfnX/0a+gEPIUZXbc7pYgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"显示DataBase\"\n        title=\"显示DataBase\"\n        src=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/00d43/showDataBase.png\"\n        srcset=\"/blog/static/c59ad56e274f395d6094c44cb4f0513c/63868/showDataBase.png 250w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/0b533/showDataBase.png 500w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/00d43/showDataBase.png 1000w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/aa440/showDataBase.png 1500w,\n/blog/static/c59ad56e274f395d6094c44cb4f0513c/f69df/showDataBase.png 1762w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"一起学Android-数据存储","date":"2021-06-29","tags":"跨端技术","path":"/android-store","top":null,"summary":null},"title":"一起学Android-数据存储","date":"2021-06-29","tags":"跨端技术","path":"/android-store","top":null,"summary":null},{"id":"085008b9-fde5-52fa-adbd-93bb4f539ede","html":"<p>广播是安卓内的消息通知机制，通过接收广播消息应用能收到系统级的消息通知/其他应用的消息通知。</p>\n<h2>接收广播</h2>\n<h3>声明接收器</h3>\n<p>声明接收器是通过在AndroidManifest.xml中声明广播的方式来实现广播的注册。这种方式在应用级别26以上不再支持。实现方式如下:</p>\n<h3>创建broadcast receiver</h3>\n<pre><code>public class MyBroadCast extends BroadcastReceiver {\n// 创建MyBroadCast 实现onReceive \n// 当接收到广播时 会调用onReceive\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context, \"receive broadcast\", Toast.LENGTH_SHORT).show();\n    }\n}\n</code></pre>\n<h4>在Manifest中定义receiver</h4>\n<pre><code>// 定义receiver\n&#x3C;receiver android:name=\".MyBroadCast\" android:exported=\"true\" android:enabled=\"true\" >\n    &#x3C;intent-filter>\n        &#x3C;action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n    &#x3C;/intent-filter>\n&#x3C;/receiver>\n// 权限声明\n&#x3C;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n</code></pre>\n<h3>上下文注册接收器</h3>\n<h3>创建broadcast receiver</h3>\n<p>同声明接收器创建方式</p>\n<h3>在活动中注册broadcast receiver</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyBroadCast myBroadCast;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建广播接收器\n        myBroadCast = new MyBroadCast();\n        IntentFilter intentFilter = new IntentFilter();\n        // 监听网络变化\n        intentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\");\n        // 注册广播接收器\n        registerReceiver(myBroadCast, intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n      //销毁监听\n      super.onDestroy();\n      unregisterReceiver(myBroadCast);\n    }\n}\n</code></pre>\n<p><img src=\"/blog/fa68f00702cb8da7b73fbba300e8fe32/showBroadCast.gif\" alt=\"接收广播\"></p>\n<h2>发送广播</h2>\n<p>Android提供以下三种方式发送广播:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/content/Context#sendOrderedBroadcast(android.content.Intent,%20java.lang.String)\">sendOrderedBroadcast(Intent, String)</a> 发送顺序广播，接收器顺序执行可以向下传递结果也可以中止广播。具有相同优先级的接收器按随机顺序运行。</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ac9f04546701d76768ab99cd9448a116/614df/orderedBroadCast.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3YFB/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERITH/2gAIAQEAAT8hdI700//aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAgMBAAAAAAAAAAAAAAABABEhUaHh/9oACAEBAAE/EKDDyFl8Qdp//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"顺序广播\"\n        title=\"顺序广播\"\n        src=\"/blog/static/ac9f04546701d76768ab99cd9448a116/614df/orderedBroadCast.jpg\"\n        srcset=\"/blog/static/ac9f04546701d76768ab99cd9448a116/0479a/orderedBroadCast.jpg 250w,\n/blog/static/ac9f04546701d76768ab99cd9448a116/41099/orderedBroadCast.jpg 500w,\n/blog/static/ac9f04546701d76768ab99cd9448a116/614df/orderedBroadCast.jpg 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/content/Context#sendBroadcast(android.content.Intent)\">sendBroadcast(Intent)</a> 发送常规广播，会按照随机顺序向所有广播接收器发送广播，无法从其他接收器中获取传递结果和中止广播。</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 766px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e518738eb7cc766faf4e21990f038705/d8ebd/normalBroadCast.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd6aQgD/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAACAwEAAAAAAAAAAAAAAAAAARAxQXH/2gAIAQEAAT8hHtih9Ef/2gAMAwEAAgADAAAAEHDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAAIBBQAAAAAAAAAAAAAAAQARMRBRYYGR/9oACAEBAAE/EL4fIlMHUTu6BpSksmWf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"普通广播\"\n        title=\"普通广播\"\n        src=\"/blog/static/e518738eb7cc766faf4e21990f038705/d8ebd/normalBroadCast.jpg\"\n        srcset=\"/blog/static/e518738eb7cc766faf4e21990f038705/0479a/normalBroadCast.jpg 250w,\n/blog/static/e518738eb7cc766faf4e21990f038705/41099/normalBroadCast.jpg 500w,\n/blog/static/e518738eb7cc766faf4e21990f038705/d8ebd/normalBroadCast.jpg 766w\"\n        sizes=\"(max-width: 766px) 100vw, 766px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/androidx/localbroadcastmanager/content/LocalBroadcastManager#sendBroadcast(android.content.Intent)\">LocalBroadcastManager.sendBroadcast</a> 本地广播，在无需跨应用广播时使用。</li>\n</ul>\n<p>下面发送本地广播的实现方式:</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyBroadCast myBroadCast;\n    private String actionName = \"com.example.broadcast.MainActivity.SHOW_TOAST\";\n    private LocalBroadcastManager localBroadcastManager;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 获取LocalBroadcastManager 实例\n        localBroadcastManager = LocalBroadcastManager.getInstance(this);\n        Button button = (Button) findViewById(R.id.broadcast);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // 发送广播\n                Intent intent = new Intent(actionName);\n                localBroadcastManager.sendBroadcast(intent);\n            }\n        });\n        myBroadCast = new MyBroadCast();\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(actionName);\n        // 注册接收特定类型的广播\n        localBroadcastManager.registerReceiver(myBroadCast, intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // 销毁广播\n        localBroadcastManager.unregisterReceiver(myBroadCast);\n    }\n}\n</code></pre>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-广播","date":"2021-06-25","tags":"跨端技术","path":"/android-broadcast","top":null,"summary":null},"title":"一起学Android-广播","date":"2021-06-25","tags":"跨端技术","path":"/android-broadcast","top":null,"summary":null},{"id":"3e6ee397-5e08-530d-92ba-1e240f8dd7e2","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1e207791889ca13b322aad1f9814efd4/8ae78/viewGroup.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVQoz4WQvUsDQRDF76+0stBSsLWQYLDwC7Qyoo0oabRIoXVIEbExJjGXBAnhcpjI5cD7MruX283t3s5IchjhRHzFwDzmN/MYDf+QUgoR66/9tZ3jzcOz9fxJrnCdmdEyPQAoAABMFCBi13jLFa4OLm93L4qFm/t/4MzxOI7DiHnB54SGEeNSyiRJpJRprixsvI+fu/1ap1fr9NxggghCxEKIBSLSdYwxIYSU8geGRc2fF1e3jzb2T1e29ipPL4j44TiNRsM0TUopAFBKDcNoNpue52nLhPMkANW6XipX7yqPpfKDadkIihDqeR4hhHOOiLPZjBDi+/50OtVSUn5r/itEUMnST5IkNX9Li6LItm3XdTnnAMA493zfsixCqViQYRiOx2Pf9xljWTgIgna7PRgMCCFKqTAMR6NRq9VyHCeO569yXVfX9eFwSCnNwF/EHvWL4zIuSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"布局\"\n        title=\"布局\"\n        src=\"/blog/static/1e207791889ca13b322aad1f9814efd4/00d43/viewGroup.png\"\n        srcset=\"/blog/static/1e207791889ca13b322aad1f9814efd4/63868/viewGroup.png 250w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/0b533/viewGroup.png 500w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/00d43/viewGroup.png 1000w,\n/blog/static/1e207791889ca13b322aad1f9814efd4/8ae78/viewGroup.png 1096w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n安卓的页面是通过ViewGroup + View的组合来实现。</p>\n<ul>\n<li>ViewGroup是布局容器，它定义内部视图的展示方式。</li>\n<li>View是视图组件，例如Button、TextView等。</li>\n</ul>\n<h2>LinearLayout(线性布局)</h2>\n<p>LinearLayout会将它包含的元素按照水平或者垂直方向线性排布。</p>\n<h3>LinearLayout布局属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout#attr_android:orientation\">android:orientation</a></td>\n<td>horizontal/vertical</td>\n<td>水平/垂直布局</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout#attr_android:gravity\">android:gravity</a></td>\n<td>left、right、top等</td>\n<td>定义内部元素的对齐方式,默认left</td>\n</tr>\n</tbody>\n</table>\n<h3>LinearLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams#attr_android:layout_weight\">android:layout_weight</a></td>\n<td>数字</td>\n<td>布局权重，结合layout_width可以实现均等分布</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams#attr_android:layout_gravity\">android:layout_gravity</a></td>\n<td>left、right、top等</td>\n<td>定义组件在非主轴上的对齐方式，会影响父布局gravity的作用</td>\n</tr>\n</tbody>\n</table>\n<h2>RelativeLayout(相对布局)</h2>\n<p>RelativeLayout是以相对位置显示子视图的视图组，每个视图的位置可以指定为相对于同级元素的位置或者相对于父级的位置。</p>\n<h3>RelativeLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_alignParentTop\">android:layout_alignParentXXX</a></td>\n<td>相对于父元素的位置对齐</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_below\">android:layout_below/above</a></td>\n<td>定位在指定视图的上面或下面</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams#attr_android:layout_toRightOf\">android:layout_toXXXOf</a></td>\n<td>定位到指定视图的左右边缘</td>\n</tr>\n</tbody>\n</table>\n<h2>ConstraintLayout</h2>\n<p>ConstraintLayout与RelativeLayout相似，视图均根据同级视图与父布局之间的关系进行布局。在ConstraintLayout中定义的视图必须至少添加一个水平约束条件和一个垂直约束条件。ConstraintLayout的布局方式能有效的解决嵌套问题，优化页面性能。</p>\n<h3>ConstraintLayout子控件属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_toXXXOf=\"id/parent\"</a></td>\n<td>相对于另一个元素或者容器布局</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_marginXXX</a></td>\n<td>定义外边距</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_bias</a></td>\n<td>通常用与调整视图水平/垂直位置</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_goneMarginXXX</a></td>\n<td>定义当相对视图不可见时候的边距</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_minXXX / maxXXX</a></td>\n<td>定义组件的宽度限制条件</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout?hl=zh-cn\">android:layout_constraintXXX_percent</a></td>\n<td>百分比布局</td>\n</tr>\n</tbody>\n</table>\n<h2>自定义视图</h2>\n<p>在业务开发中，不同页面的组件能力共享能有效减少业务逻辑的重复。下面以一个按钮为例子了解创建自定义视图的流程。</p>\n<h3>创建组件</h3>\n<p>新建一个类继承LinearLayout并且在构造函数中引用按钮的布局。</p>\n<pre><code>// 类文件\npublic class button extends LinearLayout {\n    public button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // 指定按钮的布局\n        LayoutInflater.from(getContext()).inflate(R.layout.button, this);\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Toast.makeText(getContext(),\"toast\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n}\n// 按钮的布局文件\n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    &#x3C;Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/button1\"\n        android:text=\"button\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>\n<h3>使用组件</h3>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n    // 通过类名使用组件\n    &#x3C;com.example.learnlayout.button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        title=\"clickMe\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学Android-布局","date":"2021-06-25","tags":"跨端技术","path":"/android-layout","top":null,"summary":null},"title":"一起学Android-布局","date":"2021-06-25","tags":"跨端技术","path":"/android-layout","top":null,"summary":null},{"id":"7cfe46cc-afb3-5d0e-8730-6da32b59f96c","html":"<p>Hybrid开发模式中经常需要依赖端能力来实现业务和技术方案，前端作为端能力的调用者通过对端能力的系统学习能更好的辅助业务开发。这个系列主要是自己在学习跨端技术上的一些记录，文章会偏短小，希望尽可能覆盖更多的知识点也希望能帮助到你。</p>\n<h2>Android项目目录介绍</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 566px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2922880ba1fa1f5b907f939c9657ebad/6fe44/androidProject.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 177.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAACU9ioYAAAACXBIWXMAABYlAAAWJQFJUiTwAAADdklEQVRIx5VW2W7jRhDk7+QlWCBIbF08dPAcDsnhJa2sWDYiL/Ka/wcqqJZIc3VZ+9AYikMWq7q6e2T5KxeB7yIJl8i2Bj9aHx8vFbSOkapA9vjMo2GlkYs0cpDGLvJkgf/C33Ewc+xeGryscxz3Hw9r4riYOB4mtovRzIF5PSBvtyjKCmPblfuy34d7N6yx7cmLU3cOd+mj2r5ClzXiVAsA9y7DuxlW9xJXe76ErjfImw1inclHZt5CVvu0frL0bjF0MQQdT23oZoP273eoLEdRNzB1i3r9HWWzlg+ML9LwGVZ3IQ+RkTtHvn5Bu9sjVQoqK3pm3fo44Ok6VBpB/R1us0WcZpKKYQ7vgVrnmyPbheN6+DPU+G37L7SpkJf1IH/e14A/5dB2JU9xZvC6a5GoBHM/xF/jqZTV89SWjw4r4CrgObC98KF0jHb3ilgXWEUJ/ChBmKRwFysBv8bWugZ2rEsPzjJAuz9A5UZkF1UjsQrji1x2q3UtD12hU2q7/wdJVkAXJTJTSRnRtLJdI0q1pOCu5CGgtwqx3h+QFqWUD0HZTcxxV/BDuby+CTgTwEAYEpBgsc4vQM7f+4JhgPXbB+ITOxrzNLXxfHJbHJ85Eg/lsAfUheSPxlB6qFL5zZb0YyVGReqYzy8BN28fiNIM2hxlE5BmEIQDhF20DGMppcck7w/iclcyBCVgtd7AWax+kv2QZJoSpblIZKS5QRArlM1R7sMuDwHpbl5WyMoKKi8EsGo3Uo+jmfsrdXhiqD8ZsmuCRMHUjbC923rXXT6IKT1gVohU5pID1xn09QOSQwGMO4ZlJUCUypWyE53/IsP9AaEwLKV0OG3Y42RJYBb744Cn4UCGujDSguxhzsanyawvmavT5tx+6eWFj837j94UAtIQlgwl8zmCDkeYdT7TxjwG2JveHH5dQbE7ciMApmnFFJqRFgaLIJKh65y65DpDHvjzFSYqxrd3gyjLkQnocUB0LUjA6GSOu7wBKKNp5qDY7LB5OyDNcmHxx9NIpDFvw+jujc4l9yfe6ZDnuOIhzzJhHwdnLXbLyAuXmTtVtsiqVlzluKdU1hon9S2Qu4dUYpqjEWTJvJlS5h5z9jx1+lK5deBfMORfOV02UsgcV3lV9zOQwHK2mPLmYX/BcBkpGZjLIJKuoCmUy67hNe+zU24B/g8mjevg4YzNMAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"安卓项目结构\"\n        title=\"安卓项目结构\"\n        src=\"/blog/static/2922880ba1fa1f5b907f939c9657ebad/6fe44/androidProject.png\"\n        srcset=\"/blog/static/2922880ba1fa1f5b907f939c9657ebad/63868/androidProject.png 250w,\n/blog/static/2922880ba1fa1f5b907f939c9657ebad/0b533/androidProject.png 500w,\n/blog/static/2922880ba1fa1f5b907f939c9657ebad/6fe44/androidProject.png 566w\"\n        sizes=\"(max-width: 566px) 100vw, 566px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>build.gradle 项目模块的构建脚本</li>\n<li>res 项目的资源目录 存放布局(lagout)、图片(drawable)、图标(mipmap)、字符串(values)等</li>\n<li>AndroidManifest.xml 项目的配置文件(组件声明、权限等)</li>\n</ul>\n<h2>活动创建</h2>\n<p>活动是一种可以包含用户用户界面的组件，通过活动可以实现与用户的交互，在Android开发中创建一个活动的过程如下:</p>\n<ul>\n<li>创建活动</li>\n<li>创建布局</li>\n<li>在活动关联布局</li>\n</ul>\n<p>以下的例子以创建一个展示可点击按钮的页面为例子来展开活动相关的知识点。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/821bbbd1c5b9eac1daa223540e7913f0/ab98c/create.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzklEQVQoz1WSS0/bQBSF/WsISUqICRD8iGfGr7HHEzt2MFVbqV1U6qYUELDpor/9qzJAVRaf7lkd3XPu9aL2lsv2kXP7wIV9YGXuWZk7zsw9vv5B1Vp2naUyGpEq2l5xPcaMY8DNGPDx+orrfs2uW9N3azxte1TZIIsGVVoiVRLK0k1Z1PT7kXYYsbsBkRVEyYpE+MSJj0h8yvSMKFyyXC7w/QVevW3JdUWUCMJEEAnp9EZK0lJjh5GiMsQyReYl8/mCydGU4+MZk8mUo8mLnk5f8HTTst0NJGlOJJQjTJQzKKoGawd0Y5GH7YRicXrKfD5jPp87PrzON7zSNOS6JlGZM/mHSImVQrcGY7eovHAJThYLZrPZO5P3hnVD0+3Iyopgc4gtHZtDxEJT72+w/Q2brCaQBSenS2f4xvQ/fcDLm4batmS6dpse+lKFJlEpUlvkl2eS4YmV+cV5c0ugSuJNTBCFhFFEGL8SRVxcXuLlW4PtekzbuS7bYU/T9eRljShLsn1PZVqCRJGkhTuSGT6T2xFZDQ5R9Qjds05KPG0aZ1jUho3K3GscDhQLxZUQ5ENL/lqHzDOG74+Yr3/IP/0m2D3hVz8dZ+aOZfaNv/WJPU3ARy2aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建活动\"\n        title=\"创建活动\"\n        src=\"/blog/static/821bbbd1c5b9eac1daa223540e7913f0/00d43/create.png\"\n        srcset=\"/blog/static/821bbbd1c5b9eac1daa223540e7913f0/63868/create.png 250w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/0b533/create.png 500w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/00d43/create.png 1000w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/aa440/create.png 1500w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/e8950/create.png 2000w,\n/blog/static/821bbbd1c5b9eac1daa223540e7913f0/ab98c/create.png 2356w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/24def/createdetail.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjElEQVQ4y62UaY7bMAyFfaY2E9uSRVHU5tjJLJk0aYECvf8pXiE5zXRJOggwPz6QAIUn8mlpUhDY7OFDhgsRhh3IScWwgH1EzJvKUpdL/RpNOxDYJ6RpRhgnkAQoYvTESzQW3UCVkvfn2t+oM01ZZCVi2j0hbbZV0LCvDO4N8w4Dy1nQWsizw/bbjPGYEfcBYS/g0cNLQPAB3oc6ur1FscL5RVAJgWdGylv4vAG7BMoOnA2OWuFgFF6MhrMWygoG66BvsAgywX9lPP7YYv6e4Q8MfzKQnUAkQUKEDxEuJPAtYnrrUDuCO1rELxHxIOAnAr0oUDLYKY3XocNJt3CG0JG7mH+N0mXTk61+Ta+P2Ox3GPc75OcZnOJl93cJpUP585TjOCOkCeQiNBWvpJ7cPVwEh3IpJUCzu1vkH8H/eXIv1cNfyUegqqCxH9ShrTSauM5fdymx5rd9Kl7X5/n70ys1P0JLRvPQKzx011m1PVZth89tt8R1e/6BAlql0aoB615j3St8iieswgE/AbStDGQ+zRPuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建配置\"\n        title=\"创建配置\"\n        src=\"/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/00d43/createdetail.png\"\n        srcset=\"/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/63868/createdetail.png 250w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/0b533/createdetail.png 500w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/00d43/createdetail.png 1000w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/aa440/createdetail.png 1500w,\n/blog/static/4205cc3a58e8ca0d0e94d2f514ea1643/24def/createdetail.png 1812w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n上面在AndriodStudio中创建了一个空的活动并且同步创建了布局文件，设置创建的活动为应用的起始活动。<br>\n通过查看代码Android Studio已经自动帮我们完成了布局与活动的关联。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/c6162/activityShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKElEQVQY013Py07CQBiGYS5HOp3SMj1PD8O0ELGcQpDElS5caHSB8f7zGgfE6OLJN6s384+O+4HtZknXtcx7Q//PfG4ws4Y4TkgmHpNA4kuJlD7SF0gZIKXE932E8Bit1gOr9QpjLbPOuv01w3SWum3J05Q0HKNCQRhNXTjyb9w7mirCaHIOttYwbNaYWUuhC3RV/lWXlFVJGOdE4RhbjNGZoq5yCt2QF9r9/jsshM9I3b6Q7T9pjh/Yw4lydyId3lHL17O7N+L5IypJCYKAWCmyLCfNcpIkI1EZahpfzx6l3QG7fWJxeKZePpD1x4v7iyOp2TKNE4KJRAjhTvM8z+2ZcDEXLCuN7Tt2m4F+saAxLbqu0E3ltmoqCq0JI+Ui55BwPO+Hd/UFOznJQaz4eeQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"布局与活动的关联\"\n        title=\"布局与活动的关联\"\n        src=\"/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/00d43/activityShow.png\"\n        srcset=\"/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/63868/activityShow.png 250w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/0b533/activityShow.png 500w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/00d43/activityShow.png 1000w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/aa440/activityShow.png 1500w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/e8950/activityShow.png 2000w,\n/blog/static/fff1236399c2d5248cbe9cfc9e1baa53/c6162/activityShow.png 2166w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在AndroidManifest.xml中已经自动完成的活动的声明。</p>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapplication\">\n    &#x3C;application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.MyApplication\">\n        // 活动声明 Android Studio在创建活动时候自动在ManiFest文件中完成声明\n        &#x3C;activity android:name=\".MainActivity\">\n            // 定义为启动活动\n            &#x3C;intent-filter>\n                &#x3C;action android:name=\"android.intent.action.MAIN\" />\n\n                &#x3C;category android:name=\"android.intent.category.LAUNCHER\" />\n            &#x3C;/intent-filter>\n        &#x3C;/activity>\n    &#x3C;/application>\n&#x3C;/manifest>\n</code></pre>\n<h3>实现按钮逻辑</h3>\n<h4>在创建的layout布局文件中定义一个按钮</h4>\n<pre><code>// activity_main.xml\n&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    &#x3C;Button\n        // 宽高定义\n        android:layout_width=\"wrap_content\" \n        android:layout_height=\"wrap_content\"\n        // 定义按钮的id 可以在活动中通过id查找到对应的按钮\n        android:id=\"@+id/button_1\"\n        // 按钮显示文字\n        android:text=\"clickMe\"\n    />\n&#x3C;/LinearLayout>\n</code></pre>\n<h4>在活动中实现按钮的点击操作</h4>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        // 定义点击事件\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Toast.makeText(MainActivity.this,\"hello\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n}\n</code></pre>\n<h4>通过模拟器查看效果</h4>\n<p>通过ADV Manager创建模拟器<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/a01dc/createVirtual.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQ4y31TW07cQBD0efKDQkISGz/m/fRjDRIEdk02UnKNSPnLCYjggwNwyYp6WO8uKzYfpemZ7il31bQzNzpIqSCVhlQKQipoYxJ8iFiMI4bFiPHiEs6HTc4eRfbn6Rmrm2ssl0tM0wrTNGEYBsQQEGNA8D7Be785i/9FNq1/pqDtOnRdj34YEEKEcx7O7+CPxIfIhDZQNkC7AOMjSiZQ1AznDX8TlMur5mhNpowGVwq27WFCC2k9pAtQPkJQbD2UC+mMaQuhLWxswZR5kzTj4QqFILMVuGComyqtQnEIySGVgLYKxmowISCNS0pqoVBxgYrLLRLh6bdnnAy/wbo7FOE7zvQKn8wKX+wK52GdUMU16u4Hav8VsR/QjReJkBQR+WwFISM5OQ/Ip3uc3j7i3eU9Tq7/4uPyAe9vHvDh9gGfp0ecTU8or35BGQMbu2QFyebabglTh9I61FxAao2aNSirElVTpZgJBi45hJIJJDl0A+KwSBLpcfIDH7P5VemLwngUNU+gJFN22wXXDiWTaQqIbP9BiortJJMXyQ8fE2kjdcJMNMdzbn9k5pXOiSN16NoeBO1jInjZd2mdO5kVHI4KxVRD9eQrxVnyYYN5aPf3u8vNlvw1GuRlva3PXv0ZBwbvX5xJmdLwXY+GrOICRVwib+9Qb2bxH4ZY+0FYxaAIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建模拟器\"\n        title=\"创建模拟器\"\n        src=\"/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/00d43/createVirtual.png\"\n        srcset=\"/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/63868/createVirtual.png 250w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/0b533/createVirtual.png 500w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/00d43/createVirtual.png 1000w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/aa440/createVirtual.png 1500w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/e8950/createVirtual.png 2000w,\n/blog/static/d0885da6b36b793e8aaed04e8dcce8bc/a01dc/createVirtual.png 2006w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在模拟器中启动项目<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/df2f9e33e2c539487abb53bf56f18a06/ab40b/launch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhklEQVQI1x3FWQ6CMABAQe5DLYu0bK2ytAiSEA2oyP3v8Uycnwk6P+CGgab3eO9px4lmnnDPF/P24bF9Gdc7drFcF8PWl+yXmrWzHK3lcB3uNlL3nvW9E+RaYVSE1jllWVGUNUVRoU1DWliS3BClChkLZCxRQqBF+F+JkEyERCdBmkiSc8YPbOhEx60iQJUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"创建模拟器\"\n        title=\"创建模拟器\"\n        src=\"/blog/static/df2f9e33e2c539487abb53bf56f18a06/00d43/launch.png\"\n        srcset=\"/blog/static/df2f9e33e2c539487abb53bf56f18a06/63868/launch.png 250w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/0b533/launch.png 500w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/00d43/launch.png 1000w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/aa440/launch.png 1500w,\n/blog/static/df2f9e33e2c539487abb53bf56f18a06/ab40b/launch.png 1736w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在模拟器中点击按钮展示了Toast<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a8d23e69732946a44dc47941ae242238/c5bb3/showContent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 188.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAmCAYAAADEO7urAAAACXBIWXMAABYlAAAWJQFJUiTwAAADiklEQVRIx+WWXWgjVRTHry5UKWupTVptaTKZfE0+JpNMktpKV4UVLWVd1rYsuqtik3Z3FSzoqqB1fdg+CT5scXXFF/vW7y7ig68iu/skFfWlIvWl9aGvhdBkmo+fzMSEpKS2Ql0KXvjPuefMub97zzAz94rJyUmCwSDJZBJdT6DrOrGYjqZF0TSNSCSCqqqEw2FCoZCVGwgELCmKgt/vx+Px4PV6mfl6BpGIJ4nHe0iY0svQWDSO4g/g9ZjJPtxuL27Zgyx7cEkyXq+fgBLC51Osvs/nR3K6UPwKItmjE0uoxOJhtFiIiBYgEg2i6aZVCGs+QhEvQdVDIOwmEHKjBF14FScevwPZ041D6kKSu3DJEuIJ9Qyn1NfoVy/ydOwiz8RfoV+9QNx1Ht11nphzhKhjBM0xjNY9RKR7CLXrRcKd5wg+dhbNcY4+dZiEZxi/rCGef/wzXm/9g1fbfuWyc423lN+5LK3xnPiRF8TqvjorfuKMWGXkoZ95W/uNdyN/knS+hHjZtsR1O0zadvioLcc1e45rthxTToMPThq880COqydyXH2wgU7krPsTIsN7AvrsKcSFjkVu9sCn+g63ThtMP2kwJeX4JJTj/YezXBE7vCmyvLGPyvcyTAjoeTSFmDi1yBf9cOOpDNP9O9w8neX7GwY/fG5w55bBva92uXuA7nyZZXUGhp5NIUZOLvDxI3Bd2mHKWS65WCjx71rBul66kkZMf7jM2jewOm+wOpfnl9t5drMlC1rIlygeQrtGGZgaTSO+/e523SyVViqVqvYgFQrlselUCrG8tGI55iyVGWthB7VaYGp0FLGyUgaawcMA7i/QKnl5+ciA1jNcWlo6vkCr5MXFxeMLtEpeWFg4WuD8/Pz/CZhOI+bm5o4MOHbUwPR/ApydnT2+QOtLuS8rrPzaG20Be//khwbutwXsjdW9NmNj+5dc6ReLRatfsf+0wjpgPp9vuKNtb2+zvr7OxsYG2Wy24WOoA9a+h41aJpNhc3OTra0tDMNovM3/PXZ8L9CczVxpowFmybXN9CsrrgAvjY8jZNltHWndbrd1rO3t7a36ppUkib6+PqLRKC6Xy4qZ1jwmDw4OVmNmvluWEU1NTQghqjLP0bW+qXA4hM1mq4s1NzczMDBQF2tvb0d0dnZit9stx7QtLS1Wv+y309HRYcVaW1urOaZta2uzoJVcm92G5HTyF7kXnrJ/9jLzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"展示效果\"\n        title=\"展示效果\"\n        src=\"/blog/static/a8d23e69732946a44dc47941ae242238/c5bb3/showContent.png\"\n        srcset=\"/blog/static/a8d23e69732946a44dc47941ae242238/63868/showContent.png 250w,\n/blog/static/a8d23e69732946a44dc47941ae242238/0b533/showContent.png 500w,\n/blog/static/a8d23e69732946a44dc47941ae242238/c5bb3/showContent.png 680w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>活动之间交互</h2>\n<p>在应用中不可避免的需要不同的活动间进行跳转和数据交互，可以通过Intent来实现活动之间的跳转。</p>\n<h3>使用显示Intent跳转</h3>\n<p>通过Android Studio创建testIntent活动，在testIntent的layout文件定义文字方便识别跳转.</p>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&#x3C;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    &#x3C;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"测试显示intent\"\n    />\n&#x3C;/LinearLayout>  \n</code></pre>\n<p>在MainActivity中使用intent实现跳转</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // 显示的创建intent 指定当前的context MainAcxtivity  目标活动 testIntent\n                Intent intent = new Intent(MainActivity.this, testIntent.class);\n                // 启动活动\n                startActivity(intent);\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/3a02576763653fa6a4f4d24e087e0108/intentJump.gif\" alt=\"显示Intent跳转 \"></p>\n<h3>使用隐式Intent跳转</h3>\n<p>区别于显示的Intent跳转，隐式Intent通过定义action和category信息让系统查到对应的活动实现跳转。<br>\n创建testIntentImplicit，在ManiFest文件中声明action和category</p>\n<pre><code>&#x3C;activity android:name=\".Implicit\">\n    &#x3C;intent-filter>\n        &#x3C;action android:name=\"com.example.myapplication.TEST_INTENT\" />\n        // 必须添加DEFAULT category 否则会导致通过startActivity和startActivityForResult无法识别正确的activity\n        &#x3C;category android:name=\"android.intent.category.DEFAULT\" />\n        &#x3C;category android:name=\"com.example.myapplication.TEST_INTENT\" />\n    &#x3C;/intent-filter>\n&#x3C;/activity>\n</code></pre>\n<p>在活动中创建隐式Intent</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(\"com.example.myapplication.TEST_INTENT\");\n                intent.addCategory(\"com.example.myapplication.TEST_INTENT\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/edd3089ae16056b202f01de5ee7157ae/implictJump.gif\" alt=\"隐式Intent跳转 \"></p>\n<h3>传递数据给下一个活动</h3>\n<p>可以在intent中通过putExtra中传递数据。</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 通过id查找到按钮\n        Button button = (Button) findViewById(R.id.button1);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(\"com.example.myapplication.TEST_INTENT\");\n                intent.addCategory(\"com.example.myapplication.TEST_INTENT\");\n                // 在intent中增加数据\n                intent.putExtra(\"extra\", \"传递数据\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/8d5dedf2170474f96abae68c68fb9d50/deliverData.gif\" alt=\"传递数据\"></p>\n<h3>传递数据给之前的活动</h3>\n<p>通过startActivityForResult和onActivityResult可以实现传递数据到之前的活动。</p>\n<pre><code>protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // 在onActivityResult中判断requestCode是哪个activity返回的结果\n    switch (requestCode) {\n        case 1:\n            if(requestCode == RESULT_OK) {\n                String responseData = data.getStringExtra(\"extra\");\n                Toast.makeText(MainActivity.this, responseData, Toast.LENGTH_LONG).show();\n            }\n            break;\n        default:\n    }\n}\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Button button = (Button) findViewById(R.id.button1);\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(\"com.example.myapplication.TEST_INTENT\");\n            intent.addCategory(\"com.example.myapplication.TEST_INTENT\");\n            // 通过intent和requestCode打开活动\n            startActivityForResult(intent, 1);\n        }\n    });\n}\n</code></pre>\n<p>在跳转的活动中通过setResult返回数据给之前的活动</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_implicit);\n    Button button = (Button) findViewById(R.id.buttonBack);\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent();\n            intent.putExtra(\"extra\", \"数据返回\");\n            setResult(RESULT_OK, intent);\n            finish();\n        }\n    });\n}\n</code></pre>\n<p><img src=\"/blog/af74a5d1e5ef0e39f1fdee8fd10ca82d/resultBack.gif\" alt=\"传递数据\"></p>\n<h2>活动启动模式</h2>\n<p>安卓使用栈来管理活动的层叠关系，系统总是将位于栈顶的活动展示给用户。在声明活动时，可以定义活动的启动模式从而影响活动在栈中的表现。<br>\n通过在声明activity中android:launchMode定义活动不同的启动模式。</p>\n<h3>standard</h3>\n<p>standard模式是默认模式，在standard模式下创建新活动都会在栈顶新增一个活动入栈。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/99d8f33acd23780a98ec21f4c4b832c9/5a3c9/standard-mode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0UlEQVQY01WRiQqEQAxD/f+PFO9b1xsPNMsrdGGFSjJNM20nuO9by7Jo2zZN06R5nvX5fLTvu8ZxNE6e3DAMxjlHA+YcTlzXpWBdV9V1rbZt1fe9mqZRVVVWwHmapsqyTEVRqCxLy4Odo3HOBQG/53nknRJw7ySOY0VRZIVozvM0U773fU1zHIdx8J8hGHGSJL8uMSTohvCcG/p6fobsIM9zE4EpYkw4O/OR0bgh43VdZ5w1/RkyYhiGJiTBaIzITumY7shhgCkczEXU0aE/HvgLUSrFo8BPpOEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"standard模式\"\n        title=\"standard模式\"\n        src=\"/blog/static/99d8f33acd23780a98ec21f4c4b832c9/00d43/standard-mode.png\"\n        srcset=\"/blog/static/99d8f33acd23780a98ec21f4c4b832c9/63868/standard-mode.png 250w,\n/blog/static/99d8f33acd23780a98ec21f4c4b832c9/0b533/standard-mode.png 500w,\n/blog/static/99d8f33acd23780a98ec21f4c4b832c9/00d43/standard-mode.png 1000w,\n/blog/static/99d8f33acd23780a98ec21f4c4b832c9/5a3c9/standard-mode.png 1169w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>singleTop</h3>\n<p>singleTop当栈顶是要打开的活动时，不会创建新的活动实例入栈。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 807px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/80638bb8d399426618fcc157771016a9/d2a60/singleTop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGklEQVQoz52R2a6EQAhE+///UOO+7zqORkcnYXJI8OE+3k5IA10UBe0+n49g13X9y6zWeJw9pGkqr9dL5nmWIAhkGAbNVVWl+bIsJYoiadtW89xhGErf95JlmWK+36+49/utyWma9B7HUTtRAClG7jiOJ8bA0rwoCrU8z2VdV3GAz/MUzn3fSkwxYDvLsqihwg7FqMYgS5JEGzkI/hKisK5rBXRdp2MzCT5EEOMzBWSsAEJqnRFw2IHFdG6a5lGwbdszHrvjtnfIIGVax2jsg0dU4fNJLNqAvEGIUjCQQYRK2x84VQghged54vu+FjB6HMcKpJAcIxNDQCN8I8fg0B2yP1NJYt93VYhPAar4EHIosI8wLOrBcBP/AMUep4pPDBSjAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"singleTop模式\"\n        title=\"singleTop模式\"\n        src=\"/blog/static/80638bb8d399426618fcc157771016a9/d2a60/singleTop.png\"\n        srcset=\"/blog/static/80638bb8d399426618fcc157771016a9/63868/singleTop.png 250w,\n/blog/static/80638bb8d399426618fcc157771016a9/0b533/singleTop.png 500w,\n/blog/static/80638bb8d399426618fcc157771016a9/d2a60/singleTop.png 807w\"\n        sizes=\"(max-width: 807px) 100vw, 807px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>singleTask</h3>\n<p>singleTask会复用栈内的实例，如果栈内已有实例会把实例之前的活动全部出栈。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 659px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/811c885983b4a1125c7429765cb91547/6db71/singletask.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQ4y52T144CMQxF+f9fQ7zxgOh96HXoxehc6WaDtC+7ljzJOPFxSVK53+9xu93i8XjE8/lM8/f7rdH2fM4ao9UMxgqT1+sV+/0+1uu1nMqyjMlkErvdTvbVaqXxdDppnE6nGrfbrdbO53OCCsjG8Xgc7XY7bep0OjGfz2XvdrsxGo1kXy6XWsOOjTl2EhEQGNkcj0eBF4tFbDabQHAmwOFwULaz2Uzlsg8IdvwIzBxoBQNOFqK4dAC5AGHdZVoIAENA+gXAwkb+aTbZ4owCp0ycWAdicVIJ6BKR6/X6BaQcDqHf78dgMJCd9TxDGF9AHC+XixR4DhwOhzqUZrOZgOyhZ2QJmP6iAmLo9XrKpCgKOXEYCHNKJUMUOEBaQPlkRXBOm2skIFEcHXCr1RLcQILgwE0wkIBkTRvwYZ6AnBobcHAmtMG9AgqIkUA4+aoRCCXb9FL44MxrQfOn5Kdm9T+lEsQXn2CA00v5TQ3NlRvgkmu1WlSrVWm9Xo9Go/GT4V/UcN8C+keg9PT+A8xbQpvyQB8SmXvzI+bD0gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"singleTask模式\"\n        title=\"singleTask模式\"\n        src=\"/blog/static/811c885983b4a1125c7429765cb91547/6db71/singletask.png\"\n        srcset=\"/blog/static/811c885983b4a1125c7429765cb91547/63868/singletask.png 250w,\n/blog/static/811c885983b4a1125c7429765cb91547/0b533/singletask.png 500w,\n/blog/static/811c885983b4a1125c7429765cb91547/6db71/singletask.png 659w\"\n        sizes=\"(max-width: 659px) 100vw, 659px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>singleInstance</h3>\n<p>singleInstance会创建一个新的返回栈来管理活动，主要用于不同应用间活动的共享。在下面的例子中从活动C返回时会先返回到当前栈的活动A在返回到活动B<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 990px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/812d44b27c3de2c4bfb00faf3973642c/7a3d6/singleinstance.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQoz02SVwrEMAxEff8T5iOQ3nvv0fIEXmIQstpoLNmc5ynHcQh633fZtk3WdVX7ui71ockhZuMIPuJoK4bCpmmkqioZx1HatpU4jqUsSwmCQBzHkaIopO97zeu6TjU+QPM8l2VZ5L5vbWxIQIZh0CKSrJ1lmRbQBBBbSIzm5BH7Yijg+77CsYmAcrjj4/ASbHRd1wo8TZMyhRkCuIEVSc/z/AHnedYm2DBM01TZ4ieXUYRhKEmSKHOAYQ85gwMBiDkSsDNDA4SmGECYABZFkTaihgYIOAb6ruuK53lazHN931eb5QDEHbEMuX9B0fgAN6wdyjDkS7B6O2x8dvP4iNtZ8QtgxEsggrCUH8gQYLYhbGLGAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"singleInstance模式\"\n        title=\"singleInstance模式\"\n        src=\"/blog/static/812d44b27c3de2c4bfb00faf3973642c/7a3d6/singleinstance.png\"\n        srcset=\"/blog/static/812d44b27c3de2c4bfb00faf3973642c/63868/singleinstance.png 250w,\n/blog/static/812d44b27c3de2c4bfb00faf3973642c/0b533/singleinstance.png 500w,\n/blog/static/812d44b27c3de2c4bfb00faf3973642c/7a3d6/singleinstance.png 990w\"\n        sizes=\"(max-width: 990px) 100vw, 990px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>生命状态&#x26;周期</h2>\n<h3>活动的状态</h3>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>运行状态</td>\n<td>活动处于栈顶</td>\n</tr>\n<tr>\n<td>暂停状态</td>\n<td>活动不处于栈顶，仍然可见。系统一般不会回收</td>\n</tr>\n<tr>\n<td>停止状态</td>\n<td>不处于栈顶，不可见 可能会被系统回收</td>\n</tr>\n<tr>\n<td>销毁状态</td>\n<td>从活动栈中移除</td>\n</tr>\n</tbody>\n</table>\n<h3>活动的生命周期</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onCreate()</td>\n<td>活动第一次被创建时调用</td>\n</tr>\n<tr>\n<td>onStart()</td>\n<td>活动由不可见变为可见的时候调用</td>\n</tr>\n<tr>\n<td>onResume()</td>\n<td>活动处于栈顶运行状态</td>\n</tr>\n<tr>\n<td>onPause()</td>\n<td>系统准备去启动或者恢复另一个活动时调用,通常在这个方法中进行资源的释放和数据保存</td>\n</tr>\n<tr>\n<td>onStop()</td>\n<td>活动完全不可见的时候调用</td>\n</tr>\n<tr>\n<td>onDestroy()</td>\n<td>活动被销毁之前调用</td>\n</tr>\n<tr>\n<td>onRestart()</td>\n<td>活动由停止状态变为运行状态之前调用</td>\n</tr>\n</tbody>\n</table>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/267f6/life-cycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGPklEQVRIx5VVD2xV5RU/7/W99pWREJZsKg6r0+CAEZWMJsahW1xRXJ1xkRSKS4VCMVtmgkAEpiUbmwwyaGnLWq0+KFSrUKSAtAhY+gdbCu//6yu8///un3f/fvfed9+9bSn9lvt0nZotsl/y5XxfvnN+53znnJwP4FvocCjQ2sdDQ3d61qfByd2nfNK7J93CoXPBiZbjbnVxV0CHrlHdBHeKunMp83tD41Dfwyxpd07gPR878Z/eu4ztwzI+cm3izQ+9GI5c0wvg/8Fdy6oBdmHT1g7uhW3H4pu2tEU2bj8hVFU1xX/4x7YMvNZGg8vlAo7jQBCEmWWcvw7jGZbfPF9uxRjD4EDfY5rCX44F/b0B7/XPsyIzpCriOjw9ATQRNy9atBhkSTIPDPSbmxoPmQcHh82appnBZrPl2WbPnl1os9lspaWlVuN85szZ+RmW3+LxBbYPDV/bTlLMDlnJln4xNAyGw0ceeRQkCcHw1WE4dvQYjIw4IJfLAfyo5H547GelBocFAMzGxu12gyiKD0qS1H3zxo0LLrf7vCiKl8Ph8DqDbPny5dY1ayqLBUE4Go/HXF6Ptz8eT3gQQs356Ox2e96rsQ4cbM7LRCJ5jyxLf74xFnh7ZOTa3xBCe6LR6NPGXXl5eUFV1StWnudfj0Yj9b29vY2RSKwRIfR7w7iQ59grDMOoJEFMCjz/QSSehAxDP8SymVNOl/OM2+08TZDpnkgk9DuDcNWqVUXGa4wieDzufABjYzdBlmWAi0sBBEl5I5pMvR+OxdtYRV9PjHpBZNT5Ije+L+CP1Ps8wTqakBvIlPiMYVz75u4Ck8lU1NHRYVGySsGKFSuKXS6PRVVVM+g9jUv5Mweb6E8O7Ge66g5me5p2446m7226ZC0aoCt2fhp4qf4T14sHBjOV+85FVi788GpZPiIAKPyqMwwUzfSKfuKtnWL7DnxlzwbsbfgD1k7U4qnmnQ/+ZfDn9/VGqvHh87/F9R/9GnePvoK7x17eMpDaCPREV+FzK1cWt7S0WL6iKSwpKflyd3Pfmrtu26vXhveu2kDWVdZoreufNyIg6FTJoNfeNOD959F+T/PhK/7Wo75Qb5kj2AnBsehMEf1+P8ydO/c/EYqBIdD77ICVq4DZPpB6mkBVZBjX9a1MRsAZStTINKfTlIAVWe3BGJsEnl8bi0U3MgyzFmM8BwAKHA7Hl4RI4JdNqvIvODL5tMIzv8xJ4q8QQvfrun6vrIjrb4YCmzw+5yaWp2uyWXnpuD4xP0PT0+l0GhMEgTHGPzUizWSYfA+DLMkcSZA4mYjjRCKBOY7HkizbL1y4+GNRFMOjo4FRh8PpY1k2SVHUa4ax1+tZ4vP7FyOEHlJVtXjBgodt1687CqaNYmGMn8wqyrOhUOi5cDj87NTU7XKM8UJBECwSkuopij6fSqVOi6J4UtNyC0VRAJ7ngOU4kBCCUCiUz2UgMAYiQnlCCAWDM0mOxeJ5eenSJZAkqZ0giIl0Oi1QFB3BGH/fMMIYW6LhMGhabhnDMHaCIN4hSfKwpukLjJFjNhJdXl5uKysrK25vb7fOmzfP7HK5fiBJUqXf76txOJw1oiCsS6ZSSwxndXV1hYZEovgSSZG3EomESBDk+K2p2098fXwZSS2sqKiwGcoXLl4sURTlRigUHHM6XX4kimmKovLDYfPmzbMAwFpUZLOWPPCAdfasIst/HayGMsuyhlycy+U6GYbpZRi2j+O4Poqie7PZ7OcY49U8zxs6ptWr10Brayu0NB+aSdk3EAkHzeO6Brms8iRJUUQkHHGGQmF3KpXyxKLxkVQqzUiSXCsrCiSSScu2bdvg+PHj0NnZCRKSYeLW1DcJA+E0SEg0KYoMDMPerUhoe8Dv2+Vxu3aJAr8LicITmqqCjJDJG/B891+iaTqwHG9Ckgwcx/+ER/IXbl9gcMTl60/RrBPJSrWq6cZ0MmfV7HcTTk9PQ6zxVfj3+J7sP/IUebb55fiphko89MELkfa/ziGO1QJ/cl9e944gfVRrVj5+C6jDWxdN9+zHgdYdePjg6zjbtRdPnn77DfzZfpg8u/fOv1G6aR1kWmog0bB+Dmqpbov/o7I7+PeK00xjVY/cWvO4bn8VpHc2mP8Xwb8ALx5OZ/sHMjIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"生命周期\"\n        title=\"生命周期\"\n        src=\"/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/267f6/life-cycle.png\"\n        srcset=\"/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/63868/life-cycle.png 250w,\n/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/0b533/life-cycle.png 500w,\n/blog/static/68bd569be2bf11e6e04ed1f219a48dd0/267f6/life-cycle.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"一起学Android-Activity","date":"2021-06-17","tags":"跨端技术","path":"/android-activity","top":null,"summary":null},"title":"一起学Android-Activity","date":"2021-06-17","tags":"跨端技术","path":"/android-activity","top":null,"summary":null},{"id":"ca85fd25-3188-5457-a2f7-f5f728513933","html":"<p>在<a href=\"https://https://icantunderstand.cn/webpack-tapable\">深入浅出webpack-Tapable</a>源码解析中,我们了解到webpack是基于Tapable来实现打包的任务调度,本文基于webpack的源码梳理打包的实现流程.在源码分析中会主要关注以下几点:</p>\n<ol>\n<li>webpack启动过程(compiler compilation的生成过程)</li>\n<li>入口文件的解析过程</li>\n<li>loader调用过程</li>\n<li>plugin的调用过程(webpack实现任务调度拆分的方式)</li>\n<li>文件的输出过程</li>\n</ol>\n<h2>前置知识</h2>\n<h3>Tapable</h3>\n<p>webpack基于tapable来实现任务调度和代码逻辑的拆分.<a href=\"https://https://icantunderstand.cn/webpack-tapable\">深入浅出webpack-Tapable</a></p>\n<h3>webpack基础</h3>\n<p>webpack是前端的打包工具,通过loader实现了文件转化能力、plugin实现了打包阶段的介入能力(编译能力增强,任务拆分).<br>\ncompiler在webpack启动编译后生成的对象,它负责把控整个webpack的打包构建<br>\ncompilation对象是每一次构建的上下文对象包含当次构建的所有信息.</p>\n<h2>源码解读</h2>\n<p>以下源码解读基于webpack当前master代码.我们在webpack源码下创建如下的目录结构:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 443px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6f91bb1c3d81745f56fc1e823c17e799/a120c/debugCategory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3ElEQVQ4y6WT626bQBBGeZMmwF5YWHNZLsvFxnaiREr/pO//MKdakjRK1TqO8uNoAA2HD2aI8rxgXU88P//i6eknznXEcYoQ6iKhz7l2q2VZU1U187wn0jpDqYz9fuX+/gFry02YppIkEVcRem9vE5qmfRcG+/l8R0j81vQVgrDr+hehlJq6dizLgTy33NzEHxL+ffO/rgVh2/ZEIZ3WZjvxfmIYPMZ8PeUHYWBdj0zTwuFwpO/994QhYZi0SNX2um9D+ZYwX3vy44DMzZ90V085VCnpvCcytsQUJbvFY08T2liUNCiVb8c6vw5lLX4Je5gZtDKYvqG4G9GuwszthjCGVChSqS8iQs0y+nEisraitI7Ke+rznmoeqdeZel2wVUORlxRFdZm8Ii9rlsORyLmBvpsZz0fa5UBTDS+UPa4Zce46mm7idPdIFJZaa0njErJ1oLj3yF1OfJu+fvT0EwRJnBIrSTf6IDTYIqX0FnPyFKdhw4zu+rVJJIlW9NNIJJVhZ27Y9Qaz78m6ilSql6f+SEji1wW/tOhBKF8TKiHR7YDZe4qHEXPoUG5HNjZkvkGY7F36X6EgyTT9PBEpqVC7lrwbKOeOch6wg0N31SYVWfb5b5hIYiHohoHfNU783Lp7nlAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"debugCategory\"\n        title=\"debugCategory\"\n        src=\"/blog/static/6f91bb1c3d81745f56fc1e823c17e799/a120c/debugCategory.png\"\n        srcset=\"/blog/static/6f91bb1c3d81745f56fc1e823c17e799/63868/debugCategory.png 250w,\n/blog/static/6f91bb1c3d81745f56fc1e823c17e799/a120c/debugCategory.png 443w\"\n        sizes=\"(max-width: 443px) 100vw, 443px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>// 启动文件 通过compiler.run开启编译\nconst webpack = require('../lib/index.js')\nconst config = require('./webpack.config')\nconst compiler = webpack(config)\ncompiler.run((err, stats) => {\n  console.log(stats)\n})\n\n// webpack.config.js 配置文件\n// 添加入口文件 配置了解析的loader\nconst path = require('path')\nmodule.exports = {\n  context: __dirname,\n  mode: 'development',\n  // 入口文件\n  entry: './src/index.js',\n  devtool: 'source-map',\n  output: {\n    path: path.join(__dirname, './dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['babel-loader'],\n        exclude: /node_modules/,\n      }\n    ]\n  }\n}\n\n// 入口文件\nimport is from 'object.is'\nconsole.log(is(1,1))  \n</code></pre>\n<p>在上面的代码中指定了配置文件和编译的目标文件,通过node --inspect-brk start.js结合chrome的inspect就可以对webpack的源码进行调试了.</p>\n<h3>webpack的启动过程</h3>\n<p>启动文件执行webpack(config)是通过配置生成Compiler的过程,下面梳理源码创建Compiler的过程.\n启动文件使用的webpack实际是引用的<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/index.js#L94\">lib/webpack.js</a><br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/webpack.js#L97\">webpack.js构造函数</a>中会根据入参来创建compiler.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 117.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAADNElEQVQ4y4WU63abOBSF/RhNDEISEheBEMbYxsRx0mk782Pe/3m+WYg003TszI+9jhBoa2/OZaOKivr8jB1mjN/RHY8U/Yj2e1TdkRhHapoV9i3GPffL+u2dbdjILKPsAuWuZz+3nF4D7dhQ9Y56sAiRkCZb0uRn3JKmCeIOIqHKLcaV9PsSP1S4wSHzHCEyUiEQMkNIidQ5UmuEEOv+W0x/ed5kmSTPFcPUcXh94fT9ifDHGf3tQn49R+jrhNkHqn5PHXZIKUnTNBL8jo2UGWq5ue6oj88UYY/Qhkyp9SO5qlwsJ4+PJNvtO9kt0o3MJCrPsbs94fVv6vMT5vKCHnqypiLrGlRokb5BVpYsW4jETXXvCrXOKdue6jQT5gvjPFGFnqLrKZ0j0wqxQMoPh28rlBKtNMYqzLijOh5o5kB9mbDTGdNUMXvRasx0QrLEGyqXCyLhAuMc7flE4R3h1DKeW7wv6XpH40rKMGBdi3EtVbdDScn28eH9ggXvCpfSceOZ3fU77WEmnC6cLzPz11fmb9/opgv+6Svd/MLw+hf9fKVsu0iuixJjTMS7Qq01IewZjlfK/oCuHTbssN7jmgrbeHRRIXMbVeZljW07ijas698JldJIlZD7GtXUmLFGdQWpTEl+/3/btXRiCb2V0Q3LguYwMf74k/YwMr0+cf1xZX4+4UOLGydqHz50yC38q1BKrO9pT8/Uw4nS9/Gf1sMh2i27XbRqraUoirtd8tZ6WfTf1R3lMnmGkcIHisZThSGiOc7Uw5HKNW9t97GHf0UcDlVVojOFSFJUbtDWxu7RZo15Ucb1krx1qqR3sZG2pg4TfpjYTROuPyCsJ8mbFaZZZ2Kcdy2i8J9ikylNWTb0oacbPbbKUUWO8QWmLVCVReQ5SaZIpf5fRMtSKUwbKLwnn67Y/QHTNdjQUjeW3eBom3pNxrvlOwM2k5KyrGiLFls0yH5C1R4hJKnIyIRAqbU90zuD9UNSrDVYk/Pl4QvbpWgfvvD48LAWappGVT8hRLpm+LOyWVoqsxXW5hijyU1OVS0ZVf85uE6Y+2SRUBQO2ezwncO5grK0jKOPMUk+P3yL8B8xf4859cdqlgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callCreateCompiler\"\n        title=\"callCreateCompiler\"\n        src=\"/blog/static/61143bfacd863a4828a15932971a27f6/9f21b/callCreateCompiler.png\"\n        srcset=\"/blog/static/61143bfacd863a4828a15932971a27f6/63868/callCreateCompiler.png 250w,\n/blog/static/61143bfacd863a4828a15932971a27f6/0b533/callCreateCompiler.png 500w,\n/blog/static/61143bfacd863a4828a15932971a27f6/9f21b/callCreateCompiler.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/webpack.js#L58\">createCompiler</a>中主要做了:</p>\n<ol>\n<li>入参处理</li>\n<li>创建Compiler</li>\n<li>订阅Plugin</li>\n<li>根据入参加载不同的能力和应用webpack内置的插件体系(WebpackOptionsApply)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 597px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/800fff7bc13591c48e262e16c05a1387/17602/createCompiler.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADYElEQVQ4y4WV3XKjOBSE8xpjI5AACYRB5seAwdgm49kke7H7/m/zbYGTGWdmdveiC1WpqtXndJ/DUxj7+HGCrjN2kyPaZUil0DpCG02cpJg0IUkNiVYYrYgiRaQNUWIJtUEphRACIXyevO0W19R004l+njnMzxzHlrfXkb//unD72vH2cuTb64X2dmP4eqWudtiyZteO2KpFJwlCePi+z5MMPUxqqMYd1eQoupysSIjiGJ1qtNVEiUYlGZ7JkcaiYkMQBHjbDYsgz7uTLSqffLFFZiWyPBIeTpjTDbNvCJMcWXXIviN0BaE7IPMakzuypse6PTIIVqIPsrtCXxC6FnW6EZ0n7DBgpxO6awinC/Z0QUcx280XhOfdFW3uypYy7xAPCn2fWCfs+4Hy+kw23VF9+5P9ZcbULeFhInQNtjqQtQO27laVxXDBjTMqitfHVoWB8tDGcDxXHK8lYdkR5A06sQSLc4sSz7vjXckdAX7wjseSVRRgIo2tCqKxJHeWurRkVXXvq2tIm56sO2HzYo2U74v3mPzA95JVGBKFEWXqsGWHrkd0f0FPr2tv0+5MPsy045nuPJOXNXEc4X1S+2iKlARSEkqFqY6o/itF02CHGT3csGWDtRmun3BNizHme4gfCT+wEiqpCKOQfTWxKzt2mSFJNEG2J0hzZGzw4gQ/jNfHH0v8hXAJ6EIahSGxawmLA3VTsC9z1L5FFg0mTfG97S8R+a3C5SKOY+LF+ndHva3HduMhNts7PHF39ad+/ZYwkGIdMz8KEErgBQI/8gniYIU0S48FYvNlHbX/VbjkcLdLGK6OcS45HHO6qeBwyjnOe7prQVo7RFYR2WIdt//sobfZkh063PxGebow3P6gu8w0pzPH2wuHaYnMwOFyxboSpSTiZ2WL6z9M2a5uRtMzcdPixgl3GtmfT5Tzld04rmtqV+RULiHR9zETS/nLtlnOH6RLsKXykNqiu4L0uSI+5ughx1xK0ktJXme4IqGqdoRFg3TduspU2SNdi0mzzwoXZ+OiJR1eiLszxfMb2fFMejhi+4m86ej7PXVdorTBjzTBMn6RXnO5juIj4ZLB3Oa4xBGmBWE9EOclMpA/FsBqgP9pSXw6P5a8/A+WRm+Wnizh/fiKXxeA+JfsPSr8BwDDYDbN/PxcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createCompiler\"\n        title=\"createCompiler\"\n        src=\"/blog/static/800fff7bc13591c48e262e16c05a1387/17602/createCompiler.png\"\n        srcset=\"/blog/static/800fff7bc13591c48e262e16c05a1387/63868/createCompiler.png 250w,\n/blog/static/800fff7bc13591c48e262e16c05a1387/0b533/createCompiler.png 500w,\n/blog/static/800fff7bc13591c48e262e16c05a1387/17602/createCompiler.png 597w\"\n        sizes=\"(max-width: 597px) 100vw, 597px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>创建Compiler&#x26;&#x26;订阅plugin</h4>\n<p>在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L117\">Compiler的构造函数</a>中主要对编译周期的钩子hook进行了初始化和参数的初始化.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 514px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC9klEQVQ4y42UWZbbNhBFtY2kSQLEQAAEOEikBoqtnhzbvYLsfyc3EdWSHTvt9sc9BeCQDw9VQK2Eceh+okwJPY+UuzVVisi8IMsysru7hTzLyfP8Eq/k32JRFEtcFYVAB4UKAaEdwliE0YjqHA3a+QWpSkQpkFreWOZGImRxE12JQlCqAt2NlGmLDBGRPHLdUMaasNkTt0d0sCgnsY3GxDMK7ctlLrVYnL4JFqg6UdYNhfZIm7A2YKqItp4YA9mff5Bn2fJTdnfheuxlfD3yTbDy6JQI+4566mjnljh1uC7gnCPPizeB7JK3H1k2yyjOORRCoqxBViVxrmkfI2Hvl7HfeWxf0Twkwi5QH2rCPuBHjxs8Ve+wXUV9rKnWjryQrErrUf2MPrxSHb7Qv/6NG59Q8xPy+TP2cOLw/MT8+S+a6ZEiDj+TLjH3G1aFEFTO0bQJ7RWlKyidRJ0r7yXSFMtY6JIsO+dJvI8Q5yMXKGOQoSbsOoavjzTHLfUmsH6Z6B9n2mOPstdK5kuu3mMlhFgEy5Cox47Ny0x7v8Onirgd2Hx6oB5asrvs7fJeqvkei6A2ChMEdthghi1qHTDzBj316M6gvViEzoIfsZJnQWsx3UC1PtCevtKcXgjDgB4m7HBEa7V8fN78Q8GLQ4NpInZ9oJ6/UI0j9jihpwndREotf8vdTVBpg25abL8lHl9QrkJutpj9jDIleX53yd3/XeofuBVFNwm3OxFPr6TnT8SXJ8xuQI97bF3fntdvOyx0QFce17SEbsTVDWUhESairH9z8GuX3wRViapyyrpD1gO5M8hth+wTso+IJlAacbmDNwoK8R3XfrgUxWqUN1R9oH0eSfct8WGN3ybC1OI2gaqrsK0jnRJVX+E3lnrvCGNFmj1VZ5aLv7yUUmnKOGBCJO0ONNOJbn4i7Y40h3tc8KhmRPUHzPqAqRvyPENIsbg7N9hzvDn0wV/ajxDLYvbWjq6t6Tb/rk39Moch1v9Z/Ij8vfV/Hf4D1B5Wg3DBIdAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"conStructorCompiler\"\n        title=\"conStructorCompiler\"\n        src=\"/blog/static/16a0e6501593abc91dcd723939d1ab37/dea13/conStructorCompiler.png\"\n        srcset=\"/blog/static/16a0e6501593abc91dcd723939d1ab37/63868/conStructorCompiler.png 250w,\n/blog/static/16a0e6501593abc91dcd723939d1ab37/0b533/conStructorCompiler.png 500w,\n/blog/static/16a0e6501593abc91dcd723939d1ab37/dea13/conStructorCompiler.png 514w\"\n        sizes=\"(max-width: 514px) 100vw, 514px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h4>加载webpack内置的插件体系</h4>\n<p>通过WebpackOptionsApply加载webpack内置的插件体系,用于内部打包过程的逻辑调用.<br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/WebpackOptionsApply.js#L278\">WebpackOptionsApply</a>我们先只关注一个插件的处理逻辑-EntryOptionPlugin.<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/EntryOptionPlugin.js#L13\">EntryOptionPlugin</a>对不同类型的entry加载了不同的处理逻辑,在处理非函数entry的时候加载了EntryPlugin.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 623px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 113.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAELElEQVQ4y52VWY/cVBCF+0dAJm3f3bvdXtp2r9PTMz1rJkAICCFEgkDiifz/9w/Z7oRE8MTD0a17LR9Xnap7PDNBiMqXvF4p3h0V99uAx60bkUYWIQRSyglC/nf82X5mrMXlKXkes8gC0kVMmockeUiYJLg4xTiLtgrjNNpqtNH/xONeYYIpniklMaHFrh/Q9RW6b7G3B/QiJ2068m5DkMS4xBAVjiCxuMgQ5ec4sdjQEC4Cwswx01qTFhFREuLiDBvGuCjEk4qXFxf48wt8z2fuCb6aK772FBe+4sVcMvclwhcIz0N4Pi/nciLs+pr97Ynl1T314ZZ+u+ehT+iWFa5oiLOUdRHyrnnB95XHq8Lju0qwT3xsEJLWLSbOuK4NM6M1Qjt+ONX8+arg+X7Jm8eW359S7k8b7u4P/PFQ8NNDy/tjzI+3G55Pe55WOcfdinx9xf2h5ZdTwalLBg0VzjnWi5xdnpEOyFKM9hn0dUaSWB9rFBfKMFeWl9rxQhh8bVHa4JQgtQJPqCnDtu9wYczck5jhA1qhlEErjZQaIQ2e0Cil0VIRakk8dF0PZwqpNGJ4phUzZzVR2eIWJevjkm/vSz48Gm5vKtpdw/L2hvpqx+U6Z3W5JVuveNiXPG9zgihGnUk/YmacwmpDschItz3NuuSvk+JuE5HXGW2b0rcxbzeKOjfI2KKdxvcFSvhI4X8x/DOtzVRm0WH6I+Fhz+Fxy6+vS1bHlmS3oWmW7K72XF927KqMfbPg2C14fxnztCrYNBVFmqCNmcbGWkO+6MiXHaIpqeuQu14RNDmuLEnrjqhsWFcxpy6lbgqapqDueoplT5JmKCmnkkdCoyfCque+V7RdwsWiRLmAtkmpq5QyjXjfeTzVljpLKZIYIRViKPtMNmlozBhkcUFar1lsDsSbK5rDDft9T3R7R7Xfs1k1/HwouG5zbBCj1UAmR/0GPQcM8Ug4tN+4ALfoscs9enVNU1d8uHP89lTweF1xt3bsWsfN0vB2Y6mbnKrKqOucritplgVFkU4lfySNmxX16Zms2yBsSGQlTSLIYk2e2hGLxLLMLHEcEkXBiCFOkpAwdMNNORMqia03uO4SOX+JVnLUaC4U/idIPH8yhY8l/qvkwcuGLIfr59IUaew4W6OTCImWPmp40femBiiJ0lMD9Hn9fLhndjBKpQnDkCwKMWGKiXK2ZUQeBYiowCQ5SdkQ58U4EcKbI4XA8/yzfc3P3RaThoMDO2sJ4pJ23fLNMeV4rKlXDfn2mmR14LDreXNVEy1qdLUmKkpW/YKyrsj73WhhYRRNhIOOcRShXTAOeRwoPGuRgwxhOE7AkFnkDMoGqDAez+I4wAXB+JsYfHHoxWhfQ7kD5PlODuIrKcb9eE+HVU6ayvHcH88+Ncb3P707ZjiQTTakvnCO/4O/AQ0qm/A91bEeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"EntryOptionPlugin\"\n        title=\"EntryOptionPlugin\"\n        src=\"/blog/static/04665545a50713018764d15fce4fb16a/6114d/EntryOptionPlugin.png\"\n        srcset=\"/blog/static/04665545a50713018764d15fce4fb16a/63868/EntryOptionPlugin.png 250w,\n/blog/static/04665545a50713018764d15fce4fb16a/0b533/EntryOptionPlugin.png 500w,\n/blog/static/04665545a50713018764d15fce4fb16a/6114d/EntryOptionPlugin.png 623w\"\n        sizes=\"(max-width: 623px) 100vw, 623px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/EntryPlugin.js#L13\">EntryPlugin</a>中订阅了make的hook,在触发make钩子的时候触发compilation的编译逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 737px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPklEQVQ4y5WT2XLTMBiF8xhga5flJV7i1NnqNCFpCwM3XDC8/6t8jNSyTQsMF2d+jWx90jm/tHDW4StH6Etc5fFdgWs82jmsL9BGo41CW43SP6uUEqXUCy10/Mk53HrG9iNuv8aMHaEbqFcTLnhcaXCVxfinGqF/AWrqtiR0PaZZ4dsWUzhEliFEjhASKdWz5A/Fxa9BF845uqHl/HDldL2yO1/ppx3VOFH1I33fYLRK8H/BnoGWXGpuh4pPh4FxtaYuK3y1pF5vqIaR0A4UVZ0yNdb+EZaA3nusMbi65fzxPbuHK8PlnsOHT+wv79merkzzmWk74YsCpTVK/QVorSUqZnl7GNk/XmnOF9rjHWHZIUWO+iW7X0/3aoZG6wT0ziOEJn8rkFmOyAQil6kpsUrxpDSXvgmk+n2jqEXMJdoum4CvDLqw2GApakNYujTna4srLa6IY0fZB0IT0omiM51i0M8ZhpCy6U8XVndH5suRm9OJ9eXE/HjgcNrx9Vxz3g90q45mc8P47o5+v6dpKjZTT7NssD4Q3T5ZNgZpPFJ7NrVmVWqy0CFtwBQ1IQSctTgfqFSGzDJyoVKDXliO99AYQ1htaI8P1Ls7Pl9bvjw0VIcD427L/jyzPc1Mx5n725H2ZoOfZnxZvWhMAsYM2qFnP++YDjvGzcR2aXChRPoS5UKS9BXSOLTzaY2U4ke3v4PT0yvLkrquyaOVLCPLct6kzgqUEKk+jeMVEgn0pxeziHaLUDx3Sv2XXruH3wCPH6pUFa9JtwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"EntryPlugin\"\n        title=\"EntryPlugin\"\n        src=\"/blog/static/42bb465a6651f892662fc51d336de4da/d125e/EntryPlugin.png\"\n        srcset=\"/blog/static/42bb465a6651f892662fc51d336de4da/63868/EntryPlugin.png 250w,\n/blog/static/42bb465a6651f892662fc51d336de4da/0b533/EntryPlugin.png 500w,\n/blog/static/42bb465a6651f892662fc51d336de4da/d125e/EntryPlugin.png 737w\"\n        sizes=\"(max-width: 737px) 100vw, 737px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>打包过程</h3>\n<p>通过webpack(config)获取到创建的Compiler,通过调用Compiler的<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L394\">run</a>方法打包过程.\n在run方法中主要:</p>\n<ol>\n<li>定义了三个阶段的函数 run(开始打包) onCompiled(文件输出) finalCallback(编译后处理) 串联起调用逻辑 run => onCompiled => finalCallback</li>\n<li>调用run函数发起打包</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 580px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e68874f5a553ddb3bda084ca7c980972/b6272/compilerRun.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADOUlEQVQ4y42V13LbOBRA9RcriwUgGkGAVYVqVlwUO7v7//9zdkgpideTzOThDHhJ4hDl4nJRFAVKFew2PdtxzXjesj3sqNoeIQtEnpElKVl6J0lu8XfSlHS6n2Xkec6iUAohBE4Z+nZH7A8M+5Hj9crudEKVAVFaROkQ3iFjhazKG8EjnMV7Pzsm6UIXxRxoY6i0xwmFNQVNtIQYyG1E+BJR+RnZRESobvHUlg5fVUgpb0KjNCJLUc6j60j/9IwNFUny14xUCbJIkDJBiBVSrubrQqUonSFlSrJ6IEsT8jRlYWOD0A5Rr9GbA/H1K8M//9K8vVN/fad+OtK+nImXA83zheb5jD+NxPMWf16jh45MTzMJZCawcNaSG0+5PiHrEdXtqS9X3P6Z+PiKDgO23WOaLeXmEdOOyGpAuoZUVXdZJLNxbhdWSvIsxYQeFTcU9ZqiPyDrHYX1iKGjbkrWXU2epKyWS7JkRZalc7/PLIwt5zWUpacceurDSDwcCNuWcjfgh4AuxU8qgVTZvGbZL4W+QpiA7I+Y0xP9lyP7l0cO719oLwfa11fC44X27dtM9/4Nv78g40hRDaS2JXN3ypbFlC65VFTtQOECyjlCF/F1hS4d2keUrTCxQ4cG07ToEFEhUDiHMAZhLLkyZFKzMFVEFBoZGnS/ph472suactvhj2tsFymiR7ce1XjcNmI3Eb9vsEPE9BOBovJkhWVhtCY3FW59RrZHXNPj6jUqDIhqTeE7MluTu2Yms80cp6Ymm7D/Z2EKRZ5nBGMpq5q8rPH9htC2aJWTJiselktWDw/3dkma3BP586ZMif39LAshMfWWbv+F9cvfXB5PXC9HXq7PXN7eOF4unE8jTddiygo5n918LgjZBxbqu1AKtCwwxqFciVOWUnm6tuHl5ZGnpxPX64XtuMP6QHE/u5PwIz+E0xelcejYUw07bDVVmYisepJVwnL5MLNarUjnHLzJPksXxb3aTEGoPZvdgCv97QUhbzXx/vwzvx3hdFE6x74fsdr+KJgf+Z3gt0KtFONmYOj6X3b8E9mPKU/S0pfI4rY50+5l+Z8Jfik01qCNJkl+/hvy7M9H9VH4HwgQWhFREHjXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compilerRun\"\n        title=\"compilerRun\"\n        src=\"/blog/static/e68874f5a553ddb3bda084ca7c980972/b6272/compilerRun.png\"\n        srcset=\"/blog/static/e68874f5a553ddb3bda084ca7c980972/63868/compilerRun.png 250w,\n/blog/static/e68874f5a553ddb3bda084ca7c980972/0b533/compilerRun.png 500w,\n/blog/static/e68874f5a553ddb3bda084ca7c980972/b6272/compilerRun.png 580w\"\n        sizes=\"(max-width: 580px) 100vw, 580px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>compilation创建</h4>\n<p>在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L1012\">newCompilation</a>中创建了compilation并注册了compilation hook.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxUlEQVQ4y2WUy5KjRhBF+zcEFPWmiockhISARmppNBNjh7cOe2M7vPD/f8NxgHqm/Vjcyk3Viay8mfmSZDlTJfnj7vnt7vnzk+evh+WHsaIIAaslRku0UgghEFn2P2VLFII8z3lZDmcUx9PAdOp43Ae+PEbebiPXx5XpOjLMA92pQ2qLdA4ZPNI7tPcoF7DOrbAFugKNsQQTiSaQmUiiA6Zs8Lsjxf6Ia1p8WaN9iaobdNsg6xLTVOjQEGKJlP8AKq0QeUaaJuRpSp4miCQh22xWiWRDmmzIkg0iTRHJU9miNCVdYiY+gNopbFOjfI0KAVWXqPgemwpZRny1pWhalNMopzCFRnuF9hoTNDZqlFULUKJUjt6f0d0N2bTo+YyZe/R4RPcHXFcRux3VucXvHKHzq/zWrsk8wQplJC8iy7HeUDYR7wu8d/hQoEOJLSLGOkSWkovFyXQt/rd6LcqSjCxd3H//sjQpZQxMc8t0a+mnmuPQ0r7NdLeB7alEBY0MBlUaVHzK1gZbGlz9zFKI/Nk2NqYoZVCFJfSR4lhhtwVu64mdpxpr2oNlmgpeLyXjGOg7Rxkdymq0VaupMpdIKd9N0Rp3nDHdhJ0e+PFOHG/4qkHvR366Hfj9Efl5kvwyG3591Qz7kizLEelHUz8bWyxAhR0/Y+cfceNnquGN7vaV5vSK3/WUw53mfMHvzwhdsMkk6WKmNihjvzf1ClRaoLXBNC3lMNDMF2LXsX29sr9cqKeJsus4DzvqYcL1E7o5oGND2LU0/YS1dh3BFahthlIaU1U085H2baAZOnbzyHY+0147jmNNHHpc31OMZ0ysKA8nqvaIUvLjy4vLizvLLO7qjl084E9XXH8jjJ/w227N3hqDsoHcRXJboKzDhoj1AfW+NL7P8nKEMq6PpMgRy4VFUj4vLdvkv1tGLBsm/deW+VbDvwG+jLNEjVhjvQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"newCompilation\"\n        title=\"newCompilation\"\n        src=\"/blog/static/031d2d99ede16679c6a87ef5bb26a337/32056/newCompilation.png\"\n        srcset=\"/blog/static/031d2d99ede16679c6a87ef5bb26a337/63868/newCompilation.png 250w,\n/blog/static/031d2d99ede16679c6a87ef5bb26a337/0b533/newCompilation.png 500w,\n/blog/static/031d2d99ede16679c6a87ef5bb26a337/32056/newCompilation.png 602w\"\n        sizes=\"(max-width: 602px) 100vw, 602px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h4>调起打包逻辑</h4>\n<p>在<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compiler.js#L1052\">compile</a>中触发make钩子调起EntryPlugin的打包逻辑.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACoElEQVQ4y6WU6W7bOBhF/Rgzo4USKVKURO2LZSm2m6ZNi3n/9zkDyU4AT1L0R39cSASIg8v7LQelFEkiGeYB1zbU00DZlEht0VqSWY0xiiwzFLnG6IQwCG4Kww86GGMIwhBZDLjlhfL6k/Z4pX164fzjlZfvZ759O3G+HGkuz7jhiLI5MjFEkSC4g7fvpoM1BhGGKGXI25H6ONM2E80wMx1bxnlAjxekTvnrbw/f9wkD7wH04DCxGUIIhFLorqI4j6SnkXTqMc4i0xxbOpzLsEbuYE8XCJl8Cj3oLN+BUaLRfY099eRfZuzSkY+ObKjoJsdw7RjXmn+fHT+/1iy9wfODTzJMNEKERDLBlg3VcaYejjRtx/FYsq4N6XAiqkdEVuJyTWkEqbrn9z+Xh0zrPcMoijFZsxejm6+Mw5X56w++fL/w8nrhfF3QzUhYTYRFh8ocsbFIlTw+OY0l0ZahEKjE4PqZvK4Zqoq2KanbElc5lEn3O0HwsVUegPl2cXcYESuFna5Ul1fK9cLTPLKuC/2y4OoKs+cdftp/70Cr1K0oUXwDy4S0X1DNkaJoGLuKZmip2gptc3w/wPM8Au+fm3yPwPdv2vtQJXdgtEtEManrqdZnumll6heG9YnlujKtJ/qxxWQWkdcIu+WYEW9NvnO2DN+L8gYUSGVw3UTeTVR5T9NNzE8TyzowTD2pNQSmQKQ5kU6JlSaSaucc1PuT70AhiEWEjTVaSVyhb4BIEeqcIC2J0oJ4G7vPnqy13sN8g0kpKV1JqlKSRGG35WBTRKyITHZzZTKiWH4Yu9voJY8ZFkVBHMd4/m1uPc/H34oQ+Hc3d/1qlrdt8+awLEu2874AwvC3+tThluH2k2XZAyz4xb77nXbglpu19n2n/QnwP+14BMalEIq4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compileFunc\"\n        title=\"compileFunc\"\n        src=\"/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/1e043/compileFunc.png\"\n        srcset=\"/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/63868/compileFunc.png 250w,\n/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/0b533/compileFunc.png 500w,\n/blog/static/719fb9b2f1d3af5c5b7b458fff431ae8/1e043/compileFunc.png 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n上面从函数调用上打包过程的逻辑已经梳理完毕,那到底是如何触发对应文件的解析和输出的呢?</p>\n<h3>深入打包过程</h3>\n<p>在触发make hook的时候触发了compilation的addEntry方法开启入口代码的解析.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 697px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLElEQVQ4y42T63KjRhCF/Ror5sIMc2G4CiEkZMmKXYnK2X3/9/m2QFZV4nUq++PQ1ECf6tN8PEmp2A41u9OJ+ngljTOhrLGhxPoS5z3eO4SQSPn/etJaYZ1nP888nyYu55lxnkjjjtB1NNuaVHuUkeRWo41G5xql1Jd6MoXC5oZYRZp5JA4dvg7EXU1z2lPPI2kcqKct1VAT2pIi2rVZa73qX4ZKaYzJ8VXL+Xbjenvj8nbh9f3GcP2T7vxGM/9BPx1p2wap8rVxifeonyJrrLUorTnPHT++n3n/+8ztr5mq367n9+a7Ho3/NP00oVoNvfdo4xDKIrVFaEtu7D3SF43/ucPlEmOgsIZs8w2RbRAfdbPZkGUZQgiyDy1Tre8s549nmVjrPbJSGFsQ2i2uagjN8lE6Qt3QdYmqitTB0wRHHRyuKAhNj286XFkRo6PvE4X3q886obGWOD4T+z3l9Ew5nSmPL3SHI2mcCNsDbUpU3Q4X4mpUxMUk4JylqgK2KNC54WlhatmTzC0qlGjnkc4gUkCUnhgtw5AYxoq+D/imQbqA8om86jDGstlkyEfkhUOtNHHY0r9daC8z+8uO6XWgfdmTng+0847+eqS9zpTHPXHbYWON8eFXDlc4lSbVDYfTxHicGA4H6hQw1iFdiTQOaQOyiCjryG2BXghQvyK07nBBpkoJJcWq5b+9S6BEhpRijbTeC/ERT3zJ4zqhc+6+xwXa3+Ttoc9w/wSLso7KFzNfoQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callAddEntry\"\n        title=\"callAddEntry\"\n        src=\"/blog/static/9ef339ea14e4f0e5201b9609222cc31f/7422e/callAddEntry.png\"\n        srcset=\"/blog/static/9ef339ea14e4f0e5201b9609222cc31f/63868/callAddEntry.png 250w,\n/blog/static/9ef339ea14e4f0e5201b9609222cc31f/0b533/callAddEntry.png 500w,\n/blog/static/9ef339ea14e4f0e5201b9609222cc31f/7422e/callAddEntry.png 697w\"\n        sizes=\"(max-width: 697px) 100vw, 697px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在调用了compilation的addEntry方法后触发了如下的函数调用链路:\n<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1762\">addEntry</a> =>  <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1797\">_addEntryItem</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1713\">addModuleTree</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1445\">handleModuleCreation</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1460\">factorizeModule</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1140\">addModule</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1213\">buildModule</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1557\">moulde.needBuild</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1250\">module.build</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1581\">processModuleDependencies</a><br>\n在这一串调用逻辑中完成了:</p>\n<ol>\n<li>入口文件的依赖解析和打包</li>\n<li>入口文件依赖模块的解析打包过程</li>\n</ol>\n<h4>创建模块</h4>\n<p>在处理入口文件过程中,在调用factorizeModule的时候通过SyncQueue发起_factorizeModule的调用,在_factorizeModule主要是根据当前模块的工厂函数创建模块对象,在EntryPlugin设置的moduleFactory函数是<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModuleFactory.js#L192\">NormalModuleFactory</a>.NormalModuleFactory继承<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L173\">NormalModule</a>,在NormalModule中封装了模块的build方法等供后续的调用.<br>\n在创建完模块之后,通过调用addModule将创建的模块加入到ModuleGraph中进行存储.</p>\n<h4>模块解析</h4>\n<p>在添加到ModuleGraph后,调用buildModule通过SyncQueue发起<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1224\">_buildModule</a>的调用.在_buildModule中发起了module.build的调用开始文件的打包处理.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 634px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACY0lEQVQ4y5WU3W7bRhSE9Ra2JJL7z12uuOKPJdlSZEZG2qRugV70qkB71fd/h69YKjWMxm2Si+GC3NnhOTMHuyiEYhs0f0yKvz7V/DbVNIcTYRzZ9oHTNDIcEq5xCCWoqoqyLOf1LSyErVFKknYj3UPP4ZQY7zvaIWK8ohkcYXDYqJFWfCH27/eFEBVCSDbDHtsk2jbSpgbvPet1SVFkopwhpKISgmK1olivX8Reiy7yQwiBqEqaYU//9Ew3/Uj3+IFmd8R1ezb3Z4bLR+5++Jnu/IRvO2yzmcW/qDB/zIJ17WeSjS116rCb9npIW0pp0Xk/trhNwsWECfFtQSmuRvvQkFJP0420/Z5t7Kl9IKVA8BbtasrVktXy9v9b1mWFkAIpJcZvSceJdDjz6/sjv/904s9fjny4PLA7P7J9eMRvErmI8lUorzG3nAlKKex4nL3bv39ien5m2B+Yznvu3p1J+wdCFlN6tui/x0Zcq8uCOZR4P7E73rM7v5t/dHNzw/L2ltVyySq3WpSURfEK6xdUc4VVNQtqJZHWY7aHazhNS93EOQwfanxtCdZgdbamwYYGk4MK8TM/orTOguU8hypXWUfMcKI7XRgun+injwyXZ/rdSPSO5CxeKVzbU6ceF7f4NOK3d/OqtWEhPnuSW9bWYTaJZuywwaKDxUaHMJJSllRGIKxA6hIhiyt0gXLlDGkEC2EcoqquoViLsgoTNbqWaK8wQaGcRDuFbTQm6HnfNJmTuQaX7IzMXVzTERhriJtIVVYU62z8tyPz/znzEkoI4as3ybdgFpxbVerNyf9ewb8BtKTIWzZXMsYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callBuildInternal\"\n        title=\"callBuildInternal\"\n        src=\"/blog/static/a0084889d86f5adb501cad2a829b8292/374ac/callBuildInternal.png\"\n        srcset=\"/blog/static/a0084889d86f5adb501cad2a829b8292/63868/callBuildInternal.png 250w,\n/blog/static/a0084889d86f5adb501cad2a829b8292/0b533/callBuildInternal.png 500w,\n/blog/static/a0084889d86f5adb501cad2a829b8292/374ac/callBuildInternal.png 634w\"\n        sizes=\"(max-width: 634px) 100vw, 634px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n在module.build中发生了如下的调用:\n<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L853\">build</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L661\">doBuild</a> => <a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L984\">this.parser.parse</a>,主要完成了:</p>\n<ol>\n<li>在doBuild中调用<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/NormalModule.js#L728\">runLoaders</a>调用设置的loader解析文件</li>\n<li>通过parse方法解析生成的ast 生成依赖模块的信息</li>\n</ol>\n<p>在当前Entry模块解析完毕后触发回调回到上次发起<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L1288\">processModuleDependencies</a>的调用开启依赖模块的打包.</p>\n<h4>打包文件生成</h4>\n<p>上面梳理完了模块的打包过程,通过loader的转化能力和plugin的劫持能力已经将文件转化成需要的内容,它存在Compilation中.通过make 钩子触发编译逻辑之后通过调用compilation的<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L2141\">seal</a>方法生成文件.<br>\n下面是seal中的一些关键方法的调用梳理:\n<a href=\"https://github.com/blob/cde1b73e12eb8a77eb9ba42e7920c9ec5d29c2c9/lib/Compilation.js#L2141\">compilation.seal</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L2168\">EntryPoint</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L2284\">buildChunkGraph</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L2375\">_runCodeGenerationJobs</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L3651\">createChunkAssets</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L3643\">getRenderManifest</a> => <a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/Compilation.js#L3754\">fileManifest.render</a></p>\n<p>上面的一系列调用主要做了:</p>\n<ol>\n<li>根据入口创建EntryPoint 他是一个chunk group.负责维护与入口相关的依赖.</li>\n<li>buildChunkGraph 生成模块的依赖依赖结构 相关的模块会保存到一个chunk group里面</li>\n<li>_runCodeGenerationJobs调用module的生成代码逻辑,生成代码</li>\n<li>最后通过getRenderManifest fileManifest.render进行最后输出文件的拼接.</li>\n</ol>\n<p>比如在入口函数中会通过<a href=\"https://github.com/blob/1bfb44678e8dccba3d96614df3e12778c4675655/lib/javascript/JavascriptModulesPlugin.js#L546\">this.renderMain</a>的方式拼接代码.这样就添加了打包出文件的Bootstrap逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 646px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNklEQVQoz42SWW7bQBBEdQ6J5Owrd1mUxUSOEPv+Z3oGR1ZiA0GSj4fGdAM11TWzE02NdBE3X5he3kjjjIo9aujQxxE5doShwyhNXdc0TfNHHrNdIxqs8cThiW694WNivz9Q1TWHqi51o/6o+6oq/UOZV4WH2FZ3QkqUkCSfyd/faK+vDC8/ycuV5Xziuk5cziPP55HrOnNbj9zWhSFFotUEZxBC/Ha4HYQUxJiZ5gv9ONBmT3KG7AxWK7xRWCUJRjMEV8gf8xQsQsivglIKQky08zP9NDL0ic5b+mCLizH6gtN34ac2cGojU9r6jqkNOGfvK2+qSiliP2Jixmp9v9kagtNopf76GI/svjg01rAsPzievhG8Y4qOOfmy7ud8/sUvh8YYXO7QIWGUKlltbM4/f4n/4R1XDeNFpqw4PgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bootStrap\"\n        title=\"bootStrap\"\n        src=\"/blog/static/71dda616183f18729fcaba2eba2042f8/27524/bootStrap.png\"\n        srcset=\"/blog/static/71dda616183f18729fcaba2eba2042f8/63868/bootStrap.png 250w,\n/blog/static/71dda616183f18729fcaba2eba2042f8/0b533/bootStrap.png 500w,\n/blog/static/71dda616183f18729fcaba2eba2042f8/27524/bootStrap.png 646w\"\n        sizes=\"(max-width: 646px) 100vw, 646px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>以上从源码的角度大致梳理了webpack整个构建的流程.通过源码的阅读可以看到webpack在设计上一些可以借鉴的点:</p>\n<ol>\n<li>webpack通过tapable实现代码的构建流程这样在实现上业务代码的职责更加单一和清晰,但是一定程度上也引入了callback的处理逻辑</li>\n</ol>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"深入浅出webpack-webpack源码解析","date":"2021-04-12","tags":"工程化","path":"/webpack-code","top":null,"summary":null},"title":"深入浅出webpack-webpack源码解析","date":"2021-04-12","tags":"工程化","path":"/webpack-code","top":null,"summary":null},{"id":"1cb29b0e-5c80-5d18-8eed-d5341dc110dd","html":"<p>webpack是前端代码的打包工具,熟悉webpack的的工作流程和相关配置有利于在业务开发中更好的组织业务代码和实现一些特定的功能.webpack主要基于loader和plugin来实现代码打包过程:</p>\n<ul>\n<li>loader 主要提供了非js文件的处理能力 通过loader依次对目标文件进行编译</li>\n<li>plugin 主要通过webpack在编译期间的钩子来对编译过程进行干预</li>\n</ul>\n<p>webpack的钩子触发逻辑都是基于Tapable这个库来完成的,在深入浅出webpack这个系列文章中我们先从Tapable的源码开始逐步深入到webpack的源码中来了解webpack.</p>\n<h2>Tapable的简单使用</h2>\n<p>Tapabel提供了多种类型的钩子和订阅钩子的触发方式,这里以SyncHook来梳理一个简单的钩子使用方式.</p>\n<pre><code>const { SyncHook } = require('tapable')\nclass Car {\n  constructor() {\n    this.hooks = {\n      // 定义一个同步钩子 钩子的构造函数接受多个入参\n      accelerate: new SyncHook([\"newSpeed\"])\n    }\n  }\n  // 定义设置速度函数\n  setSpeed(newSpeed) {\n    this.hooks.accelerate.call(newSpeed)\n  }\n}\n// 实例化\nconst myCar = new Car()\n// 监听钩子accelerate的触发 \nmyCar.hooks.accelerate.tap('acceletePlugin', (newSpeed) => { if(newSpeed > 100) {\n  console.log('不能开太快呀')\n} })\n// 调用实例方法 设置速度 设置200的时候 会触发提示\nmyCar.setSpeed(200)\nmyCar.setSpeed(100)\n</code></pre>\n<p>通过上面的例子可以看到钩子的触发的逻辑是:</p>\n<ul>\n<li>创建钩子,定义钩子参数</li>\n<li>订阅相应钩子的触发和拦截功能</li>\n<li>触发钩子</li>\n</ul>\n<p>通过钩子的触发逻辑可以看出Tapable的实现逻辑可能是基于发布订阅的方式实现的,但是它里面对订阅的处理是怎么处理的呢、如何高效的触发呢? 这些都是成为一个优秀的库所必须要考虑的事情,我们就带着这些疑问来看Tapble的实现逻辑</p>\n<h2>源码逻辑</h2>\n<p>以下源码梳理以SyncHook钩子为切入点,分为以下三个模块梳理:</p>\n<ul>\n<li>钩子的构造过程</li>\n<li>订阅过程</li>\n<li>触发阶段</li>\n</ul>\n<h3>钩子的构造过程</h3>\n<p>在通过new实例化<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/SyncHook.js#L35\">SyncHook</a>的时候在SyncHook的构造函数创建了底层Hook的实例并且重写了Hook的方法过滤了SyncHook不支持的功能\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 469px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABxElEQVQoz32SSY7bMBREfY1Y1ERNlijTFiXLmmxJnhKgk00WuUZWOf8L7E660Y1OFgUQxK+Hqk8u3CBGbjv8dY1UhrbZchgq5qlmW7eo5kiSpmy1Jsk15fUbySolyEuCckRu9sSmoygLXM9l4fk+wSoiUCGrMmFdJ2z6DDMr1D5l3WvWfUpWRbiehxeEOI6D4/k4foDjSVxfIgP5uF/4novMNkhdI7VBtmdilSFzg78tCcYa1dQU841YrVl3I6Y/EvgeQljYto1tC4QQj/PCc10C0xH2F/L2gBou5N2EPpxJdIGpNNNpz/XzgX7Y4cmAeyvXdZ+TvtPCv1dOQpIyYXdYsW8jmj5GlRGqStkeFc3FkOsUyxI4tv1ivkPf61E5NB1+c+HHmPHru+bn14xOh+Q65zTXXK8tT08jSq2Q0vsw2WvC+w5Ni9ec6dqC26nidtoxDAZjNoxTzTTVzHPN+dxQGI1lWQ/z8/7eauE6NnHRkrY3mn3F/GWi7mviKGIYSo5jRbXbYNsuy6WFEPYL7MOEURyhVzllskFFGW45EBV7HCFYWuIPRLwx/Qv2AKb3LxIGfLKWj+d3xBJbWB8O/w/0F/gbfDImzfUplnYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"同步钩子构造函数\"\n        title=\"同步钩子构造函数\"\n        src=\"/blog/static/fabb95efaaa8baad0c7438753b657a71/5f759/SyncHookCon.png\"\n        srcset=\"/blog/static/fabb95efaaa8baad0c7438753b657a71/63868/SyncHookCon.png 250w,\n/blog/static/fabb95efaaa8baad0c7438753b657a71/5f759/SyncHookCon.png 469w\"\n        sizes=\"(max-width: 469px) 100vw, 469px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n在底层<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/Hook.js#L25\">Hook的构造函数</a>中主要做了如下的处理:</p>\n<ol>\n<li>入参存储</li>\n<li>创建不同方式钩子调起(call)逻辑</li>\n<li>创建不同方式钩子的监听(tap)逻辑</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 441px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/cddadaa923563693da8a82c7e4708f08/efc6e/hookCon.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 142.00000000000003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAAE4klEQVRIx32Va2/bRhaG/Su6tkRyOJzh/X4RKVE3y5bt2AnSdNMWbrPtdi/AFtgW7WL/P56CZOzYTdoPQ1Eg9eg9533PzInjCFSUoeoddtVivX2H+eZ7rLf/QNz/G+v1t3h+iMoaVLNB1z1xVRPGEfXVHUW7xPc8TNPEsixOdDTDsmykKwkWAclFRXJRk143xJcNwa4kqD2izifbx8TLgKj1iVcB6SbGVjamMcFGoJucYZk2UgvCxiXZBgQLl6DSlGvNcq8JKxcv14RLH+FKTNtCSIElLUzLxDIn2KDyREUzxKDQ17iFR7UOyDKNqnz6VnHff0YSCYLaJ4wduo1Pe5kSLXzKfYxynecKhZhuVFKj05Yvzhu+2mf4YUTVLFjUJU0V0+9aXl8t+PlKsS89FklEEwdEUfSobgSapoW0bXI/oY0bSi9CJxVeWvHjpcPrlY/2Q+K2pz0/Eo+K5pjvIQ+gR4VybhBE0ahobhqYtj2+LCwL25ghzPn7HxoYhsHcMBhEDN/N8f7hc4Kf+FIivRDVHJB5jdr3uHWF7wcIpbFsOVYgpcSWDo52EWIwxEEoD0sqbEePzyeFjsIZoFGBqrbItEWmS8K6p9ofSboNeVGQJAlh1VLsjrieh5MvccoembX45YogCBC2zYmQJkLY2EIgkxKvrMg3K8rDBa7rElUteb8fWzCW9qS8T5aswik2trRxAhe/DsjPc+IuRjoOUnsMVVi/a/4frZPhMvTEHvqUL1FpQ7m/Jm3XYyQWl7dEefloyhjkJzH5CDg4ZttiKrnoUcmC+vCCvD+Q5hVNt0YqjS0kruthDYb8GdB2jKmHg8I4I6grkvWSaN1THg/k5zv8siCIPepFgRAm89n8EfpRDp/30MMtfYqFZrMOiBpNdShotgXlRUN+XpOsKpwnu8vjGuAPJYuhZFvgFD0yafnuWPOf64IoCvnrv95x//OP3Pz0X27+9yuf//8Xiq5hfno6Tcx8Nq330JPBkMkUgcy60ZQfLhO+2ccUfc/du3t2X37F9d9/4Oa7b9n/7Z/4VYepPOwwRQQJdhB/UPjBZTG67GQt7y4Lfvp8SXN5S7hYE4c+3x9i7voUsXmF3r1E7+5Qhze4118TLvdYQx4/AmZL3Kzhy13Ky5sD2e6aqKgo6obXdwfK7QG5uUX3R9QA3b5AVSuUF2AY84fYmGNkRpezDp0tSDYXlMdX5Os9URzhbF4gr+9R+1cjxL38An14Q7DYYM1OHw0aJ+V5sDvcoiNtl2TdmqDdobMGvbnF21xjJTVm1mHlHU65QvnhM9h0pszNyeUh2HmPSgfghrha4lZb3GyJLLZ4SU2ReGSxRxzqyVnD+JDHx/1Qz6ccDgrDiKDJyHct5dU5+bokyofjoMQtY7bHhtW2oijS8f1PTcuJ4z0BDhttnZL0FWHu4jcxelFTtQHdNsVQJmfGjL98djrO9cPx8RT8YZbHHk6zXO5vKPoD3tCrICetGqplTxS4VFVCloW4rub0dDaCn/XwwZTh34ZJ0XlLc7yle/mW5uoVebdCRxkiX1N0S+7uNty93LLdLWiaDKUUxtNTb7gM27fneQgdYGsfPyvw0gI/K/HSEuVIbDfAVMMp540Kk8SnLJNPA4dyhwfmfD7O53x29riMYRnmNLfDs/mc2WxaZ2cfl/wbpkc9NezuXmIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"底层钩子构造函数\"\n        title=\"底层钩子构造函数\"\n        src=\"/blog/static/cddadaa923563693da8a82c7e4708f08/efc6e/hookCon.png\"\n        srcset=\"/blog/static/cddadaa923563693da8a82c7e4708f08/63868/hookCon.png 250w,\n/blog/static/cddadaa923563693da8a82c7e4708f08/efc6e/hookCon.png 441w\"\n        sizes=\"(max-width: 441px) 100vw, 441px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>订阅过程</h3>\n<p>在钩子实例化的过程中返回的实例绑定了不同监听钩子触发的监听函数,这里我们调用<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/Hook.js#L77\">tap</a>函数的时候,会调用内部_tap函数并且传入绑定的sync参数和入参.在_tap函数中对入参进行了处理和过滤器处理\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABR0lEQVQoz4WRSY7bMBBF+xqtkRLF4iSKtGTHQ3eCbHKF3P8mLzDjAEE2WTyABImHX/Xf3ruRH8fEz+8Of/9G2Av545P8+IqEhIkZEUvXtnRNQ9e1L7rf9+a9vvV9zzAMvI3DwLws+GNnvV/wJeIfG3LPaDFsybGuDhHBxA0tFm0dWmtk3ZBUMC4wjkOVVuGkNf44SB8X1mvCPRLDFtFW2DZPzhHrPPb0BW0Ds3gWI8i2Y/OODZFx6P8R7gfpcSFeInJKqMXjRHM+J0qJpOQ4ZVcTn0qgZE9cYxW6cmB9oO+6vxMW4m3Hl4Bkj44BMZqcQ5V5b/BeKs8VBG+wIWCeY8fEYswr4fgULqhYkOi43jeut0S+3vDnB36/Ms8zTdvStl2laf6cX0W1TS2plqKUqgvvR8U0zUxKMQ4jappR8wul6uf/8Uz4CwkaymFOFPmPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"_tap函数\"\n        title=\"_tap函数\"\n        src=\"/blog/static/b003abad27e92cd6307a316a5118d62a/267f6/tap.png\"\n        srcset=\"/blog/static/b003abad27e92cd6307a316a5118d62a/63868/tap.png 250w,\n/blog/static/b003abad27e92cd6307a316a5118d62a/0b533/tap.png 500w,\n/blog/static/b003abad27e92cd6307a316a5118d62a/267f6/tap.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/Hook.js#L136\">_insert</a>中会根据当前监听项的信息将它插入到taps的正确位置.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABj0lEQVQoz3WSyW7bMBiE9RyRuGshRcm2YsubrDhxXNSXPkRPPff9D18huU2CtD0MBvxJDmcGTISU5Eqwrx4YQkbvJcYVaFdQliXGGLI0Q2SCLBWICdkHCIGUcuYJSSoUbS75cTH8/Ob5fqtZDgOPX270xx2+9Ugr0U5hvcGUGu002qp5pox6E52QTAvnHMYZbHAUq5ywzml2BbEvWY6R9hCIm4r1taV7bQl9SdE4/Logj252+i4oJcZoTFFh1yNlu2S3W/B07nl+2XK97jmeHhnPG8ZxQ7fscMaRPqT/jJ8IKbDW4gqD85ru2rK6xPn1ZvAsn2sW55rVayQePUpLtNVz1AlzdHuvQCpJMtl01uEKhws58RBYnCO+K2n2gXYI1NtA2FSzcL2tCJuSuq8IfUU8eBZPNe0pYJy+R3bWYkuP7QZ819O9fGV9OtP1W6pqEh7pL7e5mrkrJVHqzn+6e+swS1Ni2xDbSJoJlNZoY2dWSv0WuM8+fo//IZn6a5pmvvy+kf19OMuY+v7s6LPDXzgWA4uhdV6tAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"_tap函数\"\n        title=\"_tap函数\"\n        src=\"/blog/static/44794c72173ba543b2450d5ba600480b/f687d/insert.png\"\n        srcset=\"/blog/static/44794c72173ba543b2450d5ba600480b/63868/insert.png 250w,\n/blog/static/44794c72173ba543b2450d5ba600480b/f687d/insert.png 423w\"\n        sizes=\"(max-width: 423px) 100vw, 423px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>触发过程</h3>\n<p>在触发过程中是通过调用hook实例上的call方法,这里我们先梳理出call的实现过程然后在从源码的进行分析\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 363.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCABJABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHu4IVAFRkLGAqUmVNDJvIuAKtNMAP/xAAaEAEBAQADAQAAAAAAAAAAAAABABACESAx/9oACAEBAAEFAtYxjEgiYj4vULjGNxx9f//EABQRAQAAAAAAAAAAAAAAAAAAADD/2gAIAQMBAT8BL//EABQRAQAAAAAAAAAAAAAAAAAAADD/2gAIAQIBAT8BL//EABoQAAEFAQAAAAAAAAAAAAAAACAAATFAQeH/2gAIAQEABj8CW0nkuD//xAAgEAACAQQCAwEAAAAAAAAAAAABEQAQITFBUWEggaGR/9oACAEBAAE/ITkRlP6FDULLvfuic/JtkX4gLjCbQhJ2MWlgm+GtxHruYIpLz9ppmL7K2LvtZppPY8X/2gAMAwEAAgADAAAAEKPMDHPHPOPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAMP/aAAgBAwEBPxAv/8QAFBEBAAAAAAAAAAAAAAAAAAAAMP/aAAgBAgEBPxAv/8QAIBABAQACAwADAAMAAAAAAAAAAREAIRAxQVGBkWHR8P/aAAgBAQABPxC4CltmUYRJoDgAKWV7SfmGoR3EdDhJmid9sJKjpt7D3AFNmKin42TFZ0KhHeBgk24RdhCfZym0m3QN56PgxKH8rlXoV2Or5xHbbyFxIqAZ/tcCh9ncwJYZ/Y47rXu0uNfTfQh/eDn/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"call梳理\"\n        title=\"call梳理\"\n        src=\"/blog/static/542d374ac0a67cda1e65467eec38cd64/aa65c/call.jpg\"\n        srcset=\"/blog/static/542d374ac0a67cda1e65467eec38cd64/0479a/call.jpg 250w,\n/blog/static/542d374ac0a67cda1e65467eec38cd64/aa65c/call.jpg 313w\"\n        sizes=\"(max-width: 313px) 100vw, 313px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/SyncHook.js#L40\">SyncHook</a>实现的父类的抽象方法compile,compile方法也是基于基础类HookCodeFactory组装实现的<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 111.20000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD4ElEQVQ4y32U2Y7bRhBF9RW2h71xF/d9FSmNZvPEAZz8RZ7y/68nIEcTO3bgh4smC+RBVd/CPZTGotWKNjC0vqHbTk/TeJr+aDOmzl6vjdrfh8Shj20qJSnlN9VCkEnJYYju8H2bqA/IzzHZFJIOIVHtUV0TsvlI0gckQ0D1GFE9pCRViJISJSRaSqSU2FpTbcDKlgRZQ1DVHE8l4bknvPQEa0+wtDhNgVtkBO1AOJwI+u27CW9o8YYGp8oJqoLAcSmE4JBakjEP+ftLyl+fE7qhJT4/k5+vpF1HebnSPX/hWLRk8xPpfE/x8Ey2vp3JMFG0Db7jkFsWh21+zyjqKOKxbinSFL+aqOqSeel5eFqZ14HLpWUaG45RhOuH2LaN0QatNUopbKXeOtyArrHRts14OTHfL0RRiOd5uMeYME5Qjk/TZDRNSl7mxGWD7/v73WmtUPoHoGcbjO1QnJ+pH38n7WaOZcuxqPHjFCUFQsibBFKIvautu71Drb8BN2dcrUnTjLSoCOKEY1YSFTVR2RCmOVopjNY/a4MqtQOdd+C2O47vYYchd0ryUVi7Plh3uz5aFp+U+kkft1NrrJs26A58UIoXz2eyBJPQTNKwSMWqNItSLEZx0jcZvZ+LVlyMYbUsKiFItuUWYn8+zJakKWfKpOJyWlgvj/R5QRVXlPVA2bd060y7znSXE+3YUdUFfZ4xbstsWbhKEdycPhTblhcDqj5RLyPLWjNNOV41IIoZp5op718p719ImgHbdZFK82EzU0oiKbnTGnkb+1BYFqHr0/XPRNlMNC401weyfqIbW9brQvv0heb6Qtl0uxnvRhyl3McVt9qmQ2s0WRzjGwfPGKQbINwQ2/UIQ5cg9HCDI05wxA+PGGP2lRFKvQGF+Be41Q+1lHTGkAuxp0YrLRolaLY0sSTFpztqsV2+RXF3t2tPGG1opSIxNsqYtw63kZU2OHmP16x45ch0mblcek7nifLxM/E476NGeUX3+idlP+EXPW454pTTXncdB/kO1ErihAled49fjQTr6x4Ex/ZMWJfU547L05VxPRFVHXk77FG1xdf27x5jN9g+8lY0SYmzvNIsC+vTme58Iq47/GYmP63Uz6/UTY4WFsKydkP0D3qHHmwlKYKYopq51Blfl5IvU8GahvRVRzE9U51+Izm94hVvLv8f8F2HUAimIKYcn3gcWr4+zdy3BUue8Me142XpGJOYRjto17u5+QugYzStF3CftJyOGVU702QVqRSkWpEpSSYFgbCQars3/RZZ36XNf4C242B7HpYUWEphybcdE0q/vSu975n8Lqp+1eE/vS2C791tVqkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compile实现方式\"\n        title=\"compile实现方式\"\n        src=\"/blog/static/f40c6fcf44a8453f6214b5593c81ed49/267f6/compile.png\"\n        srcset=\"/blog/static/f40c6fcf44a8453f6214b5593c81ed49/63868/compile.png 250w,\n/blog/static/f40c6fcf44a8453f6214b5593c81ed49/0b533/compile.png 500w,\n/blog/static/f40c6fcf44a8453f6214b5593c81ed49/267f6/compile.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/HookCodeFactory.js#L14\">HookCodeFactory的create</a>方法中通过调用contentWithInterceptors进而调用子类SyncHookCodeFactory的content方法,在子类SyncHookCodeFactory的content绑定的SyncHook的实现逻辑callTapsSeries.\n在<a href=\"https://github.com/webpack/tapable/blob/acd0a66d3769120b1e9e5b66823475043237f30b/lib/HookCodeFactory.js#L276\">callTapsSeries</a>中主要完成了订阅数组taps的代码串联逻辑最后返回new Function完成call的调用逻辑<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 655px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 122.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAADa0lEQVQ4y5WV627jNhCF/RitLVHiRSJFibr6GifeptldYIGiKAr0/R/lK0gnzgZFiuTHgQiSOpzhnDlcKaXwbcfXv/7h659/c3n6zjjNyLIkrkkpP4WVMYY8z/H7e/rLN+owIoqSXIg0/1kkwqIoaKYd7e6ErmqkUmTZBiHEp7HSWqdBOF2Yf/9Bf7pg+xFVO4TIbxvj6R8jlIpI2oQB03RU7UDle1TdkG3yhDzL35D+H/mqrhWllOjGY6eJZmhxjaSQG5Qt0F6hrLyRvoeXQ1bG6nSHhbVUweP3M37bMTwcafc92pdoF4uUkeeb2+VnWUaeZdfvT5GvjPOJ0DWeZhkJ91u6Q093f2C4HGiPI+1xoLsb03osWCkVta3RRqO1SXJ5jbC5EtbKUHUNuvPo1lIvge64xS89buzwu57utOC3Djc4jKnQlblp9ZWwqilETlk5yn6LP90x320ZdiPd3R3NsqCsRZoYmaCQAlGKW8ovV3BLOZ6Q7lAqnBs43J25/PjO/nRgbGfm3Zkm9Gk97kvFyd8vTNJh3Ki0ojOeYEfGZWKeR6y2iHVGvsnI1hnZJkuESU7r6/hnXGXTKIQo0EZhWoX2IsH0Ejtr6tlgOo2dDHaucEuNaTXNrqYeDFXQ2NFgvEqkqzpqrigolUKFhvow4M4Lfudx+8Bw3zHsPOHY4cYK7SV20tjZIKQgFzmFLCjK4m3KhdQs+y2H8xE7H6jCgmpGjseZ03GinxZcmFGuo/AzXduw3/XMU0CWr8K/mUMhBNPUcv94xg89sfrxxKIQqafTuCwoohOV16ykjBYn33bKS4RlWaZKbp/+YDg9Mi0LztW3+VJphFQJRkuqSif9Zdk7sok/loWgqxucrGl9zTg2WGeJ3WTDgIym4QPj0LDdBrrg35dNTC0czkwPj7hhojt9oRm3NF1PGZYk4s2vv5BnG9brKzabDVnC+r8pR0LTtAwPT4xfvjFenhjOv+G8p3INxkdrC0itqesKbQzKVM+WF27tl4oSmWtr8WHADjMueqMPVOMOG0aqqkqE8XlQxmBiD+tnwuf58oUwRliWRbJ+04brJqUQpUK4QOkCItrVZk22XqcefkGyr+f5W8rx9CiZYXuiDSPjPLDsBtq2SUTxp4++JynCl+fPGXfFMKco3xJFaXzskfoX5gqrdJg+CAsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"callTapsSeries\"\n        title=\"callTapsSeries\"\n        src=\"/blog/static/0a6bef843d8f38a95e315423b2739054/ae6b7/callTapsSeries.png\"\n        srcset=\"/blog/static/0a6bef843d8f38a95e315423b2739054/63868/callTapsSeries.png 250w,\n/blog/static/0a6bef843d8f38a95e315423b2739054/0b533/callTapsSeries.png 500w,\n/blog/static/0a6bef843d8f38a95e315423b2739054/ae6b7/callTapsSeries.png 655w\"\n        sizes=\"(max-width: 655px) 100vw, 655px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>以上梳理了tapable中从生成钩子到触发钩子整个过程,可以看到在实现上tapable许多比较巧妙的安排</p>\n<ol>\n<li>Hook基类实现了所有钩子的创建方式 子类可以通过组合或者过滤对应的实现来实现不同的钩子</li>\n<li>在HookCodeFactory基类定义的工厂函数的不同组装方式,子类通过父类的接口自定义了不同的实现方式</li>\n<li>在实现call方法的时候 会使用上一次创建的结果函数</li>\n</ol>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入浅出webpack-Tapable","date":"2021-04-06","tags":"工程化","path":"/webpack-tapable","top":null,"summary":null},"title":"深入浅出webpack-Tapable","date":"2021-04-06","tags":"工程化","path":"/webpack-tapable","top":null,"summary":null},{"id":"60806375-3fd0-5bef-96e6-1328e8a6382f","html":"<p>在使用React进行业务开发的时候setState可以对组件的数据进行更新并且触发页面的渲染.本文从源码角度梳理在调用setState的相关处理逻辑.</p>\n<h2>前置知识</h2>\n<h3>React多平台渲染</h3>\n<p>React在设计上使用了依赖注入的方式,通过注入不同平台的渲染renderer来实现多平台的渲染能力.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/5c744/reactRenderer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABg0lEQVQ4y5WUiXKDMAxE+f/fZLivHBBu3HmiSyCFdsrMxrItrVeyHG+aZjdNk2EYhg37ed/3bhhGWxvH8Xv+9tvD42dZFvd8Pl1RFO5+v9tYlqWhqip3u91cnucWwBwbvziOjXSeZ8OBEIfH4+GCILAAwDxNU5ckiZGiTERRFNmeCDeFTCB8vV7mjBMq6ro21aiUcvyaprG1LEttpAQHhTK0qJRQByFqAAegEmL2sed5+VnDvVzZpNZ1nQX5vm/AZo09sBexjz0QrlhLQG1QI3IUY7O3J7pU+Jm6LqBtWwM2xErzLO5C4Tt9LoBLAthXvr8qlI0qLkKE2HQCKf9LIW1AEJdAW1A72Yzs4fOnQp1CAB+K9EoYAW3Eh8+VUk9kfKQEAYHquTAMDdgiZY8D+U4VkgKOPDs9M/UhTwxg00qUgEbHl0NOXwqOWZYZKQEokVrmSp/gtQSl+XL46VtmkaJD0rYrkd72utZuhPoTYY03fvpvA1CBM8DG4WxNTQ4p+KzhFxiCKgcyB0LkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react renderer\"\n        title=\"react renderer\"\n        src=\"/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/00d43/reactRenderer.png\"\n        srcset=\"/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/63868/reactRenderer.png 250w,\n/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/0b533/reactRenderer.png 500w,\n/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/00d43/reactRenderer.png 1000w,\n/blog/static/9bca1c5b0e82f7200da7c0c3d9f20d54/5c744/reactRenderer.png 1206w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在创建组件实例的时候,React会注入不同平台renderer最后结合react-reconciler来实现组件的渲染更新.</p>\n<h3>事件循环</h3>\n<p><a href=\"https://icantunderstand.cn/event-loop\">事件循环</a></p>\n<h3>lane</h3>\n<p>在react新的架构中定义了lane的概念.lane用于控制不同任务的更新优先级处理逻辑,具体可以参考<a href=\"https://react.iamkasong.com/concurrent/lane.html\">lane模型</a></p>\n<h2>源码梳理</h2>\n<p>基于React的多平台渲染架构,在梳理setState源码是从以下两个方面进行的:</p>\n<ul>\n<li>注入渲染renderer(setState从哪里来)</li>\n<li>发起调用(setState做了什么)</li>\n</ul>\n<h3>注入渲染renderer</h3>\n<p>在<a href=\"https://icantunderstand.cn/react-render-interpretation\">图说React渲染流程</a>中,React会根据当前的页面结构创建workInProgress树,注入renderer的逻辑就在创建组件实例的过程中.\n在创建<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L943\">类组件</a>的时候,会执行constructClassInstance创建组件的实例.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 724px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACeUlEQVQ4y42T247bNhRF/RuxRPFOUferZXuMMdpBmiAPyUOemqekLfr/n7AKyc5MGwRNHjb2JiQungMe7jIpcc1IHE8My8BwHJhOE93cEnNPlmUIITb/Ge0yISjHhf76muZ4oTssNEOLizn7V/vnH38WuhNpSnv5lfOH3xmuT9SPJ6R3rAet1X+74UfgnVGKEAtsHrEh39r0uSdNEtJkf/eEZP8KIdIfQnd6DcYhpEasrh3GOlxR4coamxe4WJK3A9qY/4Wt33ZZJvD1RPnwRPP2I9Nv76mmI7GfyOv2BiyqO9A+A1f/Xt5JKQnaUtQ9+eFC1fX4siXUPVYrkue2999t+VvwBtRao60i1B5fO0LrCN0t+8ZiosGVFl9bXGXw7S2bqHGlIR89tjT/AhqNcpJ8tITeEjpLPjri7MmHFe6Io6dYAnEKFHPYgF8PWGFrESbolwp9WVEtR8pxpDwsxK7F1S3aWZRRKCNRWm6+tZekiESQJinp5uKlQrUCu57q4bKpXBbifKA6n3BNjS4qpFVkViFWaNBIpzatWTmFdur+UjJJNIa+rpkPh01D1zLPM0NbUg3TdutVDESTEbWkcOse+ZztWr29A7XMaNYqjcZ4g3Gr6829TIk2JTerBEHdsxbkKiUYQakzYpKSiK+DbQQHnfLpMeXzk+DLG8Uf7wyfnwxd3+D7kdB2+KrePO8HbFHgm47Q9eTeUayjIyXy9pYF5+j46+3C3+/O/Pl65MsvHZ+uE9fjA+fjI6dx4TguXE5XjsNhy+fDA8dh5tSODN2IzfNtTrdLKaqGUM2E/oQdz6hmQsYWFSJaydtwp8lda05f1iL9z0v5Bw9BzFQeJzKMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"constructClassInstance\"\n        title=\"constructClassInstance\"\n        src=\"/blog/static/497d1ecebae05943263e87a1e98aa231/a242d/constructor.png\"\n        srcset=\"/blog/static/497d1ecebae05943263e87a1e98aa231/63868/constructor.png 250w,\n/blog/static/497d1ecebae05943263e87a1e98aa231/0b533/constructor.png 500w,\n/blog/static/497d1ecebae05943263e87a1e98aa231/a242d/constructor.png 724w\"\n        sizes=\"(max-width: 724px) 100vw, 724px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n在<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberClassComponent.new.js#L591\">constructClassInstance</a>中主要做了如下两件事:</p>\n<ol>\n<li>执行构造函数,创建组件实例</li>\n<li>注入组件更新逻辑实现</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 642px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1432b8761f07738688fa565358af68b7/1bba8/executeConstruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpUlEQVQoz42S7W7bIBhGexmrbcAuBvwBCeQ7Wbt0bZJqSqPe/9WcyY4qdVun7ccR/Do878N7I8qKqkuUbeTb84GXyxvH1wuny4XT6ys/3t6YpkSe50gp/8mNEAK/vid8fWR5OrM9nFk87Nken4mLFSHOqI1BFMX/CYs8x853uLSiWyaElGRfbsmzbCTLbin+kAmE+IuwLEtsSkzuN/QTizaKUiuqWo6phgdHipwiy8ZTfCIaJh2FsqywXUeTeuwq4jYzmnlPs5yimxbbB0zn0dZh/ITaOqQQo+Aj79IbKQp03KH8EjVdU0+X+Pkav30i7k8sD2dm+yPx8cT8cGb+/QXjGpRSSFVe+SWhlNzVNXVao3dHms2e+PBEWm9RztP1ntpPKeMG7RPtfI1rW0wXKP2Cqk/I8u6adBAqJamqikpr9GyLmSSUtlTGXTsbyDPE0N3AeC+uid75+CmyLAixI20Ci8fI7jCj7wzWOayfXukDd8aibEvVTdC1uQqGsaX6TSglIXQE39C3lq51hNDQeI8NEesnuBDRQ2+uo+oj2phxdT5bm59BfiES78o9rwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"执行构造函数\"\n        title=\"执行构造函数\"\n        src=\"/blog/static/1432b8761f07738688fa565358af68b7/1bba8/executeConstruct.png\"\n        srcset=\"/blog/static/1432b8761f07738688fa565358af68b7/63868/executeConstruct.png 250w,\n/blog/static/1432b8761f07738688fa565358af68b7/0b533/executeConstruct.png 500w,\n/blog/static/1432b8761f07738688fa565358af68b7/1bba8/executeConstruct.png 642w\"\n        sizes=\"(max-width: 642px) 100vw, 642px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberClassComponent.new.js#L581\">adoptClassInstance</a>中在实例上注入了updater实现了组件的更新注入能力.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 758px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABRElEQVQoz1WR0XKbMBBF/R1FQkICIYSREGC3rk3cpk3+/49OB+xk0oczV/tyZnX3UBqLDok29ixLT54C849Imnt8ytRpweUzNgzUsacOnjZO+HGmOQaabZ4idVMjheCgjcLnkeHnzHDOhCVzunT8XQO3qeeaPesycB4ctTHYqkLpB6aqMFrTGINSirIsOWitidcX8u838usbw3VleVn59f7K5XZi/XPndr+QBocyCmXVntsi2j5Qz5RSPoRp9KSpI06Bboy0OWGPAZdHmjHjUkQbidLiM1UlqRq9Y565C1VZEodEvL9z/H6jn057R12a8TsTTddThYRqjw/8gHYdUsj/2L9srcE2DuM8la0xrsW2Htt2O9ust47agHLdk4Bu2l3wlX1DY7dCS0Txbb+SEAWi+IIokFIgiwIpnny8pfwUfUj/AfXDysLcW3bxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"注入updater\"\n        title=\"注入updater\"\n        src=\"/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/c8e86/adoptClass.png\"\n        srcset=\"/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/63868/adoptClass.png 250w,\n/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/0b533/adoptClass.png 500w,\n/blog/static/0ec8d69c0ef510e14f1fdd507ed5c0af/c8e86/adoptClass.png 758w\"\n        sizes=\"(max-width: 758px) 100vw, 758px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>发起调用</h3>\n<p>在组件的实例化过程中,注入了提供更新能力的updater.调用的逻辑其实就是梳理对应的updater如何触发页面的更新.通常调用setState是如下的方式:</p>\n<pre><code>this.setState({  })\n</code></pre>\n<p>setState是挂载在组件实例上的方法,在创建类组件的时候会调用React<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react/src/ReactBaseClasses.js#L20\">类组件的构造函数</a>来初始化实例.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 723px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB70lEQVQoz22S6XLbMAyE/R6WRPDWQdm6bCdO4jTt9P0f6euI8tiTtj92FiAxywXAnU8G7RXaCcYLJghiq4z13ER5xGIl19nWZC7LkqqqvmFnmog4iwoGaRwSLMp5bAz41GLrQOgTfq0zCqW3x1f+WywLSrcQlxv97Yt4vpCuP7FpxoYG1/RYXxP6CesCVVlR7MsHyuKO8sk7XXfU84nxdiPNR/qXF7plRtvVTYnSFUo2Fre1LFahg87xlm+8OQwB23WENuKnAT2fsdOMbTzaKbTfitcHdJ7xXcjLP3kW1NFRzw3dpcOniO1qXKpxjWO9c31AR4uJDhNtdpZFVsE1rvVDfHPoIr470C5njPPEfiB0B4z1qG5C9SfkeEEOJ0yaUEooi+I5t+L7LHc6Bipn0dZhfMyiJkRMCJm182htENkcVKr673afW+47VLu2mIiHCd/2mdfNNtM55946rDEU+z3Fvrhj/+0fZsfZ4ZgwQ0s8JprlRDMODGPNcawxwaHbhD8OtPNEuyy0y0w99PQvr6RholKKongK72zf071dGH9+Mr2feP0xc/2aef81M1xn4jLRX88cP64cP95I55H5943x80qKgaEJtDGg7iPZxbqhLAXRDlGC0Ru0SM4rpVErxGyoJPN6LqrCrrVaHm3/AZ0jV2qMuOQFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"baseComponent\"\n        title=\"baseComponent\"\n        src=\"/blog/static/2ae56cda731fe7c84a8d82990745f055/c67d4/baseComponent.png\"\n        srcset=\"/blog/static/2ae56cda731fe7c84a8d82990745f055/63868/baseComponent.png 250w,\n/blog/static/2ae56cda731fe7c84a8d82990745f055/0b533/baseComponent.png 500w,\n/blog/static/2ae56cda731fe7c84a8d82990745f055/c67d4/baseComponent.png 723w\"\n        sizes=\"(max-width: 723px) 100vw, 723px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在调用setState的时候其实是调用注入的updater(classComponentUpdater)的enqueueSetState逻辑来实现页面的渲染更新.\n在classComponentUpdater中主要做了:</p>\n<ol>\n<li>创建update 形成update的链表结构(updateQueue) 在更新阶段会依次处理链表的update</li>\n<li>通过scheduleUpdateOnFiber触发更新</li>\n</ol>\n<p>在<a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L456\">scheduleUpdateOnFiber</a>中获取到根节点通过ensureRootIsScheduled发起根节点更新调度.</p>\n<p><a href=\"https://github.com/facebook/react/blob/a423a01223785a8bc4dcd55f2a0288200b033eee/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L632\">ensureRootIsScheduled</a>的功能是在根节点上调度任务的执行,主要功能如下:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 759px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 125.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD+klEQVQ4y32V2W7cRhRE9RnJDMneSPbG5q7ZR5a8JDYMBHnK///JCUhNZFm281DongFYqMuqW7yTpUWFhBsb5nPL7tJzfNdxOiWGNmBjom4CfmwxtsbUjtIFSudwfcJ6hxCCPM8py4o7qRTaR6phpAiR3Do+7Cv+Piq+ToJKFWSbLWK7Jc8ysmxLtty3W4rbfwtZURTreSeKgjokmvmAdR7fz/huIkx7bOqpfMSNO2w/44Z7/LRfT9dPGB9R3Q5Z+5V4Ib0rhUS7BlEHZDOg2hnZjAiXqKyl7TxDH+m6Z6Q2UlbVi6r/sPzOF0IlBFUcMNMFffiAuXzGnP5A799TT0fSOJGuT7SPn1akyyNxmF4UrUSvR1Y2YJQknhLtx5F46fCHlnBu6Z5a4j5g+kg1J6oxUo0BZfRPFa4jS2MwStNYjykleb4hz7cImaNKgVBiNeA7vCF7jTtVLlEocb3DthbbLXGwGK/INhn5ZkOe3dxcHf025s+wxsb6RHr6RPr4hf7zX8SHpzV7dVxcnFFpRDWL4x6pnlULuaCgEMV6rvdVofVIUSCtRjclJpXoaKiHGjtZ7D5Qzw6789jRop1c1RsvkZXAOPWMoJFacCetR2vJcIpMDw3jNTJeIuO1YbhEpmvD/JiYHhLd3uM6T9Va4j7hR7eSLypfTFnWpi5Ldqc9+w+PzA8Xdo8PzOcTqfU0raNJjhBqQqiwwSPLmirc8ljkb1yWEikkLtR0UyQuBL0nNJZmUdLWpM4RfI3Wmu1qUsZ2s6xg9mMOl5drTMn9MDDdt4RUEzuHjZbQOkLniL2nGQJlXa4PSvlsirxBiDcKlZI0yTLMka539FNEDztUN6LHe9QwI1NH4RqcqxiHQNt6hiEyz4kY3Zt3aD2u6akXdBOq8hTGkmX5OlaWCwqpKJRekQtJIeVKkv3QNkIQm477658MT19JX/7BXz4xvv9Id76yO0w093tEM6LStEKEltI3yKUHfzBFCJZwh8OZ4fE9/fWR8XplPB0Zjgd8ainrmrKqKdaN2VLctubtHt9Mkdi6JpYaq3NqnWFNQaUFlZFIbSiUQVf1bcQbbvfXZDdTBNYuJXpFzVfk/IDoj4g0U/iesirpF5cbS9cHpqmh7+OazSWny/Ovy2IdecnX8l1RsUc3A9I16NoilURptaZgjYl4HZVnvFb34nJZW+LhgXh8t56uG5iOO/oh0XUe758dz4ufN813Iy+ExhjaeWa+nOl2M/1+x/3lxDT3a95i1yIrj2uHdZpfletz22iDMRqpljz9Rp7/TlFsEGLBUqibb7j1YVHkvyzZO2mqtffSeSad98TDTNwNuClR7eb1wyVDh/QJqfT/tvVC+C8D+9HyjMLmcwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ensureRootIsScheduled\"\n        title=\"ensureRootIsScheduled\"\n        src=\"/blog/static/df31f836b5cc428cf2864f9bdd7254d1/ef3e1/ensureRootIsScheduled.png\"\n        srcset=\"/blog/static/df31f836b5cc428cf2864f9bdd7254d1/63868/ensureRootIsScheduled.png 250w,\n/blog/static/df31f836b5cc428cf2864f9bdd7254d1/0b533/ensureRootIsScheduled.png 500w,\n/blog/static/df31f836b5cc428cf2864f9bdd7254d1/ef3e1/ensureRootIsScheduled.png 759w\"\n        sizes=\"(max-width: 759px) 100vw, 759px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>根据当前任务获取优先级通过Scheduler发起不同优先级的任务调度</li>\n<li>同优先级任务合并,不发起新的任务调度</li>\n</ul>\n<p>setState是SyncLanePriority优先级,在调度上就会通过微任务发起调度逻辑等主代码块执行完毕后开启微任务执行(调度更新)</p>\n<h3>图解setState更新逻辑</h3>\n<p>假设我们在这样一个场景中在一个函数中连续调用的两次setState</p>\n<pre><code>this.setState({  })\nthis.setState({  })\n</code></pre>\n<h4>第一次调用</h4>\n<p>在第一次调用setState的时候在fiber的根节点上创建了updateQueue添加此次的更新内容,通过微任务发起调度.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/00a176694c87a68e767f39aea74c21fa/61016/setStateFirst.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/0lEQVQoz41S266EIAz0/3/TC8YLRBBBFLuZrt24J+6efZhAUzqdTin2fadt2xg5ZzqO4wXkBMjdvc3InXmgWJaFjDGktebTe89A3LYtNU3DMYpTSvzGWkvDMJC3lqwxNGlNKYQnYQiBi7uuo3meuQgAyTiO1Pf9G+E0TeScY9I1BPLOMVKMT8IYIxdCDch5jHMcxFAk4wLSkG242CNveGQoxAhQKF6gkVIt1XXNisRTyV/9vaK4Gi1mA+u6sjqoR9NvJG+EQnDtLKcsDI1+IXspvPse1jpegFgRzi1+J8yfCZVSVFUVlWXJd5D+/ZsfFOZbQiwCJADu8fwW/yl8AGbIDaEzSvt9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setStateFirst\"\n        title=\"setStateFirst\"\n        src=\"/blog/static/00a176694c87a68e767f39aea74c21fa/00d43/setStateFirst.png\"\n        srcset=\"/blog/static/00a176694c87a68e767f39aea74c21fa/63868/setStateFirst.png 250w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/0b533/setStateFirst.png 500w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/00d43/setStateFirst.png 1000w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/aa440/setStateFirst.png 1500w,\n/blog/static/00a176694c87a68e767f39aea74c21fa/61016/setStateFirst.png 1770w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>第二次调用</h4>\n<p>第二次调用setState获取的更新优先级跟之前任务一致,这次只进行updateQueue逻辑增加任务的操作<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/b6e50/setStateSecond.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUElEQVQ4y5VTa6+CMAzl//9BEz8J4SWMMQGBjY3enGrRq3gfS5qWPk572hB578laS/M8k3OOQgi0ritrax3Lsiz8DY08iNRAIyYSAdC0LSmlqO97diKx6zrK85yyLKNhGLiJ1ppzLpcLlWVJ1+uV6xCHfxzHG2DbtreEYWBAYwwnAaCua26A6WAjhnzEqqpiIMTADjryIWyAmGqaJu6Mh46IoSkEMfggYsP/TtkY7giNRNlVmqaUJAlPIXsVHcLKtjQTibwPW+JKtBUAFA2wI1n8a/G7BIok0eJ6dwoQPAABFO93sCdAZy1VZUlFlpFWineI/RRFQefzme09ej8CAqhRNRmt+WJN0/AO87xg+5Xy3jcfRQK8wyfBDkEZx4J+BfkIuDc6T+0cnU4nOhwO/6B8v/InwDiO6Xg8MuDfruwflB80wlYMUPkDxPddhzfKX/ab9wsUR/UWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"setStateSecond\"\n        title=\"setStateSecond\"\n        src=\"/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/00d43/setStateSecond.png\"\n        srcset=\"/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/63868/setStateSecond.png 250w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/0b533/setStateSecond.png 500w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/00d43/setStateSecond.png 1000w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/aa440/setStateSecond.png 1500w,\n/blog/static/76f16d8aefefa3d39948c2f406cdc6cb/b6e50/setStateSecond.png 1862w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>更新任务执行</h4>\n<p>微任务执行,开启更新逻辑</p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"setState源码分析","date":"2021-04-01","tags":"React","path":"/react-setstate","top":null,"summary":null},"title":"setState源码分析","date":"2021-04-01","tags":"React","path":"/react-setstate","top":null,"summary":null},{"id":"e0bace90-1cb6-58ad-8127-8cfb29194aa1","html":"<p>本文主要结合源码梳理React事件系统的实现过程.React事件系统通过模拟浏览器的事件系统实现事件触发逻辑从而实现不同浏览器的兼容.本文从事件的注册和响应两个阶段梳理具体的实现过程</p>\n<h2>前置知识</h2>\n<h3>浏览器事件</h3>\n<p>事件的触发阶段</p>\n<ol>\n<li>捕获阶段(根元素最先接收到事件)</li>\n<li>目标阶段(目标元素捕获事件)</li>\n<li>冒泡阶段(从触发事件的元素向上往根节点传递)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/030ae70f0fe588d9c5d6d53043bb3559/9685e/eventBrowser.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVQoz4WTXa6CQAyF2SpvLoYlsAEXwrMIXA0m8AhEAQUE+bXmlBSQ671OUgZmpl9PO0Xp+57EhmGY5rZtqeu6acaa7C/PzjZ+K2sgBgBxHFOWZZSmKd1uN95/PB70fD6/AwGQjSAIqaoqhomVZUnX65W22+0U8B02m4KIYohqmiYDi6Kg+/3OQBz0PI9UVWWYnF2WSEyBIxQAUtc1OY7D77ARmDPAdV3SdZ1r2rZzbX8pPJ1OZFkWg6IoosPhwCDUDYGgEEFhx+ORgiAgx/kh27bJ9/03dawQDwBQcESAkwAlZcx5ntN+v2cnyUh83hQKGQOOmqaxCqQEVQAhNYChCgPnpY7LGuKmp1vGAmq42WwoDENqmmZShnUAdzvzn1v+0Ic4aBgGK0MfJknCcKknava1bf5q7Mvlwr13Pp+5uSXVZZpLP/lW1hG6blY7/nrdVJJPKa4VvgB7m51af9s2ngAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器事件模型\"\n        title=\"浏览器事件模型\"\n        src=\"/blog/static/030ae70f0fe588d9c5d6d53043bb3559/00d43/eventBrowser.png\"\n        srcset=\"/blog/static/030ae70f0fe588d9c5d6d53043bb3559/63868/eventBrowser.png 250w,\n/blog/static/030ae70f0fe588d9c5d6d53043bb3559/0b533/eventBrowser.png 500w,\n/blog/static/030ae70f0fe588d9c5d6d53043bb3559/00d43/eventBrowser.png 1000w,\n/blog/static/030ae70f0fe588d9c5d6d53043bb3559/9685e/eventBrowser.png 1336w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\">浏览器监听事件api</a></h3>\n<pre><code>target.addEventListener(type, listener, options)\noptions\n* caputre Boolean true 在捕获阶段触发 false 在冒泡阶段触发\n* once Boolean true表示该listener在添加之后只会被调用一次并且在调用之后会被移除\n* passive Boolean true表示该listener不用调用preventDefault()方法\n\ntarget.addEventListener(type, listener, useCapture)\n* useCapture Boolean true 在捕获阶段触发 false 在冒泡阶段触发\n</code></pre>\n<h3>事件委托</h3>\n<p>事件委托是实现事件处理的一种通用手段.通过浏览器事件冒泡(或者捕获)过程在目标元素的父元素实现对应事件的处理逻辑,能一定程度上减少内存的消耗.React正是基于事件委托来实现事件的处理的.</p>\n<ul>\n<li>event.target 获取实际触发事件的元素</li>\n<li>event.currentTarget 指向绑定事件的元素</li>\n</ul>\n<h2>React中的事件系统</h2>\n<p>一句话概括React的事件系统就是基于事件委托机制模拟浏览器事件系统来实现事件处理.</p>\n<h3><a href=\"https://github.com/facebook/react/blob/master/packages/react-dom/src/events/SyntheticEvent.js\">合成事件</a></h3>\n<p>React通过SyntheticEvent来模拟底层事件实现,通过React传入对象的nativeEvent可以获取到底层的事件对象.</p>\n<ol>\n<li>React通过SyntheticEvent可以更好是实现跨平台逻辑,通过不同平台的React Renderer来实现具体SyntheticEvent的封装.</li>\n<li>React能更好的做性能的优化.比如React在17之前的事件复用,需要主动调用persist才能持久化React的SyntheticEvent.在React 17中已经去掉了这部分逻辑.</li>\n</ol>\n<h3>事件监听</h3>\n<p>在react 17中,事件委托的绑定节点是React应用的Root元素,在创建Root元素的时候完成的React对事件的监听逻辑.<br>\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMLegacy.js#L287\">ReactDom.render</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMLegacy.js#L175\">legacyRenderSubtreeIntoContainer</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMLegacy.js#L113\">legacyCreateRootFromDOMContainer</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMRoot.js#L164\">createLegacyRoot</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMRoot.js#L110\">createRootImpl</a> => <a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/client/ReactDOMRoot.js#L140\">listenToAllSupportedEvents(rootContainerElement)</a><br>\n以上梳理的React在首次渲染事代码的调用逻辑,重点关注listenToAllSupportedEvents的处理逻辑,这里完成了页面根元素对相应事件的封装逻辑.</p>\n<h4><a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L88\">注册支持的事件</a></h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 467px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/85ff8/registerEvent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABi0lEQVQoz2WP2Y7aQBQF+Y0J2N1eutu4bTde2OIFbCAhk0Sa//+ZijAK0mgejs7LvaU6izS1rFYrhBCIQOD7Pr7wCaQgkpLw0YEkjiRSPm8ekaGY7zzPm3/+92KdGjyxIlCC9TbGlBEqD0gPijgPSRqF2sSE6wCpJJENCU2AyiOiJMTzfHz/CZuBrk7wgxU6t9iDw40VebvBnUrWjcX1lqpNUSrCmBitY6IoRIhgXvbF0KYWXwY0tz9U0zuuv1Kef7Lpb9TXv7jdgW440vcNw9BwPu8Yhi37fY3WCinlC/acnCSIMHpCTlfK041qus9ddCPlMFG3LW1bMY47uq6e4cdjRVFkKKU+A43WCBnMgPr6m2q84/oLm/6CG264suDHtaHt6tnwdHrYlVhb8Pb2jeVy+Zr8yCIxBhkrdvePF7S+/KK+vLO9f1API91t4ntbM017zuOOcdzT9zuKwmKM+WxorcUTAlNsiNcZOnPofIPOCuI0Q2UOlVcoHeNcSppqrDVkmcHaBK31J+A/ZObxOpJI9VwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"事件注册\"\n        title=\"事件注册\"\n        src=\"/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/85ff8/registerEvent.png\"\n        srcset=\"/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/63868/registerEvent.png 250w,\n/blog/static/7d5649cb2af6891a5744b1b2e936c9c0/85ff8/registerEvent.png 467w\"\n        sizes=\"(max-width: 467px) 100vw, 467px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4><a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L384\">在root元素绑定对应事件的回调函数</a></h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/0ef7e/rootListener.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACh0lEQVQ4y52Ty5KjOBBF6zemLQkhHkI8BBgwL9tdPTGr+f//OROiyq5y1G4WNxJpcbiZN/Vm84wptWznkct2Z74s3G431nXhuk9s+051e6f4+1/8/s79MuHKCp1m6DRB5xk6S4mUQkrJW12mzPoX07ll20aWZeD30vLPWvO+dtz2kd9/FvZLzVLHXHNFJgUnIZBBp88qJUop3vI8xyiFKzJKb3GNxfuUs0/ph5K2Lei7Au9imsrgqhilFUqqA/BQAB4OU5tRR4KLjVkmz7b0rJeOqU7YW8PWGK5NzOoT5jaMRyIDJDh66Bv4LXc5nRb4xHDuG/xtoV5X6n2mWwf2vWO9b8zXhWWbWIxGxTH6kDnqCzDLcmIlaWLN6h372HKde9bBM48j8xRAd7qmo608nW8pzheKbqAcZmxVo5T8ajnMUEpFXlhcaXEuoyjSo2a1J206krJCxAk6s6RlTVY1h/Lao6PoGcinwwytY4qmI8s/QEGx1ojTCSnFx8wORUgVIUIIQiDE6Ql7phyA4cPkjmoY8dMFf5lx3UBWV8RlxV9VT5ZblPP88hOinZBx8gzkxWGapkRRRGoM/jzSLleaaaWeb9TjinEFZV3hG0fblhgTI8QDII9xvaac5wewqCzt6OhGR3O2uD44bshcjC01udOkzmBsjMk1KnrdwSfQWntcZDalPnuqsDqTx54dZmzR44S83RHTStE0JMGhlIdL8e2FvLyUcEiShGldmG874zrTTz3tMGLbATvtFL6n6QfqtqUsc+qmoCztT4chlNByAGqtiD9lYn3sp1GCJCiSyEgfixzmmCQf9QcwgIwxB/SxnF9Sh8SnHvdfLcufLVdV9fKH/6PvDv8D+gnOAI7KStsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件\"\n        title=\"绑定事件\"\n        src=\"/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/00d43/rootListener.png\"\n        srcset=\"/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/63868/rootListener.png 250w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/0b533/rootListener.png 500w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/00d43/rootListener.png 1000w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/aa440/rootListener.png 1500w,\n/blog/static/9fdd9233135bc88c3ed3145fdf0ae8b5/0ef7e/rootListener.png 1594w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4><a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L412\">绑定事件逻辑</a></h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2d77c3580045c4aec287855218f49bcd/6569d/addTrappedEvent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 136.79999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABYlAAAWJQFJUiTwAAADkElEQVRIx41V7XKrNhT0YzRGICQkJAQCDMYYY+J89ibtj07f/2G2IxE7NHGS+2PHgjFHq7O7R6soisDzGqLaoWwbdMMWu75BOzSougrNfgOVSoRhCPffn7AKgzWyzRa713/RPv2N9uEFYjqAPU/gr/dI9lsQShFSimhR9KsNViEhEFmO8nCCHSbYwwn1cEQ19LBDh2zsoMcOPFMIAwJCwm/ZriISIs0tysMdzPaAfDci3x1RdEfoTQdzGJEPI5QpIHMD2lZgeebZhm9Ml1jFPIQQAjyNwHUEJkOwNPJIDEfMKUhA/O6MUggWg8V0ZhleYRjHBEwqmL5H+/SAYuix2Tc4nFrspxpNZ1HXOdrWYtdXaNoCVZ37d7bKrxw5jMAYg92fUB7uUR0fkVUtYhpfGFB6Bn3D+/NnUcIQUgpUXpRbVMcH2H4EFxIkCC6K/i5WPCCQJgdPNRKVIUm1V13m1hcNSYBw0avlx8vn82lWcRgiEQKmq1FOBxTDDnYcYA97bxtlFYRhSDIGrhm4YmBp7NdOtMT9Zhw0nouvnPSCJSiMhekG5J2zzhvaHllhkZgSLCshdYYomu3iGdP3Hp/ZrvyLKIJUGerTMzZ3f2Jz9wvN4yu0rVGVGbqhQ7Nr0O02qCqDzSb3cMqfHaB1CkLIXDCOYw8nijN4ffsEZSu4FM09Im+4npBlPy8FnQWK/YTm/hdM00GaAlyk/8vvV4ovi66iaPZWKiWkMkhUDi41hLHgMp0/+o1CF4Yuep6dGxDW2YWDKxe3te/Jd6PqWgtWMZ9FSZRGOY2oTgfUpyOKfoQ0FqUTpSu9CE3jYmewaXIodX1G+uh5UWiMop9Qjo+op2eYtvfMvzTyFyxn21D6lufJK+xEiRn/du59LPxJ5TRN4aZ3cPMHgpsbn+P3WBGPn66BOSnhPA+3eQOd5WAyBUsEmJBgPEFEY5A4AWESNOZ+NgZXsLBNhJhSKGW8EEV/9CjHe2RVg6oqUPe9R7ffwmQp8lzB2gxFoS9rztnM8DzjuBBoHl7QPv2F7uUf1NMjEplCCg6tBbRKoJSATBNoLf16Cde2D0mJYLZ7Hz93C8ac++i5S2l5NOfNH4/sGXKOrNn5+Omq9evUFD56yym9nC5XRTmP8kLnUFwgigIQskZI1l5pt/t6HVzwkdEnHzJBQCOKVGvUY4/qdotympGkyvfLWu0FcM3PMumFYCy+mpT/AFUJAmOJILa1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件逻辑\"\n        title=\"绑定事件逻辑\"\n        src=\"/blog/static/2d77c3580045c4aec287855218f49bcd/00d43/addTrappedEvent.png\"\n        srcset=\"/blog/static/2d77c3580045c4aec287855218f49bcd/63868/addTrappedEvent.png 250w,\n/blog/static/2d77c3580045c4aec287855218f49bcd/0b533/addTrappedEvent.png 500w,\n/blog/static/2d77c3580045c4aec287855218f49bcd/00d43/addTrappedEvent.png 1000w,\n/blog/static/2d77c3580045c4aec287855218f49bcd/6569d/addTrappedEvent.png 1328w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在具体的绑定事件逻辑中,主要做了两件事:</p>\n<ol>\n<li>根据事件名的优先级生成不同分发事件的响应逻辑</li>\n<li>在捕获阶段绑定1中生成的回调函数</li>\n</ol>\n<h3>事件响应</h3>\n<p>React的事件响应过程其实就是在冒泡阶段处理不同优先级事件分发逻辑的过程,假设我们有下面这样的页面结构:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 662px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 120.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+UlEQVQ4y5WV26rCMBBF+/9fJYI+iC8iIuiDaOu93updq3NYqVOTGg81ENokzcyemZU0eDweoj1NU9OL79n4/Z2u+8aBPfl8Pp2uczR1oP1+v3uFBNliajbN53MZjUYymUwkisYyHo8liiIJw/C1OTOuTmznOCCKQD3QMHA+n0WbqlSDOGu329Lv980Tx8vlUqbTaa7YMcjC7XYzCyg7Ho+5I+Y6nY5Uq1VpNpvSaDSkXq+bORxcr1cjIND41SAbaXygDSUoSJK97Pd7SZJEBoOBxHFsnJ5Op1yIYxAlGF2v1yafbKCzmW/s3F0ul9d7Nv6oMpPkD2O73U56vZ7E8Uo2m40cDgcHDR8yXmzshkFVpNiU4lCtsxl15Iswa7WahGFkQl8sFo4S5dAdp59VBo/tdmsSrGyRcM3h91NUCFkNzmYzY4wcgs1wODRrzP8QssthhkdiQl2tVg42tkIN8cvRu+fYEDIMggVPOFOl/+cwGwd2hYEWlRSh1WoZB4QLOjZrP9022rSyP2NTnNB8clapsN4mpavsnuWZuVFQ1+1286NIDotOizn0YkM1gZvCUGnt8PlTyGoQVLjfYLBSqRigQQelvjC/Hj0bG80ZYeo8Cr9h4sXGBht15JDQefpyWBobJgGaa4wK03n3XVulDbp/vfffr2xR/gAJ9ExAqedGIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件逻辑\"\n        title=\"绑定事件逻辑\"\n        src=\"/blog/static/94e1459206a4767463eb204c53278e46/be86f/pageStruct.png\"\n        srcset=\"/blog/static/94e1459206a4767463eb204c53278e46/63868/pageStruct.png 250w,\n/blog/static/94e1459206a4767463eb204c53278e46/0b533/pageStruct.png 500w,\n/blog/static/94e1459206a4767463eb204c53278e46/be86f/pageStruct.png 662w\"\n        sizes=\"(max-width: 662px) 100vw, 662px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在上面的页面结构中,App组件的div中绑定了click点击事件.那下面从这个div的click事件响应的触发逻辑来梳理react事件系统的响应过程.<br>\nclick事件在响应过程中的优先级对应的是<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L368\">DiscreteEventPriority</a>,对应的事件分发函数是<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L122\">dispatchDiscreteEvent</a>,在dispatchDiscreteEvent中调用<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L160\">dispatchEvent</a>来完成对事件的派发处理.在dispatchEvent中主要调用<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L195\">attemptToDispatchEvent</a>来实现事件的派发处理\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 665px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACb0lEQVQ4y42U25KbRhRF9Rd2jWj6QnNtBAiEGIGQZI1Kk4mTOM6D//9PVgpky0lq7MzDrnP6ZfXm9OYsjDG4OCF1MSZPMS7BVTHNNqOqU8o6od446i7HxgE6UtjMECR6lok0OlRzP9WFkpK66WlPL6yffqM6XKlPe7bPR5rnI+XQkhQZiUuQvsTzBGIpEN7rWkjpo7MVbn/BDRdcfybf7Kj2WzYfBsp9h6tLbBLhLZf4vv9TLbSUhEVNOl5ZnX4lejyQjgPN0zg7rI49xlpkEKC1/ilMCMHCRAlhElK0GevOUQ4FzVhRbnKyrsLtKrJhTbqriMqUByHwHh4Qy0lLhDfJm2GzQzPdHDvCuiUbTyTjB5LdwOPTgW5b8jzmfP7Y8vFS8ccvDZfLgNudyPdPZPUWGcYoGzGN7uYwjJBBSLypKA89bteSFimfTzFfLiFfLhF/doZPreKvR8OnPiLIK1Reo/P1XKezVuoGDJOMyDXk/ZHV+QV3upB2PaYdMd0B22x5Z1e8twXvghXvgxVemN9kc8S3PioQccHCTrmKImxmsc7i+xJfKqTSyKlKhdIaNZ3/If+VOmkRWE3mYo7PPYdrTz921LVjs8nZbguaJqfrSrI0xvO8ry8qfqjF9KcobSiG8y3U5xdW3YAO7AyY5nLX12gI4f9QM1CbCXhic/2dajxjkxQdBPcofM+Z///Bnh0qxerxwPp4JW97wjSfZ3l35ok7/L+XvAq04fQgCTZLsGlCmDtMaJDaRwUSFag3we7AKIwoMofNMoI0QgUCE9+2x7RNpk3iyzcCJ3cT0KoApS1Sme/bQ4h/9W/55L8B3fXQMpznV5sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"触发事件逻辑\"\n        title=\"触发事件逻辑\"\n        src=\"/blog/static/a2c6e09fbe8033f2e125bf216f32261e/5f4af/dispatcheEvent.png\"\n        srcset=\"/blog/static/a2c6e09fbe8033f2e125bf216f32261e/63868/dispatcheEvent.png 250w,\n/blog/static/a2c6e09fbe8033f2e125bf216f32261e/0b533/dispatcheEvent.png 500w,\n/blog/static/a2c6e09fbe8033f2e125bf216f32261e/5f4af/dispatcheEvent.png 665w\"\n        sizes=\"(max-width: 665px) 100vw, 665px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/ReactDOMEventListener.js#L250\">attemptToDispatchEvent</a>主要通过原生的事件对象获取到实际触发事件的元素和fiber节点然后发起事件处理逻辑.\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L534\">dispatchEventForPluginEventSystem</a>中最后调用dispatchEventsForPlugins完成事件的触发逻辑.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 718px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.20000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACtklEQVQ4y5WT4XKbOBSFeYsmBglJCIGEQYBjGzu202TTtDu73dl9/4f5dkxaJ+mkP/Lj09Uw0uFczbmJW0bW3/6lPT7RHr8y3u3YPB3YfD0xbAfaPjAMDV3n6ftAXTuyTCClvCCEuNQkV4p2OhIP97TTgeW0I+5uWJ12LNcjVVwitWZxvWCxSMmy7HL5p9Br0UQXlpunf2aX8fZEf3dL/3lPfDxSNp5cCPI8f9fRuw6LwrLc7QmrNdUyEkKgawNd31I1HineXngt9B6J0oay7VmuJ6p+hWsjtvKEmwkfVyitEfPh/Lcir3+UnNspnMJ4ibKCopaYKsc4iWtztE7Jrq4Qi2uyxXOd91lKmmZv3vTZYZ7TxpGw3hLGNc16R4g9thswqx1m3KHHPabfUowTut9g4hpXe3yocc69dXhemjjQ7T8TtkeW+3vCsMbELWr6gtk+YKYHqmGDH0ak80hbo5TGGDNzeeNnhxJtK3Ktab1meSYU9G1JcBqrFbYsKUqHsSXWFlS1pYoNta/IFtdIkSGzZxJlK1Q74jdHusMDzfYwt15tp7mquiP3PcrHZ+oO7TtMEzG+Q9qALF9IlClphhu0a8jdEmk9Qru5LV16pHYIZRGqnElVyXXunlGOha4upLoi0SondCXNqsQFQ90WVK2l8BpTK2yjqfqCqjOU0bIZBE/rBX/0VzwOP4if+DJ84tRekWit2E49d3crDrcDp9PINA3EMVKUFplLcpXPSJVTakEoUrx5SzAptc5IpBBU3nP8/h/7b3+z//M7yxgJvkSfQ52Jy9yeyYQkzSSp+IUf35I8lyhT0Ewn2tsHwmpCl9Uc2Jc4vMRCzvvfk+RSznG4efyL8f4b/eEeU9gPze+bWT6PXukcRe0xrqaoPNqWHxa6CFpr57Sn6QKRpWRpivhlPj8i+D/4zQP4aPV0xgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"触发事件逻辑\"\n        title=\"触发事件逻辑\"\n        src=\"/blog/static/55b63edef27c0d88877678a01ccc9f9f/57dc1/dispatchEventSystem.png\"\n        srcset=\"/blog/static/55b63edef27c0d88877678a01ccc9f9f/63868/dispatchEventSystem.png 250w,\n/blog/static/55b63edef27c0d88877678a01ccc9f9f/0b533/dispatchEventSystem.png 500w,\n/blog/static/55b63edef27c0d88877678a01ccc9f9f/57dc1/dispatchEventSystem.png 718w\"\n        sizes=\"(max-width: 718px) 100vw, 718px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n<a href=\"https://github.com/facebook/react/blob/5f21a9fca455069bc1e986e1528963a5055a8f21/packages/react-dom/src/events/DOMPluginEventSystem.js#L273\">dispatchEventsForPlugins</a>主要是从触发元素中获取相应的事件监听函数然后依次执行.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACt0lEQVQ4y32T2XLbOBRE9RmxCYDExk0iwU0Uqd12nEpmXqdqZh7m/z/jTMmSK07s8kNXEyjcRjfu5cI5h86WmGogrQLjpqUdKuoxEIaauq/ouxWpswghUEohpXzhj7AwWmPSjHr/RNg/MJyfqbcz5WlmeZ4pzzNpWKHLHJXEn4r9FPQp7fkb3eMPwu6BdL/HH2bs4w5/mrF9gwkrEms+FHy7tzBGk2hD2J4J+0fKbk21Hen6QHjcU65bEp0g7yPUm0L5m9grL7x3aOtIDweq7Q6/rHDliiTz2LC8Okv9y/tFUnInxLVYyndiF15Yaymtpe02FHWP7bbYfoe/oJ2oi4zjtmWeGo5DxdPUUdQt5TBRtGt8mv4auc4TJqMIRcqwLuimQLepCX3NvF1xPAYOh5r9vmKeCg6VI8iIKI6J4/j9G1a545AmPGwqvh47nk8Du35Fk9zTO0lvBZ0W9EbQesWQRFQXQanexb5Fdug4xrcj6faRdPeVdHMkUTGxkMTyDW7rl4a88u8OvffESrEaJsbnPxmfflCuKuTdl5eCj/BT7P0ILZzz6Fhh6w43n3GbI7pZI/KKJEnejIr8FFJezyyc9wilMN2G9PSd9PBM/vAHbn5AxAn3UnIv1ad4FbvwIrOWTium1ZJdPzDVNdu2ZZ2nVCqiUoI6vkGJ6/rGr9/6rcOhiBmNYplrmqBpWkPTGJZZTFVo2t7Rdo5QWwqjyKQgU5JcCbyStLdL729dX8ytoYgVSeMpDyXZlOP69IrgyHqPTC6xrn9KJOSVpeSLkKQXp7EgUuqluYsu02xzzV97w78nyz9Hy997w39PjvUmcFcPiDASVT22WFK0A3nTU3YjWTfSZJ5aRUSXMbsIrpzllBsOXnJ0guOFveDkJWsbE4yhtZrGGXqTMDjDYPWVnWHUV5fiFvl/hIvsXePavXkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"执行逻辑\"\n        title=\"执行逻辑\"\n        src=\"/blog/static/e0440598172879af25eb01e9f8c9a669/00d43/executeEvent.png\"\n        srcset=\"/blog/static/e0440598172879af25eb01e9f8c9a669/63868/executeEvent.png 250w,\n/blog/static/e0440598172879af25eb01e9f8c9a669/0b533/executeEvent.png 500w,\n/blog/static/e0440598172879af25eb01e9f8c9a669/00d43/executeEvent.png 1000w,\n/blog/static/e0440598172879af25eb01e9f8c9a669/844cc/executeEvent.png 1306w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>图说React事件</h3>\n<h4>事件绑定</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/c5bb3/listenEvent.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 144.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRklEQVRIx51V6c6CMBD0/R/M+5dG8T7jCeKJB1D3y+zXbSqKok2atmCHnZ3ZNXc+n+l+v5NSimKleP11AicHQAaLY4rimNdfJ3AMoIDKCzkn38mMosgwegYUynhhUXgFaI+He8kIHyLQ+bR/KPuN79Nms6H1ek232+0NYAplGxA0u90utVotqtfrdDgcWIivcxhrBdOGBMMqXy4X8wIP7Iv2OQgCWi6X5Hoe08V0XZefmdwDED88nU6ESLHHB7DijCnnxWLBU57jGWa/3+dcGsrH45EajQaVSiWe5XKZZ7VapUqlQk3HoWKxyGAAwEBkuIeBCG9haFKUu16v/IV2u03NZpMT3ul0aDAYkOM4VKvVWNXdbmdAECHuGEC93+/3/6JInpL5s1dEBXqr1Yrm87lJAQIJw9AI+lh6UfRfAXY1WHvkEysAEQ0ik/w92OZuOV6lVAorrqMfDofswaRtMgOKbWazGfm+z4KBvud5TFsifOo2aZWCsXZd9p58ACtyNxqNTAli/VgpAgil4VdQBYj4DyJhRXTAeqKc7DYCCHqgDVG22y3bCEMAnxvshwhhG3hTOo2rU2DbJr19vejEuATKKITxeMzAUoY/2UbEwABlfMDYJqlyFkDsAYTf5/N5pg+BTkFg3n+VQ/gPFQLaEAJnAIJ+qCsqc8cWQAghwGgKUBp7FkXf+UjZBoQQiKpQKFCv1zPVE+r2pWzKKoNtAComl04/mUyMDzPbBgzQC3EZFKWFIbrpdPqjbTL8SalvbfP2rEvvD19u0smyeaCTAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"绑定事件\"\n        title=\"绑定事件\"\n        src=\"/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/c5bb3/listenEvent.png\"\n        srcset=\"/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/63868/listenEvent.png 250w,\n/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/0b533/listenEvent.png 500w,\n/blog/static/bfd20cce2d61ca856d8376ebf0e428b5/c5bb3/listenEvent.png 680w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>事件响应</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/d9b5d/eventSimulation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABz0lEQVQ4y42Ue2+CQBDE+f5fzj/UGGtiitSigoK8lIds89uw9OorJdkcDrdzM3N3erfbTbquk2djXddyPp8lz3NJ01Su16v0ff9yPqNnL1bjhL6XsizlcDhIlmUSRZEURTES3tcDIRMh4TfFg6LtdqukjJfLRXEjoHqnRwntIyriOJa6adRmGIZyOp20ILMRvGkayYti/E40IyEr8JBR27a6Ig1BECgxqpI0laqqtPnT98dmnizP1Ykp9/iBus1mo2M5NO52OyUEM/tJksh+v9cRnMW+w1Ax3hHkYXMymchisZD5fC5RHKsaCFAKOYrYaRfH0Xq9ltlsJtPpVN9b2xTKLNPAIqgAY+yHHXdxChylLGS77bEaALI5FpYjlvlmx8RGcNtIzXAgHDPkx8dqJcvlUnzfl3OWyfF41EbUjAqrShVahuRLHNbH0dIMmcy2o45VCZfJNJMbzeBYtgNuNwcxwdeXHiWz7XV2QEVUCRmikNVpghycBhe33bfHInl69f6T4asr+Es4KMU+drGBIpTQTBTYtRuEbe199+eg1rgZSaJB27FhTlGWf3DK7X0kHKzajUAF+bkZQgKOauqtQpcYexBDwlGwby4+5nZH+ANo8SR51FsE7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"事件触发\"\n        title=\"事件触发\"\n        src=\"/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/00d43/eventSimulation.png\"\n        srcset=\"/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/63868/eventSimulation.png 250w,\n/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/0b533/eventSimulation.png 500w,\n/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/00d43/eventSimulation.png 1000w,\n/blog/static/1b810a3edf897d125d9dd2ca3ad70d1e/d9b5d/eventSimulation.png 1224w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>React中的合成事件和原生事件的关系</h3>\n<p>React的事件系统是基于原生事件系统在捕获阶段事件触发事件的回调处理逻辑,原生事件的处理逻辑会影响合成事件的触发逻辑,我们通过几个例子来看他们之间的关系.</p>\n<ol>\n<li>原生事件的stopPropagation会影响合成事件的触发逻辑.</li>\n<li>在事件更新中开启了isBatchingEventUpdates,同一次事件处理过程的中更新逻辑会被合并.</li>\n</ol>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"React 事件系统源码解读","date":"2021-03-28","tags":"React","path":"/react-event","top":null,"summary":null},"title":"React 事件系统源码解读","date":"2021-03-28","tags":"React","path":"/react-event","top":null,"summary":null},{"id":"8080f2de-e3d4-5143-a419-b85bc551c360","html":"<p>本文通过图解的方式尝试生动的叙述React渲染组件的过程.</p>\n<h2>前置知识</h2>\n<h3>react渲染模式</h3>\n<ol>\n<li>Concurrent 模式  异步渲染模式,实现了基于任务的时间切片等特性</li>\n<li>legacy 模式 同步渲染模式,现在主要的渲染模式</li>\n</ol>\n<h3>react渲染阶段</h3>\n<ol>\n<li>render阶段  基于已有的Fiber树(current)构建workInprogress树 在workInprogress记录了需要进行更新的操作(effectList)</li>\n<li>commit阶段  commit分为以下三个阶段:</li>\n</ol>\n<ul>\n<li>before mutation  此时dom节点还没有渲染到页面中,执行getSnapshotBeforeUpdate周期函数和useEffect钩子函数</li>\n<li>mutation  渲染DOM 根据effectList的tag标注进行dom元素的更新,删除,替换等</li>\n<li>layout 执行useLayoutEffect,componentDidMount,componentDidUpdate等相关逻辑  进行current和workInprogress的替换</li>\n</ul>\n<h2>图解渲染</h2>\n<p>我们先假设我们的身份是React的好友,React是前端世界里面的一个一流的画师,我们希望他给我们画这样一幅画.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 370px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz4WS7Y7aMBBFeQsg+DOJnQQiCA3kQ93AgirBj+5WVd//WU6F0dK0u21/XNme0YzH53qSZTlKLCi6M/70g3xdo5TCGIPR+iGpFErKkPuXJmmaIqTEKIHf9khfstp37J+OdGXGabehWhUorT9sIKX8TRPnXNgYa4mTBL874KqWxBqiKEKKBfPbKmU4R9EixOTiHns3ofc+JKyNiWOLL1b43YBdVrRtwzAMQUVR0DQtz88D2aYm3z+xWpehVmv90KihJY7jMJnbNOw/H3l5+cr1eqXvey6XC6+v3+iPJ9yyJC23uNwHrnqEY5Ikyf3JxmCNwXmP2/a0XUdd1zRNEy46n88MhwMmX6OVRERzhBDvOAZT3hjemhfVjuTTgE098/nswW86nTKbze785IjbHxx/uawVebHEbHrSLA+FY2ffGI3d/fDb3FxWUlBWNe74nbz/QhLbvxb87x/+BPj+AExOixcKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"画的模板\"\n        title=\"画的模板\"\n        src=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png\"\n        srcset=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/63868/draft.png 250w,\n/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png 370w\"\n        sizes=\"(max-width: 370px) 100vw, 370px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact大师稍加思索(babel)就把画的模板构想出下面的两张蓝图:<br>\n元素的语言表达\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 703px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz5WS4W6CMBRGfY3RFiilBaRUpsLEOZ3b+z/TWVozf22J/vhymzQ5Od/NXemyRDuLnWc2m55lPzCOPet1i1I5eZ6jlErzkax0VVHmOcPhTD8dca4lE5KXLEugX9ij0JUxhmhZWUd3uRCOC4dpYJ4Du12gqqrnDMuyJCZXEtO09PM7wXtqUyGkRMYIgZQigeNbSYmQKv1n8S3Evc2qrutkURQFxjma7yvj6cjneeL69cb5PBHmBT8f2dgKv93jlwtbv+Y09ny8euYx4FxzA1pr0VonS2tritZhnMH7lhA6hqGj9QN111PrEtcP1G3H2ho6axi7hjEMSShVbprmZmcMzjlyKVGxjpD3PFU5QmLlaBr39ejy/z8brRMwzmdP5C/gD6QJ/B4bz1bsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"语言表达\"\n        title=\"语言表达\"\n        src=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png\"\n        srcset=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/63868/structDraft.png 250w,\n/blog/static/15014ea5ae1e57d91a06216d3982962b/0b533/structDraft.png 500w,\n/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png 703w\"\n        sizes=\"(max-width: 703px) 100vw, 703px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n元素结构\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 868px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 102%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQ4y5WU6Y7CMAyE+/4vyB8kJG5oOXogrrZBn3cn65Z2d4lkJXGd8dhjSJqmCXVdB/am/jmz+3P/u/f72ESXvvnA5/P55otxdQ+ww+D7zMrzPKxWq3A4HMx2u51Z27ZvDD3zN4aw4dHxeAy32818l8vFkuz3+zBWkdiOMgQQIBKw8w2Gihvt4RhgkRdhs9kYyHa7NXZjJf9bFFZVVaEoCjsDJoE+Ktlnhd18PjefV/vjklFZ5aJ2lmWxh/35/LVkqXw6ncL9fjfwx+MxqvLgHOLsMxQg4NfrNQIOqewt8RnEUGIAkKapGcOdpVkU588eemOgy7I0W6/XYblcxjuJNJ9DkxEBySpms9nMRuV8PtuAw44WYPhgvFgsOmxjyUKuysqUJHA6ndpDAPSIBXNiaMVkMomt8OUnEoGPNB8nquqnRmnqKwkYJ7HCzzv2DkMByqk/AwUrBtZSXKMEQxGIgPp3wdR8egjDqHz7Newkoc/EcKd8L1DiZwoQgrTTM5L58fAxMCam00N/6a+hAZZAWkoowBehpBywowW5SAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"元素结构\"\n        title=\"元素结构\"\n        src=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png\"\n        srcset=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/63868/draw.png 250w,\n/blog/static/9f629706c2e341539b8d92bc7a0db691/0b533/draw.png 500w,\n/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png 868w\"\n        sizes=\"(max-width: 868px) 100vw, 868px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nReact真的是一个画术大师,他有两个最出色的技能:</p>\n<ol>\n<li>在脑海里面构想画图(workInprogress)然后一次画到画板上,画出的画大家都称赞道奇(首次渲染)</li>\n<li>在已有的画上修改(current => workInprogress) 画出的画既有原来画的痕迹又有新的神韵(触发更新)</li>\n</ol>\n<p>React欣然接受了这次的绘画任务,因为他很喜欢每次作画后大家对他的称赞,于是他开始作画了.</p>\n<h3>构思(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L991\">render阶段</a>)</h3>\n<p>React大师看了下自己空白的画布,决定先在脑海里面构造画的样子.React看到画的模板的时候第一时间是看到了各个节点之间的联系于是他对画的模板有了重新的构想.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 598px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQ4y5WUSa+CQBCE+f8/igN3Ew8ejYILsrjhAi5Am6+TNgPoi2+SzgDTXVNdNYP3eDyEuN/v8nw+5XA4SBzHkuf5O9brtZxOJ10nz2o+hecCNk0jaZrK7XYTBt8Z5/NZdrud1HX9P0AKsix7A+73+4+Af4EOALfbrRbTIkDH41FZI8XPDN1dq6rS4vl8LqvVSnzf101g3c/9CTBJEjVlPB7L9XrVZ4AxxnLc/P4GXt9lWgRkMpnoHIahLJdLKctSTSOXPKtx5wFDc5m2GWjGKIpCgQG9XC4argRfWzaXeW7bVrVjwDoIApWD2Gw2yhpQq7UYnEMOMkBmEME3WDFolzyAjUSn5b7AOBxFkYxGI5lOp3oWYU27rFurMMQo5HC7fAOaIWjFkaEAdzmTLgMYIQeG0QkbuVeyw5C2aAV2gMLAbY1iO/iz2UxnOkAWY9kBtJ8A75xBNsAAnIcRMyC2xmzfTEvP1Y9FBs9mgp1FdOXWsGY5DFh/BYQhorOz/a4Wi4UKz3faxDTyueesIwHRATRQ9EAz+w/CmKCQAjZiHddZZ0YSujFjBlePwn64m35ad2/MCzzXa7RrdkvIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fiber结构\"\n        title=\"fiber结构\"\n        src=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png\"\n        srcset=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/63868/fiberStruct.png 250w,\n/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0b533/fiberStruct.png 500w,\n/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png 598w\"\n        sizes=\"(max-width: 598px) 100vw, 598px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个是React画师特有的作画方式,还是我上次跟他一起喝醉他说漏的,哈哈我就这样把他的秘密告诉大家了,大家还是装作不知道让React来给大家讲他作画的过程把.<br>\nReact: 我在作画的时候主要思考了两件事:</p>\n<ul>\n<li>怎么把画的模板对应成更好解读的结构(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiber.new.js#L110\">Fiber结构</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1543\">performUnitOfWork</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L782\">completeWork</a>)</li>\n<li>如何在构思的过程中把绘画的思路记录下来在画的过程一蹴而就(effectList 创建节点)</li>\n</ul>\n<p>经过一番构思,React想好了绘画的思路\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 885px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y52U2W7CMBBF8/+fhQRIUF54YhGITewBwpaExJnqTDup24aqraWRrVmu7yx2kCSJOOdU8jyXx+Mht9tN0CP3+13SJC3tiH/2BX1ggCiKopDz+Sz7/V7CMJTdbieHw0EFW579EZD9er0qw+l0KqPxSBlyyb8YsgA8Ho+6A3S5XOR0Oqkty7JKoG+ApMOCTRRFEu7DN4ajkaYOIDYC8LXd4rQcBkgTACXN5XKpAJwBYI/jWGu4WCyUMb7EcMYOAcQuCtI01RS3260GrddrBfFv5qLJZKJCw7BTCpoGe7/GCgiD1Wolw+FQU7X0bIwAJP3xeKwXowNos9mUoDZ6CogCllCHgQG63GmwZYAfPugh0O/3pdfrfYwVDKmJpQcIyx8jdjpu6dpl/vrUFH9sqsbAasxu5akaH1iXKRs7U5qgNxCYAWSAvp8vPzPMnQZTO9Ltdru6W4pV/srQ/xy+PjEAo1Mk8/lcBoOBglcB/o7hew0BsadJPel8VUxZw2cMC/dRQzqN8JKshpUMnwFqU1yhbGq1mtYuiROdv09Nyd3PgPYv2tNikBlezvE91gEnbfs0fAIKaOOQPTJlg+CAM/W1C2ezmTSbzdKODlCLQcAJ5MnCCCDBfAYWYIBm/7qCVqslnU7nTV465bndbkuj0VBW9Xpd8KvSlbHv8got71ieyO6scwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"render阶段\"\n        title=\"render阶段\"\n        src=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png\"\n        srcset=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/63868/renderPhase.png 250w,\n/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/0b533/renderPhase.png 500w,\n/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png 885w\"\n        sizes=\"(max-width: 885px) 100vw, 885px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>挥墨(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1008\">commit阶段</a>)</h3>\n<p>在挥墨这个阶段对于React大师其实是小菜一碟了,因为费心的事情已经在构思阶段解决了,他主要根据之前的构思思路(effectList等)去作画就好,不过大师的作画方式还是不同于一般画师的</p>\n<ul>\n<li>在开始作画之前他要喝一杯酒,他私下跟我说这杯酒会影响之后的作画(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1800\">before mutation</a>阶段 周期函数钩子),我心想也是喝多了肯定不能画了吧</li>\n<li>在作画中,他又老能搞出一些新花样(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1818\">mutation</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1842\">layout</a> 组件添加到视图 生命周期函数执行),正是这些每次不同的新奇花样让他成为一个出色的画师</li>\n<li>在绘画后脑海中那个构思图成为了真实的画(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1829\">workInprogress => current</a>)</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"图说React渲染流程","date":"2021-03-25","tags":"React","path":"/react-render-interpretation","top":null,"summary":null},"title":"图说React渲染流程","date":"2021-03-25","tags":"React","path":"/react-render-interpretation","top":null,"summary":null},{"id":"31eeff5e-284b-587a-831c-38d2fc3d52b0","html":"<p>React在函数组件中引入了Hooks机制使函数组件拥有了类组件的生命周期能力(本质上有差异),本文主要通过源码和图文的方式用最简化的方式来阐述React Hooks的实现原理.</p>\n<h2>前置知识</h2>\n<h3>Fiber</h3>\n<p>React为了实现时间切片,将页面的组件节点都进行了新的抽象-Fiber.通过引入Fiber结构React可以更好的实现组件更新的调度.Fiber结构主要有以下几种类型的结构:</p>\n<ol>\n<li>Fiber节点的连接结构,在组件更新时候需要依赖这些属性</li>\n<li>动态的运行数据(updateQueue,memoizedState)等,在渲染更新的时候会利用这些属性存储需要更新的操作和数据.Hooks的实现就是依赖这块的结构.</li>\n<li>Lanes 这里主要定义任务的优先级,Fiber Reconciler实现了一套新的优先级更新机制,这块在之后的文章会重新介绍.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 538px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e25e72a540b8d4ed7997271e175c0bff/9516f/Fiber.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAADcklEQVRIx5WV53LkNhCE9RjWMgeAJBgAxs1J2ZZ/uFx+/1f5XAtJt6dTSbf6MTVAgWxOs2caV2Hgk5oF+bRBH7fo+yOiqQiSGD8K8TzvW3EVhiHNYoveHOiPt4yrHUpr2ps1ejnhux6+718cV6cK9fpAu95TzVv648qCdfsVhSrsQ0EQXBxXeZFTtz1JViAzSakrVFORihTXcSzgtynHytjQqz0ilejlnigM8VwXz3O/R9n3PaKyQ5g57e6Wapgz3j8ji4IgSgniDM/1cB0Pd+bata3mtHdcu35jYQED3ycqe9Jmojs+0W6OZP0GNaxIVUE+GopekqgYNWWkKiZMAtIyITMpfuC/A30BzCSiKdD7jnJekY8leXeqMCCMfCIR2nWcRTafXg7jgDB9bSv3Jc4V5iXSaOrVRP9wS3dzQJYS0Q4IlRGEPlEa2ghf8499EtgPhkn4S4VaoaaGam3ITYY0FbLJyHuBqBOyVlAM0mZpUpvtWZWQd8L+gjNgPZI2c8z2jma+RRQ1absmjhOcmXMWxXFf8znezt5TVoa0GWyD18sdZdsT1z1pUeF7l0/Ka4UeUTWS1CP98U+qcY3uB+JE4PsBfhB8fPFrwJMoyopSTi1CpYjeIGuJ5zk419c4s+vXPMPz/Hd996GxX0TJkaam2Yw0mwV6t6TZ9IhckpuBoptQ/Zys1l+CnQGrAWFWTI//0N08Mz39S3d4otQtanlDOa6RtUaoitNk/R5QtQgzMdz9RXt4YLj/m3paISpjxzKKIpzrP3CdSymr1qrc3zxhDg+0h0erdlFrEr1AqvonAO8yyrJfs3j+j253R3/7TLe7JYwioqKx2buwfV5FEaRVhhobEhmRqpxY5i/2NbvGc50PrvI1YGlI6xazO1DPF2TDkmR+RAwbokwRJJIgCC+q8mxf9US7e8ScYn9v7xnZLSxw0q+JUmErvpByTj5ozHFOvR3J6oYoCAhlyenO8ay63xGlqBFaY/YbqrElLg1Bv7XzHLhnZ35z69+3TdEgdEe9XNOstuj9kaLtEIst2e6GrG0J4xdT/dmhP7lTTrOck48NejdQrwaazclYBdloKFc1WSuRTWq9781IPwVM4tgqGUqFrAyZ7slOExIlRFlNGEYvlN3zVfkl5dNYBZ5nx8qdzayzuNZV3F/EeG9Tn1X4P50bH358JSUOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Fiber结构\"\n        title=\"Fiber结构\"\n        src=\"/blog/static/e25e72a540b8d4ed7997271e175c0bff/9516f/Fiber.png\"\n        srcset=\"/blog/static/e25e72a540b8d4ed7997271e175c0bff/63868/Fiber.png 250w,\n/blog/static/e25e72a540b8d4ed7997271e175c0bff/0b533/Fiber.png 500w,\n/blog/static/e25e72a540b8d4ed7997271e175c0bff/9516f/Fiber.png 538w\"\n        sizes=\"(max-width: 538px) 100vw, 538px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>update</h3>\n<p>react在处理更新中引入了update的概念,在触发更新的时候React将update插入到对应的updateQueue中然后调度页面的渲染更新.最后通过updateQueue的执行来完成更新的实现.</p>\n<h3>React Fiber Reconciler</h3>\n<p>React为了实现更新可中断等特性,在具体的渲染过程中会维护两个数据结构:</p>\n<ol>\n<li>current Fiber树结构  当前展示的页面结构</li>\n<li>workInprogress树结构 在更新中添加了更新但是没有渲染到页面的结构</li>\n</ol>\n<p>在具体的渲染过程中主要分为:</p>\n<ol>\n<li>render阶段 render阶段主要根据已有的Fiber节点构造对应的workInProgress节点 这个阶段实现了任务的中断,优先级任务处理等逻辑</li>\n<li>commit阶段 commit阶段主要根据Fiber节点的类型不同来执行对应的更新操作(更新Dom等)</li>\n</ol>\n<h3>Hook的数据结构</h3>\n<p><a href=\"https://github.com/facebook/react/blob/0203b6567c6fd6274866c853ef938241d24551ec/packages/react-reconciler/src/ReactFiberHooks.new.js#L140\">hook的数据结构</a>如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 477px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuklEQVQoz12S6W7bMBCE/RiJJR6iSFESJR8SLV9xbMcJkrRpgbz/w3yF7RxIf8zOLkgOONgZ5eUYYTIeult+bxLKpcfWhiRJkVJeIIRACkEq5AXn+RNf5x93R9ooYuh5iWu6psQuD/jVQHW/IrQNw7C4PlASowUuS1FaIrX8IfbJI+UbrHX0z+802xPd6Y3++Mx6s6ONKyZxQGcp+dSy3yreNzc0y4KwLcnLjDT5/t1F8FxsUdA9vNIdn+kfXqjbCZP7I9Z7tDFordEmJ880uRZIkyGVQsqfYlfBzGBdQXz6Q3d8Zbp/pF0tyQ4b7GHD/PBIPdxTL+7o1nvKukYPPXmoEUlKeoG48jhlpJs51uY06y3ToaeMNcVhgdt0mDihPw28nSJxEeif9sxjwC5nuNhiS4MLOcZn2JBTTCwj3fZoLSm7OXUMlHczfF9RTT35NNBGx6/1Dbujwy8L2sHx96SIiwwTLH7mcK3FT92lH8ncEReRyWpH5StUE1DekzmHDhVKZaSZxlQGdWYtOM7G1CZhfPth9cPuxbIUKbM2oERKkowRSYJI0yvO/WcGk+/s3Y6vefx/Ieel/AOaqgbxYD1/+wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hook的数据结构\"\n        title=\"hook的数据结构\"\n        src=\"/blog/static/c3abb96049ba35de696bfaeac50d17b8/d743b/hook.png\"\n        srcset=\"/blog/static/c3abb96049ba35de696bfaeac50d17b8/63868/hook.png 250w,\n/blog/static/c3abb96049ba35de696bfaeac50d17b8/d743b/hook.png 477w\"\n        sizes=\"(max-width: 477px) 100vw, 477px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Hooks实现思路</h2>\n<p>Hooks在组件初次挂载和组件更新阶段是调用的不同的<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L389\">实现逻辑</a>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 561px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABh0lEQVQoz12RW5LaMBRE2caAJOthy5Yf2NgYg4cZBuaZqmwgO8j+N3BSCFKZykdX36+jVvfCWEsTajZhTZo6pFghpUBIiVQSldx1vZVCJYpEJ7dbqpvHWyKlZGGMwWWeamgJU41tCsquoN/ldHNFMZaUu5uyxpLVhnxj0VYhhIiPR93BC6MTdFHh9i/43RNuODBNAz+eB86PW4qup5lm2scToe1wRcA3bXRjNNqmJDb7ntCSKIXPc+rjK/XzB1+niffTgf00kh8/KS8/8eue0O8Im5FymMjbgTIE0qImSYsIjAmtMUSoEJhmi9u/8evS8fur4+04IsZX7PyJrTrEwwNitUKsljcJgbh2Hr9+T+icI8sc2imM19jgSIPD5A6dWbS30dMyxVqNWC4j4JomSZJ/o/zt0DqHrRvqQ8/mcqQ7jfTHNU8fW+bzht15y+ZlZj13tIcD5bCn6rdcx/wfdhvFWJRJMc7j8gptPUZrqpBT5BlZ5mNPxmZYH0jLGl/WESjvvX0H/gH+iejWe9cPNwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"挂载不同的hook\"\n        title=\"挂载不同的hook\"\n        src=\"/blog/static/79d42a604971a40c38b3cd9a50682d77/410f3/different_hook.png\"\n        srcset=\"/blog/static/79d42a604971a40c38b3cd9a50682d77/63868/different_hook.png 250w,\n/blog/static/79d42a604971a40c38b3cd9a50682d77/0b533/different_hook.png 500w,\n/blog/static/79d42a604971a40c38b3cd9a50682d77/410f3/different_hook.png 561w\"\n        sizes=\"(max-width: 561px) 100vw, 561px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 501px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC2UlEQVQ4y3WTyXLrNhRE/RGpLCxxEmdwAMRZokRNfJKVOMvsUtnm/7/gpEDZtPwqWTQuCkU0+t5uvqyCJY5I8JTArRR+uybqC8S+JOr0vkEcWqI6I94mxENOuM2IuoSsFsTrEFessGwLwzB4MU0LX1bkdYs6nEl3J8J6x1KUGKLAlB1G1mIGKXEmyNsS2RTEWUIcx/i+z+J1gWmaE15WhoEQPuOl5XQoGc81SgmS2EVmAZnwWMuQRAQYyyWmxmIx1eVyOanSRIZpPBQahkmaxozjht2+4nRuSfKM263n9tZzPnfs9jVxHKK/NcwPGMYX2VOdCJMk4nLpOB5rqloiVcr53HI41Ox2JUKEvL4usKxHW7rato1tW98Ip5YfCiOOp2ZSud9XDEM1Ky5rxfHYTI9dxm56YLNZT4/1fUEQeCyXT4R60Qq1ov1Qsd0WDENJuykoypy2lVRVNhG1raLrFEJELBaP+VmW9V3hJ+H9tx1v9z1Vo6aZ3W5b3t8HpBSzCt22JnpW9PMcZ8K3t57h0EztFLXi8qMnzRNUkZLnMauVM8/vk+y/8GXK2LHtS1Qp+eua8c/vGX+fQvrU4pdfX1ksFt9j8uHyz5gVjmPH9brlcGx4P0rufcKfo+SPsWY/NJNRdZ3jee5E/L8K9aJzqHOnM6gvnsYt3b5h3ZQcz93kuI6VToB2t+vWSJl9jMCaq8Yc7NOpmXOnL9banF3FYajm82GoyTKB6zpTBrVJzw4/5TDmft9xvfb8uG4n6MvNpmTbPzJ5vfVcnqpSKbEIcBznQfo5Qy3T911UHrJWMUrG5GmAiFakwp/UpImPkhHFhHBC+vGvu471NdNPU9wgws9LoqLFFTlxtSHpBgJZEsoCP1UYXoSZ1Zhqg7nusfIGI5bYaYnjehjGg/TFc13WdYUnMoJM4kUxYaaIZEGQ5ngixYsEdhBhixwnkTjpetrbUYoVCmxnNQf7XxK2AFDTeZdbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mount阶段hook\"\n        title=\"mount阶段hook\"\n        src=\"/blog/static/55b46db6b69afb0beaa46bd58608e2fb/55811/mountHookCode.png\"\n        srcset=\"/blog/static/55b46db6b69afb0beaa46bd58608e2fb/63868/mountHookCode.png 250w,\n/blog/static/55b46db6b69afb0beaa46bd58608e2fb/0b533/mountHookCode.png 500w,\n/blog/static/55b46db6b69afb0beaa46bd58608e2fb/55811/mountHookCode.png 501w\"\n        sizes=\"(max-width: 501px) 100vw, 501px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 485px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC5ElEQVQ4y31UWXLiShD0NWwQvbc2hCS0byBWY3vuf52c6MIm7Bi/91FUtEKR5KZ+YpxD5x3kOodq9jDDBbIcIZsZshgh6xlquEJ2J+h1inVXYj02SMYaQZYgCkMIIeB5HlarFZ7cj7YW075GO1ZopwbpNoMnFDwu7iM0llxhxTiMVjDW0JZSgDNGQA9Axhg4W8EaBaMlrJFQSkBwBqU4pORQgkFrAc4Zlsvlt/EI6AvM7SfPWyEIDI7HBtNU0s6LFHWT4fY2Yrer6Lnb6ySEe5+xFQF8nwfDB+CpJbBhLBFEIU6nhp6dzy2GYYvFwsPz8wsWizs7t5+fF3h5WfzO8HRqsd9XaJoMZZXi42PC5dyiKDeo6hTbbYJkEyJNI3p/swlRVRtkWQQh+HeGHqLI4nBsCPT8Cbzf18i3G+znGpdrj7e3kSz4+LPD4VCjqlJkeYwsi6GU/CnZ9w0ulw7nS49su8E8V5jnGvOhQd9vKU1jFKyvoV1wVoNz/mnBL5J9X+N67Qm06wukeULeubPzsW0zJEn06Z9HHn6B/Gcor689hrEi/3b7is7TVBErYySx/D+gryHAMLQ4nzvMhxplnWEcS/LUyXZ1ieOAOujkOqmOqZvvUn8ABqF5SHbAh0ODqsnRDwUFcn3tcbsNFMYwFIgiH9YquI/iV4bOQ5fwtCvRtBklO4wF8uKesuunA+u6nABdUGW5gZTyH5YPyU6u+yKczHEqsS1SYkh/NJXEepoKssCl7KriAvql2B4Bvr1PuL4OOF866ptj5WR3g/Ozxe024vU23Dv5PlHFXOlTV2z547ZhdAFEgUISG8SRQRgoGMXg2/uF4FuJdWyxjjQ2a4M4kAitQGAF4lBDsBWWD0DPgzA+4mZCMhxhkhzrbo/t8Z12VHWIqgEyiLHKevBqhuiu4PURPB/AshYiKegaI8lSCKRpBi4VpLH3sT6N0AZCaRouBJjSYNqCGf++3VlqMKEeHv4Fc1cdpF0sQpIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"update阶段hook\"\n        title=\"update阶段hook\"\n        src=\"/blog/static/25312134b5bc77843da2562709c24e6e/44c61/updateHookCode.png\"\n        srcset=\"/blog/static/25312134b5bc77843da2562709c24e6e/63868/updateHookCode.png 250w,\n/blog/static/25312134b5bc77843da2562709c24e6e/44c61/updateHookCode.png 485w\"\n        sizes=\"(max-width: 485px) 100vw, 485px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n下面先整体的介绍不同阶段Hooks的实现过程然后在深入到源码中看具体的实现.</p>\n<h3>图解hooks的实现思路</h3>\n<p>Mount阶段Hooks的实现逻辑\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 652px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/a6d32/MountHook.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe41ACywA//EABgQAQEBAQEAAAAAAAAAAAAAAAABEBEx/9oACAEBAAEFAuuplTxU2P/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CT//EABgQAAMBAQAAAAAAAAAAAAAAAAABMRAh/9oACAEBAAE/IahEZ0sjaDhY4Qf/2gAMAwEAAgADAAAAEPMPDP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB0QAQEAAgIDAQAAAAAAAAAAAAERABAhMWFxgaH/2gAIAQEAAT8Qrh+MUpA9kxcjfuquM850VugMJcJEJNd2j//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mount阶段hook逻辑\"\n        title=\"Mount阶段hook逻辑\"\n        src=\"/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/a6d32/MountHook.jpg\"\n        srcset=\"/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/0479a/MountHook.jpg 250w,\n/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/41099/MountHook.jpg 500w,\n/blog/static/38746c08a5fcd5ae402c6fdb39b40b99/a6d32/MountHook.jpg 652w\"\n        sizes=\"(max-width: 652px) 100vw, 652px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nUpdate阶段Hooks的实现逻辑<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 685px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0a2b8/updateHook.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 149.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAeABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe41koLnUIo//8QAGhAAAgIDAAAAAAAAAAAAAAAAARAAAhEhMf/aAAgBAQABBQLMJ0jwK0CK/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwJP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQETEh/9oACAEBAAE/IdYaKYuqbENSG5CWhYf/2gAMAwEAAgADAAAAELPKMP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EABsQAQACAgMAAAAAAAAAAAAAAAEAERAxIVGB/9oACAEBAAE/ELWLcdRBAK7jpXG6a8By34Qa79MFQlwgKCp//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Mount阶段hook逻辑\"\n        title=\"Mount阶段hook逻辑\"\n        src=\"/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0a2b8/updateHook.jpg\"\n        srcset=\"/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0479a/updateHook.jpg 250w,\n/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/41099/updateHook.jpg 500w,\n/blog/static/acf124ecaccb1c0fb4fe2140077cba9c/0a2b8/updateHook.jpg 685w\"\n        sizes=\"(max-width: 685px) 100vw, 685px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>源码解析hooks的实现思路</h3>\n<p>以下主要以useState这个hook来分析React在mount阶段和update阶段的源码实现.</p>\n<h4>mount阶段源码分析</h4>\n<p>在mount阶段组件,useState调用的<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L1235\">mountState</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 548px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADoUlEQVQ4y22U23LcNhBE9Rn28gKCAAEQvC+X3OVyL9JasqWU/QGpylP+/x9OilQiy4ofmoPCQ3Ma0z13URSjfYXvR4ax4++vnr/uDX9eLO22RbmcREqiJGGz2bAJAqIwIo5joui1vsfd8im85XjsGc8Du9tMO+8ZzzO7457Dw4npeqQ+9NR9y9B3GGcJw/CN5D3xXRxHZK6g2J2wuyP29MgwdDx9O/Ht+cSXxyP3t4mH28TXx5k/ns7s+o4kka+dRr+Srh1abTGZI+lGRNlRtpZhX7HbV/RDSV56jNF0PqOvLE3lyMucRAli8aFDIQRJkpAXGbtDyTjX7C8trrTU25x+qhjPDbt9jW880iakTiJNQlYqhBTvCCPulj9YYzBZiss1zmlyp5FSYIxaz84qnNUomRJuAsIwIghCgk241vDdkO7SLEAZi6o9xbHGTzX+UOH3NaZe7h2685gmR2aGVGdImaB1is7S9adpKn++oVQhqc3R+wPtdaa7n2mvZ+rzTNlX6G2HPRyo55linHHtDpNptttyxTDUVJUniv6VLHVIqg2qKtFdgR53uMbihhY7DTSnkWJs8JUhCgPCxYdRRBi8yg2C4M1Cq+TlIJUmH69Ulxfc8RGZd6hyR6wcOq+R2pEIuXaxvNeC6IOh3yQvU5aJoBz27J9e2M5nTNPjtwNKxog4RIoQlcZoJdbhZUoixP+Tsna4EAqR0Pcl379feHk58fw88+PHdTVzs+s5fbnn9PjA9fmJ6+OZ6ctEWRWr7N9Gz1lHVXgKb/Aue0Vu1kmKVCOtR7kC5SukNljvsCb7fZaXS5MXlMcLcdEQdRNhM5J4j596yn2PsRmfP31i8/kzwWZDsAnYbII3wg9JiSmMoZkG6vsz1e1G+3hj+3Bhfroxjj15btboWZuRZQqdqfW8JOxjl3cijtn6nCIvsbszqujwZUPVHzCuwKRyfd/FbwsW77VtwTg2KJX+snXeZVmgq45yP5NvB8rDmXy3X1HN92hfs/m87ML/vBf+IvnDUARKStJuws7fUMvWSTNEote6IkmJwvgdohVh8BPr3WqbNMIZg64r6suJujUIGZDaiNS8QmYxyiZoJ1BWkC4bx6aoPEW51yp18m+WdUiWGbqhpj3U+OtEPo30Tye625H+64XmPJDvW/z9EX+Z8GOD9ilZqckKta6xNJOvhIlM8XVNbh2ZNsSmRLoKU3Zr7Fa4EpFaYtcgbIVIs9XUHyUvhP8Axs1mSXuqYs4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mountState代码逻辑\"\n        title=\"mountState代码逻辑\"\n        src=\"/blog/static/52a5be7aa726b705f79a180697dd6fe8/a58fe/mountState.png\"\n        srcset=\"/blog/static/52a5be7aa726b705f79a180697dd6fe8/63868/mountState.png 250w,\n/blog/static/52a5be7aa726b705f79a180697dd6fe8/0b533/mountState.png 500w,\n/blog/static/52a5be7aa726b705f79a180697dd6fe8/a58fe/mountState.png 548w\"\n        sizes=\"(max-width: 548px) 100vw, 548px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\nmountState主要做了:</p>\n<ol>\n<li>根据initialState初始化memoizedState和更新queue</li>\n<li>返回memoizedState和更新函数(绑定了当前的hook的queue)</li>\n</ol>\n<h4>update阶段源码分析</h4>\n<p>在使用useState返回的回调触发页面更新的时候是调用的<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L1901\">dispatchAction函数</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 485px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 142.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEE0lEQVRIx5WVZ3LbSBSEdYy1CEwexAEIEgRzkinJYe3avf9lvq0BJZVkOdT+6HoDFNmYfqlvpFRUw5bp6RNlG9g+bljtZlReEgpNmSmcc1hrEFKSpilCiF/iRkpBvdyxuHylmnVMH09M7/aUhw3tbk0z7+jmHVopkiey35HeaGNol5uRtOrmhKbCCYGTEicFXimsUggh3/35Z8Q33vuRJLn9QDK5JZ3cjjFJJuON0uSWNJkgXiFNkheyH0lvjNYI41FZjfQFqu6Q9YzUVwhtmfjAxAUS3zBxNYmvsb7A6J+nYCQ07QrbH9DdCrd7IOsGloct203P+v6B/efPLD9eWF8+0py/Mnz6l+l0SpIk7yVHQh0W6DAgQ487fcOHKdPdnOnDgeG4ZLGe0fUNy74lyzNsXmKt+4VkY5DGEbZ3FLMB4Quk9bjMUdQlZZFTZh5nLbHF4q2uOU5II0nM8xvJxqCUojtcmJ/ux557TnoySZhMkivJq0K8IJK9kxwJjWH+8Qv9/Tf6+79ptydc3aLCApNXSJH+sV3eSpaKxeN3uuOF+d2nkdCEOeVii9b6j9ORvpJ9Y43B+2xsbFfUlM2UvJ2T1w3T1Y5YtGe5L0je4t0Nq1ChjEA5ibQSqQVCpSgnUCY+K5RVKBOjRHuFzq7niNcfu7Gxeial6B3Tc0U5s+StIWwL6nVG3hnymaFeO8ImJwzV+BFbGIzXmEz/eENN2Q90hz3FekF+OONWe8quor/c0R0PY1x8ume4nMhy/06mlPIFo+R2GqiHLWbziFpeKIc9TWixsz1VN1CFKUI6jCve5e8FT7kdCbUWmMLh5wHblGShoOwyTJ3hmwxfGbLOYnI1SsymDltoTK5xlcEHO76P5yuhsfjtBbc8UPUL6mGFyzx2dcStDriiQMgJUgmEFMhYKCWeEIsmr++VuBYlL0rq3YUQW8dnaOuvOfEFwmbjaBqXoZR+2z4/wXhDoTTu+BWz/0y9PTM73lNUNW73iD1/p9jc0QwbsiqMY/lbC4heYZ1HtsMI0/bk7QxflOgyoPs9tmrGxft6Yn41PaPkajojqwNZWVG0HXloRw8RcdkWARn95DZu8skY0zT5tQXEWW02JxYP3ylXZ8rjF+q772SzFdXmTPvwD/ViTdH1VIs19bAZFf0o/WWWYw5dmVMNgXBqyBaBfNUgYxFEis0LrM9xRTUuVl+FsStGgvT9FnpasCl572iPJWGXU608QsSFIJhMJuMPJ9HEonF9+GuMo3FFJ0yTt9smEvaLltN5yWY74+NlzfluyXY353DoWa9nNKs9Tdw8RY1dnrBVi14c0fMdbnmirMOV9NlGn41cKYnWakQ8P0NIhdRPS0Dp8fka5Rhjzz5bwU1c+dEC3u28/4unKv8HIjYjhkrSpr8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dispatchAction代码逻辑\"\n        title=\"dispatchAction代码逻辑\"\n        src=\"/blog/static/ffb63f0539dcde4bca5e0f77c2ba284d/44c61/dispatchAction.png\"\n        srcset=\"/blog/static/ffb63f0539dcde4bca5e0f77c2ba284d/63868/dispatchAction.png 250w,\n/blog/static/ffb63f0539dcde4bca5e0f77c2ba284d/44c61/dispatchAction.png 485w\"\n        sizes=\"(max-width: 485px) 100vw, 485px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n在组件更新执行到对应的函数组件的时候,会执行对应hook的update阶段对应的hook逻辑.useState对应的就是<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L1262\">updateState</a>.从updateState的代码可以看出useState底层是使用的useReducer代码逻辑.这样具体的更新逻辑就在<a href=\"https://github.com/facebook/react/blob/1d1e49cfa453b58769e87c3c8d321024d58c948f/packages/react-reconciler/src/ReactFiberHooks.new.js#L710\">updateReducer</a>中了!!!\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 570px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 152.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEZElEQVRIx42V627cOBaE/Rg77pZ4E0mJut/VdrfdcWIn2SAXLPbH/pknmEeYh/8Wkp0gcOJMfhRIUFDplFh1zoUwlmqcqMeBfqg4HGemZaAZW/KmpMg8oQhIKYmiiDiOf4kLEccMVwvL+ZZmPjKMM3mWYROL0opov3/EE9nz9QdCpTXF4YZyWnBdRzZNuDxDbRW9XMmLhFpryjylrXPqsaYeaoauJnjLfndJtN89w/6XVV7EQiB9ifAFohxQNkWEFlEvqGpGVROyGJDFiKhm0rJBq5f/54WQEt0e0PWMO38gGxbcckc4f6R7+ELaLcTKYHyK8gGlDHEcEb14KVJhljck/YlweEV195Hi+pb6/i3N4YZ6OdFOM68/vGNcRnRI0do8XVb0Ay6EEOgsJSlTTBkwRSDrM4oxJ60dWVuQ9TVp35K2OdVUEKoUmQi0V5hMo53CpApp5COh8THp4nCTJWkMaZ9QXDnCYjG1JvYxcRpjgiIWEULFCCWQWiAT+bgasZ1thDIEjq9K3ryquLkOmMQgbEpsM9oy5TwUnPocazT7VVr0hOeSo4iLNQEubfjz3YG//3fDX58WuqZENTOiueJmbnk7ZdxPAZ9o9v+QlgspBEliqPucfspphkAoHdOcMTSOsrbEmWGnInaXu1+a+lv0pMuQ5YSuBlR/TVEEPt8f+O/7Ew9317SvHqimBW2Sf8zzhRAx0q43PDA9fGR695lqOWLrAVnP2PZAVjW4qsNmYbPLbxHqsqd//Z7p/Rf6Nx/ozvcU4wFfNqi8Q2nDfve7km2GKSeGh88M95+ojm8oz/8mdDM6SdF5j1L6N9uXEAitN1O3d1dUxxbfOuxQkXYeWyqSIDcjPyd8oTnEpImnLgu0F+hUbglQ+sm8Rm7YCJ78tt9FL3acx+gpjbYaN1jCwZONDlsmKKtQaxKM2OK17pWVmKAR8oUKpZCspD51jF1D1RfodJWpcVXymFWvsKXZzmxh8K3dqv8p4RY9KTFa05aBckxxjd6w/oJ1TXJFUhpck3B5uefyX7tN+lfJ3xN/I9xInSZfKrKhJIwVWV9RnTp8k2GMwjpFliXbfn1v/5Pu/UioFEpIQqgY336iubmnmg6Md++Y3v+H8nBDezgxHE8cz1f080xVNyTeIZ5dzEaopEJIQVP1LPOJUJWI3SWJdRifoa0jyUuUS1HGkaQ5qfdYZ39O+FXy+kWZOIR2REmKEAptPSrxSGW2/frSmphV7lfJ32NrX+soXcem9hm2rfFLh5tnXJlRna5pzgfysaM8zGhjiJ/yvBbzo21WQqW2CrOqpj3fUh8Xiibl6twyzgXt7UJzviUfWlQo0c2MDzlRtH8hekJiE4Pzjkgookiw++MSGUeo9bnUSJ1ssoXSxNtePcr8zjqb5HWMrqRZ0+GrlnXwu6LClQ1JKND2ceBv+Dro97ufWuZbhYkx9P0143RDNS709x9plmvKYcHWE0VeELqJrJ/xaYrLAr7ucd7/IPv/GmRg+gK7bPkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dispatchAction代码逻辑\"\n        title=\"dispatchAction代码逻辑\"\n        src=\"/blog/static/275788fe27b5e1522a0d62b15f3b7910/432e7/updateReducer.png\"\n        srcset=\"/blog/static/275788fe27b5e1522a0d62b15f3b7910/63868/updateReducer.png 250w,\n/blog/static/275788fe27b5e1522a0d62b15f3b7910/0b533/updateReducer.png 500w,\n/blog/static/275788fe27b5e1522a0d62b15f3b7910/432e7/updateReducer.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\nupdateReducer主要逻辑如下:</p>\n<ol>\n<li>根据fiber上存储的hook链表获取到当前的hook,hook的更新queue</li>\n<li>循环执行hook的更新queue,将执行结果保存到hook的数据结构上</li>\n<li>返回处理结果和更新函数</li>\n</ol>\n<p>以上梳理完了React Hook的源码执行流程,也能解决开发中的一些疑问:</p>\n<ol>\n<li>比如hook的添加为什么不能使用条件语句  因为前后会导致hook的链表无法对应</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://react.iamkasong.com/hooks/prepare.html#%E4%BB%8Elogo%E8%81%8A%E8%B5%B7\">React技术揭秘</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React Hooks源码解读","date":"2021-03-17","tags":"React","path":"/react-hooks","top":null,"summary":null},"title":"React Hooks源码解读","date":"2021-03-17","tags":"React","path":"/react-hooks","top":null,"summary":null},{"id":"920475d0-e103-5307-a3bf-1471ce48b961","html":"<p>javascript的执行是单线程的,React老的架构是利用栈(递归)来完成组件的更新渲染,这样当组件层级较深更新任务较多的时候,js线程会阻塞UI线程导致表现上页面卡顿的现象.React新的架构Fiber中将更新任务进行了<a href=\"https://github.com/facebook/react/blob/f227e7f26b81cb1eba0c837ab2acd7fa7f91404f/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1472\">细粒度的划分</a>并且实现了新的任务调度系统.这样保证了React页面更新的流畅和响应的速度.本文主要从调度React更新任务的Scheduler包入手从宏观的角度了解React中的任务调度机制.</p>\n<h2>前置知识</h2>\n<h3>事件循环</h3>\n<p>javascript中的事件循环可以参考<a href=\"https://icantunderstand.github.io/blog/event-loop\">事件循环</a></p>\n<h3>isInputPenging</h3>\n<p>isInputPending是Facebook实现的一个浏览器的新的api标准,现在只在最新的chrome版本上有对应的实现.通过调用navigator.scheduling.isInputPending方法来获取当前是否有高优先级的用户输入需要处理,从而实现打断js执行响应用户输入的目的.</p>\n<h2>任务调度的演进过程</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 943px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEBAQEAAAAAAAAAAAAAAAAAEQFB/9oACAEBAAE/Id4qv//aAAwDAQACAAMAAAAQc8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAADAQEAAAAAAAAAAAAAAAAAASERYf/aAAgBAQABPxB24lpLzGLhn//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"长时间执行任务\"\n        title=\"长时间执行任务\"\n        src=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg\"\n        srcset=\"/blog/static/08a926bcf0d7610b88cd024eff38d4ba/0479a/scheduler_long_task.jpg 250w,\n/blog/static/08a926bcf0d7610b88cd024eff38d4ba/41099/scheduler_long_task.jpg 500w,\n/blog/static/08a926bcf0d7610b88cd024eff38d4ba/2b51a/scheduler_long_task.jpg 943w\"\n        sizes=\"(max-width: 943px) 100vw, 943px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n当js线程执行一个比较长时间的js任务的时候,会导致UI线程无法快速的响应用户的输入,造成体验卡顿等问题.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/71f0d49fe6d23486141918239a4604af/faa66/scheduler_split_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3AUH/8QAFhAAAwAAAAAAAAAAAAAAAAAAABAR/9oACAEBAAEFAir/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQEAAT8huqV//9oADAMBAAIAAwAAABBwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQACAgMAAAAAAAAAAAAAAAEAESExQVGR/9oACAEBAAE/EAlxd53DoPYN4J//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务分片\"\n        title=\"任务分片\"\n        src=\"/blog/static/71f0d49fe6d23486141918239a4604af/a2510/scheduler_split_task.jpg\"\n        srcset=\"/blog/static/71f0d49fe6d23486141918239a4604af/0479a/scheduler_split_task.jpg 250w,\n/blog/static/71f0d49fe6d23486141918239a4604af/41099/scheduler_split_task.jpg 500w,\n/blog/static/71f0d49fe6d23486141918239a4604af/a2510/scheduler_split_task.jpg 1000w,\n/blog/static/71f0d49fe6d23486141918239a4604af/faa66/scheduler_split_task.jpg 1056w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n将长时间执行的任务划分成多个短时间执行的任务,能有效的降低js执行线程卡死的状态,这样就引入另一个问题就是如何划分任务切片才能产生更好的UI体验.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe4g0o//xAAYEAACAwAAAAAAAAAAAAAAAAAAAQIQIf/aAAgBAQABBQK5CeH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAEBAQACAwAAAAAAAAAAAAABABEhMUFhgf/aAAgBAQABPyHfTfGHfDJ6LLDscl//2gAMAwEAAgADAAAAEIMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBUXH/2gAIAQEAAT8QU31Z1sLKHX5kQcH2UGzTklACfYqEvfZ//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务调度\"\n        title=\"任务调度\"\n        src=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg\"\n        srcset=\"/blog/static/150e0b4d08aa0861f4343a41e1c4da61/0479a/scheduler_continuous_task.jpg 250w,\n/blog/static/150e0b4d08aa0861f4343a41e1c4da61/41099/scheduler_continuous_task.jpg 500w,\n/blog/static/150e0b4d08aa0861f4343a41e1c4da61/4dfa3/scheduler_continuous_task.jpg 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n基于以上两种模式的思路,js如果能在执行过程中主动的获取用户的输入(执行的deadline),主动的暂停当前js的执行并通过事件循环在下一次的事件循环中再次唤起js任务的执行，这样就能充分的利用起所有的执行时间来执行任务并且保证用户输入(高优先级任务)的响应，以上就是Scheduler在调度任务执行的实现方式，下面从源码的角度来看下Scheduler是如何实现任务调度的.</p>\n<h2>Scheduler的实现思路</h2>\n<p>以下源码分析基于React master分支的<a href=\"https://github.com/facebook/react/blob/master/packages/src/forks/SchedulerDOM.js\">最新代码</a></p>\n<p>在React进行渲染任务调度的时候,是通过调用Scheduler暴露出来的unstable_scheduleCallback将任务函数作为callback传入等待Scheduler调度执行.<a href=\"https://github.com/facebook/react/blob/00d4f95c2ad000f40ea0c774cc1ced3a0ceb6f23/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js#L131\">源码位置</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/84f4d/scheduler_call.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQY022QW0vDQBSE8/9/jPiqeMEnpX0QrGCtF6zdjZu0qdlks0n39kmKikgHhuEc5gyHyWLdELuOoEe1GO3RW0dbe5rtgPeBESmlX/7Mh5B1WvMhc6pyTVUoSrXGbkqGYsXwWRGaithWxBR/j/6G/2dWa83j8wvVWuHkAzv5gFcLvJgRqndi3+BNi7c9ZhfxYQw+/N24z0xr6bsBFyBG8CHt7WGcXdqr6yOuC3Q9DEMiffu8j4SQcD7iXGBsIYs6x6k3xP0ly5sjxPSY4u6UfHpGPjmhmF2jhEStBKUUfI61SEEun5BigVwtKNUr9XZFcFsyZ9dEW2HFLXp+jn2+Qs8vaBaXNPMzmuWEzhTYrsC0it2w2as1Jb3dYJqC6GvAQNR8AbVpy5r5USwPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler调用\"\n        title=\"Scheduler调用\"\n        src=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/00d43/scheduler_call.png\"\n        srcset=\"/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/63868/scheduler_call.png 250w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/0b533/scheduler_call.png 500w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/00d43/scheduler_call.png 1000w,\n/blog/static/ca6441d2c8e031ae801366f7f1cb0ed1/84f4d/scheduler_call.png 1208w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在使用Concurrent Mode的时候此处传入的callback是performConcurrentWorkOnRoot函数，这个函数是React内部调度更新的起始函数.</p>\n<p>以下是Scheduler_scheduleCallback的代码逻辑\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/67a79/schedule_callback.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 112.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIklEQVQ4y42V6W7cOBCE/RrJSBRJiaduaaSxxxd8rBf7/g/0LUQldgLbcX4UmoDIQnd1detC6BLlA815ZXw806wz7XnCtoH+YSXOA7qy+GFGV4Y8zxBCfIoLISXKOFw/Uq+X1OOIa2qklAhxIM8OZFlG9v0bebaT5Xn+OWEhBJUPDHfPjPcvhGnF1i1lWZHn7x/8iWwnLAoq64nLFe3lbSLbMsmy7DeSv8VFUWwZRrrrB/qbR9r1jIsxlSrEn7P5MENZCJquw3cTflywIWKso1AapaukZZ7lCSIXr/HzkpXGVQYTA7ZtqILH1AE/DYRpxDiLMpIy6D16jSzlh/omwlwqSmsY725pr8501zd012fqZaK/vaVZFqpQoZ1AlgJlJUIKssNhR3Z4bVQuci62gzWG4zwwrgvd1T3Nck3sJ+JwRBtPZSxV6Ci3c1kSg8PEBtP0SSKt9U6a/+hyUUhi9IynkfZ8ot+yPR3prhfCcaadGvzUYZtAPXiayeOGmjD3+KHBxBLtVJIlEW7CK6kwbSRMHWHsCFNPOI6EsU0PXg2eZRxSfF/yqw83OGs4nyamOdL3nmmuca4iFwcK9bVdfvHhTmitZ1xu8f0R9wN+XKlcQJqYbLTN8dbdjwz9k3QvuZDoSqOcQjuNNpoqlCluF7c7YsMXGf5WctM51nPP8dQyLw3Hq555aRnHmmmqccHj+gnfT5TWYdutIcfkBlkUb4SiENjKEkxMM3z49n0XfouHjDxlUHw502/rK8/xMXLz9MJ498Rw/0J3dUd3umG6e04ZxWnXcn9Y/FKmeKfphRIFqpS4psQPIS1WU1eY1uM6iyxzhMrQvkjnQmUJyhRor9BW7dGrNJpJQ6UUvvHEdcTPA2GZqC+PxHWmPk3UU5O+2bbDdWNaxpWpkGprlkgo5B73LouC/rhyevqX5eGZ9fGF0/N/LA//MJ4u6Y6XlNanzV66QOljSuIjXfcuS4l1JdFrvFUEv81rhbeaprG7wX+djsPhXTPe9qEQBBuwpUP7mtLX6WKW5WQ/Y5Z/6b9XQiUlRlcJpQ9pexefmPir/8lG+D+6pI2XBDmakQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler调用callback\"\n        title=\"Scheduler调用callback\"\n        src=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/00d43/schedule_callback.png\"\n        srcset=\"/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/63868/schedule_callback.png 250w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/0b533/schedule_callback.png 500w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/00d43/schedule_callback.png 1000w,\n/blog/static/e7a5ba63b1b3fdd71b78b5a7cf0e69f1/67a79/schedule_callback.png 1408w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在unstable_scheduleCallback中主要做了如下几件事:</p>\n<ol>\n<li>根据传入的执行函数和优先级创建执行任务，加入异步执行队列或者同步执行队列</li>\n<li>调度任务更新</li>\n</ol>\n<p>以下先只关注同步taskQueue的执行流程,requestHostCallback通过Message channel发起宏任务来执行flushWork,最终走入到workLoop整个调度的<a href=\"https://github.com/facebook/react/blob/00d4f95c2ad000f40ea0c774cc1ced3a0ceb6f23/packages/src/forks/SchedulerDOM.js#L200\">实现逻辑</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 733px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 131.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAD9UlEQVRIx42Vy27dNhCGz1sEjSXxTlGi7jo+Olc79zRANl0UfYsWBYp20V374F8hyY6dxEG6+DEUIQ5n5p/5udFGYIKnOjTEqUfnAWUcNpTYvEBKSZokK9KELMsQQnyF+/2NNorpuOP46sR02jJOI/3xTHfzhtiPn37O7u13sFFS0bcT/e6CawaqqiBUNaHp8UW5/HQf3QPSb2IjhcDmOf76jN/dYPsJ2U648YirOvKiIHQjoe3J24G8atdL0vTpCKWShDygrScVklQqshnGIYxHSIXQdoE0FmXMGs23Up6LrpWm3R3pLm/ozi9pTi+J447heKS/HuinHdc3F8ZpjzWGJEm+cnQf8RKhMQYXAjZGfF3jmxrjHc4oiuDIvV2s0Zo0SZ/EvdPN3DZSKnxpCYPFd5py5/CdRVqB0ALp5GqtRFmJ9gqdK5STmKCWvYcI5RphWzTkzpOJFCEzhJydSTK5OhVKIB/ZT2uz2kcOBcYHhI+koUFWA9oHXGwp24EQK6phh/WB5OrqIc00u8O6/owUqy31/pb69gPx9Ip4+57hdENdN2zHLVUV0cYuzT2zPh9Mrp6TJFdLj84XLZctfSglUmuK6xP15S3V5R3V5S3x/Aa7PROmW6rdifb0kub4gvbyiridcLHBlxXW57hY46sWqRQbpQVKKeq2ZNw39IcR148U0558vMb3PXGaqHYTWmvUDGPR1i3npNJoly9lm8ldWVYa1/aUhx3l+UA8TFSnifK4p51adueG7alDVANp0SKKBhl7ZL3FOH9X2+QhZaU0sdsRj69x44nmsKI9X+jPN8S6pfSOGHLKEDA+J1NmnSApybKHMdxoK5BCorTCthWuqzFtjR86TF0g65rMBuQsaXO9vEeK7JGkPTT1EuFcB5EJuqHn8uqW/WXP9jDRnF5Q78/4cb8IR3F6Tdi/QIaK7ItZfiwUGy0lQkmaENkOW8qZkG4kL0qapqRqW0K/pahb7DJ6V3fO0icVZ9FDIeQyp23fUm6PVLsz1nqMlhhrUS5fmJ3FNn0iqs8dKrnQb/06u/MoKTfPbUaaJQ8MflGvbyu2EYt89dtqaY9hKmkOHdXxmri7Rt/pX/adyD45nNO11jD1A1XTkccapRxpki2lWNNM/9d7srA8H/Ah0I4jxfawCGtVx0UgbIgobR4JwiObfr13l7LF5gETI7Yssd5QtYHQtYRhiyvmHpRIo5B6tbOszZ2x7qnFrq+imEkROJMSWkveePLa4aPC1RofEqT6AVem2JCg3dWyNvm6nvfMbIuE7OoZ6fNnbOyPvxE//kX/8z/EX/6l/Olv8o9/4D7+if/wO+bdr+i3v6LffQ7z5ff7Ff8BGwXxHBeZuTwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"workLoop调用\"\n        title=\"workLoop调用\"\n        src=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png\"\n        srcset=\"/blog/static/698bc99b2ece9e667db04ba2c3e361f0/63868/workloop.png 250w,\n/blog/static/698bc99b2ece9e667db04ba2c3e361f0/0b533/workloop.png 500w,\n/blog/static/698bc99b2ece9e667db04ba2c3e361f0/00b70/workloop.png 733w\"\n        sizes=\"(max-width: 733px) 100vw, 733px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0f586/yieldTimeout.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACs0lEQVQ4y4WU2W4cNxBF9RlG1NybO3ubGY2txWNY8Ev+/4NO0GxFseEkergokkAfXNYt9l2KEeUiqS2cHzY+P125XM+cdz1slJJxsWLdiBQC8YHuaq1IqQjTRn7+Rry9Mt5+UL488fT9kfOXE+enK/M6oaxCGoXUCm0USu+Sh+yxvvMxEoRg0gNTFMxRMgfBmgRbVX2/BMGSFFuznKthqhZbLb45xl3V4rJFGXUA0yAoKZJOE3GOjEvGLg3tPWOI+FIYU0Jbi5OCogSDlCgl312+XznXShzuyW3DXV4Qp0c+Xb/z6fINOV+IywO+rbiYkcaih4F0PzAI+VtPpZTcpZzx+5XVwDTuV9OsWbMEyZo00yhpZqDZgeYkq1dkr7HZYoPpMl53WHe4p7xvzKgPuaNab7pkd/KmQSCGN0fD7wl3hznnA+gUYzWMVffqksZlg58cLpmj+c3h57GfhWVkrK4H09fNHQ5LKQfQj5TrzHw7Ux4afor4OeFnh02mw8Ps8Hu6k+va0x2LwTeLtuoAxv3KQhBCJc0n/LQyxoIdPS5ErNGYNwltGbRFKIOQGiHVsdf2px6mhJSCGBOnyzPTdu2wWgLzlFmWQq2R1jKyLPzRTtzXE0OaECFzv9eyYIx5eymldvpoHcu0sT5/pTxcia0grUQogTT7S5Boc/S6y2u0U+j93Kq+7qEcT28fUtWbX7ZAOyema2b5XChrJFVPrB47mgPyNgkHUL3X7jCEcIRiDGub2OZGDI6SAyV78l5LIMWA0YZhGI6R+Rf9MjZaKebrC+fXP1luP5hfXpkeb4x1wbbzL7P2X/rpbyMZnUM7h/Wxp2t6ygltLMq6fz76H2B3uI+N1ppWZlIsB8AYlNbHx3pPb3h395HLA6gUPlfydiGtZ+JyIrSluzWxIJX6EPQ38C/i5f+uoA5LswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"任务过期处理逻辑\"\n        title=\"任务过期处理逻辑\"\n        src=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/00d43/yieldTimeout.png\"\n        srcset=\"/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/63868/yieldTimeout.png 250w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0b533/yieldTimeout.png 500w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/00d43/yieldTimeout.png 1000w,\n/blog/static/0f8e2a77fb4e9e1c3bb8a3bda58434ff/0f586/yieldTimeout.png 1498w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nwookLoop是实现任务调用的核心逻辑,它主要实现了如下几件事:</p>\n<ol>\n<li>对可执行时间进行了切片(yieldInterval == 5ms)</li>\n<li>当超时可执行时间后,进行任务队列的调整在下个事件循环中唤起任务调度逻辑.这里有区分的是同步任务队列是直接通过postMessage发起调用,延迟任务队列是通过timer(setTimeout)发起调用.</li>\n</ol>\n<p>抛开源码可以简单的理解Scheduler的调度任务实现思路如下图,它正好实现了任务调度切片,优先级,高优任务插入等逻辑.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 984px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9INAQKD//EABcQAAMBAAAAAAAAAAAAAAAAAAABIDH/2gAIAQEAAQUCFl//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAACAwEBAAAAAAAAAAAAAAABIQAQETFR/9oACAEBAAE/ITyelNuDcVGDlf/aAAwDAQACAAMAAAAQMwc8/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHBABAAICAwEAAAAAAAAAAAAAAQARITEQUWGB/9oACAEBAAE/EN1dRqHbhBk0fNTqPsLrNQYmPD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scheduler整体的思路\"\n        title=\"Scheduler整体的思路\"\n        src=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg\"\n        srcset=\"/blog/static/d056dfc402ef23dd6cb937078e3b9073/0479a/how_scheduler_work.jpg 250w,\n/blog/static/d056dfc402ef23dd6cb937078e3b9073/41099/how_scheduler_work.jpg 500w,\n/blog/static/d056dfc402ef23dd6cb937078e3b9073/f30f2/how_scheduler_work.jpg 984w\"\n        sizes=\"(max-width: 984px) 100vw, 984px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考链接</h2>\n<p><a href=\"https://engineering.fb.com/2019/04/22/developer-tools/isinputpending-api/\">isInputPending的实现背景</a><br>\n<a href=\"https://web.dev/isinputpending/\">isInputPending的使用思路</a><br>\n<a href=\"https://someu.github.io/2020-11-10/react-scheduler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\">react scheduler源码解析</a><br>\n<a href=\"https://react.iamkasong.com/concurrent/scheduler.html#%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%E5%8E%9F%E7%90%86\">React技术解密</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"从Scheduler包来看React的任务调度","date":"2021-03-15","tags":"React","path":"/react-scheduler","top":null,"summary":null},"title":"从Scheduler包来看React的任务调度","date":"2021-03-15","tags":"React","path":"/react-scheduler","top":null,"summary":null},{"id":"5a169371-ce61-5740-8df6-19cc70f60667","html":"<p>最近公司组织架构调整，来字节的一年多时间难得有这样一段清闲的时光来思考下自己这段时间做的事，坐在电脑旁想用一句简短的话来总结下这一年，想了半个小时愣是没想出来。所以还是以片段的方式来思考下2020一些做的不好点的，希望2021这个新年能做的更好。</p>\n<h3>技术能力</h3>\n<ol>\n<li>从原来的B端业务场景比较快速的熟悉了C端Hybrid项目的开发流程。对于跨端开发的知识的深入度不够。</li>\n<li>快速处理问题的能力有提升</li>\n<li>业务实现设计思考比较欠缺，在忙于业务的时候并没有思考好业务代码的组织形式和方案。</li>\n</ol>\n<h3>业务理解</h3>\n<ol>\n<li>低头看的时间比较多，没有看的更宽或者从业务的视角看的更远。</li>\n<li>没有更好的从业务的视角去思考技术，导致从开发视角看一直在实现PM的各种业务，没有一个长期的技术路径视角。</li>\n</ol>\n<h3>管理协作</h3>\n<ol>\n<li>没有把握好自身的精力。有时候会压缩自己在短时间内做更多相对简单重复的事，而不是压缩自己做超出自己能力的事。</li>\n<li>原则性不够  需要意识到良好的规则能更好的让事情发展，应该与协作方一起建立规则，否则会导致自己疲于奔命得到的事情的结果不一定是正向的。举个例子：需求排期的时候会估算需求的测试时间，如果一味的为了赶时间点，去压缩这个测试时间，就可能导致下个需求跟这个需求同时出现问题。保证一件事做好有可能真的不比两件事做完差(自身成长+ 业务价值)</li>\n</ol>\n<h3>2021的一些小目标</h3>\n<ul>\n<li>在技术和业务上希望自己能小步慢走，踏踏实实，走几步回头看看。不是一味的低头快走。</li>\n<li>自身学习上多看一些书，给自己的笨脑瓜充电点。体重上要控制住自己的嘴，减重年度okr: 10KG。</li>\n</ul>\n<p>结尾附录一段看到的话，共勉</p>\n<p>当我们提，技术驱动业务的时候，我们说的是：“我们已经想清楚业务的目标是什么，知道技术能在其中起到什么作用，目前现状是什么，我们可以怎么做，并且每个双月都定期复盘和回顾。”\n当我们提，我们这个方向好缺人，里面隐含着：“我们知道长期这个方向要解决哪些问题，目标是什么，需要招什么样的人，招来做什么？”\n当我们问，如何才能在技术上走到下一个阶段？除了执行力和自驱力之外，想清楚规划和执行路径，也是很关键的一步。</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"2020年总结","date":"2021-02-01","tags":"年度总结","path":"/2020-summary","top":null,"summary":null},"title":"2020年总结","date":"2021-02-01","tags":"年度总结","path":"/2020-summary","top":null,"summary":null},{"id":"4151e490-cb74-597a-b9ce-9c6fa68b6efa","html":"<h2>概要</h2>\n<p>本文主要梳理前端路由的实现方案，按照如下的逻辑进行梳理：\n前置知识 => 路由方案现状 => 从源码的解读理解前端路由的实现过程</p>\n<h2>前置知识</h2>\n<h3>history</h3>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>history.length</td>\n<td>只读, 代表当前会话历史的长度</td>\n</tr>\n<tr>\n<td>history.state</td>\n<td>只读, 代表当前会话栈顶的state</td>\n</tr>\n<tr>\n<td>history.go(number) history.forward() history.back()</td>\n<td>从当前会话加载特定的页面,会触发popstate事件</td>\n</tr>\n<tr>\n<td>pushState(state, title, url)</td>\n<td>在当前会话的添加一个新的记录(关联state) url参数需要保证同源策略</td>\n</tr>\n<tr>\n<td>replaceState(state, title, url)</td>\n<td>替换当前会话栈顶的记录(不会增加history长度,关联state) url参数需要保证同源策略</td>\n</tr>\n</tbody>\n</table>\n<h4>history相关事件</h4>\n<p>当用户触发浏览器动作或者js调用history.back/history.forward/history.go方法时,会触发popstate事件。</p>\n<h3>hash相关事件</h3>\n<ol>\n<li>当url片段标识符改变(#xxx), 会触发hashchange事件。</li>\n<li>当设置与当前不同的hash片段的时候，会在当前会话中添加一个新的记录。</li>\n</ol>\n<h2>路由方案现状</h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>原理</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于history实现的路由方案</td>\n<td>使用history相关事件和方法完成路由的切换</td>\n<td>history可以设置同源下的任意url，需要注意与服务端结合的场景，防止出现404</td>\n</tr>\n<tr>\n<td>基于hash实现的路由方案</td>\n<td>使用hash相关事件完成路由的切换</td>\n<td>hash只能改变当前url的#，有局限性</td>\n</tr>\n</tbody>\n</table>\n<h2>从源码的了解路由的实现过程</h2>\n<p>以下源码分析了history路由的实现过程,源码涉及<a href=\"https://github.com/ReactTraining/history\">history</a>, <a href=\"https://github.com/ReactTraining/react-router\">react-router</a>.整体的实现逻辑如下</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 424px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 172%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC8UlEQVRIx62W6U5yMRCGuf/rIPzgF3dgQgCDyCIoyL7JjrKobAo1zyRz0gOFD83XZNKeLtN3+r6dnsB2uzVfX19ms9mY9XottRrfjO92O6/+lwW+v7/NaDQytVrNtFot02w2PeP7+fnZfHx8yKbXOA3s93tZDCJX6ff7ZjabGTa+2mG73ZbwDoeDmc/n4uDz8/P/OHx5eZHwB4PB3x0SMpNdBcdvb28+h9TnyBJShsOhoAJpo9Ew8XhcCOl2u6ZcLgspbGw7OEdSQDtXq5UQ8/r6akKhkHl/f5dQF4uFtDHGmUvNJk6Ex53s3Ov15OwymYxJp9MmkUhI/fT0ZKrVqle7ztVDyCBhsXsul/NNBg2hwzzkEQ31WYQMTqdTCZFzDAaD0qYPQpiDs+PFzjNU2UDAeDwWgyQMh6VSSbTJPGX3IstMhFHOzlW4lsc6vKRHcdjpdIRdkNIGGdoENUIH4Z9uihqLNSG4EF51U1iIE3QHImqIqFQqv3MICkSL7tTQn/19TiJOh5pgSQygpXButLXvVwnWztjUkBOJRLw+W3O2MeaSkCSHyWTisUpyuLm5Ebb55opxtsxT00g0CjsCIQUny+XSm0BhIQUFQBJO2RgjpdXrdakZhzzNPp5s9AmAXe4qpvmQzbhBJAXu9MPDg7m/v5c2NeOqAp8OtQ1iwqWQediEq8g1BBnJ4/HxUdr0oQQfQs4Ph+cyNmFyPdmIVzCVSokVCgVxWiwW/aSwyH5G2Z0atExGp4pAVcE6zZ929g643gmQqCyOZeOSkE829hNAm8MPh8PShj3VosuJaxPvz4GzIETqWCwm4fPNmWnImtlVixq2D+E1zyjJAX1qZkcmEEU0RGAnjpOHnpSPA4RsP/QswBGIIQrpZLNZkZX9Ap44BBGkoDt1yCZcRdhHdzjN5/MmGo2a29tbEfhJyJd+lrh6jPMDcHd3JxrkWU0mk/LEcgzeTTn+nQOdGshBZOvw+NWz5eXJ5rc/nK7cqKT8ABAkKsYiO95UAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"route\"\n        title=\"route\"\n        src=\"/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png\"\n        srcset=\"/blog/static/b70462c5399fc0b238df6097205f72be/63868/route.png 250w,\n/blog/static/b70462c5399fc0b238df6097205f72be/1cfa9/route.png 424w\"\n        sizes=\"(max-width: 424px) 100vw, 424px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>下面代码是在react项目中使用history路由实现的一个例子，它能实现根据特定的path来渲染对应的组件。</p>\n<pre><code>import './App.css';\nimport React from 'react'\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nfunction App() {\n  return (\n    &#x3C;Router >\n      &#x3C;Switch>\n        &#x3C;Route exact path=\"/\">\n            &#x3C;div>home&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/about\">\n            &#x3C;div>about&#x3C;/div>\n          &#x3C;/Route>\n          &#x3C;Route path=\"/dashboard\">\n            &#x3C;div>dashboard&#x3C;/div>\n          &#x3C;/Route>\n      &#x3C;/Switch>\n    &#x3C;/Router>\n  );\n}\nexport default App;\n</code></pre>\n<p>react-router/packages/react-router-dom/modules/BrowserRouter.js</p>\n<pre><code>import React from \"react\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory as createHistory } from \"history\";\n\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    // 初始化browser history 可以推断出路由的切换逻辑是history与Router结合的实现\n    return &#x3C;Router history={this.history} children={this.props.children} />;\n  }\n}\nexport default BrowserRouter;\n</code></pre>\n<p>packages/index.ts</p>\n<pre><code>// 在最后执行跳转的时候 会执行所有的listen函数\nfunction applyTx(nextAction: Action) {\n  action = nextAction;\n  [index, location] = getIndexAndLocation();\n  listeners.call({ action, location });\n}\nlet history: BrowserHistory = {\n  // 以下为主要的跳转函数，在实现跳转逻辑的时候都调用了applyT方法。\n  push,\n  replace,\n  go,\n  back() {\n    go(-1);\n  },\n  forward() {\n    go(1);\n  },\n  // listion方法用于增加路由切换的监听函数\n  listen(listener) {\n    return listeners.push(listener);\n  },\n  // block方法允许传入一个block函数,在路由跳转的时候会执行所有的blocker函数\n  block(blocker) {\n    let unblock = blockers.push(blocker);\n    if (blockers.length === 1) {\n      window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n    }\n    return function() {\n      unblock();\n      if (!blockers.length) {\n        window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n    };\n  }\n};\nreturn history;\n</code></pre>\n<p>从上面history源码看出，history这个库主要是维护history的相关状态(state, location, hash)并且增加路由跳转的告知能力.</p>\n<p>react-router/packages/react-router/modules/Router.js</p>\n<pre><code>import React from \"react\";\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.history.location\n    };\n    this._isMounted = false;\n    this._pendingLocation = null;\n    if (!props.staticContext) {\n      // 这里订阅了history的变化并且在变化的之后更新location\n      this.unlisten = props.history.listen(location => {\n        if (this._isMounted) {\n          this.setState({ location });\n        } else {\n          this._pendingLocation = location;\n        }\n      });\n    }\n  }\n  componentDidMount() {\n    this._isMounted = true;\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n  render() {\n    return (\n      // 将location作为context 在需要订阅的位置获取   Route消费location完成特定children的渲染。\n      &#x3C;RouterContext.Provider\n        value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      >\n        &#x3C;HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      &#x3C;/RouterContext.Provider>\n    );\n  }\n}\nexport default Router;\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"聊聊前端的路由方案","date":"2020-12-15","tags":"JavaScript","path":"/history","top":null,"summary":null},"title":"聊聊前端的路由方案","date":"2020-12-15","tags":"JavaScript","path":"/history","top":null,"summary":null},{"id":"d63f14dd-5eb9-58f0-b5db-568acadf7f7d","html":"<h2>为什么开启设计模式系列</h2>\n<p>在业务压力下，仓库的代码量是快速增长的。最近在思考如何能让代码有灵活性和扩展性。随着产品的迭代，一部分业务逻辑需要重新实现，那一种良好的设计是否能在重构代码中帮助我们呢？答案是确定的。开启这个系列主要有这两方面的原因:</p>\n<ol>\n<li>在翻译业务的时候更高效和优雅</li>\n<li>通过对模式的学习能加强思考</li>\n</ol>\n<p>设计模式是解决一类问题的通用的方案，希望通过对设计模式的学习能完善解决问题的能力，本系列会结合《设计模式-可复用面向对象软件的基础》来对设计模式进行比较全面的梳理。</p>\n<h2>创建型模式</h2>\n<p>创建型模式通过对实例化过程进行抽象，隐藏了底层的具体实现，从而实现更多的灵活性。创建型模式有以下几种:</p>\n<ol>\n<li>Abstract Factory(抽象工厂)</li>\n<li>Builder(生成器)</li>\n<li>Factory Method(工厂方法)</li>\n<li>Prototype(原型)</li>\n<li>Singleton(单例)</li>\n</ol>\n<p>本文会结合一个创建迷宫的示例来介绍以上几种设计模式.通常实现一个迷宫会定义以下基类:</p>\n<pre><code>// 方向枚举\nenum Direction { North, South, East, West };\n// 迷宫组件的公用抽象类\nclass MapSite {\n  public: virtual void Enter() = 0;\n}  \n// 房间  保存其他MapSite的引用\nclass Room: public MapSite {\n  public: \n    Room(int roomNo);\n    MapSite* GetSide(Direction) const;\n    void SetSide(Direction, MapSite*)\n  private:\n    MapSite* _sides[4];\n    int _roomNumber;\n}  \n// 墙 \nclass Wall : public MapSite {\n  public: \n    Wall();\n    virtual void Enter();\n}\n// 门\nclass Door : public MapSite {\n  public: \n    Door(Room* = 0, Room*  = 0);\n    virtual void Enter();\n    Room* OthersSideFrom(Room*);\n  private: \n    Room* _room1;\n    Room* _room2;\n    bool _isOpen;\n}\n// 迷宫类\nclass Maze {\n  public: \n    Maze();\n    // 在迷宫中添加Room\n    voidb AddRoom(Room *);\n    // 根据RoomNo查找Room\n    Room* RoomNo(int) const;\n  private:\n}\n// 一个可能的迷宫生成代码\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room* r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n</code></pre>\n<p>上面代码在定义迷宫布局的时候对布局过程进行了硬编码，在未来需要对迷宫布局进行修改的时候就需要修改硬编码逻辑。通过创建型模式可以实现将实现的细节封装起来，给予代码一定的可变化性。</p>\n<h3>Abstract Factory(抽象工厂) - 对象创建型模式</h3>\n<p>抽象工厂提供一个创建一系列相关或相互依赖对象的接口而无需指定他们具体的类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 891px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABK0lEQVQoz41S147DMAzL//9gkYHMZu80O01UkAcd0ocDToBgW5ZpkrYhInJdl7zfb9n3XZZlkW3buP5v4LyGoYWqqsT3fXk8HuK6rqRpKl3XyXEcvACX6fh6vbjfNA3376CGTnA4CAI2Pp9P5rqu3APb8zyZiGmaSKBt2y8lwCJDNCoT3cAazfcDd1t0Pc8ze/UyoyxLSjVNkwyLoqCUMAzFsixxHEeSJKHMKIq4hiUIMLRtm7W6rn8AIc3zPAIAGIcAeq9hDkAo6Puec2U4jiNrYP77KGhUc++ButoAmQCHd/A5jmPOcRkIQB1Y8lHQjFTP9BHgDx5Ae/I8p0wkQIZhkCzLOOqagGr0PcEMLw8/AYzUOkZcBFUq9UvyXwGmCoIvpKk1BVRr8G0+DjIE5/TLV5AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"抽象工厂结构\"\n        title=\"抽象工厂结构\"\n        src=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png\"\n        srcset=\"/blog/static/e80d271562927a69d5fe496b8b2a10a7/63868/abstractFactory.png 250w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/0b533/abstractFactory.png 500w,\n/blog/static/e80d271562927a69d5fe496b8b2a10a7/b7877/abstractFactory.png 891w\"\n        sizes=\"(max-width: 891px) 100vw, 891px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>AbstractFactory</li>\n</ul>\n<p>声明一个创建抽象产品对象的操作接口</p>\n<ul>\n<li>ConcreteFactory</li>\n</ul>\n<p>实现创建具体产品对象的操作</p>\n<ul>\n<li>AbstractProduct</li>\n</ul>\n<p>为一类产品对象声明接口</p>\n<ul>\n<li>ConcreteProduct</li>\n</ul>\n<p>定义一个将被相应具体工厂创建的产品对象，实现AbstractProduct接口</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>仅使用由AbstractFactory和AbstractProduct类声明的接口</p>\n<h4>适用性</h4>\n<p>抽象工厂通过将具体的对象创建延迟到ConcreteFactory中，能提供丰富的灵活性，适用于以下场景:</p>\n<ol>\n<li>一个系统要独立于它的产品的创建，组合和表示时</li>\n<li>一个系统要由多个产品系列中的一个来配置时</li>\n<li>需要对一系列相关产品对象设计进行联合使用时</li>\n<li>对外提供产品类库，提供统一的接口</li>\n</ol>\n<h4>优点&#x26;缺点</h4>\n<ul>\n<li>分离了具体类的实现，通过具体工厂封装对具体产品实现的细节。</li>\n<li>通过具体工厂的实现，将具体产品的实现逻辑封装在一起，增加了整体的一致性。但是在增加新的种类的产品的时候需要实现新的具体工厂。</li>\n</ul>\n<h4>代码示例</h4>\n<p>下面的代码使用Abstract Factory模式来创建一个迷宫。</p>\n<pre><code>// 定义抽象方法类\nclass MazeFactory {\n  public: \n    MazeFactory()\n  \n  virtual Maze* MakeMaze() const { return new Maze; }\n  virtual Wall* MakeWall() const { return new Wall; }\n  virtual Room* MakeRoom(int n) const { return new Room(n); }\n  virtual Door* MakeDoor(Room* r1, Room* r2) { return new Door(r1, r2); }\n}\n// 通过传递具体的工厂实现迷宫的创建\nMaze* MazeGame::CreateMaze(MazeFactory&#x26; factory) {\n  Maze* aMaze = factory.MakeMaze();\n  Room* r1 = factory.MakeRoom(1);\n  Room* r2 = factory.MakeRoom(2);\n  Door* aDoor = factory.MakeDoor(r1, r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  \n  r1.SetSide(North, factory.MakeWall())\n  r2.SetSide(North, factory.MakeWall());\n  // 省略很多的SetSide操作\n  return aMaze;\n} \n\n// 创建过程\nMazeGame game;\nMazeFactory factory\ngame.CreateMaze(factory)\n</code></pre>\n<p>通过传递ConcreteFactory,上面的代码将创建逻辑都封装在具体工厂中，这样通过传递不同的工厂就能完成不同类型对象的创建。</p>\n<h3>Builder(生成器) - 对象创建型模式</h3>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Builder模式能更好的封装产品的内部表示。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 871px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuTSRRX//EABcQAQADAAAAAAAAAAAAAAAAAAEAICH/2gAIAQEAAQUCBg7T/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABUQAQEAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Aqv/xAAYEAEBAQEBAAAAAAAAAAAAAAABABEhEP/aAAgBAQABPyED3cSusO+EX//aAAwDAQACAAMAAAAQpA//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCn/8QAFhEAAwAAAAAAAAAAAAAAAAAAECEx/9oACAECAQE/EEg//8QAGxAAAwACAwAAAAAAAAAAAAAAAAERMVEQIYH/2gAIAQEAAT8QqGJomDZtdCEqvvGTMD//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"生成器结构\"\n        title=\"生成器结构\"\n        src=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg\"\n        srcset=\"/blog/static/490bd2e7f7396de6958c32afdb0388ba/0479a/builder.jpg 250w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/41099/builder.jpg 500w,\n/blog/static/490bd2e7f7396de6958c32afdb0388ba/953da/builder.jpg 871w\"\n        sizes=\"(max-width: 871px) 100vw, 871px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Builder</li>\n</ul>\n<p>为创建一个Product对象的各个部件指定抽象接口</p>\n<ul>\n<li>ConcreteBuilder</li>\n</ul>\n<p>实现Builder的接口来完成对象的创建\n定义并明确它所创建的表示\n提供一个检索产品的接口</p>\n<ul>\n<li>Director</li>\n</ul>\n<p>构建一个使用Builder的接口对象</p>\n<ul>\n<li>Product</li>\n</ul>\n<p>被构造的复杂对象</p>\n<p>抽象的Builder类为Director要创建的对象定义操作。ConcreteBuilder实现Builder定义的方法</p>\n<h4>适用性</h4>\n<p>通过生成器可以把复杂的对象创建过程隐藏，通过不同的Builder来完成系统的创建, 适用于以下场景：</p>\n<ol>\n<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li>\n<li>当构造过程必须允许被构造的对象有不同的表示时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeBuilder {\n  public:\n    virtual void BuildMaze() {};\n    virtual void BuildRoom(int room) {};\n    virtual void BuildDoor(int roomFrom, int roomTo) {};\n    virtual Maze* GetMaze() { return 0  };\n  protected: \n    MazeBuilder();\n}\n// 在具体调用的时候 可以传递一个实现了抽象类builder的ConcreteBuilder\nMaze* MazeGame::CreateMaze(MazeBuilder&#x26; builder) {\n  builder.BuildMaze();\n  builder.BuildRoom(1);\n  builder.BuildRoom(2);\n  builder.BuildDoor(1,2);\n  return builder.GetMaze();\n}\n\n// 创建过程\nMaze* maze\nMazeGame game\nMazeBuilder builder\nmaze = game.CreateMaze(builder)\n</code></pre>\n<p>对比抽象工厂,Builder模式封装了创建过程的细节，通过不同的builder实现可以创建出不同的对象。</p>\n<h3>Factory Method(工厂方法) - 对象创建型模式</h3>\n<p>工厂方法定义一个用于创建对象的接口，让子类来实现对应的接口来创建对象。Factory Method使一个类的实例化延迟到其子类。</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 818px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABdUlEQVQoz5XRwY6DIBAG4L7/g/XQSisJcTSgoIK12GqtgDXadlPd3Zi97XeawPwBhs00TcYYa61zbhgG55yZTdP0/tH3fdd1fd8/Hg9rbdd1y+6mKAohhNaac04IWWo5m6bpMWOMaa0ZY0EQFEWRpmlZlp8w5/x0Oo3jqJTCGOd5boxpmoZS2vf9/X5vmuZ4PDZNQwjxPE8pJYSI4/g7jDEmhPi+DwBKqSzLktly59frxRiL45hzDgBZlgFAVVWf8HKg7/sIoe12myRJnudJkiilluTvy8dxbNt2vbh5rxhj1t1/PJ9P59x6ZWOt1VrXs/P5vBRa63Xf9Xqt67qqKinl7XbTWltrP2EhhJQSAA6HA0Jot9uFYXi5XBhjbduWZVnXte/7QRAghPb7ved5GGMp5ffAOOdpmgJAGIZxHAsh8jynlI4zYwxCiFK6NERRhDEWQnzCZVkCQBRFABAEAWOMUkoIWX5yYX+4Wdd1wzD8Hdh/fQFNImIPdtdAXwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"工厂方法\"\n        title=\"工厂方法\"\n        src=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png\"\n        srcset=\"/blog/static/4abb3f8897249fdbe81056e7e9397567/63868/factoryMethod.png 250w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/0b533/factoryMethod.png 500w,\n/blog/static/4abb3f8897249fdbe81056e7e9397567/64d87/factoryMethod.png 818w\"\n        sizes=\"(max-width: 818px) 100vw, 818px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Product</li>\n</ul>\n<p>定义工厂方法所创建对象的接口(抽象产品)</p>\n<ul>\n<li>ConcreateProduct</li>\n</ul>\n<p>实现Product的接口(具体产品)</p>\n<ul>\n<li>Creator</li>\n</ul>\n<p>声明工厂方法(抽象工厂)</p>\n<ul>\n<li>ConcreteCreator</li>\n</ul>\n<p>实现工厂方法，返回ConcreateProduct实例</p>\n<p>工厂方法依赖它的子类来实现工厂方法来完成对象的创建。</p>\n<h4>适用性</h4>\n<p>工厂方法适用于以下场景:</p>\n<ol>\n<li>父类不知道它需要创建的对象的类的时候</li>\n<li>当一个类希望它的子类来指定创建对象的时候</li>\n<li>当类将创建对象的职责委托给多个帮助子类中的某一个并且希望某一个帮助子类代理这个创建过程</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazeGame {\n  public: \n    Maze* CreateMaze();\n\n    // factory method;\n    virtual Maze* MakeMaze() const { return new Maze(); };\n    virtual Room* MakeRoom(int n ) const { return new Room(n); };\n    virtual Wall* MakeWall() const { return new Wall; };\n    virtual Door* MakeDoor(Room* r1, Room* r2) const { return new Door(r1,r2);  };  \n}\n\nMaze* MazeGame::CreateMaze() {\n  Maze* aMaze = new Maze();\n  Room* r1 = new Room();\n  Room&#x26; r2 = new Room();\n  Door* theDoor = new Door(r1,r2);\n  aMaze->AddRoom(r1);\n  aMaze->AddRoom(r2);\n  r1.SetSide(North, new Wall);\n  r2.SetSide(North, new Wall);\n  // 省略很多的SetSide操作\n  return aMaze\n}\n// 子类实现工厂方法来完成对象的创建\nclass BombedMazeGame : public MazeGame {\n  public:\n    BombedMazeGame()\n    virtual Room* MakeRoom(int n) const  { return new RoomWithBomb(n); };\n}\n</code></pre>\n<h3>PROTOTYPE（原型) - 对象创建型模式</h3>\n<p>原型模式通过原型实例指定创建对象的种类，通过拷贝原型来创建新的对象</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 747px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY03XQ224EIQiA4Xn/x5wLKzr1iA6guG3cbA9p+l0S/pBw1FpjjABQSqm1Pl7GGMwsGxGFEGKMPyeqepznaYwJIVzXZa3tvRMRM8cYvfcppbC9bYhYa0XElNIY40gplVJ67601Zv66rKrMXEpBRGaem6q21u77VtW11vFcXWs9fltriQgiEpGIrI2Z28bM3/FfRAQA1loAcM6NMUTEGOOcs9uc89+Ymb33Oef3bc4pIgCQc34+6DP+AFoUWqjoiPwWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"原型方法\"\n        title=\"原型方法\"\n        src=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png\"\n        srcset=\"/blog/static/248deee1cdd58b5c46a8d268e9521388/63868/prototype.png 250w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/0b533/prototype.png 500w,\n/blog/static/248deee1cdd58b5c46a8d268e9521388/d54e4/prototype.png 747w\"\n        sizes=\"(max-width: 747px) 100vw, 747px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Prototype</li>\n</ul>\n<p>声明一个克隆自身的接口</p>\n<ul>\n<li>ConcretePrototype</li>\n</ul>\n<p>实现一个克隆自身的操作</p>\n<ul>\n<li>Client</li>\n</ul>\n<p>让一个原型克隆自身从而创建一个新的对象</p>\n<h4>适用性</h4>\n<p>原型模式适用于以下场景:</p>\n<ol>\n<li>实例化的类需要在运行时刻指定</li>\n<li>类的实例状态是相似的，通过原型的克隆能减少类的创建</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class MazePrototypeFactory : public MazeFactory {\n  public :\n    MazePrototypeFactory(Maze* , Wall*, Room*, Door*);\n\n    virtual Maze* MakeMaze() const;\n    virtual Room* MakeRoom(int) const;\n    virtual Wall* MakeWall() const;\n    virtual Door* MakeDoor(Room*, Room*) const;\n\n  private:\n    Maze* _prototypeMaze;\n    Room* _prototypeRoom;\n    Wall* _prototypeWall;\n    Door* _prototypeDoor;\n}\n\nMazePrototypeFactory::MazePrototypeFactory (\n  Maze* m, Wall* w, Room* r,Door* d\n) {\n  _prototypeMaze = m;\n  _prototypeRoom = r;\n  _prototypeWall = w;\n  _prototypeDoor = d;\n}\n\nWall* MazePrototypeFactory::MakeWall() const {\n  return _prototypeWall->Clone();\n}\nMazeGame game;\n// 需要初始化传入的实例支持clone操作，可以通过传递不同的实例完成不同的对象创建\nMazePrototypeFactory simpleMazeFactory(new Maze, new Wall, new Room, new Door);\nMaze* maze = game.CreateMaze(simpleMazeFactory)\n</code></pre>\n<h3>SINGLETON（单例）- 对象创建型模式</h3>\n<p>保证一个类仅有一个实例，并提供一个访问他的全局访问点</p>\n<h4>结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu6QD//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARIUFR/9oACAEBAAE/IVnbLE7KXJ//2gAMAwEAAgADAAAAENDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECExkf/aAAgBAQABPxB7NzXBiTW+QRKuDzP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"单例模式\"\n        title=\"单例模式\"\n        src=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg\"\n        srcset=\"/blog/static/03abfaad5a513dba67caa9b1bc031dc5/0479a/singleton.jpg 250w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/41099/singleton.jpg 500w,\n/blog/static/03abfaad5a513dba67caa9b1bc031dc5/acb04/singleton.jpg 750w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Singleton</li>\n</ul>\n<p>定义一个Instance操作，允许客户访问它的唯一实例</p>\n<h4>适用性</h4>\n<p>单例模式适用于以下场景:</p>\n<ol>\n<li>唯一的实例需要全局访问时</li>\n</ol>\n<h4>示例代码</h4>\n<pre><code>class Singleton {\n  public: \n    static Singleton* Instance();\n  protected:\n    Singleton();\n  private:\n    static Singleton* _instance;\n}\n\nSingleton* Singleton::_instance = 0;\n// 对成员初始化未空，第一次访问的时候创建成员，再次访问直接范返回成员\nSingleton* Singleton::Instance() {\n  if(_instance == 0) {\n    _instance = new Singleton();\n  }\n  return _instance;\n}\n</code></pre>\n<p>在单例模式中，想要实现动态的确定单例的类型方式，可以通过维护单例注册表的方式来实现。</p>","fields":{"readingTime":{"text":"13 min read"}},"frontmatter":{"title":"编程拾遗系列设计模式-创建型模式","date":"2020-07-06","tags":"设计模式","path":"/build-pattern","top":null,"summary":null},"title":"编程拾遗系列设计模式-创建型模式","date":"2020-07-06","tags":"设计模式","path":"/build-pattern","top":null,"summary":null},{"id":"0b34442c-60aa-5d28-afd8-15a19f696f40","html":"<h2>前言</h2>\n<p>在react native开发中通常会使用Touchable<em>组件来实现对用户手势的处理.本篇文章从Touchable</em>组件的基本使用出发,逐步深入到react native中的手势处理的原理.</p>\n<h2>Touchable*组件</h2>\n<h3>基本使用</h3>\n<p>在react native中通常使用一下几种组件来实现点击的处理</p>\n<ol>\n<li>TouchableOpacity</li>\n<li>TouchableHighlight</li>\n<li>TouchableWithoutFeedback</li>\n</ol>\n<p>对于TouchableOpacity的基本使用如下,通过绑定onPress事件就能获取到用户的点击行为进行处理</p>\n<pre><code>    &#x3C;TouchableOpacity\n      style={styles.button}\n      onPress={(evt => { this.onPressEvt(evt)  })}\n    >\n      &#x3C;Text>Press Here&#x3C;/Text>\n    &#x3C;/TouchableOpacity>\n</code></pre>\n<p>在开发中不禁会有这样的疑问,为什么TouchableOpacity能响应用户的手势点击而普通的View组件却不行.这就引出了React Native中的手势处理流程</p>\n<h2>手势处理流程</h2>\n<p>React Native中组件对手势的响应是通过如下的阶段来实现:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 862px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG6AD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAWEAADAAAAAAAAAAAAAAAAAAAAEWH/2gAIAQEAAT8hVFRU/9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAABEAASFR/9oACAEBAAE/EH3VNXZv1f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react native 手势\"\n        title=\"react native 手势\"\n        src=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg\"\n        srcset=\"/blog/static/ce81bc10b7f8954188997bc88c7eef3f/0479a/gesturelifecycle.jpg 250w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/41099/gesturelifecycle.jpg 500w,\n/blog/static/ce81bc10b7f8954188997bc88c7eef3f/b4708/gesturelifecycle.jpg 862w\"\n        sizes=\"(max-width: 862px) 100vw, 862px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在每个阶段会有相应的处理函数来处理当前阶段的行为</p>\n<h3>手势响应的阶段</h3>\n<h4>申请阶段</h4>\n<ol>\n<li>View.props.onStartShouldSetResponder: (evt) => bool(返回true 代表当前组件申请在触摸手势的时候成为响应者)</li>\n<li>View.props.onMoveShouldSetResponder: (evt) => true(返回true 代表当前组件申请在移动手势的时候成为响应者)</li>\n</ol>\n<h4>通知阶段</h4>\n<ol>\n<li>View.props.onResponderGrant: (evt) => {}(获取手势处理回调)</li>\n<li>View.props.onResponderReject: (evt) => {}(获取手势处理失败回调)</li>\n</ol>\n<h4>响应阶段</h4>\n<ol>\n<li>View.props.onResponderMove: (evt) => { }(手势移动回调)</li>\n<li>View.props.onResponderRelease: (evt) => { }(手势行为结束(touchUp)回调)</li>\n</ol>\n<h4>释放阶段</h4>\n<ol>\n<li>View.props.onResponderTerminationRequest: (evt) => bool (当其他组件想成为当前手势的处理者时会触发,返回true表示释放)</li>\n<li>View.props.onResponderTerminate: (evt) => {} (当前组件失去响应者身份触发）</li>\n</ol>\n<h3>手势拦截</h3>\n<p>手势的响应是冒泡的,父元素可以使用如下的方法来实现对手势的拦截处理.</p>\n<ol>\n<li>View.props.onStartShouldSetResponderCapture: (evt)=> bool (返回true成为手势的处理者, 子元素不响应)</li>\n<li>View.props.onMoveShouldSetResponderCapture: (evt)=> bool ((返回true成为手势的处理者, 子元素不响应))</li>\n</ol>\n<h3>自定义响应组件实现</h3>\n<p>通过对手势处理阶段的了解,在定义响应组件的时候可以通过添加相应的函数来实现,react native定义了PanResponder.create()方法来快速的实现组件的定义.PanResponder响应回调函数中封装了事件和手势的状态信息,能更细致的实现对手势的处理.</p>\n<pre><code>class App extends Component {\n  constructor(props) {\n    super(props)\n    this.PanResponder = PanResponder.create({\n      onStartShouldSetPanResponder: (evt, gestureState) => true, // 触摸的时候成为手势响应者\n      onPanResponderStart: (evt, gestureState) => { console.log('someone touch me') }, // 触摸时间回调\n    })\n  }\n  render() {\n    return (\n      &#x3C;View style={styles.container} {...this.PanResponder.panHandlers} >&#x3C;/View>\n    )\n  }\n}\n</code></pre>\n<h2>后记</h2>\n<p>最新会按照下面的思路逐步的梳理下React Native相关入门与实践的一些知识.\n<img src=\"reactNativeBasic.png\" alt=\"react native 入门\"></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"react-native中的手势处理","date":"2020-04-15","tags":"跨端技术","path":"/rn-gesture","top":null,"summary":null},"title":"react-native中的手势处理","date":"2020-04-15","tags":"跨端技术","path":"/rn-gesture","top":null,"summary":null},{"id":"78aae74d-c5ef-5f1d-be91-cf676102521f","html":"<h2>前言</h2>\n<p>长列表优化是一个老生常谈问题,优化的方案也是相似的(减少内存占用,复用渲染结果,可视区域渲染,预渲染),在跨端开发的React Native中列表主要有FlatList和SectionList两种,以下主要通过对FlatList的介绍来了解React Native中的长列表.</p>\n<h2>FlatList</h2>\n<p>FlatList通过预渲染和可视区域渲染的方案,来降低列表渲染时候的内存占用从而提升页面的性能.下面从FlatList的基础使用来逐渐展开.</p>\n<h3>基本使用</h3>\n<pre><code>renderItem = ({ item, index }) => {\n  return &#x3C;View>&#x3C;Text style={{ color: 'white' }}>{item.name}&#x3C;/Text>&#x3C;/View>\n}\nrender() {\n  return (\n    &#x3C;FlatList\n      data={[{ name: 'a' }, { name: 'b' }, { name: 'c' }, { name: 'd' }]}\n      renderItem={this.renderItem}\n      keyExtractor={item => `${item.name}`}\n    />\n  )\n}\n</code></pre>\n<p>在上面的例子中通过设置data, renderItem(条目渲染函数)就完成了列表的渲染功能</p>\n<h3>结构</h3>\n<p>FlatList数据渲染的原理是通过数据项和底层容器ScrollView的布局事件计算出需要渲染的条目,在滚动过程中动态的更新渲染条目来完成列表的绘制.FlatList渲染的内部结构如下:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 157.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsTAAALEwEAmpwYAAADeElEQVRIx6VWS4/TZhS1xKhQsUfqhkUXlUCCUhYUqZVaCQmVAv+jSEjdTIuEkKpu2k2X7T9ohbqoVAQbEBKLMu9h3knITDJ24vgR5+XxK4kd56BzwenAamJs3Xyfbfn43nPPd74ocRwjDEP0ej0cHBxIuK4r1/1+H3w+HA5lPEoofEnXdTQaDezt7WF/fx+1Wg31eh22bWM0Gk0HGAQBLMtCs9nE7u6uAJZKJZimKfdyATITZrm1tSVZbmxsCHir1UKSJNMBkj+WR2BmtrCwIOUzO8Mwps8wiiIpk80gCMHZEM7JZZqm+UrmwRdZImMwGAi3uThkNr7vo1gsolqtTjLOBUgOydV4PJaXGZyTitwcMivKJJMKM9M0TficmkNmSKBMLmzE+vr6pNPTlxyEMEwDcRqj8LKA+aV56JaOcBCiYTQmgEcJAfQDHx2zg9iJ4Rs+AjOA1/AQ2REcy0E6TpHEiZTO7mc8Z0GQTBkEVRABv1f+wJf2V7hu3cQ31re4Zt/AFfUqnqnPkIQJ3AMX7XZblECNZkZCE6G8OOczgioIgNv2d1AOn66Cr9cv4f7cX3ix+AJaTRN+V1ZWsLS0hLW1NSwvL2N1dVWkVigUZJkyY8nwzv5vUNyzONn9Ase7l3HCvYwZ+yIe1Z8iDRMM4oFkUC6XJ86kqqoogWBUyqGSQ/xY0aH4wAc+MOMBygBQemM81HRZQYM3HPKgRhnZnAcz+x8wDDGra1AwwgzIQYqPWgY+L23iz+f/QS3vouk42N7eFmnRQFgm3YjBe1y6XAT8qIIwwA81C8oYmEkh4ykPuGCGeLBdhKPr8IJAyqM+yeHc3JzwSF4XFxdRqVTE9UU26AN3yn9DMWdx0vwJH5r3cKz1M5TGXTzSVl6bRvJatFz35JJdJQCvOSeHmV6ly983b73dZZ4jBf9a/wAjIBpGb+nt3Ti870iXf1F/xengY3zqXcTZ3jmcDz7DJ60zeFx/AqRAf9g/0iqRDMMoRF2rQ91ToVZUtO02quUqtIoG0zDzb1JOy8Hm1iZ2Cjsoloroub332/W4nbJb7BxNwfM9caHcewplQfXTAzkSnKtiaj8kIMEycrnY+YAGkAuQJTuOg2w7pasw+KFcewqFSkACEJBzOkduQL5I26fiPc+bjLR/usrUJfOHWXY6nUl0u10Jfmzaf1+vACaDAH8XnMbBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listSection\"\n        title=\"listSection\"\n        src=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/list.png\"\n        srcset=\"/blog/static/537a1f30ce767d4c75b99f25fe28c847/63868/list.png 250w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/0b533/list.png 500w,\n/blog/static/537a1f30ce767d4c75b99f25fe28c847/3e286/list.png 523w\"\n        sizes=\"(max-width: 523px) 100vw, 523px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>FlatList性能优化</h3>\n<h4>减少更新时列表项总体数目和条目的重渲染,</h4>\n<ol>\n<li>列表条目使用PureComponent或者shouldComponentUpdate来减少条目的更新.</li>\n<li>调整windowSize大小(默认是21)</li>\n<li>调整maxToRenderPerBatch的大小,控制每次更新的最大条目</li>\n</ol>\n<h4>减少内存的占用</h4>\n<ol>\n<li>在列表项中合理的使用缓存</li>\n<li>减少匿名函数的使用</li>\n<li>列表条目的渲染逻辑尽量简单</li>\n</ol>\n<h4>减少渲染过程中的计算</h4>\n<ol>\n<li>使用getItemLayout减少列表条目的计算过程</li>\n<li>调整滚动事件的触发频次(scrollEventThrottle)</li>\n</ol>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"聊聊React Native中的长列表","date":"2020-03-22","tags":"跨端技术","path":"/rn-list","top":null,"summary":null},"title":"聊聊React Native中的长列表","date":"2020-03-22","tags":"跨端技术","path":"/rn-list","top":null,"summary":null},{"id":"539f2928-413b-54c3-8c37-f42a442c9ec9","html":"<h2>前言</h2>\n<p>最近这半年从原来的PC转到了移动端开发(主要使用React Native),在跨端开发的时候需要与端上进行交互(jsBridge,使用端上的组件等).通过对端上知识的学习能在业务开发中知其所以然,也能更好的把一个方案落地.这篇简单梳理了第一行代码-Android的总体大纲.</p>\n<h2>读书导图</h2>\n<h3>笔记图片</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/6f464/android.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 124.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAACt0lEQVQ4y41Vy5KbMBDk//MT+Yoccs8hx1Tl6N31Az+wAYEkQBhwp3rYYbGNq6IqWbI06ul5Et1uN3AMw4Dr9Sqz63ro0HuunH3fo65rNCGgLEs45zAfEX8IYq1DHO9xOBwRQhBBPp6DKpi1FpdLijzP5b8q4hqpYNM0uKQp0ixD27YoikJWBeN9VVWyJ0iSnJGcz0Li7f1d2NLKiA/40JgcqSlQ1Q26rpvcoJq99zL1XBUYYxDH8aQsorb1ZoPNZismUFjNVEBVwH1ZWgFRAHFZ102WRKO5QfxGM2n23FSCcZIdgQ7HI3ZxjCRJJsbzAEb6h4+OxyNWq9VdQAhOZbxXpfQXA1PXzV0GCEPd0AQKn04nZFku5tNPCqjgPGcglN0c7A6QK5lx5rn5NBsorUUI7QS4P10EsG6apzyd8nCuwXkv5tAs3AYMgUzGoARf4pLFTyCLDMcIljifzzCmgHcWcerw888ev99ytD3QtQGuSBeBngA1edM0Q1GU8LbA322Obz9W+P4rxikrUXmHqjRw1k3l+eTDz1MpPzrfOifBIctb3wEdfXUTGSosyhKr1RtMUSyyFEBGbLvdSXKnaTqrFAbKS+JqzefG4P3jY/TxK4ZkxmQlKItemForjLjXnCQgFZLhfn+YwO7yUNOBJtB/WZYJmArwTgEJzqbwsV5L6lDBU5S1e1RVLaWlbUmFx/741SyodH84SPIvJXf02AikjV2+6llrWbIgBHELWZLtvJEsVMp4cCkbFK7GMPTo+1GJdvOxDybSILT8Hptw9EjZFB5t2wnDtr1OLFjr9C2bKtOKvmZVPfrxCTA1O9TBwvtKQOfCVuo8n2r78buzCJikG1iXv/xIaXAe0+WO4fzA+1qmBuLx4StmLxmWhzWulcVww2JXecXsCVAjHSqHaxswLJj6P+MfteqgdEuoDakAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"安卓基础知识\"\n        title=\"安卓基础知识\"\n        src=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/00d43/android.png\"\n        srcset=\"/blog/static/03da0e420e87d88d88c51f3b533002d2/63868/android.png 250w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/0b533/android.png 500w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/00d43/android.png 1000w,\n/blog/static/03da0e420e87d88d88c51f3b533002d2/6f464/android.png 1464w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>笔记导图</h3>\n<p><a href=\"https://github.com/icantunderstand/learnStuff/blob/master/androidBase.xmind\">第一行代码笔记</a></p>\n<h2>后记</h2>\n<p>后续会逐步更新react native和跨端开发的基础知识,希望能坚持下来.</p>","fields":{"readingTime":{"text":"1 min read"}},"frontmatter":{"title":"第一行代码-Android读书笔记","date":"2020-02-01","tags":"跨端技术","path":"/android-basic","top":null,"summary":null},"title":"第一行代码-Android读书笔记","date":"2020-02-01","tags":"跨端技术","path":"/android-basic","top":null,"summary":null},{"id":"03092f3c-0c57-5f81-b05c-9a7974eeb81b","html":"<p>本文主要对EcmaScript规范中函数对象解读。</p>\n<h2>函数对象</h2>\n<p>函数对象是对外部的词法环境和有一定入参的代码进行封装后的对象.函数对象的调用支持动态的绑定执行环境.在javascript函数执行的时候,实际上是调用当前函数对象的一些内置方法来实现的.下面是函数对象的一些内部实现:</p>\n<table>\n<thead>\n<tr>\n<th>内部实现</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[Environment]]</td>\n<td>Lexical Environment(词法环境)</td>\n<td>词法环境定义当前函数对象生成时候的外部环境,例如引用的外部变量等</td>\n</tr>\n<tr>\n<td>[[FormalParameters]]</td>\n<td>Parse Node</td>\n<td>定义函数的参数列表</td>\n</tr>\n<tr>\n<td>[[FunctionKind]]</td>\n<td>String</td>\n<td>函数类型(normal, classConstructor, generator, async, async generator)</td>\n</tr>\n<tr>\n<td>[[ECMAScriptCode]]</td>\n<td>Parse Node</td>\n<td>代码体</td>\n</tr>\n<tr>\n<td>[[ConstructorKind]]</td>\n<td>String</td>\n<td>构造类型,当函数通过new操作符进行调用的时候,会用到这个属性.(base derived)</td>\n</tr>\n<tr>\n<td>[[Realm]]</td>\n<td>Realm Record</td>\n<td>当前函数对象的Realm记录,在函数执行的时候需要将函数与Realm进行绑定,由Realm提供全局的环境对象等</td>\n</tr>\n<tr>\n<td>[[ScriptOrModule]]</td>\n<td>Script Record or Module Record</td>\n<td>记录当前函数对象不同创建方式的记录</td>\n</tr>\n<tr>\n<td>[[ThisMode]]</td>\n<td>(lexical, strict, global)</td>\n<td>this会在进入函数的执行环境时进行绑定.lexical代表着this的确定规则是由外部的词法环境决定的(箭头函数),strict代表this是由函数的调用者提供的,global代表着this由外部的全局对象指定(需要区分严格和非严格模式).</td>\n</tr>\n<tr>\n<td>[[Strict]]</td>\n<td>Boolean</td>\n<td>确定当前函数是否是一个在严格模式下执行的函数</td>\n</tr>\n<tr>\n<td>[[IsClassConstructor]]</td>\n<td>Boolean</td>\n<td>是否是构造函数，如果是构造函数通过[[Call]]方式会报类型错误</td>\n</tr>\n</tbody>\n</table>\n<h2>规范详细解读</h2>\n<h3>[[Call]]</h3>\n<p>当通过指定this调用函数对象的时候，实际上会执行内部定义的[[Call]]方法。<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/da952/Call.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACJUlEQVQ4y42SC4+tKBCE/f9/cHfmzpnjG48KKiIgoN9GZ242+7ib7aRIA6Horq6s719UVUn+fFJ1glpJKiVplaSUI41eEXrF7gG/71hrcc7hY8SnhN8Dbk+4kDjOk6wUA3nT0/aSVggaOdIpieh66qqmrBrK5kVeC4qiuD/O85xCCIpOkFcVz6rlWQs268jmZcG4nZgOnPd3FXsIhHTi48F5nnAenMfBX+I+P7/z6+5rn3nv6aeFblkQQ09ZljTDRKs2WmWQqyOk45vj/BNfFJw/+b+RGWNohpHKrLSrpnqNFK+JYtCU0lKOmkdRk1cNKaV/Ev8N2SXwpc97UfCjKvl4PHh/e+O3t3c+niWjmpn0hg+J/xPZtax6oShLummiapo7z9uGZyco64au75FS0Q2SfjaMq2VPiRgjIaZb/wvpOL8IQ4jU4sViLWvcWTeD1prVxRvaBqbVotSEVAplLcvuWbRmWS3TtjMZj9sj2XEc9P3A74+Cclip5UY+GGo1M7sNnyI2BmyKpJ9T/a+Wr0o+i5yi7/l4TfwQirey50MoHv1EriY+p5l8HNDriosBl+JtMef8bWi7R/b4pXF26dDLmdVa/BFxu2dbNZsPbD5iXMC4iDEbyzyjncXEgLEbZrNoF9B2v9u9CZdl4dFJ3quOz6KmaMU9ADktSO1Qxt9enJ1lGMeb9Fdx2+ZquREvhFqplaGdDXI21HWFlPKXD/8NV4V/AHQW58QcFWiNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Call步骤\"\n        title=\"Call步骤\"\n        src=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/00d43/Call.png\"\n        srcset=\"/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/63868/Call.png 250w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/0b533/Call.png 500w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/00d43/Call.png 1000w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/aa440/Call.png 1500w,\n/blog/static/8dd9d06f57c8cce4f5daf449ce67ade9/da952/Call.png 1872w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>将执行上下文切换到当前的执行上下文并对当前的执行上下文做基础的设置</li>\n<li>如果当前函数是类构造函数报错并退出</li>\n<li>在执行上下文上绑定this</li>\n<li>执行函数</li>\n<li>恢复执行上下文，如果有返回值返回结果</li>\n</ol>\n<h3>[[Construct]]</h3>\n<p>当通过new操作符调用一个函数对象的时候,实际上会执行内部定义的[[Construct]]方法,下面从规范上理解[[Construct]]方法从而理解调用构造函数的实际行为.<br>\n在通过new调用构造函数的时候会进行一些参数的修正然后调用构造函数的[[Construct]]\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/5068c/newBefore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABlklEQVQoz42Su27cMBBF9f9t+nxG6sCt26RJvGuJEiW+RFLUY7VriSeQErsL4AEOwEvM3JkBWUgpEULw+lpifY8eBsQQkWlAx4j2jtJ1SN0xpkTOmW3b2Pf8l5zZD71t5H2nkI1EdR1N02CtRWlNpxRKK3QYaH58p3v6ivz5hAkDSim01tg4YdOKiQsuBFqtSdNEIQ4za88pGymRbUdVVVRCIFR3UoqSsqkpmwZR12fzqpaUdUvVKoT3VKEnLQvF78vlTKrKksv1SlW3XF5esMYweI+PETtN9N5jtcaHcOKspXcO73uMtYQY2Y+VjwIzJlwMWKMxWtPHiFtm0u3Gtu+w7+S885kotA80Q6IbbnRmoq47tFL4ZaFfZoZpIqWE73timnjb9vNh/kchtacxA7X+RdU9I+wV4Xpc71gfD7acPzVZ/pdXaGOIw0hrvlG3X2jtM2a8YWLApYQbE/f7ncfjcXKcj29zX1fWdf3Q76bFcXHE9IDpDR73zDJPrLeVZZ5P5mVhHEfmeT7XP2pijIQQPvS74R+Y/K4/ae/U/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"newBefore\"\n        title=\"newBefore\"\n        src=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/00d43/newBefore.png\"\n        srcset=\"/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/63868/newBefore.png 250w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/0b533/newBefore.png 500w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/00d43/newBefore.png 1000w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/aa440/newBefore.png 1500w,\n/blog/static/a8aaa81fd5db1aa5cda7b93d497f662b/5068c/newBefore.png 1917w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/9efb3/new.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIklEQVQ4y42T2Y7bMBRD8/+/VxQoWkydWNa+Wd5i2UlO4Uy36cxDBRDSiwjykveUc0Z2EqUUnRBIrZExYnJ+RYrInEnjwlJ31roxzzPLsjBPM8v1yrJvXPf9+T7lcUDlhCsZ02d8SqhOouUBhVQG0Qo65bh0GtFJRNvSdR3n85lWCIS1CGNIOXPat400LLh+xsWIdPap0oRMnipLvfF6HvzPOdW6YqznHBJtSjRKcu40L60ijVfytDIslcfj8V841VqJOeNK/7RhteaYaykD9/v9nbjnxw+U/SbctkouBeEsX7Xiu7Eol1BxQoYRGQZ0HpFpJA4Tpa44759ztNbS/rx/kT4VGh8RMXOJAeE9rTQ0KnC2I40ttKHQxp65Vrb7jXq7sd1ub6z+IVxXYt8TxwFpLSEGnDHYkLAho13C50JY5iemulLWlWldD4b3oRydUkcQKdA4T+MT343jpbN8bS3fWk3jEnGeqfv+4dz+Vnm6LgttJ2mNxZSCGSa0C+hQUGnB9jO6zJiYSSGQx5G+rvTzRN8X8rg+21Dm+kq4Xq/kccKm8kx3GAopRa7L/K5/h4j748G27xz9ffxj+WfKG/tWMSFysY6mvXBpGkSnEMrRaY/wBRELIhTCMNIPAzHG37V6Y/lIuT8KrS3fpObT5y80QtCcW17OAmUDnTK8tBeUs3jv36l6E8qx5FJKrI+4cUZaj9CaEDw87h+u10d1+UX4A21fMqcRX5VbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"new\"\n        title=\"new\"\n        src=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/00d43/new.png\"\n        srcset=\"/blog/static/86392e3bf6a558e63d48d3af4d524b6b/63868/new.png 250w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/0b533/new.png 500w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/00d43/new.png 1000w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/aa440/new.png 1500w,\n/blog/static/86392e3bf6a558e63d48d3af4d524b6b/9efb3/new.png 1894w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/161ec/createObj.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQoz3WS646kIBBGff/368kmCiLSAord4/3aezYwmZ9byUlRX6Coj5BJY3jkOX+kJBcCXWmMMdR1nei6Dj9PuGWmW2bcHJkw00gzTzTjwHEe/EZWhQ4dOqrWY71jnibWdWVZFuZ5Zt02tuNg3Xf242DZtrT+JdXryr7vnOdJJqREx2kaj7YBqTRfXw8ejwdCiISuKkqlkJGypCxVQhQFpZR47wkhpCEy5R3Ke+ouYBr3c1AIpJQoVaUcNWVtclHZJu3TpkGVJZWuecZaa8ZxJHNNg7cNMbfO4Z3DWUfbtolo575vrvPkvi6O4+A8D67r+tHvD+f9SXoka/sB17/x32+efaAdvulCoHmaRB8CXWzufSLWfegTzvlkN178er24rpusfloKrSlKRVFbRG1RxiGUoVCGsjbkukJoTfwRea3JtaY2T5y1OOfS+8WmwzCQNdHqe8C/V/x7wY8zYVnxy0o7LeznxQcSN3Dxl4v/xz9Dj1l5z6jTKAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"objCreate\"\n        title=\"objCreate\"\n        src=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/00d43/createObj.png\"\n        srcset=\"/blog/static/80ebd86d02879f771e89df0c9c2b0c60/63868/createObj.png 250w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/0b533/createObj.png 500w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/00d43/createObj.png 1000w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/aa440/createObj.png 1500w,\n/blog/static/80ebd86d02879f771e89df0c9c2b0c60/161ec/createObj.png 1840w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n[[Construct]]主要分为一下几个步骤:</p>\n<ol>\n<li>将执行上下文定义为当前的执行上下文</li>\n<li>获取当前函数对象的[[ConstructorKind]], 如果是base类型, 将当前的执行环境的this设置为以构造函数为原型创建的对象</li>\n<li>创建新的执行上下文将2中的this绑定到当前的执行上下文</li>\n<li>在当前的词法环境和环境记录上执行构造函数</li>\n<li>退出当前的执行上下文,返回到上次的执行上下文</li>\n<li>如果执行构造函数的结果是有返回值的,当返回一个对象的时候直接将执行结果返回.当有返回结果但是不是对象的时候返回之前创建的this</li>\n<li>没有返回值的时候,返回之前创建的this.</li>\n</ol>\n<h4>简单实现一个new的调用过程</h4>\n<pre><code>function myNew(Con, ...args) {\n  const obj = Object.create(Con.prototype);\n  const ret = Con.call(obj, args);\n  if(ret instanceof Object &#x26;&#x26; ret !== null) {\n    return ret;\n  }\n  return obj;\n}\n</code></pre>\n<h3>Object.create</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6cf0fab11d6071570431a07fe120598e/019a6/ObjectCreate.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+klEQVQY032QW26DMBBF2f93V9Bt9Ct7aKUooQ8IoRA/iAUo4NepbLVRko9auhpd2XfmeAohJX3bUG2eaV6e6F43qNXSjoZhnoghEGO8KoRwp9u7pEJKyaGuqD92HKuSrm0YjEFojVQKYwxaa4ZhuCr5lOv7Pvvz+Zz9PM8UKdD1J3qhSLRaKZxdcdayXC4sy8I0Tfnx5dffEnrv72ph15VDd6KWmqrt2X81bN8ryqqh7TqmccxDhBDoYcjE/50ikZy0Yn885IbbzyNvZU1ZfyPMxOwso7WEGK+hx73d7dB5h5IKoRTWe1wAH8l1sZ7Fuaz0pb/QbeNHwh/2uc30ZuRRvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Object.create\"\n        title=\"Object.create\"\n        src=\"/blog/static/6cf0fab11d6071570431a07fe120598e/00d43/ObjectCreate.png\"\n        srcset=\"/blog/static/6cf0fab11d6071570431a07fe120598e/63868/ObjectCreate.png 250w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/0b533/ObjectCreate.png 500w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/00d43/ObjectCreate.png 1000w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/aa440/ObjectCreate.png 1500w,\n/blog/static/6cf0fab11d6071570431a07fe120598e/019a6/ObjectCreate.png 1818w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>判断传入的原型是否是Object/Null，不是的话抛出异常</li>\n<li>根据传入的原型创建对象(如果传入的原型参数是空那么创建的对象没有原型)</li>\n<li>在创建的对象上定义属性并返回结果</li>\n</ol>\n<h3>规范示例</h3>\n<p>[[Environment]]定义函数对象创建时候的外部词法环境.实际上在javascript中函数就是闭包的概念.函数在创建的时候就已经跟外部的词法环境进行了绑定,在调用的时候并不会改变函数的外部的词法环境.</p>\n<pre><code>const a = 100;\nfunction test() {\n  console.log(a);\n}\nfunction test2() {\n  const a = 200;\n  test();\n}\nconst obj = {\n  a: function() {\n    test();\n  }\n}\ntest2() // 100\nobj.a(); // 100\n</code></pre>\n<p>在一个构造函数中返回一个非对象:</p>\n<pre><code>function Person(name) {\n  this.name = name;\n  return 1;\n}\nconst person = new Person('ss'); // { name: 'ss' }\n</code></pre>\n<p>对于this的确定,可以参考下面的确定规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://tc39.github.io/ecma262/#sec-ecmascript-function-objects\">ECMAScript2020</a><br>\n<a href=\"http://ldllidonglin.github.io/blog/2019/04/26/2019-04-26-ECMAScript2016%E8%A7%84%E8%8C%83%E7%90%86%E8%A7%A3%EF%BC%888%EF%BC%89-new%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/\">ECMAScript2016规范理解（8）-new表达式的执行过程</a><br>\n<a href=\"https://icantunderstand.cn/2019/01/15/LE/\">深入理解javascript系列之执行环境</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"ECMAScript规范-函数对象","date":"2019-05-29","tags":"JavaScript","path":"/ecmascript-function","top":null,"summary":null},"title":"ECMAScript规范-函数对象","date":"2019-05-29","tags":"JavaScript","path":"/ecmascript-function","top":null,"summary":null},{"id":"e89f4cab-35d0-5952-9b50-1f844568b2f2","html":"<h2>前言</h2>\n<pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nReactDOM.render(&#x3C;App />, document.getElementById('root'));\n</code></pre>\n<p>当通过create-react-app初始化一个项目的时候,上面这段代码就在浏览器中绘制出了内容.ReactDOM.render(ReactElement, Container, callback)是怎么将React组件绘制到浏览器中的呢?本文是React源码阅读系列的起始篇,在这篇文章中主要围绕以下两个方面进行介绍:</p>\n<ol>\n<li>render()方法调用中相关函数的调用</li>\n<li>render()方法调用中产生的数据结构的梳理</li>\n</ol>\n<p>阅读源码是一个知其然知其所以然的过程.通过源码阅读的过程中我们能学习到一些设计,代码优化,解决方案等,通过这些来反哺实际工作的遇到的问题.这个也是这个系列想要获得并且与大家分享的内容.</p>\n<h2>如何阅读React源码</h2>\n<p>React仓库是一个包含多个package的仓库.在阅读源码之前需要对独立的仓库有个简单的认识.比如react通过react-reconciler和renderer(react-dom, react-native)来完成页面的渲染.</p>\n<ol>\n<li>\n<p>下载<a href=\"https://github.com/facebook/react\">react源码</a>, 打包本地文件</p>\n<p>yarn build react/index,react-dom/index,scheduler --type=NODE</p>\n</li>\n<li>\n<p>通过yarn link声明包的指向</p>\n<p>cd build/node_modules/react\n// 声明react指向\nyarn link\ncd build/node_modules/react-dom\n// 声明react-dom指向\nyarn link</p>\n</li>\n<li>\n<p>把项目中的依赖指向设定的包</p>\n<p>yarn link react react-dom</p>\n</li>\n<li>\n<p>增加断点调试</p>\n</li>\n</ol>\n<h2>ReactDOM.render()调用过程中的函数调用</h2>\n<p>以下所有代码基于React 16.8.6</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 218px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/548b054e096b5dbdd8ab61b79d1b93ba/5c416/renderFunc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 241.28440366972478%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAwCAYAAAARtFotAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHUUlEQVRIx41XCVNaWRbmj07VVHei2dNVE2MiLqhIlGjU9GSbpaqno6QjCrKDS0eT6ThqOu7GhSgCb+WxKKuKfF33PBaJS88rP+653znvcOWd+93zNAAQjK3DFtDBE+6CTzTCy3fBJxjJHivOS5xX6IKXM8K2p8M8ZwUK7K+AQqHAUkHDPkLxdbjkFjiCbRhYrMfwViNMKw/wevE+Xi/cx9CGFkNftDCtPsDb9QbYAq0U/0myACcXJHRLbRj92oY+1w08cVzHU+9NGnvs1/Di17t46r2FJ/Zr5DctauGR2/BJtJ6fcC++AgtfB5esgzfWCk+Ujarti6vzEudRdHBJLbCKdZgV3xYTnlQnjKYELMguLEd8WJK9ZSxKHvzOOas4Bha3KDuxG1s8+xsWCvQV9E1VYFweyKaOz/cXY9j9KljS4govu3K5Q/z/VwGaWEqAkgojmuLOgPHbgXVEkmFE02zOXRiXyETUFXr3euHi2uEKdxDcXAdcRbg5A2x+Q9mnchXQPGyAPdyCD9x/UDgGNGNcL7wRPbyyAR6pA25BD4/YQXDzjFc5r2RQOUFfBpt7pUdwSTr8JhYTjqwY0Gb6Cx5br6LfewPtpr/isa0GncPfo2vkCrosV8g2Wq+S3W2rwRNHLfrc12G0XIHRchXd7u8rCcfCfRjxN2F0pxX2vTY4Qu1whvQ0usLq6GRjUOUZR+A6aO4M6mELNeOj9FpN6A52wSU307KdYssZuMTz+Yq/FTbxIab5f+HkCNAE4+sIxJewF19WkSgivozg/gr88u/YiS6UubL/FHbjCxAOvqqFnclmkMmkkclkqpDOpJHNZREKhpBIJMhW406jcm86k0Qysw/NeLgP4xEjxqXHFcjdmIh0Y1LphifEuG6Myypf8jGUYsmvdGFy95/QWDf1MG83wPK1CeYtLd5uNMC8qcWbtYf4eaEOlp0mGks+JmuDy/XEDW83YmhTS/L2dqsenu1+aAZmm2EY+g7do7Xod9/Eq+kf8NhaC6OlBj/6bqHXeR3Pxm+ThJE9cYckrcd2Dc8n75Ck9TpuoNddA8dqHzRsBzjlJpIkgtwCd0SVKY/SSrYv1kYjQ8nvVk7Zsg7uWBM8O73QfOJtmJdGKhCrMRMewvTXgQp3OqZsWzAnmfE57C2qTeFipA8OoUiJS2PKKOlhAfkLkcokkT3MkABeFqeq9gk0JSFl24ZwpIJxudQxhHAEmeRRxXd8FixWFdsCNJnDJGb4X2gvzkiDmIu+waxiwnzsDWbkAbwP/4S5qIn4OcVEMTPiAGakAbI/Sj/Tb3h4mFP/5WQ2pmqd3Ax7uBmD6/eopgZW/gbTeh1Ma3X46fMPGFy9R3M711Te92yfO6RGjPE9yOYyxYS5OHxcD8aUTtgDeqrF55N38WqK1WMNfhy7Rccpq8m/j92GPdCO8UgXfFInxqQu0st3wrNKwoNsDI69Djj4Fjj5Vngi7fDIKryRdlV8FT3xTFkcnO4UWmnFvtCTSsKj40M66IOJVQI7o0tgc7+0gB1lqew/ixVwiU3k88eVc/myK39UKNfYn5557CmzjxN2NuP8Qk3up5FOZs/1l+49KZx8c9CzdiS2go/8IOZEM20jhk+RYfw3YMKHgIns+SI/KwxhVjAjldkvr6x0lROuRn7FqFAPl9AKa7AR1j0tRnYbMLKrhS3cBEtAnY+GmuCU2APUIZ6UL074RXlPHZgzaECv8wbJV6f5Kp6N38FTz010j16DcaQG//7tHiaias+YSCmXrXASVuE+nIIODqGZwIqXlQXN+QrnENn8whWqEy6xjQXJiWXZh2XWYclezIfs1Gl95l3UiVV1Z5IP6VzybMJvidOXyMv0NI+yeRTy57VGBZT+Q7X7KlRWeN6VTasbPp3KolRZF9Vf1QrTuQOqdn5/G/z+FriEikBkFWLSj2X//xBUvpCf8WrcNrj9TURTfPUK1beANYyGG+Hi9XCLevgiBowpBnilDjj5Nowpj+Di2b7ugC/SQTaLtXGNmOXNVV2s2rQn1unpTihGmDeaSGFYM8QaKDb2OGqpSXo+eRs99lpYv+owrhhJvuhN4NuEwfga7IKWlGV0rxlv1usxuFKHXzYe0JnN7GG/lvjXS/dgC7XAK+thF7W0s84k5BN+jIf78Y5/iSnhJd7Lr/Ah8g9MiS8wJbwg+53wAtPSq7LNYie4fiyKvrMJ8/k8cofZMpi2HeePEOZCiMYUsuOJODLZdFUcA5M/esoF/HnZHOdOcHJcbN4zR5fKWNV7SiIdIZFlpRNObBCYvRddo/dA4WAba7tz8PNL4A+21Ji4GsPuY/eX9ZD2sTyJUa4BLqGdjgGX2EZHALPZQ2I2e1l0i+3kY4rEODYf5R5iTX5XTHiiJlxXpmjTe8VHGI92YnDxAfXXL6fvUtmwkimBlQ3rtR+Zv6MDjQkGU6rqhJEpOIQW6uhZt+8Mt8Pib4Z9r5XeUJnNxpHtZlh3dLD4WzC81QSLX1dMOF1O+Ad/ywI6ZgPl1gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reactRenderFunc\"\n        title=\"reactRenderFunc\"\n        src=\"/blog/static/548b054e096b5dbdd8ab61b79d1b93ba/5c416/renderFunc.png\"\n        srcset=\"/blog/static/548b054e096b5dbdd8ab61b79d1b93ba/5c416/renderFunc.png 218w\"\n        sizes=\"(max-width: 218px) 100vw, 218px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>走入ReactDOM.render()源码</h3>\n<p>首先定位到packages/react-dom/src/client/ReactDOM.js\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 698px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ccc403ac7ab7468246c5721e902cf82e/487bb/domRender.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC+ElEQVQ4y52U226jVhSG8xSpOR+92YABY2OM8RHHsevJTNJeVDMv0Mve9P2lr2LbsWamSaXmYmn/WoKP9e/1i7tCuPz1lPL384h1HjDQDUxDR9cGGLqOaRhog3t0XVM9bTDAtCxs28a6nt/X3dBz6NoJz89n2v2RaFRQ1EvKdke53FMuO6abI+O6ZbJYU7UbQt+/Qf8FdBwHNxpR7r8we3yh2p+ZTmecn77y+9c/OTx84dPnb3x++cZ6vqTKCnzPe3M6BXQdmzAeKdDs8MTi199IkpSm27E6HZlv1tTLlkmaE3geA027wd607PseSVYg0gJfZgRxRuB6FGlMmkqyUUwcR5imqQC9o/dgCuh5Hkkimc8yUukxHUsSGTK4v0cf/II+GKBrGqauqWVdTuNN2MWy6+L7Lov1gqbbsz4eaPaPiKIiKmuicYUc5cSTOSKfIssamWZouoFhWuimiW6YGFcHasLeThSPWKx2tKst9apjsdqy7Q6sNlumVUW93NKstjTrjrqascgTkmFILocUckgyDHBd5zphEBB6LsXQo0kChGNQCJ9p5DOLh0jfJfYd8qFPGrgkoU9bJArW5AmLPGYkQoIg4M62HeJYUo5zTNslzKb4UYzjenhBiGFZKnOmZX+nLbSrzd7uRVsXy/3W4liQZxKR5pTro7onEUmiKMLqQf0Lhqmu5mdtXvXr1hVQiIgkjvF9H8+xiESAEAFShupjURSSxOLaG6rqezK6aCFC+vhdJ3QRUcSu65gvlhTjjNOpZbetOZ2WPDw0rFYVh8OCpinpujm7Xa16m81M6badqGszTbVlH8s0iIqK8fqAzMbomo6uG2iarupVX84fdX/21du+BduxbeJxRf34QvvpD/KqwbJMHMdW9V6If65bDm3LIi5nTHZHxqsHZvszkUywrl/9GHA8Y9qdKdsttm398ND/gd6Aspgy2R6pjy9Um0f6wP/XX+Vd4Gts0jRVge0D7Xr+h6ZTQCEERVGoJfSAS5kfmq4H/gP/FkIGbbuk8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domRender\"\n        title=\"domRender\"\n        src=\"/blog/static/ccc403ac7ab7468246c5721e902cf82e/487bb/domRender.png\"\n        srcset=\"/blog/static/ccc403ac7ab7468246c5721e902cf82e/63868/domRender.png 250w,\n/blog/static/ccc403ac7ab7468246c5721e902cf82e/0b533/domRender.png 500w,\n/blog/static/ccc403ac7ab7468246c5721e902cf82e/487bb/domRender.png 698w\"\n        sizes=\"(max-width: 698px) 100vw, 698px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n可以看到ReactDOM.render()方法将当前的ReactElement和Container信息传递给了legacyRenderSubtreeIntoContainer.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b5582cb16e1290c05326982304c8019a/fe9e8/containerRender.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC7UlEQVQ4y4WU627bRhCF+RrlbS+8L6+iSNOUFCVV7LS1oaBFgwJtUPRX3/8RvmJXieE0sPzjYHbJmd2ZOWfWy7sZs/uZD3dv+fePO/5+XPl8vuHP8w2ff1v563zDPx9vOJ82ZHVNHEXEcfwivLSo2BxOtMuRat3R7ncM+1vaaUTnOTpN0UlKmiQUeeaCoiuHemnVsD58Yv/4iel0Yno4MT+8p+lbQt93wVEUOhuGIVH8WoZ5Sbe8oZlW6q5j2A70fUMcRkT/c74cfh1emqYorYlFjJQxSgqEEMQW9qCvayEQ8lvYGPEMdu/FIiIzkqJVZLWFJq0kaSXc3q6zWl6+lQKdCVQmSEpFUijS0vprZ3Wu8FSSUU8zm8OedhkxvaGdt/T7A808Uk8Tm+OR8d0b2mVHWXfU/UhRlERh+H0PE5ViTEO/rjRDjU4FUmuE1MSxLV8hVHKBTomFQn75FwQBQRA6svwgcNazuir7ATN0NDcL7e1CXtdUw0Q93TprNjNJXjJ0FduxYRgM89yx2dSs64ZpatluW4wp8UQckdcdy0+/sv7yO2aYEUIikxTbDqETtxZSkSSaNNXPrPrGKiXxpJQUWU5SGNKqJats2ZljWsYRWsQox6IgDC9afMk62SilaApDUvXIsiNvB8x2obJl5ylDldObgjzPrwr6iRR7c14lVI2mbjWllU4u0IVC55JYR0grk0o5nX0du5fGz7OCHfuG0/sfuf/4yP35gcPdB4ZlR9MNFE2PqQq0lmitXp9lIaXTU9FNjOuB5bBjOR7ZH3eM247tNDBPHePYMI4tyvo/y/L70UskF6Zbx/Jyf6a2MimqS6O/NP150NUedrV0t2ZlST3v6eadYzcMfIRzip7eQNvv1+DFscRKZx4WTFGiVeRko7McqbTTols/K/VqhtbRZlgPM90wMG1bqm7AjAt5VVN2I832ljTLnmb36vNl0zTGuOfH9318PyC0c+n7hGHgSg/8H1w/X2PYZvgf6TQ+Dh0+uR0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"containerRender\"\n        title=\"containerRender\"\n        src=\"/blog/static/b5582cb16e1290c05326982304c8019a/00d43/containerRender.png\"\n        srcset=\"/blog/static/b5582cb16e1290c05326982304c8019a/63868/containerRender.png 250w,\n/blog/static/b5582cb16e1290c05326982304c8019a/0b533/containerRender.png 500w,\n/blog/static/b5582cb16e1290c05326982304c8019a/00d43/containerRender.png 1000w,\n/blog/static/b5582cb16e1290c05326982304c8019a/fe9e8/containerRender.png 1146w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n由于是首次mount,这个时候还没有root节点并且是应用的根节点这里直接进行root节点的创建.最后调用root的render方法就开始进行页面的绘制.在legacyCreateRootFromDOMContainer方法中会对当前容器的内容进行清理.这里调用创建了ReactRoot节点.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 972px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/7ae9c/createReactRoot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABu0lEQVQoz22S3U7cMBCF9y0qNrFj52eT2InjkGQ37MLC0iJVAgoUbtqC+v5P8VUJVEUqF58851wcz2hmkZWOZneF333h9umJ+98v3Dw/8+3lF7c/f3Dz8MDd0yPXd/fcfH9ktz9Ha02SJB+y0HGCP/vM5usD/vQSvz2h3Y90hy3W14TLgCD4RxiGSCk/RAjBIs8L7G6L7ToK68hyQ2ksRWmQoeBoDgxZvnsn768OgiXB8mhm+mwRRQrbbmk25/SX1wxXtzQnF3TjiG8sTWNwrqRxhrouZz1RVQXWrChsRV635LUnzbIpUJKZgnocqNdrqnVHWZf4Y8N627DZeYbRMe5bfGvnYO/ta6DNKWxN7o4pXPsWqCKiKEDpACE+EakjIhUgY4FUIXKuJdFEEhHK8L+Rw/cjK61J64ayd7hxTb3uqfp+7nLlagrvSHNNvFJkJp5rKcW8ACHCN171tJiF1jGdP8VVA2ZzwOzPMYcD5WbAbS7mkzK+Jy0stjuhaHpMO7AyNbbf4sYzqmFH5TtUJFlkWUYcKZSMCIVEKInQEVIrdBwznZVOUlQcE2eruZ68WaerVy/NiJN07vAPulILAw+TO9QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createReactRoot\"\n        title=\"createReactRoot\"\n        src=\"/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/7ae9c/createReactRoot.png\"\n        srcset=\"/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/63868/createReactRoot.png 250w,\n/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/0b533/createReactRoot.png 500w,\n/blog/static/91680b2c143842cd0cbd5fb4f5cc6eca/7ae9c/createReactRoot.png 972w\"\n        sizes=\"(max-width: 972px) 100vw, 972px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c5e79bbf934850f9fe4c7198d42ec888/46e51/ReactRoot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFUlEQVQY052Qy1KDQBBF+QxlhsDAPCBAIA9CHkQqhIVa7nSvW///A44F2bi0XJyqvnfRt297WXtj2V75fDvw/bHn6/2CSS2RTgjDkCAIWCwWf8ZbX0Z2wwur00CxP1JeDuyer6y7FhVF/1jY3ajPA/l2R3U+sjk0ZM4RhSG+EEgpkVIghSCQckbO/p3fegr37LJEGUdiLdrEOJdgTIzWCqMV2mgSm5K4DJVolDbzHBtLrO3sTVpbN7/IM5seu2pohlfq9kw3jvRDx/npRD/2VFVJvj1S7jvSosKVNUVzIls3LOsdrqgo9h3ltiVWCi+MDcl04ZSS5ui8Ioo1odIokyJ8H+E/zszVxF1L378jBMJ/mL2p8g9NYa5liRgmAQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reactRoot\"\n        title=\"reactRoot\"\n        src=\"/blog/static/c5e79bbf934850f9fe4c7198d42ec888/00d43/ReactRoot.png\"\n        srcset=\"/blog/static/c5e79bbf934850f9fe4c7198d42ec888/63868/ReactRoot.png 250w,\n/blog/static/c5e79bbf934850f9fe4c7198d42ec888/0b533/ReactRoot.png 500w,\n/blog/static/c5e79bbf934850f9fe4c7198d42ec888/00d43/ReactRoot.png 1000w,\n/blog/static/c5e79bbf934850f9fe4c7198d42ec888/46e51/ReactRoot.png 1003w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\ncreateContainer根据当前的container信息来创建根容器.\n定位到packages/react-reconciler/src/ReactFiberReconciler.js\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 983px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d744dcb576c159192651c4712d527cc4/91b29/createContainer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+ElEQVQY04WNSU7DQAAE/Y3EM94nnsXbTOIosYMUCCCxiAMP4AT8/weFSCQOHOBQUnUfuqM8y5n6mdaNKH9FEa6Zxp7P54GPlw3vT56325a6KoiFJEmSP4mkWFI2geH0Sjvf0x0eqEOgPx0YjjOVUiwWS6RM/h07DyZSYMOIv3vETTNuv8VPW5zVFGmKiJdIESPiC1KIi4tf+dulJEqThLb37G5OjMcD++OO9brHuhprVihtUab5IS8VyraUtaHSlqJanfvaNmRZRpRmKXalaXONLSt8Z+g7QwgNfnCYzmP8iO7X1O1wPjDDBt2FM0o7zDDi/IaiKPkCswmTgkGvCxoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createContainer\"\n        title=\"createContainer\"\n        src=\"/blog/static/d744dcb576c159192651c4712d527cc4/91b29/createContainer.png\"\n        srcset=\"/blog/static/d744dcb576c159192651c4712d527cc4/63868/createContainer.png 250w,\n/blog/static/d744dcb576c159192651c4712d527cc4/0b533/createContainer.png 500w,\n/blog/static/d744dcb576c159192651c4712d527cc4/91b29/createContainer.png 983w\"\n        sizes=\"(max-width: 983px) 100vw, 983px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n定位到packages/react-reconciler/src/ReactFiberRoot.js(Fiber !!!!!!)\n在createFiberRoot方法中,创建了根据当前的容器信息创建了FiberRoot并且创建了一个HostRootFiber进行相互引用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/52525f7a291707863825ad97e39b8ba5/05fb0/createFiberRoot.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABr0lEQVQoz42S2WobQRRE5zeiWXvvHs2u0UhCXmMldggB61H//yEnjBYTCAY/FNW36S6KqhutlyNl6NDtFlONrH4d2byf2B5P7I4nlHUkSUKWZV9CVE13bF7fGb//pr17pnl5IEwjWSFIs+LLQh+Cy9XE8HSgmiaa7UjdVhgpSNOUNF6QxjHp4oIknrEgWSwuPM+Lb9f7mCSJiXwz0OwfGB8fqboWO7SoqsRYh/QNoq2QfYNctdiuo+wmQj8x/3PLlnLY4MqaUHf4UBLlhSAXkpmlEoRgcU4htUQYg/CawmkKr5HeoJxDeYtyFmU12nuMMxhrkEISSSMJg6OaPMsxEHpH6D1CC5TJcaXElQrnFb7SmKAwQV9QGpQt0EFQqPxcXqRDi2vX1NOOZrOnWu/o7w/4dqTuenZ3W1ZDxWqoz1w3DaGbcPVA2a3PruI4IU1vpYw7+oefdPcHxqc3Vk+vdPtnNm9Hph9/GO5fWPbrc+jnomZk6cf534bnOVJSY5VDWY9y/pxllucUc655TpamFEJ8uiY30RtHwQaC8tiyvixxHF8fJFcX2X9OPhOdBf8CLMQh8QdqEjAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"createFiberRoot\"\n        title=\"createFiberRoot\"\n        src=\"/blog/static/52525f7a291707863825ad97e39b8ba5/00d43/createFiberRoot.png\"\n        srcset=\"/blog/static/52525f7a291707863825ad97e39b8ba5/63868/createFiberRoot.png 250w,\n/blog/static/52525f7a291707863825ad97e39b8ba5/0b533/createFiberRoot.png 500w,\n/blog/static/52525f7a291707863825ad97e39b8ba5/00d43/createFiberRoot.png 1000w,\n/blog/static/52525f7a291707863825ad97e39b8ba5/05fb0/createFiberRoot.png 1138w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>ReactDOM.render()调用过程中的数据结构</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/f058b/renderStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.999999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIUlEQVQY032RXUvCcBjF95WDboIKyVCq267Eu6CQzMILTSovhLoLUpmpaep82XTa3KZD5/b/RYkVIh04nIcDzwvnkYQQrNMXPl+w50NS3RDJ1gHxyv633mphekaNXldF10bk9RTxcoBLOUBhmEbiH9jukIx2RLIVJCbvkWwuB+oThYXr4S+gbGZJd45Jt08oje+QPOb8UMzxhYdhGKiqSqfbRhlUsRZ9bG+A6fYZz1Q83/1dak7RtQ9MY8LUmiFdVw5JvAa5qYSIybtUjScc28W0xjiOgzvzNl6/iqeu5SkqOWr6M03jBemhEeH+PUK2GSVTP0Wx8hua/TWKpe8LHkdRLt62OC9tE2/sbM5w/Ul/vVW90lzzjFghwFUxREIO8wk517n0JFsJLQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reactStruct\"\n        title=\"reactStruct\"\n        src=\"/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/f058b/renderStruct.png\"\n        srcset=\"/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/63868/renderStruct.png 250w,\n/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/0b533/renderStruct.png 500w,\n/blog/static/14dbf1020c707361e3ce32d83f6c0dd5/f058b/renderStruct.png 630w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n通过启动最开始create-react-app创建的项目,可以看到以下的输出.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8bea5b913ac20f4f3d728869ac3041fd/2c0d3/showRenderStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAmElEQVQY05XQywqDMBCFYd//HVvwUk3UxFzEadTmL0oXxVV74IMzMKtT6EYzjJFlEebZ4Zxlmgx2Moi37Gkh55382sj547tfFF3T4l0gycYqK9fkQ/5dcb/dUaqnqhrKskIpzTMlUkrs235+5T8UbdcxjCN13aD7HqU1xhi6h8HaQAiBGCMicjq6954QjpkSMYbznucFkZU3QZw2325BZlsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"showRenderStruct\"\n        title=\"showRenderStruct\"\n        src=\"/blog/static/8bea5b913ac20f4f3d728869ac3041fd/00d43/showRenderStruct.png\"\n        srcset=\"/blog/static/8bea5b913ac20f4f3d728869ac3041fd/63868/showRenderStruct.png 250w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/0b533/showRenderStruct.png 500w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/00d43/showRenderStruct.png 1000w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/aa440/showRenderStruct.png 1500w,\n/blog/static/8bea5b913ac20f4f3d728869ac3041fd/2c0d3/showRenderStruct.png 1849w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>后记</h2>\n<p>这篇文章只梳理了React在实际调用渲染函数之前的函数调用和数据结构.在这个过程中终于盼来了千呼万唤的fiber.之后的文章会继续深入react的渲染流程和fiber的实现来对react进行学习.</p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"React render流程梳理","date":"2019-05-10","tags":"React","path":"/react-render","top":null,"summary":null},"title":"React render流程梳理","date":"2019-05-10","tags":"React","path":"/react-render","top":null,"summary":null},{"id":"fccee0d2-2a7a-5228-b6ca-58de7a6fb82d","html":"<h2>前言</h2>\n<p>在react最新的reconciliation使用的是Fiber架构.Fiber使用的增量渲染的模式,具体的实现是渲染的任务可以被拆分,在页面更新的时候具体的任务可以被打断,复用.这些特性无疑对页面交互是有很大的提升.下面通过React Fiber Architecture这篇文章来对Fiber有个大体的认识.之后的系列我会深入react的源码来仔细学习Fiber的具体实现.</p>\n<h2>基础知识</h2>\n<h3>What is reconciliation?</h3>\n<h4>reconciliation</h4>\n<p>react通过Virtual Dom和真实Dom之间建立缓冲,通过diff出变化前后virtual Dom的差异来将差异更新到真实Dom上.reconciliation正是对比Virtual Dom差异的实现.</p>\n<h4>update(更新)</h4>\n<p>渲染页面的数据发生变化导致页面更新</p>\n<p>在没有reconciliation(调和)的情况下,数据的变动将会导致整个页面重新绘制.通过Virtual Dom来代表将要渲染的页面,将Virtual Dom交给对应的renderer(react-dom, react native)来进行页面的绘制.在页面更新的时候通过调和来生成前后Virtual Dom树的差异来进行页面的更新.这样一定程度上提高了页面的性能.React的更新策略是在下面的假设下进行的:</p>\n<ol>\n<li>组件很少进行跨层级的移动</li>\n<li>不同类型的组件生成的结构是不同的</li>\n<li>相同类型的列表元素可以通过唯一的标识来进行复用</li>\n</ol>\n<h3>Scheduling(调度)</h3>\n<h4>scheduling</h4>\n<p>确定哪些更新的任务需要执行</p>\n<h4>work(更新任务)</h4>\n<p>需要执行的任务,通常是页面的更新\nReact的构建UI的库,它采取pull(拉)的模式来处理页面的更新交互.在push(推)的模式中数据(更新)推动整个页面的更新.React对更新的任务进行了一定的调度,来达到更好的页面交互.React采用这种策略主要有以下的原因:</p>\n<ol>\n<li>在处理UI界面的时候,通常上不是所有的更新都需要立刻被执行的.(可以类比图片的懒加载)</li>\n<li>不同的类型更新应该有优先级.为了更好的交互体验,通过优先级可以提供更好的页面交互.(比如动画的优先级更高,页面会更加流畅)</li>\n<li>push的模式需要开发者组织页面的更新,pull的模式使得React可以帮助开发者实现更好的页面交互.</li>\n</ol>\n<h2>what is Fiber?</h2>\n<p>通过Fiber使得React可以更好的调度任务.主要有以下的功能:</p>\n<ol>\n<li>暂停任务并且在之后继续执行</li>\n<li>对不同的任务设置优先级</li>\n<li>复用之前完成的任务的结果</li>\n<li>丢弃不需要的任务</li>\n</ol>\n<p>在这里可以简单的将fiber理解为需要做的任务.在进行页面绘制的时候组件更新和函数执行的任务都会被推进执行的栈结构.这种模式当太多任务需要执行的时候会导致页面的交互变的卡顿.浏览器提供了两个api来处理上面的问题.</p>\n<ol>\n<li>requestIdleCallback 通过requestIdleCallback可以在空闲的时候执行一个低优先级的任务</li>\n<li>requestAnimationFrame 可以在浏览器下次重绘之前执行一个较高优先级的任务</li>\n</ol>\n<p>为了利用上面的函数来实现页面的更新,就需要将渲染的任务拆分成多个任务.Fiber架构可以理解为重新实现的栈而fiber节点是一个虚拟的栈帧.Fiber架构通过调度帧的执行逻辑来完成页面的更新.</p>\n<h3>fiber结构</h3>\n<p>一个fiber节点代表一个栈帧,也代表一个组件的实例.下面是fiber结构一些重要的属性:</p>\n<h4>type  key</h4>\n<p>type和key对于fiber节点的作用跟type和key对React element的作用一致. type可以判断fiber节点对应的是React组件还是宿主环境的组件(div).key用于调和的时候复用fiber.</p>\n<h4>child sibling  return</h4>\n<p>fiber是通过单链表进行关联的.fiber节点的return指向它的parent.child指向fiber第一个子节点.sibling指向当前fiber节点的兄弟节点.</p>\n<pre><code>function Parent() {\n  return [&#x3C;Child1 />, &#x3C;Child2 />]\n}\n</code></pre>\n<p>上面的结构Child1是Parent的child,Child2是Child1的sibling,Parent是Child1和Child2的return.</p>\n<h4>pendingWorkPriority</h4>\n<p>优先级</p>\n<h3>alternate</h3>\n<p>一个组件至多有两个fiber结构与它对应: 当前的fiber(正在处理的fiber),flushed fiber(处理完毕,准备渲染(commit)的fiber), alternate(当前fiber的替身).</p>\n<h2>参考</h2>\n<p><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a>\n<a href=\"http://www.ayqy.net/blog/dive-into-react-fiber/\">完全理解React Fiber</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"React Fiber Architecture(译)","date":"2019-05-09","tags":"React","path":"/react-fiber","top":null,"summary":null},"title":"React Fiber Architecture(译)","date":"2019-05-09","tags":"React","path":"/react-fiber","top":null,"summary":null},{"id":"df8f6b88-1488-54c8-9389-2453fcc16845","html":"<h2>为什么使用容器技术</h2>\n<p>在传统的软件部署方式中，开发者需要在不同的主机之前同步配置来确保应用运行环境的一致性。通过容器技术能有效的优化集群环境的部署，极大的改变软件开发和发布的方式。下面从容器与传统的虚拟化技术对比来揭开容器的面纱。</p>\n<h3>docker与传统的虚拟机方案的对比</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/91bde82c19e5c029f3ea93c87ea5572c/a0b80/different.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 107.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACMklEQVQ4y22U6Y7CMAyE8/5Pxx8kQJzaIu6rLbRQWq8+o4myXSpZOeqMx2Mn4fV62eFwsOPxaKfTyfI8t7Zt7f1+x9Hn78+86zr322631jTNHx8sAHa5XOx6vdrtdrPdbmf3+90PRrC29TWjjC9dCzgQDZbL5dIjA1YURQTEESZ1XVtd1T7H+Me55/PpJrbOECDsfD57KilDxv1+75KQBfOu7ZwhvmTEHiO+oaoqK8vSxuOxZT+ZPR6PyEAMCbZarfzgdDp1QyYA1+u1G+uoIYVgg5F1n6GyQOPNZuMECAorsuIfPs6QVHCCAQ4x5baL1UU//LIsc904iOEHCYzMooZsEJVNDjJPq6yKEhCWnCFI//OUqSiOg8HAJpOJA8JCfQcQOuMnJnQEmgPKHv8iQ7UKkRnRRBriADjFKPLCfTiM3vgx1x6sq0f1AWSBjuiXtg0GC9ol/QjAGTU4H2eQKpCuqkhUWqAsysgQQFWW9GCEH0Yg9gADxwHRh/zn87kfVB+m10m3B9Pdx5c5IOwzxquHA8yIgklgVRm2fADASG3GHEJ86oqgaKPRyBaLhevTfxwEyj6+Shm9kUAtQ2c4IAtGmKkNvgHyH910O9S/EZC2yW+5pzkcDm02mzkwr0f/nQOQ9GCloJxjFGDUENoaaWyY9BkqADoC7M9ZXf97iAP0ceCe0rCkkF49dEkrrnbqP7iyQBFIAWBGGH7TMLX4vDX//wUqpwYlZeZpH34zpfmN4S/QFFY8EAFUSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"different\"\n        title=\"different\"\n        src=\"/blog/static/91bde82c19e5c029f3ea93c87ea5572c/a0b80/different.png\"\n        srcset=\"/blog/static/91bde82c19e5c029f3ea93c87ea5572c/63868/different.png 250w,\n/blog/static/91bde82c19e5c029f3ea93c87ea5572c/0b533/different.png 500w,\n/blog/static/91bde82c19e5c029f3ea93c87ea5572c/a0b80/different.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>传统的虚拟机技术主要通过虚拟机监控器完成虚拟操作系统和宿主操作系统之间的交互.docker容器直接与宿主系统通信，减少了语言转换的过程,因此在启动速度和运行效率上更胜一筹.</li>\n<li>容器技术更加偏向于程序的移植和依赖的打包而虚拟机技术则是侧重于完全的虚拟出一个另一个虚拟环境。</li>\n<li>docker能提供更快的交付过程.通过合理的对宿主操作系统资源的划分,能有效地提高系统的资源利用率。</li>\n</ol>\n<h2>核心技术介绍</h2>\n<h3>namespace(隔离)</h3>\n<p>通过NameSpace技术可以修改容器的视图.</p>\n<pre><code>int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);\n</code></pre>\n<p>在linux中可以通过系统调用clone来创建新的进程,当第三个参数flags指定CLONE_NEWNS就会在新的namespace下启动新进程.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/3279e294d23ef287fc82b78db94dc906/f32b7/namespace.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABSklEQVQoz51S2XKCQBBcjajReJCrkh9ITEBUYDkEhJjy/z+pUz0LllYkSeWha4dhp6e3Z9RolWEaFOi+aajXAGoR4nq1xWidSdzk5GzinzANdpiFOzymnxgsU0z8AvfJHrauBCTvXCpsI5/rypDEe/SXCW42Oea6xMTPMQ9LDL0UahFAvfiGpDnbSElk6xJP2QEDLwUVUy1zJOu7CXpOLM2u3iPJdU7s+a4wLEXVXfwhxfSOCsfrTIrZYOhthbRbE0ohlTYQ5bXH9Iukz9nhSMAcGxCMb6NK7hD0ld/MS60uMQt2cpeNFX8KSbzHoPbQrn2lSstNJE9wQGzK4bG4iRtLek4ExSISmqeZi1wjEvP5lhOfD+QSTp/MlSEJ/aPZhjTF1C/Muvxl905huTHGm1wUcrnpy0NiJq/+Qyhm6+q4vFTKJr/uWwu+APHeN3Z6HfW8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"namespace\"\n        title=\"namespace\"\n        src=\"/blog/static/3279e294d23ef287fc82b78db94dc906/00d43/namespace.png\"\n        srcset=\"/blog/static/3279e294d23ef287fc82b78db94dc906/63868/namespace.png 250w,\n/blog/static/3279e294d23ef287fc82b78db94dc906/0b533/namespace.png 500w,\n/blog/static/3279e294d23ef287fc82b78db94dc906/00d43/namespace.png 1000w,\n/blog/static/3279e294d23ef287fc82b78db94dc906/f32b7/namespace.png 1136w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在上面的例子中系统本身有已经运行的很多进程,通过运行镜像并且执行bin/sh进程可以进入容器的交互界面.在容器中只能看到root进程和ps进程.这样通过namespace技术就实现了不同进程间的隔离.</p>\n<h3>Control Groups(限制)</h3>\n<p>namespace创建的进程与其他进程之前对主机的资源是竞争关系的.Linux Control Group技术就是限制进程组能够使用资源上限的一种技术.通过对容器使用资源的上线进行设置能有效地使用主机的资源和防止资源的过渡占用。</p>\n<h3>联合文件系统(Union File System)</h3>\n<p>联合文件系统可以同时挂载不同的实际文件或者目录到同一目录.Docker基于联合文件系统提出AUFS(Advanced Union File System).AUFS通过将新的镜像层挂载到老的镜像层之上,通过共享基础镜像和增量更新可以使docker的镜像管理更加快速。</p>\n<h2>docker核心概念介绍</h2>\n<h3>镜像</h3>\n<p>镜像是封装了虚拟环境的运行内容的文件包,docker通过利用AUFS实现了增量的镜像结构.</p>\n<h3>容器</h3>\n<p>容器是隔离的虚拟环境,里面运行着docker镜像.容器有以下的运行状态:</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Created</td>\n<td align=\"center\">容器已经被创建资源已经就绪,应用程序未运行</td>\n</tr>\n<tr>\n<td>Running</td>\n<td align=\"center\">容器中的应用容器处于运行中</td>\n</tr>\n<tr>\n<td>Paused</td>\n<td align=\"center\">容器暂停</td>\n</tr>\n<tr>\n<td>Stopped</td>\n<td align=\"center\">容器停止</td>\n</tr>\n<tr>\n<td>Deleted</td>\n<td align=\"center\">容器被删除,占有的资源以及资源的的管理信息已经被删除</td>\n</tr>\n<tr>\n<td>### 数据卷</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>docker运行时的持久化目录,通过将外部目录挂载到容器中,来实现数据的持久化.</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<h3>docker engine</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 780px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/a1792/dockerEngine.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACF0lEQVQ4y4VUa1faUBBMUNSivNS2fm5PaQnhlTdgIGB9W7GHWvv//8j2zCQ3JEDTD3uSm2xmd2Z2ow2f3+SwG8jJ8FK0r7Zo35x14JwN9Sybsxnm4yvBTr25HPVGorWs9MP9ji9NN5KGG8me4f0fLAZ8k8pgLDV7Kk13JlUrFL0dA5baLgu964+LwbLv2ncrUm44MwaAFcUDMyAgivxTki3A+18p4MX4uxwPJilg2Qzk3F/IxeQ6fg45NnXdBO3/+M1kdFA2fdFVpZYlh72RnHlzFoO+CMiC84kVSiORKN/5zVKqdsikA9PPmQIjTt1I6s5UPo6uCK63XT6HvqXkmgPsPKyoG5LfBwtWRacK8NyPNdzveGuniygb9yvRPvU5IqpydgZxputfhmsNi1y2ln/oJkYDOkKjymDC+Ws6MxaBXuge1DmrRaDG3QsTQQ1UVZe4giZMKhlu7t3ObUrvb5asivFIHUO0rNgUL6KuW7SzQLkOH1YErNtTBt3uBql+oF6zQ7478+dSs0IWRl6lP5Hj4SWvWkuB375IueOTNpLQ0Z7hshMAY1NYzJmyY9I2Ykl0GuamqxrP7/UzP6wmwsMUPRlsbAq6wqZwn3fR3Rqd259MBjW4vWtTlLtHvTE7Bos6fybR9qZ0n17ZITrJ7rEabHSsNgVAWuL6mu7GpnxePFJY0AJlhPqzAPDD6IqbxFVTHxdsyl+4DAFtbO+JwQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dockerEngine\"\n        title=\"dockerEngine\"\n        src=\"/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/a1792/dockerEngine.png\"\n        srcset=\"/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/63868/dockerEngine.png 250w,\n/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/0b533/dockerEngine.png 500w,\n/blog/static/58e76180f7926e9bad32f7ab4cd8b90d/a1792/dockerEngine.png 780w\"\n        sizes=\"(max-width: 780px) 100vw, 780px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\ndocker engine是负责启动镜像的服务,通过docker client提供的指令调用docker server提供的接口来实现对镜像和容器的操作.</p>\n<h2>使用镜像</h2>\n<h3>启动指令</h3>\n<pre><code>docker run --name nginx -p 80:80 -d nginx // --name 执行容器名 -p 宿主端口:容器端口 将宿主端口映射到容器的端口 -d 后台的方式启动 \n\ndocker run --name myredis redis\ndocekr run --name test --link  myredis:redis debian  // --link Container:Alias 目标容器的名称:目标容器的别名 建立容器之间的链接\n</code></pre>\n<h3>操作容器指令</h3>\n<pre><code>docker ps -a // 查看所有的容器  \ndocker images // 查看所有本地镜像 \ndocker stop name/ID  // 停止某个容器 \ndocker rm name/ID // 删除容器\ndocker rm $(docker ps -aq) // 删除所有容器\ndocker rmi $(docker images -q) // 删除所有本地镜像\n</code></pre>\n<h3>使用docker创建一个hello world应用</h3>\n<h4>编写程序文件</h4>\n<p>创建一个目录结构如下:<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 599px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9e987ebb1b9062f3b284fb7472d9291a/43142/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA50lEQVQoz52Q0W7CMAxF+Q+mUWInXcfWUAhp2m6QIFoGiP3/39ypAR4QE9N4OLqyYh/ZGbzPLKplgG+/UH0GzGwN26ygjcNkavBWXDN3DbQpsVx3mBqHuftAYSssmhUSkhiwTKFzjePxG9aWGA6fMBqNQcQgljcIwfEtSQQEcayFIIxJ4Vn0QmK8Oo9FWeOwPyCEAO8DlEohWUJK9SvqqpaQKjsL0wwT41DVDUJYR9lm00Yh3xFe4D5ZgtXLSZiZGkXjsW1b7HZ7dN02Zp7reNq/hf0Q0+kf6Jw9l+3+2vJWyHeaHzj5B5La0UdAZFlIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/9e987ebb1b9062f3b284fb7472d9291a/43142/category.png\"\n        srcset=\"/blog/static/9e987ebb1b9062f3b284fb7472d9291a/63868/category.png 250w,\n/blog/static/9e987ebb1b9062f3b284fb7472d9291a/0b533/category.png 500w,\n/blog/static/9e987ebb1b9062f3b284fb7472d9291a/43142/category.png 599w\"\n        sizes=\"(max-width: 599px) 100vw, 599px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在index.py中编写程序的主要功能如下:</p>\n<pre><code>from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n  return 'Hello world\\n'\n\nif __name__ == '__main__':\n  app.run(debug=True,host=\"0.0.0.0\") // 创建一个服务 在/路径下返回Hello world\n</code></pre>\n<h4>编写Dockerfile</h4>\n<p>镜像的构建可以通过Dockerfile和构建环境的上下文来完成.通过Dockerfile可以将镜像的构建过程持久化.</p>\n<pre><code>From python:3.4 // 从某一个基础镜像开始 From语句必须是Dockerfile的第一条语句\nRun pip install Flask==0.10.1 // 执行指定的指令  由于每次执行的执行都会行成新的镜像层,可以将多个指令进行合并\nWORKDIR /app // 执行Dockerfile指令执行的工作目录\nCOPY app /app  // src dest 这个指令将上下文的app目录复制到容器的app目录\nCMD python index.py // 容器启动时执行的指令\n</code></pre>\n<h4>构建镜像和启动容器</h4>\n<pre><code>docker build -t hello . //在当前目录的上下文上构建镜像\ndocker run --name haha -p 5000:5000 hello // 以haha容器名字启动helloword镜像 并且将容器的5000端口映射到外部的5000端口\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/218a4/run.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABEUlEQVQY02WQ6W7CMBCEXZIg7gQStU9AW0gK5LBzx0kptPT932eq3YAQ6o9Ps2vZs+MVxlbCLU/w9AVj1WGaHeGUZ6yqbyyKL3jNBS/tL7OsznCbH9jFCWas8RTWEPsS4lDdMXyFlergyBbzuGFdJBqzqMb4UHI92hcM9ZOwwvAjZzWDFOI9gdjIXgljq/CcH+GqDvOohh03jOkriNcIYh32emMdPfZv8SPDIIOXfbLpLKzgSH1NrOEkGlaQwQpShoaYfgrLTzHYSNDbf4aLuAFB6QZbybWbdmy6JFPZYqVa2Mn9HtXTsOLz8a5g49Eu779sRzVfnNB+DiXsRHMSSmRcExE0jNZzS0ja94rVuu7zD6I7rWtyPWZUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"run\"\n        title=\"run\"\n        src=\"/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/00d43/run.png\"\n        srcset=\"/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/63868/run.png 250w,\n/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/0b533/run.png 500w,\n/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/00d43/run.png 1000w,\n/blog/static/3cde57fd0f4d17734ee81d9f7f7139cc/218a4/run.png 1052w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"docker入门","date":"2019-04-28","tags":"工程化","path":"/docker","top":null,"summary":null},"title":"docker入门","date":"2019-04-28","tags":"工程化","path":"/docker","top":null,"summary":null},{"id":"76895145-6bce-5daf-ae09-0fdaa2ce4753","html":"<h2>简介</h2>\n<p>　　WEB同构应用指的是通过代码的编译转换手段(通常借助于babel)来让代码在不同端client(浏览器), server(服务器)运行.同构的web应用主要有以下的优点:</p>\n<ol>\n<li>一套代码多处运行减少维护成本</li>\n<li>任务拆分,通过同构可以实现更多的功能(SSR, fetchData)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b82aa5b7dcbe650b3365aa69d1137419/5a190/isomorphism.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACH0lEQVQ4y22U547CQAyE9/1fi780iSIheockJPSS5tPnO4cF3Upml8RlPJ6sy/NcsCzL5PtcFEW1s9iDIJAwDCWKosr4j+33e3FlWarz906w2ePxkOfzKdvtVlarlRY8n89yuVzU7ve7pGkqSZKIu91u6hiFUVV5s9lokrIoNdF8PpfT6SSNRkNms5lcr1eZTqeVER/Hsfq44/GoVUlC4HK5VCMh6/V6aSEWKIJ9oEUMNQZC9sPhIA7ok8lE6vW61Go13YfDoVYm8Wg00oKWEBTwaGb8cdaWDSpVOp2O7rQNcviDI5yV36KUMAj1HUCI42yG35tDb2q0Twss45AWQQtqaGCiIKIgiXlPEZ2yyiP7k0mRf0wY2STxb2Cv19P2Sci+2+0qZAyKpM60R8J/z3n+ISWCSU5nJDHpcIZL5yPxz76wfY3S/ng8VvmYMUAGizkLYoIINs3Sj+QYHMGPTZxn8GcGWmJB6vhZr9eqISDjQJDpkKGYLvv9viwWC1UCPsRh0ACXlbDtAclIypRBBBK4MdmAnOkaZ2b2GSqH/CGA6s1mU9rttk4PbpAT/PjCxt+/FPwzoByoeEAlHsAHKNitZfv0QEwx6CHOFzX/9baxAJz4ajAQozWmCneghJ9Wq6WThDfjk3cMC5qUw+9ry5Y/ZYZAAYYDDSzkMxgM1Lrdrk4ZP2cXql6qmXfBZm+Rk9S+KBLSml0KxiG3EO9+AMYPXMq0YF8iAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"isomorphism\"\n        title=\"isomorphism\"\n        src=\"/blog/static/b82aa5b7dcbe650b3365aa69d1137419/5a190/isomorphism.png\"\n        srcset=\"/blog/static/b82aa5b7dcbe650b3365aa69d1137419/63868/isomorphism.png 250w,\n/blog/static/b82aa5b7dcbe650b3365aa69d1137419/0b533/isomorphism.png 500w,\n/blog/static/b82aa5b7dcbe650b3365aa69d1137419/5a190/isomorphism.png 800w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>简单的实现思路</h2>\n<ol>\n<li>将client端的代码转换成server可以执行的代码(es6 => commonjs).</li>\n<li>在两端组合出一套模式相同的代码逻辑.下面的例子中在server和client端使用不同的react-router提供的组件.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bf1905df4de812eae1d1f3e6776426ad/35751/app.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB10lEQVQ4y5WS2W7bMBBF/RVJrIWiqIVaKUuyIsux4y2Fu+SlL/3/PzmF6RRB0ARIHi5mOOAc3BlyFhUdab/HTAdWP37TH75TLTrK6Rv5sKcet6yf/9CtH2mahmlYclyvOEwjQ78kjGKiNCPOS0KlmMlYozJDWrXk7T35YqDoV1TDRJplpEVFuZzQpiNKUsrhgayfyLoV5f2GONUU7YCZdqRZfgXK1GBMRlUkpHGM8Fzmtze4zhzXcXDubnHnty/5DZ4zt3KdOzzPs3V3fs1nKtHU04n77Z5FPzAcflK2g3XVrPfoylCPG9rtk3Vhxg1CCIQIXiSuCq75LNeavF0SFQW+CvGFwPc8AimRoULKkECGNg/CaxS+b++JdzQLhCBpDNXpRLV/JK0aksLgi8CC/UuzlfcaL80v9f+AMghQKiarO3Reoy+xavF98W6D+Af7yKGUEhUp1KJCNiXSFISL0p5F8Ar9EP4e8OIyH0b68zPNww7z+ER7PKN0aUf8DOgN8LLHrBnod2e6zZFue2Y4/aKejvYlP+vu1eFl7DAmChVmtaPsR+rxwX5mz3W/5lD4grTISZYtarkgTCI8x7Eg33O/tD8L1FqT6BSRxIS5RkbqzYWvwC7Av9bTc0i3qhGxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"App\"\n        title=\"App\"\n        src=\"/blog/static/bf1905df4de812eae1d1f3e6776426ad/35751/app.png\"\n        srcset=\"/blog/static/bf1905df4de812eae1d1f3e6776426ad/63868/app.png 250w,\n/blog/static/bf1905df4de812eae1d1f3e6776426ad/0b533/app.png 500w,\n/blog/static/bf1905df4de812eae1d1f3e6776426ad/35751/app.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n3. server端路由匹配,组装资源(css, js, data), 可以通过不同的中间件根据请求信息来组装.<br>\n4. client端路由匹配,匹配资源(data, 检查页面渲染结果是否正确).</p>\n<h2>过程</h2>\n<h3>代码转换</h3>\n<p>　　在进行代码转换的时候,首先要明白代码转换的目的才能明确对不同文件的转换策略.比如为了实现同构将client端的代码转换成server端可以运行的代码,对不同类型CSS文件的不同处理策略.通常借助于webpack来实现代码的转换功能.webpack会根据入口文件依次的解析引用的各种文件类型,通过配置的webpack loader可以实现对应文件类型的转换.以下主要从不同类型文件处理的角度进行介绍:</p>\n<h4>javascript</h4>\n<p>转换的目标是client端的代码(排除node_modules).\n将client转换成server端可以运行的代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 871px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e5742945b47fa9c8c9867704e895953b/9d5da/srctolib.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB40lEQVQ4y42U63KbMBCF8xiN0V0ISQjMxZjEt/oycWfaP33/pzkdCU/rNE3NjzOzEuhj9+yiJ84YlCnQHa5otmcUxoAxBkJpUowppUkxfqQnzjkYozDGQOcGUhsIzqGlQK7khwOPwAkopAQjBNWwQbM9wecKfWlRO4uMUCwygueM/Ib9DzoBhQDnDMYHtLsT+t0RXAisygKNmzQEByXlzAyFgJRTed3Xb1hff6LqBvTBpWy90ahsDinFfOCUJYerOwzn72gPb5DGgjKOL4sMz1mGjDwu+x0wNiOujSlgTQ5nchitYJRMik2Sgs/z8F6cC2yagE0o0FqNl8qh9ZOXWql34/QQyJOfArkr4YcdbLsGVxpLm2MVHILRqYp5Jd98jA1yZYUiNDBlDSEVnFYIRY5Cq/TebGDcLL1HaQ04zSAZhRI8+StumdH5JfNUcu0KnPo6lThULs1g9G+sPIzW85sSY1+WUNH4OCJ3//Gkz+aPfgTGRQgBtiiQZQvQCCQEhNCbyN0e+etDf3QDSjBKENoVuv0FYdig7F+wHPdY9RW2mw5tt4RthnQj1eMOVks03qZLhdF/ZCg4g28HDJcfaPeXdLA/vCXY5TxifF2jfj2l56vjNY3Psa+x62rs25D8ttbiF1VywpYXj5JcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"srcToLib\"\n        title=\"srcToLib\"\n        src=\"/blog/static/e5742945b47fa9c8c9867704e895953b/9d5da/srctolib.png\"\n        srcset=\"/blog/static/e5742945b47fa9c8c9867704e895953b/63868/srctolib.png 250w,\n/blog/static/e5742945b47fa9c8c9867704e895953b/0b533/srctolib.png 500w,\n/blog/static/e5742945b47fa9c8c9867704e895953b/9d5da/srctolib.png 871w\"\n        sizes=\"(max-width: 871px) 100vw, 871px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>css</h4>\n<p>对于CSS可以有以下两种的处理方法:</p>\n<ol>\n<li>css-in-js (css-loader style-loader)处理,包括node_modules,client端不需要提取的CSS</li>\n<li>client端全局样式或者通过mini-css-extract-plugin提取的样式</li>\n</ol>\n<h4>代码转换优化</h4>\n<h5>公有代码提取</h5>\n<p>可以使用DllPlugin对使用的基础组件库进行统一的提取和引用.提取公有模块代码主要有以下的好处:</p>\n<ol>\n<li>通过DllPlugin对公有代码的提取,能一定程度上加快webpack构建代码的速度</li>\n<li>公有部分的逻辑相对来说是变化的较少,可以充分的利用缓存</li>\n<li>减少其他bundle的体积,页面加载的资源更少</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/821e520963f2813946911c2ecea26c92/40601/dll.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACG0lEQVQ4y51T2XLTQBDUZ2DtrvY+dVmyJMeJDVRcBAqe+P+PaUorJ1DEvPDQNTvSTqt7ZlQIHSFNhA01Yj8jdBOkEBjHBm2f0EePYxuxjw59cBiiy+chejhrUVUVGGM5rijU0EKPPVSbIPYNhDP5IqEUhNAcS/o7ln/klLE3stdYmLbF8PwN3emM2DXQRsNoBSk4lBDQUuTzlm8xP5PiTdWfKCTncKGGMh7JakzJQyuJLlgcao+5CfDG5HxMPlueag/n3tvNhC5E7E8fEboRSqnNCmXZLl3tlSUIKTfLtxb8y24m5JyjXS6Yr98xXK4IMeFyaHHsa3TRY+w6uJAgBIdV8p3VdwoZJWjmJ8zXH+ifrhiXI57PI57PE47Lgv54Rnf6BO8sDskhBX+X6I1Qaw1jHWxqoYyDrhicEKitzmuyfpDsdrkNJd3a8Ep4j7SwPmC4fEGaH2FTAFMKlZS5eEcIqoqj4jxf5n8V83sK1wLbHNBcrrDTgLjs0R8GNFbDSA5KCCgp8xDWYbBbXPGBMOwIy6rJTX0xdgLWCCwvP9HOj1geHnGa93i5LDhMM5rphNAfENcWRJeHsq7P+gd93Wt87i2Ss+iDzf0ttOLo+g6h7iC1gUktrLcwzkL5BBubDUrCGwUhRCZf8RAlBi/htEI0CtYaFD5ErIOhlICtsld7N/nrQDbLJFumdyyXlG17S7f3RQjh7vj/F78AVLmMr+asXT8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dll\"\n        title=\"dll\"\n        src=\"/blog/static/821e520963f2813946911c2ecea26c92/40601/dll.png\"\n        srcset=\"/blog/static/821e520963f2813946911c2ecea26c92/63868/dll.png 250w,\n/blog/static/821e520963f2813946911c2ecea26c92/0b533/dll.png 500w,\n/blog/static/821e520963f2813946911c2ecea26c92/40601/dll.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>加快编译速度</h5>\n<p>可以使用happyPack加快编译速度,happyPack通过多进程的方式来加快代码的打包过程.\n使用happyPack的例子:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 784px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/40f9262c0aafbe2acfc44122737b534e/4971b/happy1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJklEQVQY032P3U7bQBSE/Rxk/3ftrNchideObaBOk1Cg6UUveP93+aq6KgIuuPh0NNJozkyxPdzR5AHnHEpKhJSshEBKiVLqS/573nsLZw2hisR9j/eeYDX7FLHGcCPEEn6zIN/4/PBDoFaSet+Tz1fSuuLUNlyHLcf2lm1V0qf1Qo6BabNmSCWbWKGtRQiBUh+XFFop4i7Tzk/k+ULuDsyXF+6mge/3Lc/nkanb0/YTD6cffLs80dSRrqlZVyXq75LVCiHk0rTQUhJ3Hd3pJ8Pzb2IeOby80o4Tx2PH5XGin0Y294/k8y/G6yuhLDm1G+a8Zc63POwSuakpq4oipUSdEtpYrPMYa7E+LNc58w8fsL7EOI8LAa01zhhKZwjO4K1ZtDaGP709r9YMfGdnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"happyPack\"\n        title=\"happyPack\"\n        src=\"/blog/static/40f9262c0aafbe2acfc44122737b534e/4971b/happy1.png\"\n        srcset=\"/blog/static/40f9262c0aafbe2acfc44122737b534e/63868/happy1.png 250w,\n/blog/static/40f9262c0aafbe2acfc44122737b534e/0b533/happy1.png 500w,\n/blog/static/40f9262c0aafbe2acfc44122737b534e/4971b/happy1.png 784w\"\n        sizes=\"(max-width: 784px) 100vw, 784px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 625px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/de4d6689ef1ce9cb39affd3fa962b202/80d71/happy2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA30lEQVQY042Q3W6CQBSEeQ7ZH5eFZVk3IIgIQmNqY5rU3vb9H+VrqvGiiU168WVmbibnTLLWiswFfDNhYsAeOtZ9i+63+F3LpgoIIVBK/YskFRqTe8p2oZpmwunAcJ7ploFm3ONcySpNEVKSCnFDCImUz0n2W0luNG5T079+EMqKy7Dj3NXU3uELi7MZeWbwuaX88TbDGHO7SGv9i+RlXOMKS1FFhssn0/WLMJ6wPjA0ketxx9JG2lDyPna89TXbGIgxPi9cpRrvK5Z5RiuJSFcoed/s/qa86cM/8l8bfgPDJ4+/gqBPswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"happyPack\"\n        title=\"happyPack\"\n        src=\"/blog/static/de4d6689ef1ce9cb39affd3fa962b202/80d71/happy2.png\"\n        srcset=\"/blog/static/de4d6689ef1ce9cb39affd3fa962b202/63868/happy2.png 250w,\n/blog/static/de4d6689ef1ce9cb39affd3fa962b202/0b533/happy2.png 500w,\n/blog/static/de4d6689ef1ce9cb39affd3fa962b202/80d71/happy2.png 625w\"\n        sizes=\"(max-width: 625px) 100vw, 625px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>资源匹配</h3>\n<h4>静态资源(CSS js)</h4>\n<p>可以通过webpack-manifest-plugin生成资源的位置信息文件,然后通过该文件查找资源的位置.\n资源位置文件\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6e4772a601a10df8ea960d04f7109c5b/37523/manifest1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABSElEQVQoz4XQy46bQBCFYR5jMtA3czfQgE0gxGCDkSYjbybrvP97/BGdmSiKImXxSbVondNV3jhapukL9/vGPM/Osqxcponr9cq6rgzDQFGUhKGmrmOW5c7j8eB2u7FtG23bUpYV1hZ4RZlibUXf94zjiK1KmrrGVvsDy/l8cnMUxUgpCCNJWVkX0jQNXdcRxzHGGLIswRNCYswBrTW2tghl0IcIE6coc0CaEKkUB60ItSbSGiMFKvBRIuDp6RO+7xMEAUIIPCmla9jbpdKcl1eGl+9Mbz84L99oLytFnvPVHtm6mpe+cboiw+YZQir2jA8uMEmSX18+HqmGmfqyYoeJ42kgSTOqJGRuK/oq53OZUyQRgRDs2ykl/w5UpGlKFEU0pwb/+RkR+I4UwhFSugD/fd4ppf7J2/f+2H+33+u3P5rVO/kfPwH7ocz+Fbi26AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"manifest\"\n        title=\"manifest\"\n        src=\"/blog/static/6e4772a601a10df8ea960d04f7109c5b/37523/manifest1.png\"\n        srcset=\"/blog/static/6e4772a601a10df8ea960d04f7109c5b/63868/manifest1.png 250w,\n/blog/static/6e4772a601a10df8ea960d04f7109c5b/0b533/manifest1.png 500w,\n/blog/static/6e4772a601a10df8ea960d04f7109c5b/37523/manifest1.png 720w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n通过manifest查找资源的位置\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/6bfd0/manifest2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAuklEQVQI1wXBW3KDIABAUdfRVkhNiAiK+KigoqadZPzrTPe/mNtzMqFKlPGUPlL7gXj+4eeD2miGecXYivtd4seSLlr8ZOhni+s0PliayWBHTf2l+SwuZFIKbrZHdYlufzE8TtyUGJaV4/mNHyfCerBvG6HRLE7TaoVRV1qjkTLn4/0NIXKEEGQXKbiajls74+KOixtN25J+duISKLUlrQm/PAmvX8bHSV0Z+kpRaU0TNlxIFEVBnuf8A+AOXPtnf8/gAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"manifest\"\n        title=\"manifest\"\n        src=\"/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/00d43/manifest2.png\"\n        srcset=\"/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/63868/manifest2.png 250w,\n/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/0b533/manifest2.png 500w,\n/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/00d43/manifest2.png 1000w,\n/blog/static/94f9283cd1f897cf4c3d44e99885c8ad/6bfd0/manifest2.png 1011w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>data</h4>\n<ol>\n<li>server端执行匹配到组件的获取数据的方法(返回promise),primose执行完毕获取到最新的数据储存.将数据通过脚本挂载到window上的属性上.</li>\n<li>client端通过window属性的获取,生成存储数据.</li>\n</ol>\n<p>服务端获取数据和注入数据\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c7802c7fda66242f6b27d030fd19a685/78958/serverStore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACNElEQVQ4y42S6XKcMBCE9zFiELdgJYSkBZbDZ2znquRX3v9lvhRybK/jdVV+TEkDNa3unt61fmb+8Zvx7hvu8gE7X6OtR5uOdpjZ2wPKD+h+pvUHjHMoe8AME6pzFEVOmqVkeRrOnfdH+uUG5Xq6cea4HBmmAXtc8Zf3mHHFX91jl1vGZWJex/B/vV7onEc2JY2V6L6m6Sp2xng6P5GWJZlR1EriOkVdS0QckyQJSSJIxPP9qRdbL8TLtzRNQ+3MuGD6kWH01LqldQ4pS4qieAOYbucJSJZlZ2tXu4V2eWR9/E5/85W7L/f8+nnN48PKsFxS7zWNcUjVovspeNrs9y+M/q1dpR1+uWK5e2BvLAevmSbHOHQM80Ila/KyIi9KStlQVDKw34ZfLXitXVVV3IyOXtfoqiBLUj5dRERRTBxFT/4lf706kfzM6PQeGG66J6M46CZ4kGcZRb75kZKkKZEQxLEgFtsikhdAcbKMN0tJswxZljyMjs+D5a7vwnk/Wm77jl439EajGklZbbLrILkq8vD4O4YboJJVGPaqxqmarpGB8dDu6ZoKpVuca7G2pT2M7PcK20hkkQem7wB1XaFlSRSLIDESSaiLrd/kxvGT7Fgg4gix2SCSF7B3kjeGU6cCw6FV+GHGjguHVmPqKnj7UUzOSpZlETxcrWLwnnG94ei3XjNbzWI12ZnhsznM85zVtWEoRCPNSLL8DYNt4+n/AhpjKPL8KRLbwJmwJh9E5BzgHwrjq/i/6imaAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"serverStore\"\n        title=\"serverStore\"\n        src=\"/blog/static/c7802c7fda66242f6b27d030fd19a685/00d43/serverStore.png\"\n        srcset=\"/blog/static/c7802c7fda66242f6b27d030fd19a685/63868/serverStore.png 250w,\n/blog/static/c7802c7fda66242f6b27d030fd19a685/0b533/serverStore.png 500w,\n/blog/static/c7802c7fda66242f6b27d030fd19a685/00d43/serverStore.png 1000w,\n/blog/static/c7802c7fda66242f6b27d030fd19a685/78958/serverStore.png 1320w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nclient端提取数据\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/ffe34/clientStore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.400000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAApUlEQVQI113OXW6EIABF4dmIjFABHZCfUWlQJzZN97+l0wx968OX83Zzb1JK7lLTDyMfxjZ6UHhnGmNHtEso/VftAtpHrI8opei6DiFE69tNyR4XHEOo+O0g1ItHSNRXpR6F17nw8134ulb2o7DuF+nzxG07xgUeuTDnFdEGxXtQMseJMT9JZyWWjdEF3FrxKZOz47nMLMtMzp44WSZruPd9e/bfLyKkWa3wDvPqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"clientStore\"\n        title=\"clientStore\"\n        src=\"/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/00d43/clientStore.png\"\n        srcset=\"/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/63868/clientStore.png 250w,\n/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/0b533/clientStore.png 500w,\n/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/00d43/clientStore.png 1000w,\n/blog/static/5f8f2c4d4b0466ae5d0fc8f8df735520/ffe34/clientStore.png 1055w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>扩展性</h2>\n<h3>配置单页是否支持服务端渲染</h3>\n<p>通过中间项配置是否支持服务端渲染\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28b4d894e176fc6f70cfdb3580c17811/8cdda/configServerRender.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjElEQVQoz5WS2Y7UQAxF+yuAzlZblkoqa2XpdYAB/v+XDupKM4KHEfBwZFtVsq+vfOgGR+c3nD+zvLyyvnxjuX1hvr/Sj56mqbHWUpYleZ5TFEWoq6rCmD/rRzyUNqVwDc1ypxpXjPNIUwSEVKRJQhxHJEnyLnEcv+WHutXUtkAJicoeCISUpGlKJgRKG6TSCCHIsuyvHIpS0dqO3i14NzM0I27wNNOCKSvqwZNXNVqbfUiWhfgeh8pJtNE4f6PbLgzLRj+MDOsFZfJ9slT/pC40rDtNnium8cRy/ozzG7afqKcV23uUKTFVGz4nSfwkIYnj4O+uLHlTHzzUJsO6BTeemF5+4OYzZdMxzBPT2NK2LcM8o/PySYGp6t1fqRAqD34HhU1n0EZQ9Z52vTLev9NtN7rTnX67YJ2j2+5065Vm2nDLhdZvDNev1N1AUVp0M6GU2htqo7C2ZBodWkqOHz8QR0fi485jtVBHR5IoeuYR8fFTeHusnybRbyvXDcaYMEEIGc7jf8h+8Tybn8y1HPDoF0VLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"configServerRender\"\n        title=\"configServerRender\"\n        src=\"/blog/static/28b4d894e176fc6f70cfdb3580c17811/00d43/configServerRender.png\"\n        srcset=\"/blog/static/28b4d894e176fc6f70cfdb3580c17811/63868/configServerRender.png 250w,\n/blog/static/28b4d894e176fc6f70cfdb3580c17811/0b533/configServerRender.png 500w,\n/blog/static/28b4d894e176fc6f70cfdb3580c17811/00d43/configServerRender.png 1000w,\n/blog/static/28b4d894e176fc6f70cfdb3580c17811/8cdda/configServerRender.png 1168w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>思考</h2>\n<p>在是否在项目中使用同构应用的时候,还是要结合具体的场景.可以有以下的几点考虑:</p>\n<ol>\n<li>项目中是否需要进行服务端渲染 => 使用者角度</li>\n<li>是否有引入node中间层(api转发)的必要, 其他的替代方案是否可行(nginx) => 整体设计的角度</li>\n</ol>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"如何构建一个WEB同构应用","date":"2019-04-24","tags":"工程化","path":"/iosmorphism","top":null,"summary":null},"title":"如何构建一个WEB同构应用","date":"2019-04-24","tags":"工程化","path":"/iosmorphism","top":null,"summary":null},{"id":"4cdd0882-440a-5f52-8e06-f45478281f93","html":"<h2>函数</h2>\n<h3>函数声明</h3>\n<p>函数声明包含函数的名字,形参列表,返回值列表(可选)以及函数体构成.</p>\n<pre><code>func name(parameter-list) (result-list) {\n  body\n}\n</code></pre>\n<p>需要注意一下几点:</p>\n<ol>\n<li>\n<p>函数的形参列表和返回值列表组成函数的签名,函数的签名会在函数被调用的时候做校验是否调用合法.</p>\n</li>\n<li>\n<p>参数的传递是按值传递的.当传递引用类型作为实参的时候,可能会修改实参变量.</p>\n</li>\n<li>\n<p>支持多返回值.</p>\n<p>func test(a [3]int) (int x, int y) {\nreturn x, y\n}\nfunc add(vals ...int) int {  // 变长参数声明\nsum := 0\nfor _, v := range vals {\nsum += v\n}\nreturn sum\n}</p>\n</li>\n</ol>\n<h4>函数变量声明</h4>\n<p>函数声明只能定义在包级别的作用域,函数变量声明可以在任何表达式内指定.函数变量生命能获取到整个词法环境(可以访问外部的变量)</p>\n<pre><code>func test() func(int) int {\n  x := 2\n  return func (y int) int {\n    return x * y\n  } // 这里的函数变量(匿名函数)可以访问到外部的x\n}\n</code></pre>\n<h3>函数流程控制</h3>\n<h4>defer</h4>\n<p>defer语句是普通的函数调用,defer语句能确保函数的return语句或函数执行完毕之后执行对应的defer函数.主要为了在函数的执行完毕后做特定的行为.</p>\n<pre><code>func test(x int) int {\n    defer func() { fmt.Print(x) }() // defer语句必须返回一个可执行的语句\n    return x\n} // 这个函数会在返回后打印入参\n</code></pre>\n<h2>方法</h2>\n<h3>方法声明</h3>\n<p>方法是声明特定类型(对象)上可以执行的函数. 通常可以使用如下的方式声明:</p>\n<pre><code>func (p structName) funcName(parameter-list) (result-list) {\n  body\n}  \n// 声明可以在p类型上调用funcName的方法 \nfunc (p Point) add() int {\n  return p.x + p.y\n}\np := Point{ 2, 3}\n  p.add()\n</code></pre>\n<p>注意:</p>\n<ol>\n<li>由于方法的调用是p.funcName和获取p结构体上的属性一致,要注意同一类型上的命名冲突.</li>\n</ol>\n<h3>指针接收者方法</h3>\n<p>由于方法会复制实参,当需要方法的调用对外界产生影响的时候,就需要通过指针类型来完成方法的声明,如下面的例子:</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10} // 获取指针\n  p.ScaleBy(2) // p{20, 20}\n  q := Point{1,2}\n  q.ScaleBy(3)  // q{3,6} 当类型符合的时候,会进行隐式转换 相当于 (&#x26;q).ScaleBy(3)\n}  \n</code></pre>\n<h3>方法变量和方法表达式</h3>\n<h4>方法变量</h4>\n<p>可以将一个特定类型的方法赋值给一个变量,这个变量称为方法变量.该方法变量已绑定到特定的接收者上(caller),通过传递形参就可以完成方法的调用.通常用于绑定特定的接受者.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := p.ScaleBy\n  scaleBy(2) // p{20, 20}\n}  \n</code></pre>\n<h4>方法表达式</h4>\n<p>方便表达式必须在调用的时候,提供接受者.方法表达式是把对应结构的函数行为进行声明.</p>\n<pre><code>type Point struct {\n  x, y int\n}\n\nfunc (p *Point) ScaleBy(factor int) {\n  p.x *= factor\n  p.y *= factor\n}\n\nfunc main() {\n  p := &#x26;Point{10, 10}\n  scaleBy := (*Point).ScaleBy // 方法表达式\n  scaleBy(p,2)\n}\n</code></pre>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"go语言入门之-函数和方法","date":"2019-04-19","tags":"Go","path":"/go-func","top":null,"summary":null},"title":"go语言入门之-函数和方法","date":"2019-04-19","tags":"Go","path":"/go-func","top":null,"summary":null},{"id":"c97e3748-f65b-5727-ba7a-18d780b68885","html":"<h2>前言</h2>\n<p>React在处理界面更新的时候,是通过对比虚拟DOM(js对象)之间的差异来更新UI的.这种方式能一定程度上的减少对DOM的操作.通过虚拟DOM这个中间层结合多平台的renderer使React实现了跨平台.本文梳理了在medium上关于Virtual DOM的两篇文章来介绍如何简单实现一个Virtual DOM.</p>\n<h2>为什么虚拟DOM</h2>\n<ol>\n<li>UI = F(data)  Virtual DOM使数据,操作,属性可以集中在一起,这种方式能一定程度上降低项目长期维护的复杂性.</li>\n<li>页面性能 通过虚拟DOM的对比,进行差异的更新能提升页面的性能.</li>\n</ol>\n<h2>如何实现虚拟DOM</h2>\n<p>虚拟DOM可以理解是真实DOM的映射,如何实现虚拟DOM主要需要考虑一下几点:</p>\n<ol>\n<li>如何描述虚拟DOM(create)</li>\n<li>如何绘制虚拟DOM(render)</li>\n<li>如何差异化的更新虚拟DOM并且更新UI(update)</li>\n</ol>\n<p>下面主要从上面的三点来逐步实现一个简易版的虚拟DOM实现.</p>\n<h3>创建Virtual DOM</h3>\n<p>DOM的节点可以通过type(节点类型),props(styles, event), children(子元素)来描述.可以通过下面的函数来创建虚拟节点.</p>\n<pre><code>// 创建虚拟节点\nfunction h(type, props, children) {\n  return { type, props: props || [], children: children || [] };\n}\nconst root = h('ul', { name: 100, onClick: () => { console.log(1); } }, [\n  h('li', {}, ['sss'])\n])\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVQY022PyW7DMAxE8/8/1muBXtogrpN4k0wvihfJm/SK2EUPQQcYgCQGj+RJa839fkeXmjRL6Jqaoevo+x7TthhjdidJglKKqqrI8wLnHEPf77lxHBmtZZpXTiEE8jwn+vymVQ32mjHVDWmW8nU+01tLKYK1lsfjgYhQliVN26JESLKMNE3JC01nAyeAVgzqXaM/hCIS4vjGJbpglGITwTtHPww7TBUFTdPgrcWLMImwLAuHfoHzOHN/Symjik4KsujCYB1+npmrisW5/cInqK5rWmPY5pm1bZiMYV3XAxfC8bKzjkfW0ekeWw0sbiKOY663G90w8J/Cax/CAVy2Z+GPgQ/4LeB92Lc+X/He/4Wffu1f/QOtmsze8Gl17gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"virtualDom\"\n        title=\"virtualDom\"\n        src=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png\"\n        srcset=\"/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/63868/virtualDom.png 250w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/0b533/virtualDom.png 500w,\n/blog/static/e8d0c0010655ddccb98b99cd8e63f2b4/7e509/virtualDom.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>绘制Virtual DOM</h3>\n<p>在下面的实现中,以$开头的元素指代真实的DOM节点,node指代虚拟节点.</p>\n<h4>绘制元素</h4>\n<p>在绘制元素的时候,如果节点的内容是文本,就直接创建文本节点.否则就创建当前类型的DOM节点并且遍历它的children节点递归的调用自身并且添加到创建的节点.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\nconst root = h(\"ul\", { name: '111', className: 'test' }, [\n  h('li', { name: 'child' }, ['text'])\n]);\n// app是页面中已经存在的容器节点\nconst container = document.getElementById('app');\ncontainer.appendChild(createElement(root)); // 已经能绘制到页面\n</code></pre>\n<h4>添加属性</h4>\n<p>在添加属性的时候,有以下的节点需要注意:</p>\n<ul>\n<li>对DOM节点上不存在的属性名字进行转换,例如ClassName</li>\n<li>布尔属性值的设置</li>\n<li>增加属性过滤功能来实现特有的实现</li>\n</ul>\n<h5>实现</h5>\n<pre><code>//设置布尔属性\nfunction setBooleanProp($target, name, value) {\n  if(value) {\n    $target.setAttribute(name, value);\n    $target[name] = value;\n  } else {\n    $target[name] = false;\n  }\n}\n// 属性过滤\nfunction isCustomProp(name) {\n  return false;\n}\n// 设置所有属性的入口\nfunction setProps($target, props) {\n  Object.keys(props).forEach(name => {\n    setProp($target, name, props[name]);\n  });\n}\n// 对单一属性的设置,实现过滤,转换\nfunction setProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.setAttribute('class', value);\n  } else if(typeof value === 'boolean') {\n    setBooleanProp(name, value);\n  } else {\n    $target.setAttribute(name, value);\n  }\n}\n</code></pre>\n<p>通过将设置属性的操作加入到之前的createElement函数中,来实现DOM属性的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n} \n</code></pre>\n<p>通过运行之前的代码,发现属性已经添加到DOM中了.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABIElEQVQoz6XO207CQBSF4b7/I3nphcSEKFAoyqkoh0Kn9DhMp8PM/IYYTUw8XLiSL3tf7bWD8UtJv7dlOBaMJnOGjyPuh4LbfspTIgl3NQ+rjCg5syo9i9z+KmjOkmR2IO6tOb4KmkohZimnWGCdx3vw3uOcx33Mj/0bQWc6xEtKfBdT7E50Mke1jv1e0umOP/Pe+CkAj9Yt2aug3Obk6wnJckk0EazjHK00phFIscN2LVmmSMX5x7Kgbi2VupCViu3yxHax4rl3w2GzIZwWjKOMKFwTDQaE0ZzpNCXs7zkeaxrtqJX9ImiNo7Oe6nrw6UBVKGRV0tQNUllORUclHVJbsqKh1QZ9Nqj2gr54tHFfBNc3rTEcnxPSRcrFGP6TN4i4F/4kEuvBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"domWithProp\"\n        title=\"domWithProp\"\n        src=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png\"\n        srcset=\"/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/63868/propShow.png 250w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/0b533/propShow.png 500w,\n/blog/static/6ba2dffdd4a79427500d57a2d8c07e87/a6d36/propShow.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>添加事件</h4>\n<p>在对事件的添加上,由于具体的事件也是在创建Virtual DOM的时候添加到props的,如果不想通过之前声明的setProps函数进行事件的处理,就需要将这些属性过滤出来,具体实现如下:</p>\n<pre><code>//判断是否是event属性\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n// 获取属性的后缀  例如 onClick => click\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n// 修改之前的过滤属性函数,加入对event属性的过滤\nfunction isCustomProp(name) {\n  return isEventProp(name)\n}\n// 添加属性函数\nfunction addEventListeners($target, props) {\n  Object.keys(props).forEach(name => {\n    if(isEventProp(name)) {\n      $target.addEventListener(extractEventName(name), props[name]);\n    }\n  })\n}\n</code></pre>\n<p>将添加事件的函数增加到createElement函数中,完成对事件的添加.</p>\n<pre><code>function createElement(node) {\n  if(typeof node === 'string') {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  setProps($el, node.props);\n  addEventListeners($el, node.props);\n  node.children.map(createElement).forEach($el.appendChild.bind($el));\n  return $el;\n}\n</code></pre>\n<h3>对比差异更新UI</h3>\n<p>如果完全的对比两个树形结构的差异,时间复杂度是O(n^3)的.为了一定的性能优化,可以有以下的假设:</p>\n<ol>\n<li>节点的类型变更,两个DOM的结构就是不同的.这种情况可以直接进行替换操作.</li>\n<li>很少存在跨层级的节点移动</li>\n<li>同一类型的节点的DOM结构是相同的</li>\n</ol>\n<p>通过对上面假设的分析,在更新Virtual DOM的时候,主要有以下几种情况</p>\n<ol>\n<li>对比两个node的类型不同,直接替换</li>\n<li>最新的node中没有元素和属性,需要删除对应的节点的属性</li>\n<li>最新的node中增加了元素和属性,需要添加对应的属性和节点</li>\n<li>节点类型相同,对子节点实现1 2 3的操作</li>\n</ol>\n<h4>更新节点</h4>\n<pre><code>// 判断两个node是否是同一个节点\nfunction changed(node1, node2) {\n  return typeof node1 !== typeof node2 || typeof node1 === 'string' &#x26;&#x26; node1 !== node2 || node1.type !== node2.type;\n}\n\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  // index是子元素的位置\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新属性</h4>\n<p>在更新属性的时候跟更新节点的步骤类似</p>\n<pre><code>// 删除布尔属性\nfunction removeBooleanProp($target, name) {\n  $target.removeAttribute(name);\n  $target[name] = false;\n}\n// 移除属性\nfunction removeProp($target, name, value) {\n  if(isCustomProp(name)) {\n    return;\n  } else if(name === 'className') {\n    $target.removeAttribute('class');\n  } else if(typeof value === 'boolean') {\n    removeBooleanProp($target, name);\n  } else {\n    $target.removeAttribute(name);\n  }\n}\n// 当不存在newVal的时候,remove对应的属性.其他情况进行覆盖\nfunction updateProp($target, name, newVal, oldVal) {\n  if(!newVal) {\n    removeProp($target, name, oldVal);\n  } else {\n    setProp($target, name, newVal);\n  }\n}\nfunction updateProps($target, newProps, oldProps = {}) {\n  const props = Object.assign({}, newProps, oldProps);\n  Object.keys(props).forEach(name => {\n    updateProp($target, name, newProps[name], oldProps[name]);\n  });\n}\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if(!oldNode) {\n    // 如果不存在oldNode进行添加操作\n    $parent.appendChild(createElement(newNode));\n  } else if(!newNode) {\n    // 在新的节点中不村存在移除\n    $parent.removeChild($parent.childNodes[index]);\n  } else if(changed(newNode, oldNode)) {\n    // 如果节点类型改变进行替换\n    $parent.replaceChild(\n      createElement(newNode), $parent.childNodes[index]\n    )\n  } else if(newNode.type) {\n    // 增加属性的更新\n    updateProps($parent.childNodes[index], newNode.props, oldNode.props)\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    // 更新子节点\n    for(let i = 0; i &#x3C; newLength || i &#x3C; oldLength; i++) {\n      updateElement($parent.childNodes[index], newNode.children[i], oldNode.children[i], i)\n    }\n  }\n}\n</code></pre>\n<h4>更新事件</h4>\n<p>函数是不好判断是否有变化的,可以通过一些参数来完成事件的更新(触发重新更新,通过节点替换来完成事件的更新这样不好)</p>\n<pre><code>function changed(node1, node2) {\n  return typeof node1 !== typeof node2 ||\n      typeof node1 === ‘string’ &#x26;&#x26; node1 !== node2 ||\n      node1.type !== node2.type ||\n      node1.props.forceUpdate;\n}\nfunction isCustomProp(name) {\n  return isEventProp(name) || name === ‘forceUpdate’;\n}\n</code></pre>\n<h3>参考</h3>\n<p><a href=\"https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060\">How to write your own Virtual DOM\n</a><br>\n<a href=\"https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76\">Write your Virtual DOM 2: Props &#x26; Events</a><br>\n<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"How to wirte your own Virtual DOM(译)","date":"2019-04-02","tags":"React","path":"/react-virtual-dom","top":null,"summary":null},"title":"How to wirte your own Virtual DOM(译)","date":"2019-04-02","tags":"React","path":"/react-virtual-dom","top":null,"summary":null},{"id":"b6744961-a515-567c-9bf3-185d20eae82e","html":"<h2>go数据类型</h2>\n<p>go语言数据类型主要分为以下的四个大类:</p>\n<ol>\n<li>基础类型(整数,浮点数,负数,布尔值等)</li>\n<li>聚合类型(数组,结构体)</li>\n<li>引用类型(slice,指针,map,函数,通道)</li>\n<li>接口类型</li>\n</ol>\n<p>go语言是拥有类型系统的语言,相对于笔者最熟悉的javascript这种动态且无类型的语言来说有着长远的好处.通过类型系统能在编译阶段减少一定的运行时错误.例如在go语言中不同类型值之间必须通过显示转换来进行赋值操作.本文主要从go语言中的基础类型开始,逐步的讲解go语言中几种基本的引用类型.</p>\n<h2>基础类型</h2>\n<h3>字符串</h3>\n<p>字符串是不可改变的字节序列.可以通过[i:j]操作符截取对应字符串的子串.由于字符串不可改变的特点,子串和母串共用一端底层内存.</p>\n<pre><code>s := \"hello world\"\nb := s[6:] // [i:j] 从i开始不包括j 注意越界 b world\nb[0] = 'a' // 错误 \n</code></pre>\n<h3>常量</h3>\n<p>常量是一种表达式,可以在编译的阶段来确定相应的值.在声明常量的时候可以指定类型和值(如果没有指定类型会通过值来推断常量的类型).在连续声明多个常量的时候,主要有以下两种方式:</p>\n<ol>\n<li>\n<p>在声明枚举值的时候,可以通过iota常量生成器来实现.iota从0开始,逐项加1</p>\n</li>\n<li>\n<p>省略赋值语句的一项会复用前一项的表达式和类型</p>\n<pre><code> const (\n a  = iota\n b\n c\n d\n )\n // a b c d 0 1 2 3\n const (\n a = 1\n b\n c = 2\n d\n )\n // a b c d 1 1 2 2\n</code></pre>\n</li>\n</ol>\n<h4>无类型常量</h4>\n<p>无类型常量(常量字面量)是还没有确定从属类型的常量值.无类型常量相对于同样的有类型的常量有更大的精度.例如0.0相对有浮点数拥有更大的精度.在将无类型常量复制给对应的变量的时候,赋值的变量会转换为无类型常量默认的类型.</p>\n<pre><code>i := 0 // int(0)\nb := 0.0 // float64(0.0)\n</code></pre>\n<h2>聚合类型</h2>\n<h3>数组</h3>\n<p>数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列.由于数组在声明的时候对长度有限制,当存储元素到达数组的容量的时候就需要申请新的内存空间来进行数据的存储.所以在存储数据上一般不会使用数组.数组元素的初始值是该类型的零值.在声明数组的时候需要显示的指定长度和类型.</p>\n<ol>\n<li>\n<p>声明数组需要有长度的定义和类型定义,可以通过定义长度或者数据数量来确定数组的长度.元素类型和长度相同的数组是可以比较和复制的</p>\n</li>\n<li>\n<p>数组元素的初始值为该数组元素类型的初值</p>\n</li>\n<li>\n<p>在函数中使用数组指针来完成对原数组的修改</p>\n<p>b := [...]int{1,2,3}  // 通过初始化数组元素的个数决定数组的长度\na := [3]int{1,2,3}\na == b // true\nr := [...]int{99: -1} // 定义一个含100元素的数组r 最后一个元素是-1 其余都初始化int类型的零值 0</p>\n</li>\n</ol>\n<h3>结构体</h3>\n<p>结构体是将多个命名变量组合到一起的聚合数据类型.可以通过下面的方式声明一个结构体:</p>\n<pre><code>type Person struct {\n    name string\n    id int\n}\n</code></pre>\n<p>在声明结构体的时候需要注意以下的几点:</p>\n<ol>\n<li>结构体变量的大小写决定变量是否可以导出(可以被其他导出的包读写),</li>\n<li>结构体变量不可以拥有自己本身的结构体类型,可以通过自身结构体类型的指针来实现递归结构</li>\n</ol>\n<h4>结构体字面量</h4>\n<ol>\n<li>\n<p>可以按照声明的顺序来初始化结构体变量或者指定变量名称来初始化结构体字面量</p>\n</li>\n<li>\n<p>可以获取结构体指针来设置结构体的值</p>\n<pre><code> a := Person{ name: \"haha\" } // 指定变量名声明\n b := Person{ \"haha\", 20 }\n var copyPerson *Person = &#x26;a // 获取结构体指针\n copyPerson.name = \"100\"\n</code></pre>\n</li>\n</ol>\n<h4>结构体嵌套</h4>\n<p>在定义结构体的成员的时候,go允许只指定成员的类型来实现成员的声明.通过这种方式定义的结构体成员成为匿名成员.匿名成员的类型必须是一种命名类型或者指向命名类型的指针.匿名成员可以为方便变量提供便捷的操作.</p>\n<pre><code>type Circle struct {\n    x int\n    y int \n    radius int\n}\ntype Wheel struct {\t\n  Circle\n  color string\n}\nwheel := Wheel{Circle{ 10, 10, 19}, \"red\"}\n// wheel.x = 10\n</code></pre>\n<h2>引用类型</h2>\n<h3>slice(切片)</h3>\n<p>slice是用相同类型元素的可变长度序列.可以基于一个已有的数组来创建这个数组的slice.slice有三个属性:指针,容量,长度.可以在一个数组的基础上产生多个slice,它们共享内存空间.需要注意的是slice可以理解为对原数组的引用,通过对slice的修改是会影响到底层数组的.</p>\n<h4>声明切片</h4>\n<p>主要有以下两种方式声明切片:</p>\n<ol>\n<li>\n<p>通过切片字面量和内置的make函数</p>\n</li>\n<li>\n<p>slice的操作符[i:j]操作数组或者切片字面量</p>\n<pre><code> var b = make(int[], 3, 5) // make(type[], len, cap) 声明一个长度为3容量为5的切片\n var b = []int{1,2} // 声明一个长度和容量都为2的切片\n var c = []int{ 99: 1 } // 声明一个长度和容量为100的切片,初始化第100的元素为1\n slice := []int{1,2,3,4,5}\n newSlice := slice[1:3]  // 通过切片创建切片\n var num = [10]int{1,2,3,4,5,6,7,8,9,10}\n a := num[1:4] // 操作符[i:j]创建一个新的slice,引用原数组i到j-1个元素.slice的容量是slice起始元素到底层数组最后一个元素之间的个数,切片a只能看到底层数组i以及之后的元素\n len(a) // 3 获取切片的长度\n cap(a) // 9 获取切片的容量\n b := a[:5] // 可以在一个已有的slice上扩充容量,产生新的slice\n len(b) // 4\n cap(b) // 9\n</code></pre>\n</li>\n</ol>\n<h4>操作切片</h4>\n<ol>\n<li>\n<p>slice相当于对底层数组的引用,通过操作slice可以修改底层数组</p>\n<pre><code> a := [3]int{1,2,3}  \n b := a[:2]\n b[0] = 100  // a[0]也是100\n</code></pre>\n</li>\n<li>\n<p>append函数可以动态的添加元素到slice.append函数会返回一个新的slice</p>\n<pre><code> slice := []int{1,2,3,4,5}\n newSlice := slice[1:2] \n newSlice = append(newSlice, 10) // newSlice容量足够,修改底层数组返回新的slice. a[2] = 10\n a := slice[1:2]\n b := slice[2:3]\n c = append(a, b...) // 支持批量添加\n</code></pre>\n</li>\n</ol>\n<h3>map</h3>\n<p>在go中map是对散列表的引用.散列表是无序的键值的结合.可以通过如下的方式创建map:</p>\n<pre><code>var test = make(map[string]int) // 声明map的键值的类型 \ntest[\"name\"] = 100  // 赋值\nvar person = map[string]int{ \"card\": 1, id: \"2\" }  //声明并初始map\nperson[\"card\"] // 1\n</code></pre>\n<p>map有以下几点需要特别注意:</p>\n<ol>\n<li>在赋值map类型的值的时候,需要对map进行初始化.初始化的map的值是对应类型的零值.</li>\n<li>map是引用类型,在函数间传递的时候会对原值进行修改.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null},"title":"go数据类型初识","date":"2019-04-01","tags":"Go","path":"/go-type","top":null,"summary":null},{"id":"b1b97732-ab7b-5428-9c38-f5af9e4d1fa1","html":"<h2>go语言简介</h2>\n<p>go语言是一种编译型语言,在设计上融入了设计者对复杂项目中易出现问题的思考,go语言在设计上突显了简单性.这种简单性在长期来看是会为项目带来收益的.下面主要从go的环境配置开始进而通过一个简单的go程序\b来认识go.</p>\n<h2>go环境配置</h2>\n<p>当go安装完毕后,可以通过go env来查看相应的环境配置,如图\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 641px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABiUlEQVQ4y51U2VLCQBBcOQRFzoCgFo+inELuhJCEcMj//9BYPZsNFmUh8DC1u7Op3u6emYjS1KOHL5/aTkJNK+Yoz3zKDS0SHwaJT/O66Ppb6kcH6rgJ1c2Qut6GOu6GcqMbATvehvrhgVp2TIWxQ2Kgk3hfkBgYEvBc4NvTnOasWe7LckcNM6KmFZHmJNm+qq9kzl5T3QipYcXUdhPSbGkP8rgHofupKxn2ljsCcHnmUX5kU3HiMFus+fHxXEj36nw/cbPvWJ2SDP/wKopzNzSlZBVnJf+RQwGeU5ZYH+dLfhkrGN9UFPjX9bb0GuzZC3j1tvrm/dWVBsOeL9kpMMjHvgSTFeDpeo5hz99mQKju0yKQLaHiUjDFEM2NKgOsnbZMzQj5kZYVc+tcLB1S4R1Aa/qK2aGfMJJqLLklLgXUuKn3LBeMOMmTov+aGv3/qVEBhqgoerEyD7ixEWjiYzhZXt4dz8WTO6HGDl5VFgGPEWTLv08kfeQxi9hnjBv8rab24A524R6AP/kYq3qmQSoOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"go env\"\n        title=\"go env\"\n        src=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png\"\n        srcset=\"/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/63868/goEnv.png 250w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/0b533/goEnv.png 500w,\n/blog/static/66c77bdf9d311b2f54836f210a7eeeb6/c7dcc/goEnv.png 641w\"\n        sizes=\"(max-width: 641px) 100vw, 641px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n其中GOPATH,GOROOT是我们需要关注的两个配置.GOPATH指定的工作区间的根目录,在GOPATH下通常有三个目录:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 596px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQoz53OSY7CMBSEYd/EwXHiAWXhDMgWqJsM4gAsEFIvcv9T/C0jOIBZfHp6tSiVWNeVfd+Z55lxHEkpEWP8ilIK4b0nhMCyLPR9jzEG5xzWlquqCuHckRBGtu3GMEwY48iZteVehSn9cr3eeDz+uN+fTNOFnMVY6gel9GfhwLJsnE6RtrXvhb6YlBVC6wbvj5zPF7quQ6manGmti0kpEU3TUteaw0G9bv6/lQv/AcdU1m38VSPNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"category\"\n        title=\"category\"\n        src=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png\"\n        srcset=\"/blog/static/0fd3c16ae228def45cefbe8249683ee8/63868/category.png 250w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/0b533/category.png 500w,\n/blog/static/0fd3c16ae228def45cefbe8249683ee8/699b7/category.png 596w\"\n        sizes=\"(max-width: 596px) 100vw, 596px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在src目录下的每个子目录是一个包.pkg子目录是构建工具存储编译后的包的位置.bin子目录放置可执行程序.GOROOT主要提供标准库的包.</p>\n<h3>go语言的基础结构-hello world</h3>\n<p>在GOPATH下的src目录创建helloworld文件夹,在该文件夹中创建helloworld.go.(通常文件的名字都跟包名一致),通过在命令行使用go run hellowrld.go</p>\n<pre><code>package main // 定义包名\nimport (\n  \"fmt\"  // 导入包\n)\n//  main函数可执行程序的主入口\nfunc main() {\n  var a = \"hello world\"  // 定义变量并且在控制台输出\n  fmt.Print(a)\n}\n</code></pre>\n<h2>go中的包</h2>\n<h3>包的初始化</h3>\n<p>包的初始化从初始化包级别变量开始,按照这些变量的声明顺序进行初始化,对于一些复杂的初始化场景,可以定义init函数来初始化变量,在其他包对当前包进行引用的时候,init函数会被调用.</p>\n<pre><code>var a = b + c\nc = 100\nb = f()\nfunc f() {\n  return 1\n}  // 会按照 c b a 的顺序依次初始化\n</code></pre>\n<h3>包的命名</h3>\n<p>在go源文件的开头都需要进行包名的声明,同一个包下的所有源文件同属一个包(有一个例外是当前go文件是一个可执行的go程序时,只能声明main包来生成可执行的文件)</p>\n<h3>包的引入</h3>\n<p>包是go实现代码复用的一种主要形成.在声明包名之后,可以通过import语句对需要使用的包进行引入.通常有下面几种方式导入对应的包:</p>\n<pre><code>import (\n  \"fmt\"  //正常导入\n  XXX \"fmt\" // 别名导入 XXX可以作为fmt包的别名来使用\n  _ \"image/png\" // 空导入 通常为了执行包的初始化函数来获取副作用\n  import \"github.com/xxx\" // 导入远程包\n)\n</code></pre>\n<p>包的查找是先查找go的安装目录,然后GOPATH</p>\n<h2>声明</h2>\n<p>实体的声明主要有以下的规则:</p>\n<ol>\n<li>如果声明的实体在函数体内,该实体只在函数局部(存在块级作用域)有效.实体声明在函数外,该声明对当前包所有的文件可见.</li>\n<li>实体的第一个字母的大小写决定其是否可以被其他包调用</li>\n</ol>\n<h3>变量声明</h3>\n<p>在go语言中可以通过下面的几种方式来创建和声明变量.</p>\n<h4>常规变量声明</h4>\n<pre><code>var name type = expression\n</code></pre>\n<p>上面这种声明方式指定了变量的类型和初始值表达式,类型和表达式可以忽略一个:</p>\n<ol>\n<li>当类型忽略的时候,变量的类型会由初始化表达式的类型决定</li>\n<li>当初始化表达式忽略的时候,变量的初始值对应着相应类型的零值.</li>\n<li>当把一个类型的变量赋值给另一个类型的时候,需要通过显示转换.</li>\n</ol>\n<h4>短变量声明</h4>\n<pre><code>name := expression\n</code></pre>\n<p>上面这种方式称为短变量声明,这种方式声明的变量类型由表达式返回的类型决定.在使用短变量声明的时候,需要注意一下两点:</p>\n<ol>\n<li>短变量声明在左侧已经存在对应变量的声明的时候,相当于赋值</li>\n<li>短变量声明要求至少声明一个变量</li>\n</ol>\n<h4>new操作符</h4>\n<p>new(T)创建一个未命名的T类型变量并且初始化T类型的零值,返回其地址(指针).</p>\n<pre><code>p := new(int) // 初始化一个int类型的变量返回地址\nfmt.Println(*p) // 输出0\n*p = 2\nfmt.Println(*p)  // 输出2\n</code></pre>\n<h4>指针</h4>\n<pre><code>x := 1\np := &#x26;x  // &#x26;操作符获取变量地址 复制给一个int类型的指针p\nfmt.Println(*p) // 输出1 *操作符获取指针指向的变量的值\n*p = 2 // 通过指针修改变量的值 \nfmt.Println(x) // 输出2\n</code></pre>\n<h4>变量的生命周期和作用域</h4>\n<h5>生命周期</h5>\n<ol>\n<li>\n<p>包级别变量存在于整个程序的执行时间</p>\n</li>\n<li>\n<p>局部变量有动态的声明周期,在执行声明语句的时候会创建一个新的实体.当局部变量不可访问时会被回收.</p>\n<pre><code> a := []int{1,2,3,4,5}\n for _, num := range a {\n   fmt.Printf(\"%d\", num)  // num变量在每次循环创建\n }  \n</code></pre>\n</li>\n</ol>\n<h5>作用域</h5>\n<p>作用域指的是用到对应变量声明的源代码段。go语言中声明的作用域是词法块的，词法块决定着声明作用域的大小。</p>\n<h3>变量赋值</h3>\n<ol>\n<li>\n<p>在进行变量赋值的时候,go语言有对应的类型检测(例如你不能把一个int类型赋值给string类型的变量).</p>\n</li>\n<li>\n<p>支持多重赋值语法</p>\n<pre><code> x,y := 1, 2\n x, y = y, x\n</code></pre>\n</li>\n</ol>\n<h3>类型声明</h3>\n<p>类型声明提供了一种方式来区分底层类型的不同或者不兼容的使用方式。相同类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较，不同命名类型的值不能直接比较.</p>\n<pre><code>type name string\ntype id string\n\nfunc main() {\n  var a name = \"\"\n  var b id = \"\"\n  fmt.Println(a == b) // 这里会报错 a b 不是相同的类型无法比较\n}\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://golang.google.cn/cmd/go/\">go命令行使用</a></p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null},"title":"go入门课-简介","date":"2019-03-26","tags":"Go","path":"/go-basic","top":null,"summary":null},{"id":"0f98dd9a-5532-56d0-bc00-01267ece2905","html":"<h2>前言</h2>\n<p>在开发公司内部web版聊天工具的时候,用户联系人数目是100+的.最近在思考如果每次都把100+的联系人进行渲染并且更新,这种实现是过度的.用户可能只操作20个联系人,浏览器却要为此付出多余的渲染性能.因此考虑通过虚拟列表来实现这个功能.虚拟列表只渲染可视区域,这样一定程度上降低了性能的消耗.本文主要通过react代码来描述如何实现一个简单的虚拟列表,在实际的生产环境还是推荐使用比较成熟的包,例如react-virtualized.在最后分享下自己在工作中的一点想法.</p>\n<h2>虚拟列表的简单实现</h2>\n<p>使用虚拟列表的前提是容器的高度是固定的,渲染的每个条目的高度也是相对固定的,这样就能计算出容器能渲染出的条目.下面是页面的结构:</p>\n<pre><code>import React, { Component } from 'react';\nconst allData = Array(1000).fill({ title: 'sss' }); //所有的渲染条目\nconst styles = {\n  container: {   // 外层容器样式\n    height: '400px',\n    border: '1px solid black',\n    position: 'relative',\n    overflow: 'auto',\n  },\n  openContainer: {  // 容器内通过定义一个空元素 高度为所有条目的高度,撑起父元素显示滚动条\n    position: 'absolute',\n    height: allData.length * 40 + 'px',\n    left: 0,\n    right: 0,\n    top: 0,\n    zIndex: -1,  //显示在列表条目下面\n  },\n  listContainer: {  // 列表容器\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    top: 0,\n  },\n  listItem: {  // 列表条目\n    height: '40px',\n    lineHeight: '40px',\n  },\n}\nclass VirtualList extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      visibleData : [],  // 实际显示的条目\n      visibleCount: 0,   // 显示的数据\n      start: 0,  // 显示条目的起始位置\n      end: 0,  //   \b显示\b条目的末位置\n      itemHeight: 40, // 条目的高度\n    };\n  }\n  render() {\n    return (\n    &#x3C;div>\n      &#x3C;div\n        ref={container => this.container = container} // 外层容器\n        onScroll={(e) => {this.scrollHandle(e)}}\n        style={styles.container}\n      >\n        &#x3C;div style={styles.openContainer}>&#x3C;/div> // 撑起父容器,父元素展示滚动条\n        &#x3C;div\n          style={styles.listContainer}   // 列表容器\n          ref={listContainer => this.listContainer = listContainer}>\n            {this.state.visibleData &#x26;&#x26; this.state.visibleData.map((item, index) => (\n            &#x3C;div \n              key={index}\n              style={styles.listItem}\n            >\n              {item.title}\n            &#x3C;/div>))}\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>);\n  }\n}; \n</code></pre>\n<p>接下来在组件挂载的时候,\b计算出\b\b\b容器可以显示的列表条目和初始显示的数据</p>\n<pre><code>componentDidMount() {\n    const visibleCount = Math.ceil(this.container.clientHeight / this.state.itemHeight); // 计算实际应该显示的条目数\n    const end = this.state.start + visibleCount; // 计算位置\n    const visibleData = allData.slice(this.state.start, end);  // 计算应该展示的条目\n    this.setState({ end, visibleCount, visibleData }); // 更新状态\n  }  \n</code></pre>\n<p>在父容器绑定滚动事件,在滚动列表的时候,计算实际需要渲染的条目并且列表的位置.</p>\n<pre><code>scrollHandle(e) {\n    const scrollTop = this.container.scrollTop;\n    const fixedScrollTop = scrollTop - scrollTop % this.state.itemHeight;  // 计算到父容器顶部的距离\n    this.listContainer.style.webkitTransform = `translate3d(0, ${fixedScrollTop}px, 0)`;  // 移动列表\n    const start = Math.floor(scrollTop / this.state.itemHeight);\n    const end = start + this.state.visibleCount;  \n    const visibleData = allData.slice(start, end); // 重新计算需要显示的元素\n    this.setState({ start, end, visibleData }); // 更新状态\n}\n</code></pre>\n<h2>一些想法</h2>\n<p>在最近学习和工作的思考中,产生了几个想法:</p>\n<ol>\n<li>学习是一个需要渐进坡度的过程.在我刚开始工作的时候,自己还没有接触react并且对MVVM等概念也不是很明确.\b在对一些类库的\b使用之后比自己之前直接去看相应的文章更加能理解文章的意图.学习的\b\b坡度\b最好是渐进的.</li>\n<li>在工作上,在完成业务要求的时候的同时个人应该有更多的思考.让自己有一个正向的工作模式.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/14b5013e441a414126d7d5ce364726a9/20785/work.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHElEQVQoz02S246DMAxE+f+/6xNIfaiAUhAtlHArd6/OSFkFyXKYjO2M7eg4DjvP04ZhMOecfNd1Bt62rdV1be/32/q+t3EcxcHg7Ptu3+9XMXCnabKIZAR/Ph9dQCA4z3NL09Sez6eScn48HkoEt6oqYa5z4oNRMKLKPM8iQCahr9o0jbwvRBCe13AmERxejIppnCzioixLkXjpuq6Scl2X/Lqswnxrtm2TcRf+Y8d+WETmoihUkQ8iwT6hN4LP4/xPFhYNMUn+/X7q2f1+tyRJ1LOhHyQDiXjagbxQMkPAc+dlaygYsuM4ttvtZlVZWZZlGgi9fb1eOoOREIyi4L4ofQaPwrWBhNFs8HBVlmXR8MC0Yp2TZL9qfnB/0aNjqAd6ymQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"how to work\"\n        title=\"how to work\"\n        src=\"/blog/static/14b5013e441a414126d7d5ce364726a9/00d43/work.png\"\n        srcset=\"/blog/static/14b5013e441a414126d7d5ce364726a9/63868/work.png 250w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/0b533/work.png 500w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/00d43/work.png 1000w,\n/blog/static/14b5013e441a414126d7d5ce364726a9/20785/work.png 1307w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"虚拟列表的简单实现","date":"2019-02-24","tags":"JavaScript","path":"/virtual-list","top":null,"summary":null},"title":"虚拟列表的简单实现","date":"2019-02-24","tags":"JavaScript","path":"/virtual-list","top":null,"summary":null},{"id":"6c1963de-72c8-5ab9-8515-232321c28746","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有先入先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这个在一定程度上也解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定(<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>).</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a></p>\n<p><a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a></p>\n<p><a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a></p>\n<p><a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null},"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null},{"id":"64e44923-c974-57a6-9439-3efd01fbd7b5","html":"<h2>简介</h2>\n<p>最近在做业务中,\b需求的场景是需要在原有的组件上添加点击\b事件\b并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回组件的函数.\b高阶组件能最好化的复用代码.实现高阶组件\b有如下几种方式:</p>\n<ol>\n<li>属性代理(\b操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state\b完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(\b子组件先\b\bDidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.\b通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有\b调用\b,不会执行Wrapped的\bDidMount)\n    }\n    render() {\n      return super.render() //\b在这个可以实现渲染劫持,例如\b\b常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的\b时候通过在定义一个render函数来决定组件的具体内容.(children API\b)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个\b实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的\b可以\b\b复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的\b问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null},"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null},{"id":"1f2ad40b-098b-52f8-a30d-d3cd6c4e0a51","html":"<h2>简介</h2>\n<p>\b\b如何利用缓存在计算机系统或者网络服务中\b都是提升系统体验的\b的一个很重要的思考方向.相对于网络(磁盘)的I/O,直接将需要的数据存储到一个相对较快的获取位置,这样就能尽快的获取到需要的资源.这里\b主要总结下\b在前端开发中一些缓存方面的知识.</p>\n<h2>请求资源</h2>\n<p>下面这个图总结了网络请求中缓存涉及的几个\b方面,\b下面将具体的从每个方面进行展开.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvTUgo/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQITFh/9oACAEBAAE/IWxwjVLNf//aAAwDAQACAAMAAAAQO8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJVpB//EABsQAQADAQADAAAAAAAAAAAAAAEAEUEhMVFx/9oACAEBAAE/EKAD7uLzWqMJSlfrK2AtzJQeCf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"缓存\"\n        title=\"缓存\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/0479a/cache.jpg 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/41099/cache.jpg 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>本地-强缓存</h3>\n<p>强缓存\b是浏览器在请求具体的资源的时候,直接使用本地缓存的资源的副本而不通过服务器\b去验证资源的相关信息的一种方式.通常有通过expires和Cache-Control中的max-age来控制.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"right\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>expires</td>\n<td align=\"center\">指定缓存的过期时间(与客户端的时间设置相关)</td>\n<td align=\"right\">HTTP 1.0 \b max-age优先expires</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">\b指定请求资源过后多少秒后资源过期</td>\n<td align=\"right\">HTTP 1.1 \bmax-age有优先expires</td>\n</tr>\n</tbody>\n</table>\n<p>当请求的资源存在本地缓存副本并且处于新鲜期的时候,直接返回本地资源.<br>\n当请求的资源没有本地缓存的\b时候,向服务器拉取对应的资源.<br>\n当资源存在缓存\b但是\b\b已经过期的时候,通过是缓存协商去服务器获取资源.</p>\n<h3>请求-缓存协商</h3>\n<p>\b缓存协商是指通过与服务端交互\b缓存资源的信息来判断当前缓存是否可用的一种机制.<br>\n当通过缓存协商服务端认为当前的资源是可用的,返回304(响应体是空).客户端可以时候当前的缓存资源并且可以更新\b缓存的相关信息.<br>\n当服务端\b认为资源不可用的时候\b,返回200(响应体中包含请求的资源).</p>\n<h4>Cache-Control</h4>\n<p>Cache-Control 被用于在http请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求设置的指令,在响应中不一定包含相同的指令.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td align=\"center\">下次请求是强制验证资源有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td align=\"center\">\b\b不进行缓存</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">\b\b相对于请求时间设置的最大过期时间</td>\n</tr>\n<tr>\n<td>public</td>\n<td align=\"center\">\b\b可以被\b客户端和代理缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">\b\b只能客户端缓存,不能被代理缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td align=\"center\">\b\b缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源</td>\n</tr>\n</tbody>\n</table>\n<h4>last-modified和Etag</h4>\n<p>last-modified和Etag(Etag还可以结合If-Match来判断当前提交的内容跟服务端存储的内容是否一致)都是在响应头中返回的对资源的一些设置\b信息,可以通过这两个值\b来缓存协商当前缓存资源时候可用.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">作用方式</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>last-modified</td>\n<td align=\"center\">资源在服务端的上次修改时间</td>\n<td align=\"center\">通过在请求头中设置If-Modified-Since的\b值为缓存资源的last-modified值来与服务端询问\b缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td align=\"center\">\b代表资源的\b实体标识,当资源的内容在\b服务端修改的时候,需要重新生成Etag</td>\n<td align=\"center\">通过在请求头中设置If-None-Match的\b值为缓存资源的Etag值来与服务端询问\b缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n</tbody>\n</table>\n<h5>last-modified和\bEtag的区分</h5>\n<p>Etag的出现更像是为了弥补last-modified的不足.例如:</p>\n<ol>\n<li>last-modified的时间只能\b\b精确到秒</li>\n<li>一个资源的频繁修改但是内容并没有修改</li>\n</ol>\n<h2>存储-协商存储</h2>\n<p>\b协商存储就是根据上面学习的相关字段来决定获取到的资源是否可以被存储被下次请求使用的策略.上文已经对响应的字段进行了说明.</p>\n<h2>CDN</h2>\n<h3>CDN简介</h3>\n<p>CDN(内容分发网络)指的是一组分布在各个地区的服务器.这些服务器存储着数据的副本,当用户访问资源的时候,CDN服务器可以根据用户的IP,服务集群的负载状态等信息尽快的返回给用户所需要的资源.</p>\n<h3>CDN优点</h3>\n<p>CDN主要的功能是托管静态资源,项目中对静态资源进行CDN的配置已经是标配,使用CDN主要有以下优点:</p>\n<ol>\n<li>将静态资源托管给CDN起到给源站分流的作用,降低服务端负载,解决网络网络带宽问题和不同服务商网络速度不同的问题.</li>\n<li>对资源的请求大部分都在CDN的边缘节点完成,访问延迟降低,用户能尽快的看到内容.</li>\n<li>CDN域名与源站域名不同,源站的cookie不会随着静态资源的请求发送,能一定程度上减少网络数据的发送.</li>\n</ol>\n<h3>CDN请求资源流程</h3>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器.</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户.</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求.</li>\n<li>CDN全局负载均衡设备根据用户IP地址,以及用户请求的内容URL,选择一台用户所属区域的区域负载均衡设备,告诉用户向这台设备发起请求.</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近;根据用户所请求的URL中携带的内容名称,判断哪一台服务器上有用户所需内容;查询各个服务器当前的负载情况,判断哪一台服务器尚有服务能力.基于以上这些条件的综合分析之后,区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址.</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户.</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地.</li>\n</ol>\n<h3>CDN优化</h3>\n<ol>\n<li>合理设置CDN节点的缓存时间，保证用户能及时同步到最新的内容</li>\n<li>根据不同的路径 配置不同的缓存规则，实现缓存的最大化</li>\n<li>CDN缓存节点预热</li>\n</ol>\n<h2>缓存的意义</h2>\n<ol>\n<li>资源或者服务的尽快到达和可用</li>\n<li>解决网络带宽问题和服务负载</li>\n<li>减少网络流量,让流量做更加有意义的事</li>\n</ol>\n<h2>思考</h2>\n<p>缓存能给应用带来\b一定的好处,同时也给服务增加了一些\b负载\b(保证资源的更新,增加缓存的成本等等).在对系统的一些基础\b服务做修改的时候,先要把这些有可能出现问题的点考虑清楚或者为什么这么做想好,在去做事.</p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null},"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null},{"id":"717227d4-91ff-5f6b-aee3-770c03c30d3d","html":"<h2>简介</h2>\n<p>作为web开发者,CSS是必备的一项基础技能,下面将从CSS的盒模型开始,来展开了解CSS的相关基础知识.</p>\n<h2>盒模型</h2>\n<p>当对一个元素进行布局的时候,渲染引擎会根据CSS-Box模型(box-sizing)将对应元素表示为一个矩形盒子.理解好盒模型能让我们更好的理解生成元素的大小和布局.生成布局的盒子由以下的属性决定\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/705cc/box.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABkklEQVQoz52S3UobQRiGc1VegFDBE4Vqq9Rjr6DQIz30xDsoQknbg0CCFgqKmFIFNdskNhip1F+oFsTEg6wmutn5e2RmXJKupaWd5Zllvu/dl3dnJhNFEVJoRKwccSzdWynDddimVquxt1en2bxCSeM1Xa8RQvV9KxFCkAnblxRKU+SDZxSCCUe+9JzF8gRvi2PMZ4eZWxjkzepTV7O9ROeZJLc9yqfdWbQ2ZJqtI16vDXDW+MKPS0vg+HlVoX6wxsfVLMvF92xWljhvlh/6Pe1Zo8LJxTpLwTSxiLzhu/Vh7DDKToB2S9rXXfa/HfB1p87h91NfNH3gtTbZys4rYnHnDbOfnyCVdBj7GI1BI6Wg02kThi1ubzu9XgIapTTd+Ibl6st+wyGUUkgpfQhjHOmR1Pv7zlB0eoaN1qEztGkspFP8AatVUhGlEyZ7iP7NHqXX6Zq2yWGlmuxhePxwymXHr6f4d84bVU4vNvgQTCNE19/D/PYL8qVxd8f+lUJpktzWCMXdGbQyZKRUj3/jfwHuAf3PF8lVSwfnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"盒模型\"\n        title=\"盒模型\"\n        src=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/00d43/box.png\"\n        srcset=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/63868/box.png 250w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/0b533/box.png 500w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/00d43/box.png 1000w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/705cc/box.png 1071w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nbox-sizing是设置盒模型的属性，分为IE盒模型(border-box)和W3C标准盒模型(content-box).</p>\n<ol>\n<li>W3C标准\b盒模型: 属性width和height只包含content, 不包含 padding border 也就是标准盒模型的实际宽度 = border-left + padding-left + content(width) + padding-right + border-right 在实际布局的时候还需要将margin考虑在内</li>\n<li>IE盒模型:  属性width 包含content, padding, border. IE盒模型的实际宽度 = content(width)</li>\n</ol>\n<h2>布局</h2>\n<h3>Box</h3>\n<p>Box是CSS布局的基本单位.元素的类型和\bdisplay共同决定着这个Box类型.不同的\bBox类型会参与到不同的格式化上下文中.</p>\n<ol>\n<li>block-level: display属性为 block, table, list-item.</li>\n<li>inline-level: display属性为 inline-block, inline-table,inline</li>\n</ol>\n<h3>布局模式</h3>\n<p>在进行布局的时候，浏览器采用一种dirty位系统，如果某个呈现器（需要渲染布局的元素）发生了更改，将其自身或者子代标记为dirty，则需要布局，在进行布局的时候，元素会确认自己宽度和高度.</p>\n<ol>\n<li>父呈现器确认自己的宽度</li>\n<li>父呈现器依次处理子呈现器\n<ol>\n<li>放置子呈现器（设置x y 坐标)</li>\n<li>如果有必要，调用子呈现器的布局</li>\n</ol>\n</li>\n<li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用</li>\n<li>将dirty设置为false</li>\n</ol>\n<h3>布局上下文</h3>\n<p>布局上下文决定在渲染容器中各种盒子的布局方式,主要有以下几种\b(本文简单介绍BFC和FFC):</p>\n<ol>\n<li>\b块级格式化上下文(BFC)</li>\n<li>行级格式化上下文(IFC)</li>\n<li>网格\b布局格式化上下文(GFC)</li>\n<li>自适应格式化上下文(flexbox)</li>\n</ol>\n<h4>BFC(Block formatting context)</h4>\n<p>\b通过为元素进行一些属性的设置,可以生成\b块级格式化上下文,其中的块级元素会按照BFC的规则进行布局</p>\n<h5>生成规则</h5>\n<ol>\n<li>根元素，即HTML元素</li>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为inline-block、table-cell、table-caption</li>\n<li>position的值为absolute或fixed</li>\n</ol>\n<h5>布局规则</h5>\n<ol>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。不与float box重叠.</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h5>作用</h5>\n<p>关于BFC的作用和例子可以阅读下这边文章,博主写的很详细.<a href=\"https://juejin.im/post/5909db2fda2f60005d2093db\">关于CSS-BFC深入理解</a></p>\n<h4>FFC(flexbox)</h4>\n<p>FFC就是CSS3所说的弹性盒子布局. 详细的使用指南可以参考这篇<a href=\"https://css-tricks.com/snippets/a-guide-to-flexbox/\">A Complte Guide to Flexbox </a></p>\n<h2>定位</h2>\n<p>Box一共有以下三种定位方式:</p>\n<ol>\n<li>Normal flow: 包括块级的格式上下文, 行级的格式化上下文, 相对定位的(position relative)的块级和inline-block</li>\n<li>Float: 这种情况脱离了文档流,但是会影响之后元素的content(环绕)</li>\n<li>绝对定位(position absolute): 脱离文档流, 不会影响之后元素的位置和内容</li>\n</ol>\n<h3>position</h3>\n<p>position相关属性及含义</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>absolute</td>\n<td align=\"center\">绝对定位,相对于static以外的第一个父元素进行定位</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td align=\"center\">绝对定位,相对于浏览器窗口进行定位</td>\n</tr>\n<tr>\n<td>relative</td>\n<td align=\"center\">相对定位,相对与正常位置进行定位</td>\n</tr>\n<tr>\n<td>static</td>\n<td align=\"center\">默认值\b,没有定位.</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td align=\"center\">粘性布局 可以认为是固定定位和相对定位的结合.元素在跨越特定阈值前为相对定位,之后为固定定位</td>\n</tr>\n</tbody>\n</table>\n<h3>float</h3>\n<p>浮动是一种脱离文档流，对之后或者之前的盒子中的content flow产生影响的一个属性(区别于定位  例如position absolute 也是脱离文档流 但是它不会对之后之前的盒子产生影响),\b浮动元素会产生一个块级框,即使它本身是一个行内元素</p>\n<h4>浮动规则</h4>\n<ol>\n<li>浮动元素的左右外边界不能超出其包含块的左右内边界</li>\n<li>浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动的(或右浮动)元素的右（或左)边界，除非后出现的浮动元素的顶端在先出现浮动元素的底端下面（防止浮动元素之间的覆盖）</li>\n<li>左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边 右浮动元素的左外边界不会在其左边左浮动元素的右外边界的左边</li>\n<li>一个浮动元素的顶端不能比其父元素的内顶端更高   浮动元素的顶端不能比之前所有的浮动元素的顶端或块级元素更高</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/46e51/float1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA10lEQVQY05WRzWrCYBBFP3BR9z5ki1YQmtRW81NR69JNgw/g+4jvkWzkm5EocU6JaaVdBNoLZzNwL/cyLh88omGIPAXtBCEyGiHvK+RwQFQR7xGRG6pKnue40jn4K50OlCVXVRVcLmDGt+pQx3SKLZfYfN7OYoGlb9hHdjPbT75C66bOBwEkCRZF7cQxNh7DZsNpv0f6fWw4xO4fsNkMO5+bQO9x1X8m93rYdssvz10XylMzuW6o4TOSpkgct5MkyMsrkmXIbodGUXObTJD1+vooPR4pioJPcH1oF5VRdrwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"float示例1\"\n        title=\"float示例1\"\n        src=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/00d43/float1.png\"\n        srcset=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/63868/float1.png 250w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/0b533/float1.png 500w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/00d43/float1.png 1000w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/46e51/float1.png 1003w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里例子中三个元素均为浮动元素,包含块的宽度固定,由于规则2 导致第二个浮动元素bbb移动到aaa下面.由于4的限制，浮动元素ccc的顶端是跟bbb一致的，不能超过bbb或者跟aaa平齐.<br>\n5. 如果源文档中一个浮动元素之前出现了另一个元素 浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高<br>\n6. 左浮动元素必须向左尽可能的远 右浮动元素必须向右尽可能的远 位置越高 就会向左或者向右尽可能的远<br>\n7. 浮动元素与正常内容流重叠的情况:\n1. 行内框与一个浮动元素重叠的时候，其边框 背景 和内容都在该浮动元素之上显示.\n2. 块框与一个浮动元素重叠时候 其边框和背景在该浮动之下显示 内容在浮动元素之上显示</p>\n<h2>居中</h2>\n<p>可以阅读下自己之前翻译的一篇文章<a href=\"https://www.cnblogs.com/tiantianwaigong/p/5291370.html\">CSS居中完全指南翻译</a></p>\n<h2>参考链接</h2>\n<p><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#4_1\">浏览器的工作原理:新式网络浏览器幕后揭幕</a>\n<a href=\"https://www.zhihu.com/question/24529373/answer/29135021\">css脱离文档流是什么意思</a>\nCSS权威指南\n<a href=\"https://www.w3.org/TR/CSS21/visuren.html\">Visual formatting model</a></p>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"CSS基础总结","date":"2018-10-18","tags":"CSS","path":"/css-basic","top":null,"summary":null},"title":"CSS基础总结","date":"2018-10-18","tags":"CSS","path":"/css-basic","top":null,"summary":null},{"id":"63290450-7688-5343-b1bc-e0bb0a56cced","html":"<h2>简介</h2>\n<p>事件循环是不同的宿主环境(浏览器或node)对javascript任务进行调度的一种机制,在讨论事件循环的时候首先应该区分node和浏览器(不同宿主环境实现的事件循环机制不同).下面通过介绍一些javascript的基础知识,进而简单的介绍浏览器中的事件循环和node中事件循环.</p>\n<h2>基本概念</h2>\n<ol>\n<li>javascript程序的执行机制是通过栈来\b管理的.当进入一个函数,就创建了这个函数的执行环境并将这个执行环境推入栈顶,执行完当前的函数后,从栈顶移除对应的执行环境,进入到外层的执行环境.\b</li>\n</ol>\n<p><img src=\"/blog/ee34151d44d3f796b1f1436e0926a2a7/stack.gif\" alt=\"stack\">\n2. javascript的执行是单线程的.但是由于整个事件循环的调度,赋予了javascript对异步任务的强大处理能力.对于异步任务(网络请求,按钮点击)javascript代码调用宿主环境提供的api,将异步任务交给其他的线程去完成.当对应的异步任务完成的时候,将回调函数添加到回调函数的队列中,由事件循环来实现会回调函数的\b调用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>marcotasks microtasks</h2>\n<p>将macrotasks和micortasks单拉出来讲解,是因为理解好这点能更好的理解浏览器或node的任务队列.在实际的实现环境中不同的任务可以放置在不同的任务队列中,然后通过对多个任务队列的调用来完成整个事件循环.</p>\n<ol>\n<li>macrotasks:</li>\n</ol>\n<ul>\n<li>定时器(timer) setTimeout setInterval setImmediate</li>\n<li>message channel  (message channel执行的优先级高于timer)</li>\n<li>I/O</li>\n<li>UI rendering</li>\n</ul>\n<ol start=\"2\">\n<li>microtasks:</li>\n</ol>\n<ul>\n<li>Promises</li>\n<li>MutationObserver(监听DOM)</li>\n</ul>\n<ol start=\"3\">\n<li>其他api</li>\n</ol>\n<ul>\n<li>\n<p>queueMicrotask(fn)\n将Fn推入微任务执行队列</p>\n</li>\n<li>\n<p>requestAnimationFrame<br>\n通知浏览器在下次重绘之前调用传入的回调函数，回调函数默认传入函数执行的时间戳.requestAnimationFrame不属于宏任务和微任务，在微任务执行之后执行</p>\n</li>\n<li>\n<p>process.nextTick\nprocess.nextTick是node上的api，具体的执行时机是在微任务之前执行。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVQ4y42T227aQBRF+QwItudqjw12bGyMuQQCCRENtE9VK7X//x+r8uSiRkmkPGwdzRnN1lkzewbKWHTeYos5dTujW9V0q4Z6XhPHCWEYEkXRO33WHyilUPGUpKjJ2xVuWpBVDWlRkkxywiB4o6Cvz2YfmQ6klBTJFCcNURgiTYxU2ktEEUJIdOzQxqJih4kdSsp3Zi9rP6GWirbdUa9vqfcn2rszy8svuvtHqs2B+eEbi/szy4fv1G1Hf+YjXG+otSYMxuTdlmb/SN4sqW6OlMs9Rbcju679lFJZpFSeIhj3+CFBEPrqFT5poLTyaPEkIy0zXJkxbUuS3CFtgHEC4xQ2lWgnsZnGpMrXF/X7QkZE4hlZCIGOIyYzTT43ZJUiKxVZZUgrS1Zb3LV+rUlumC4crrToRL2aSiN6ZEUQRtzXhr+nip93Bb+PBX+OBZdDQ96tmcwaqps7quWaOE3xVEr4Owv+R++Re8MoEuTOcbqcOP04s9jsKNuOax+jkrSYkbcbf7/5fIW1sY/PpznUShEnFmsVUghGwxHD4ZDRaMT46upJoyHjq5FX+GoWvovPoH+5fsrH84bLZcf2Zk5TF1jT9yVKPSkS4ms/pX+Q1CXcrjs22479w579ccf2sGW9W7FoSxZd47P3mcnbHBqNS1KcchibYLMCk05J8hk2nWKtJUliH62vGP4DF253f3L9M/QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nextTick\"\n        title=\"nextTick\"\n        src=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png\"\n        srcset=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/63868/nextTick.png 250w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/0b533/nextTick.png 500w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png 1000w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png 1150w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>setTimeout(function(){\n  console.log(1);\n});\nnew Promise(function(resolve){\n  console.log(2)\n  for( var i=100000 ; i>0 ; i-- ){\n      i==1 &#x26;&#x26; resolve()\n  }\n  console.log(3)\n}).then(function(){\n  console.log(4)\n});  \n\nconsole.log(5);\nprocess.nextTick(() => { console.log('nextTick'); })\n输出的顺序依次是 2 3 5 nextTick 4 1 \n</code></pre>\n</li>\n<li>\n<p>requestIdleCallback\nwindow.requestIdleCallback(callback[, options])</p>\n<ol>\n<li>callback是一个在事件循环空闲时即将被调用的函数的引用，接收一个IdleDeadline参数，通过该参数可以获取当前空闲时间(timeRemaining())以及回调是否在超时时间前已执行的状态(didTimeout)</li>\n<li>options 可选参数 可以配置timeout  表示超时毫秒数未调用回调函数，回调函数将在下一次空闲期间被强制执行。</li>\n</ol>\n</li>\n</ul>\n<p>在具体的实现中只会有一个microTasks队列,简单的理解事件循:</p>\n<ol>\n<li>浏览器或者node会按照顺序执行自己环境的多个macrotasks队列</li>\n<li>每执行完一个macrotask队列就会拿出micortasks队列的任务全部执行，然后继续执行下一个macrotask队列</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1CLID/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRR5Ef/aAAwDAQACAAMAAAAQ48//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAAAATFBEVEhcfD/2gAIAQEAAT8Qy3TXN2M1O2ZJuxz7aIH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runTask\"\n        title=\"runTask\"\n        src=\"/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg\"\n        srcset=\"/blog/static/9a253bb0db2af3498f93ce723c928568/0479a/runTask.jpg 250w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/41099/runTask.jpg 500w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg 1000w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg 1098w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in browser</h2>\n<p>其实通过对上面相关的知识的介绍,已经可以大致的了解浏览器中事件循环的任务队列 主要有以下几种macrotasks队列</p>\n<ol>\n<li>事件callback</li>\n<li>I/O(xhr)</li>\n<li>timers</li>\n<li>UI渲染</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in node</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAACzklEQVRIx5WVC0/qQBCF/f//RQMKUfAJCpIoAYxBBBGjEfABgkApbWFuviHbFCwpt8lkutvu2TMzZ2d3ZO1ZLBbqHceRwWAg39/fav1+X/3Pz498fX2ptyxL7NlM/505jsznc9kBYN14AMtmsxKLxdQODw/l4OBAfTKZlKOjI3l5eZHp1JbZbKbg0+l0CRjG0LZt+fz89BliMMN4//j4kNFo5K+DnQUgA8/zlLbruiugwYdv/LMpRa7rLQH56f39XVqtlry9vfm7MgcLE/7d3Z1cX18rw263K8/PzysbQ0oBf39/5fb2Vs7Pz6VQKMjr66tY1lR6vZ70en2ZTCZSq9UknU5r/vgX0E6nqyB/AAnl/v5erq6u5ObmRobD4Z+wmON7JpNR5ibHoYBGIhQANptyOB6P/RQsx5NwwE1VZhPySehojjySnuAYmYQyDNMhi4rFomru5ORE9vf3VXtYIpGQXC6nRQwFXAflQaxGc0Ed4mFJikjDRsD1cBuNhhYL//j4KA8PD9JsNrXiSIi5arXqy4zibgTkGCEhQj07O1N/enoqx8fH+h70aDISkI+Eg1F5NsB4pxDG+E5qVk5KGCALn56eVMQwoQCpVEouLy+VMYXh1BA2+YxkyO4AYuTM5NB4rF6v65i2FglIxdAZlUQ+sGBh0PONE2QaRmTI+Xze73tokJ5o+iHjvb09LRTAWxUFJrCEISckaMxjMKVYkYAc/E6no5Jot9tSKpWkUqlozsrlsrYuzjXfttIhIQOAAUB1MaqNUX3EzdE0DSOyKGiMpOON7sy9wYbMw24rHbKQ8Eg6zLis0OHFxYU2YpotY1j+tw7RmznPeIw5o0OKtlWVCcd0F3P7UXkKZW4/UrJVyOSHxKNDY/F4XEPd3d3VdzTJlWCagxPF0HTooPZgSUFgjzFnGIb2w033iXlY4HlzcT1PAXh3HFdBl0qw5R8VVUHLG1SyuAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node\"\n        title=\"node\"\n        src=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n        srcset=\"/blog/static/624c9768d8888b109a4649298c0cb091/63868/node.png 250w,\n/blog/static/624c9768d8888b109a4649298c0cb091/0b533/node.png 500w,\n/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>注意点</h2>\n<ol>\n<li>在浏览器或者node中某些代码的执行会导致event loop失效(停留在处理一个事件队列导致无法进入其他的事件队列的处理).比如浏览器中javascript的长时间执行会导致UI无法交互,node中process.nextTick的递归调用</li>\n</ol>\n<h2>相关资料</h2>\n<p><a href=\"https://tuobaye.com/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/\">通过microtasks和macrotasks看JavaScript异步任务执行顺序</a><br>\n<a href=\"http://docs.libuv.org/en/v1.x/design.html\">libuv Design overview</a>\n<a href=\"https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f\">How JavaScript works in browser and node?</a>\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&#x26;utm_medium=email\">Tasks, microtasks, queues and schedules</a><br>\n<a href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\">Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018</a>\n<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;t=55s\">菲利普·罗伯茨：到底什么是Event Loop呢？ | 欧洲 JSConf 2014</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null},"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null},{"id":"70c3382e-a071-5536-a147-725929d63e20","html":"<h2>简介</h2>\n<p>在不同的\b场景下,需要页面实现不同的滚动效果\b例如滚动到最底部、滚动到最顶部\b。以下首先对滚动的几个基本的属性进行\b总结并给出实现滚动的一些方案</p>\n<h2>基础属性简介</h2>\n<p>当元素的子元素比元素高且overflow=scroll时,元素会scroll.此时移动滚动条出触发本元素的scroll事件</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th align=\"center\">定义</th>\n<th align=\"right\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clientHeight</td>\n<td align=\"center\">与元素的高度有关,\b代表元素的高度加上padding(不包括border、水平滚动条的高度、margin),对于inline元素该属性的值为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>clientWidth</td>\n<td align=\"center\">与clientHeight相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetHeight</td>\n<td align=\"center\">与元素的高度有关,不同于clientHeight,它包括border、水平滚动条的高度,\b不包括margin.对于inline元素该属性为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetWidth</td>\n<td align=\"center\">与\boffsetWidth相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>\b\bscroll\bHeight</td>\n<td align=\"center\">\b当出现滚动时,scrollHeight代表元素内容的高度(包括在不在内容区域的内容)  当一个元素\b出现滚动, 它的相关属性 判读元素是否滚动到底部 scrollHeight - scrollTop === clientHeight</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>scrollTop</td>\n<td align=\"center\">当元素出现滚动的时候,scrollTop\b代表元素可见内容距离该元素顶部的高度.不存在滚动条的时候,scrollTop为0</td>\n<td align=\"right\">可读可写</td>\n</tr>\n<tr>\n<td>offsetTop</td>\n<td align=\"center\">获取当前元素跟\b\boffsetParent父元素顶部(position不为static的父元素)的距离</td>\n<td align=\"right\">只读</td>\n</tr>\n</tbody>\n</table>\n<h2>实现滚动\b的几种思路</h2>\n<p>在实现滚动上首先要确定的一个点是你需要知道\b此刻这个元素的子元素已经绘制完成(高度确定)。比如在\breact的项目\b中可以在didUpdate中触发元素的scroll事件,下面介绍下实现滚动的几种方法:</p>\n<ol>\n<li>锚点 通过在页面中设置锚点能在实现跳转到页面相应位置的目的,这种方式也比较好操作.缺点是需要在url中添加其他信息</li>\n<li>\boffsetTop, scrollTop</li>\n</ol>\n<ul>\n<li>offsetTop 可以在页面\b隐藏一个元素 通过获取这个元素的\boffsetTop来设置滚动元素的scrollTop</li>\n<li>scrollTop \b直接设置scrollTop来实现定位 当scrollTop设置\b的值超出元素的最大值(scrollHeight) 会被设置成\b最大值(定位到最底部)</li>\n</ul>\n<ol start=\"3\">\n<li>scrollIntoView(alignToTop)</li>\n</ol>\n<ul>\n<li>alignToTop\b默认是\btrue \b通过item.scrollIntoView()/item.scrollIntoView(true)会\b使元素的顶部跟可视区域的顶部对齐</li>\n<li>item.scrollIntoView(false)会使元素的底部跟可视区域的\b底部对齐 \u001e</li>\n</ul>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"页面滚动","date":"2018-08-26","tags":"JavaScript","path":"/js-scroll","top":null,"summary":null},"title":"页面滚动","date":"2018-08-26","tags":"JavaScript","path":"/js-scroll","top":null,"summary":null},{"id":"6d00a615-26fe-5d55-86fb-68b1514e2f14","html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收\b事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.\b下面从几个方面来拆分这个小例子来重新学习下\bXMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 \b启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受\b收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息\b,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合\b来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,\b\b顺序对应着请求的方法、地址、\b是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中\b增加query的方法进行数据的发送并且在调用send方法时必须\bsend(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, \b\b注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open\b之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error \b请求发生错误的时候的监听函数</li>\n<li>\bloadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>\bxhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载\b并且可以\b通过download\b进行文件名的设置.\b这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件\b名,这个时候可以通过设置\bresponseType为blob,\b生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的\b时数据\b上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress\b这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload\b.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么\b\b\b上传阶段完成是\bmock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的\b切分\b上传阶段和\b数据接收阶段的比例来完成\b对用户接受更合理的\b进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>\b作为一个web前端开发者\b离不开\bXMLHttpRequest的使用,以上通过\b对xhr基础的介绍和自己在项目中遇到的\b问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null},"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null},{"id":"ee07b2ad-54b7-5c32-bd80-53dd6ae5afc3","html":"<h2>简介</h2>\n<p>在看深入浅出node.js这本书的过程中,遇到了几个容易迷糊的\b概念,例如阻塞I/O、非阻塞I/O、同步、异步。下面主要从I/O模型上对上面的概念进行理解.</p>\n<h2>基本概念</h2>\n<p>I/O复用指的是内核具有当进程指定的I/O条件就位的时候通知进程的能力.</p>\n<h2>I/O模型</h2>\n<ol>\n<li>阻塞式I/O 在发生系统调用(I/O)的时候,对应的系统调用直到相应的操作完成或者错误时才返回.(例如在进行网络IO时,需要等待网络数据的就绪完成读取才会完成系统调用的返回)</li>\n<li>非阻塞式I/O 进程可以把一个套接字设置成非阻塞模式.这样当通过该套接字进行相关I/O操作并且需要进程进行等待的时候(例如通过网络读取数据,但是数据并没有就绪的时候), 内核不能将该进程投入睡眠而是返回一个错误标识(轮询)</li>\n<li>I/O复用模型 通过select或者poll来对多个相关的描述符进行监听(此时进程阻塞在select和 poll的调用上)),当描述符状态就绪的时候,返回可读条件然后在通过系统调用来完成对应的I/O操作</li>\n<li>信号驱动式I/O模型 通过开启套接字的信号驱动式I/O的功能并且添加相应的信号处理函数,当套接字准备好读取的时候,通过信号通知进程来完成响应的I/O操作.这种模式进程是不被阻塞的</li>\n<li>异步I/O模型  通告系统调用告知内核相应的操作,然后内核在完成相应的操作后会通知进程.这个过程中进程是不被阻塞的.</li>\n</ol>\n<h2>同步VS异步</h2>\n<p>同步,异步的概念区分上在于实际上发生系统I/O的时候,是否会阻塞进程.因此上面的前四种模式都是同步I/O,只有最后一种是异步I/O</p>\n<h2>select</h2>\n<p>int select(int maxfdpl, fd_set *readset, fd_set *writeset,fd_set *exceptset, const struct timeeval *timeout) 该函数允许进程指示内核等待多个事件中的任何一个发生,在其实一个或者多个事件发生后或者经历了一定时间后唤起进程.该函数的当有描述符就位的时候返回描述符的数目,超时返回0,若出错返回-1,下面对主要的参数进行分析</p>\n<ul>\n<li>timeout 告知内核等待所指定的描述符中任何一个就绪所花的时间.\n<ol>\n<li>当该timeout结构的代表的值均为0的时候,表示无需等待直接返回</li>\n<li>当设定一定时间的时候,表示当select返回的时候,不能超过该时间</li>\n<li>当设置为空指针的时候,表示select会一直等待直至有响应的描述符就绪</li>\n</ol>\n</li>\n<li>readset writeset  exceptset  表示让内核检测响应的读,写,异常描述符,当有响应的描述符就位时返回.</li>\n<li>maxfdpl 指定待测试的描述符的个数</li>\n</ul>\n<h2>node如何实现高性能的异步I/O</h2>\n<p>参考自己之前整理的一篇blog<a href=\"https://www.cnblogs.com/tiantianwaigong/p/6234961.html\">node的异步I/O</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null},"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null},{"id":"a9b0d541-f9ec-5cf4-93b7-812c9ac0b32f","html":"<h2>简介</h2>\n<p>网络套接字是应用层和传输层的桥梁。套接字提供了应用层与系统内核的交互的能力来完成数据的发送和接收.下面主要从套接字的几个基础api来介绍套接字并且结合tcp来理解网络应用对外提供服务的整体过程.</p>\n<h2>基础api\b</h2>\n<ol>\n<li>在使用套接字发送数据时将数据从应用进程的缓冲区写入到套接字的发送缓冲区，来完成数据的发送.</li>\n<li>通过对\b套接字函数的调用可以获取套接口的一个描述(一个套接口可以对应多个套接字描述),当内核中不存在套接字的描述符的引用的时候,内核会触发该套接字的close.</li>\n<li>基本TCP客户/服务器程序的套接字函数调用过程</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB6klEQVQ4y5VT25KiMBD1/z/MB6t884qgYhEFBJKQK52kmdJMMe7s1K5zHqhKyOk+fbp7Nr6Nvu/X6/Vut9Nax5vZm0xEFEKkaVqWpbX2/2REHMeRMZYkyel0EkJcLpeyLIdheDczPhFCkFKmaZrn+VuZXxFCMMYQQuq6BoBf18w53+/3RVF8NwwRlVKTnm9lRwDA4XAghEz3syipbdvdbne73SZJPzq3WCyWy6X3/iuz955SmiRJVVVCiBCC9x4RrbX3+905h4j+CSGE1nqSM4uBGWNpmrZtG9tojPHeE0Lm8/l2u7XWaq1jrCjtUzYitm3bNE2apk3TaK3DE7GllNJhGKZUxpjJrQfZOSelVEp1XSeltNYCgDGGMdZ1HWMMAIZh6Lquqqrz+VxVVV3XUsoHGQCcc+M4/m31q2HOOa11lmWEkBgdER/kWMY/yNOcZFlWVVV8HEL4JMduvZbHGMvz/HK5aK2998YYSunxeLxer5xzKeUjs3Ouf2K/30e3o7HGGCllLCp+h2EQQiil/hjPEELf95vN5n6/x3+ICACU0q7rXntjnvhyO5KVUnVdc86NMQBgreWcE0Ji8wGg73tKaVEUcWx+txha67Zt42JzzgHAez/7cQemNY6Ix7IsV6tVkiRFUcQR+AAp44e3Q8OxXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"套接字基础api\"\n        title=\"套接字基础api\"\n        src=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n        srcset=\"/blog/static/488016f75fa3e6b554b97157803a13e8/63868/api.png 250w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/0b533/api.png 500w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>socket(int family, int type, int protocal) 默认产生一个主动的套接字 其中family字段指明协议族如Ipv4\b,Ipv6等\b, type为套接字类型如SOCK_STREAM(字节流套接字), SOCK_DGRAM(数据报套接字) \b\bprotocal指的是由前两个参数决定的\b协议说明 例如tcp传输协议  UDP传输协议</li>\n<li>connect(int socket, const strcut *servaddr, socklen_t addrlen) 在TCP套接字\b状态下调用此方法会激发TCP的三次握手.几种常见的网络错误也是在这个阶段出现了\n<ul>\n<li>如果发送了SYN,在经过TCP的超时重试之后仍然没有收到对应的ACK,此时显示ETIMEOUT超时</li>\n<li>收到RST(复位) 通常对应的\b对方没有正在监听的服务器、TCP想断开一个已有的\b连接、TCP收到一个不存在连接上的分节</li>\n</ul>\n</li>\n<li>bind(int sockfd, const struct *myaddr, socklen_t addrlen)  将一个本地协议地址绑定到一个套接字\n<ul>\n<li>在\b绑定地址\b上,在服务端上的\b\b一般都绑定到特定的端口 对IP地址进行0.0.0.0(INADDR_ANY)绑定(为了处理服务器有多个网络接口), 最后由系统内核指定IP地址  在客户端一般有内核指定IP\b地址和端口 \b</li>\n</ul>\n</li>\n<li>listen(int sockfd, int backlog) 将一个从主动状态转为被动状态,指示内核接受指向该套接字的请求\n<ul>\n<li>backlog参数代表着未完成连接队列和已完成连接队列之和.在正常的三次握手的过程中,一个未完成连接的条目存活的时间是最后一次客户端对服务端ACK的确定(RTT)</li>\n<li>设置成\b较大的backlog是为了扩大为完成连接数目的队列.当为队列数目是满的时候,TCP会忽略该分组,这样TCP将重发SYN而不是显示连接错误等</li>\n</ul>\n</li>\n<li>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) \b从已完成队列中返回一个已完成的连接\n<ul>\n<li>\b区分监听套接字和已连接套接字  监听套接字在服务器的整个生命周期只存在一个,连接套接字是为每个接受的请求都会创建的\b</li>\n</ul>\n</li>\n<li>fork 创建自身进程的一个副本\n<ul>\n<li>fork的调用会在父进程和子进程中进行返回,通过区分返回值来区分父进程和子进程</li>\n<li>子进程共享共享父进程fork之前的所有描述符(注意在fork的时候\b关闭对应的\b描述符)</li>\n</ul>\n</li>\n<li>int shutdown(int sockfd, int howto) howto指明如何关闭改套接字是关闭读的部分还是写的部分,这样能防止关闭套接字时候无法处理到达的网路请求返回数据</li>\n</ol>\n<h2>相关参考链接</h2>\n<p><a href=\"http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html\">tcp backlog</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null},"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null},{"id":"b34d966c-2fd9-5dba-a9cc-0f796cfe9c0a","html":"<h2>简介</h2>\n<p>通过对运输层和网络层的基础知识的学习,了解到他们分别提供了基于主机进程间的通信和主机间的通信,这都基于数据链路层实现的上述功能,下面通过对数据链路层的学习来了解数据是如何通过相应的数据链路来实现传输和交付的</p>\n<h2>基础</h2>\n<p>1 在通信路径上连接相邻通信节点的通信信道称为链路。链路层协议将网络层的数据报封装成链路层帧来实现数据在链路节点间的移动。\n2 链路层主要提供的服务有数据报的成帧,链路的接入(无线链路,有线链路),可靠交付,差错检测和纠正.链路层的功能主要在网络适配器(NIC)上来实现相应的功能\n3 链路层通信通过MAC地址(LAN地址或者物理地址)来实现,所以一个通信的具体过程会涉及到三种地址:</p>\n<ol>\n<li>主机名</li>\n<li>IP地址</li>\n<li>MAC地址</li>\n</ol>\n<h2>地址解析协议(ARP)</h2>\n<h3>ARP的作用和寻址过程</h3>\n<p>ARP提供的是同一个子网和路由器的网络层地址到MAC地址的转换.主机会在内存中维护一个ARP表,这个表保存着一定时间内该子网内主机IP地址和MAC地址的映射.当目的主机的IP地址在ARP表中时,发送主机通过封装链路层帧目的MAC地址为保存的目的MAC地址将数据推送进数据链路层.当ARP表中没有响应的条目的时候,发送主机通过MAC广播地址发送APR广播分组,这样子网内所有的主机都会处理该分组,符合该IP地址的主机会发送ARP响应分组,将自己的MAC地址通知给请求发并且更新请求方的ARP表</p>\n<h2>以太网</h2>\n<h3>以太网基础</h3>\n<p>以太网是基于之前的各种协议实现的一种局域网技术,它提供给网络层无连接服务.</p>\n<h3>以太网帧结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 884px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVQY0z2LTUvbYACA80PEHzC9CLrLKlLGDuJgpTI3vzpE2EUZyHbRIt5kh6FsggeL2po0PSiryeL7NhVddVK1TWcjJbXWFisxpB9C0tqlJjbv0E0fntvDg5mmiRBSlUr27DyTzpbVa4RQWa2kkplqtYYQusv3mA8+gkmiVJALSkkVc2IumytIRVmSxXMpk8rqNf3fdFUsyZeyWf8/GrqRlwpaVcMOufhxIq1UtJKqXpXL+aKyuxdJZy5EOV+rm9c3xs2tKSTP4ryg6beabvwx6mpVi0bixZKCPaUTnZunjgDXQfNW6miQjVlgygZiL9bCr8FRZzBlBUL7hmBhEh0waYVCFys4AlzbOj8Vu8AmmajNz7W6wccNboyJWtxwiuXH/L/mNw+ee7efeMPTW8euHd61f7IQijsB1+zbf0kEvgR/fw6fYv1L4JkLNs3gvR7Y6wYts95hcntg0T9OMq1zqw1fqdHVkPP7Tye9N7G2NYSzjd+o9jlv9yL4BCNY1zLT5wuOkvQbAr4l4AhJ2wh2iPjhwKn3JDPgC3bj0L4C7B7GvgJ6cPiOhB981KtlaiYU/Qscvja2c8oD8QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"以太网帧结构\"\n        title=\"以太网帧结构\"\n        src=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n        srcset=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/63868/dataLink.png 250w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/0b533/dataLink.png 500w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png 884w\"\n        sizes=\"(max-width: 884px) 100vw, 884px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>前同步码 主要用于在发送方\b和接收方进行时钟的同步</li>\n<li>\b目的MAC地址 当接受方收到对应的链路层帧的时候,当该帧的目的MAC地址是本机的MAC或者是广播地址的时候,数据字段的内容就是向上传递给网络层进行处理</li>\n<li>源地址 发送方的\bMAC地址</li>\n<li>类型字段 用于与上一层的某协议相结合</li>\n<li>数据 网络层数据报</li>\n<li>CRC 循环\b\b\b\b冗余\b检测用于接受方检测是否存在差错</li>\n</ul>\n<h2>交换机</h2>\n<p>\b  链路层交换机主要提供转发和过滤的功能.过滤是\b\b指决定一个帧是否被转发到某个\b接口还是将其废弃的功能.转发指一个帧具体应该被转向那个接口.</p>\n<h3>交换机的转发过程</h3>\n<p>交换机通过自学习的特性定期的维护自身的交换机表.表的条目分别是\bMAC地址,接口,时间.当交换机收到\b一个\b帧的时候,会\b根据该帧的目的地址做出不同的\b行为</p>\n<ol>\n<li>如果交换表中没有该MAC地址的时候,交换机就会\b向它所有的\b端口转发该帧</li>\n<li>当交换机接受到该帧的端口MAC地址和目的地址\b相同的时候,丢弃该帧.</li>\n<li>当交换机表中存在相应的条目的时候,将该帧转发到相应的端口</li>\n</ol>\n<h2>web页面请求的详细过程</h2>\n<p>\b可以结合前两篇来\b理解这个过程(DHCP HTTP  UDP CIDR IP \bMAC(ARP))  里面涉及的编制 寻址 传输等相关协议</p>\n<h2>思考</h2>\n<ol>\n<li>网络协议虽然是分层的，但实际的实现上层与层之前的界限并没有那么清晰,不能割裂的去学习网络协议模型,要从整体上理解网络协议的\b\b整体过程</li>\n<li>在具体功能的实现上,例如数据链路层\b通过MAC\b地址进行通信而不是依赖网络层的IP地址,这样就能使\b数据链路层与其他种数据格式对接,增加独立性</li>\n<li>\b层与层之前的功能不具有强依赖关系,例如数据链路层是能\b够通过CRC循环冗余检测来实现\b\b\b差错检测和恢复的,网络层自己实现了本身的差错检测,在实现一个大型的系统的时候,功能到底是依赖于\b上层还是自己去维护(稳定性)都是值得考虑的点</li>\n</ol>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null},"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null},{"id":"c483d85a-973c-5c8d-a0d7-764a27b93895","html":"<h2>简介</h2>\n<p>\b在\b初学node的时候,都会在\b学习到下面的这个例子:</p>\n<pre><code>const http = require('http');\nconst server = http.createServer(function(req,res) {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('okay');\n});\nserver.listen(8080,function() {\n  console.log('server is on');\n});  \n</code></pre>\n<p>上面的例子就创建了一个最\b简单的web服务,当通过浏览器访问本地的8080端口的时候页面就会输出okay。下面主要从两个方面来理解node如何加载和运行这段代码来提供服务的。</p>\n<h2>nod\be代码结构(基于node V6.11.0)</h2>\n<p>\b下面就是node的代码结构,在lib中主要是\bnode提供的标准库(例如http等模块),在src模块主要是node的入口文件和node提供给lib的C++接口.在deps中主要包含了DNS解析,http解析,事件循环\b和跨平台的异步IO的\b实现等.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 932px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABB0lEQVQ4y62STU+EMBRFWasLE93KAKV8tDhAS9FAYTIMBtf+Aifj3v+/uqadxGh04XRcnDT9yMm779XLshxaa/S9RpKkoDRxgpAYnBfwzKaqakzTDmmaIQwj+yCOqcVJ2DQK2+0EISTW6/Ik0Q+hiVnXAsMwYlmeoVRrL8+KLIRA1/Uoy+oz7tfVKfI8P1mhi+yXCiXa9sH271+mrJSyMt9ffZuuc2QpGzsUrQfbS/N9zoicQsgGfT+AscJizmJT4R85CulRyLMMQ9fhnjOQIACNIiSEnEZMQKMQBcvh0eoRzWZBwCV8JrBy5C6vYVzezfyG9OUd19MBl+MrrjZ7Jy7GPW53B3wAKwuBpW1A2esAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node代码结构\"\n        title=\"node代码结构\"\n        src=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n        srcset=\"/blog/static/38795164842a3beb02db9ed01e44311f/63868/nodeSrc.png 250w,\n/blog/static/38795164842a3beb02db9ed01e44311f/0b533/nodeSrc.png 500w,\n/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png 932w\"\n        sizes=\"(max-width: 932px) 100vw, 932px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>node如何加载我们的代码</h2>\n<p>通过都是通过命令行 node server.js来启动一个简单的服务,下面来简单的看node如何\b加载和执行\b这个server.js文件<br>\n在node的启动文件src/node_main.cc中有如下\b这段代码,\b它调用了node.cc的node的\bStart方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABG0lEQVQY032QW27CMBBFs44SE+dhk4Q4YAenBIIoffFH1Q10/7s4VRxRqf3ox9Gdq5k7I00k1ZrWd4wnh2oc286z6yxp7ShbyzDs8d5TVRWJTEiSJctkOetyroOXs48SKZGFpNwW6HYip+4UK5MFKqso6hTVZKGnTY5a55RbxWpTUFqFbvKQV+uMSEqJdTV+aHF+y+PBU7Y1WbNBGYuqNafLkd3eYeyaXKXILCFTkrxMA2khg58IC5/OPa8vA+N45Pr2zqGzbPoL2p3RuuLjdmMcT3TeMc3HsUDEIui9vhPJVGK0waiWbmfoe8PX1fL53OH7R5qmYT/s0VoTx/H8t3+ITGlwtSVN0hAQQvCwECymi+I3U+Cv/iDmhd//Pa9jeahOZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"main\"\n        title=\"main\"\n        src=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n        srcset=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/63868/nodeMain.png 250w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/0b533/nodeMain.png 500w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在Start方法\b先对平台进行了初始化操作 主要关注下面的代码<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVQ4y5VUbY6bMBTMLbbi0wYCBtuYGBuyCWxIVlWlXqA/ev9zTGWTRNlmW2l/PD3LFuOZeYM3QgjM84TpeMDr64j9fodx7GCMhLUGfW8wDAP2+z2UUhisBWMMURQhSZKn2nBewfQSvS8BY1owVoGQFJTSe2VZBkKIX6dp+gEkjmNfHjDNKmRlg6auIYT0t2d5hjiKEIUBojBEGAYIgwBhGCKK1orjyLN0e4/Am4o1aLhE27a+hOCoawZabJGVa89LhrKskOcFsiz3ndIM2+0WVVVdGV4lZ5Si19p71XUdrLW+s1ZDmAMaPUDYA6Z5wvvlDafTEfN8wPnyhmEYvafOgrtk58ttw3W/ThIQv06QXqUYs8PhYNDUBRjL0ba19zMIgrvcO6A7cACPphNCr+v1Qr57RdPPyLlFKQxS1oFUClKPsMZgHEfkeX5lSCiSK6ADSh/AbwpcdKZpwnlZ/P4/Y0MoQUkT5CS+Azn6N6BVTgJrB5zeTricz56N1hrO/5vUW3Q2NKP4dZH4/dPi+48T5sni/f2I83LCspyxLG4QM5ZlRte1Po9uuq4/DuPO0B1yLiDlGp2iKPyU21aiU2uXkkGpGkoJb4nL3mOYH0E3Utbouhq7XQO949gWW7y8fPPTC32o1wCvIY6eGD0xdIykFF6OY8M5gxAMVVUiSdJPjf8b5EmyUh3cI+H+krZlnq37W1xk/vfxp4BN2WDgFoop/5qoTkP3wwewr4BuHLNxGH25x6HgGkwfkRelfwC+ws4B/gFXCsyHoBFOiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"init\"\n        title=\"init\"\n        src=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n        srcset=\"/blog/static/8b7bf7989faf13dade451e000d201e37/63868/init.png 250w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/0b533/init.png 500w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这创建了一个node的实例\b并且传递了一系列的参数(v8_thread_pool_size uv_default_loop 后续会对这些参数进行讲解) 最后\b调用StartNodeInstance开启了node的实例,然后顺着这个方法往下走发现node继续这行了LoadEnvironment()和下面这段代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmElEQVQoz22R227iMBRF+YtpCSQhsZ2LE99iQoBQOmj6/5+0RrhSpen0YWmf87C395E3tajx0RHPgbh4/GwJJ8dpPWKmnuXmmM+GMGviMnL7PRFPPs3LanFRU6kyIfuKTVVVtG1H23RIoRC1RIqGRikaJRh0g7WaQXeM4yezM1y8YXEj12Dxg0ZJRbbN2MhacD1feH9/436/8XisfHy8sa5HrutMCCPGarR+8gx/hvZpb5oGY0aC97Rty36/Z1MWJZdz4PHnwvV65BgNMfpkMMYyDCN5XqTXs2xHtt2RZVlit/t3zvP88+TyUFDJA/t8z6+XF16320S227LbZxRlTl7kSYuyoCjLZP5OaqiUYL1HjufAss4s68Tl7jldHPEUUJ1E9QLRVMiuTnslqmT+KXQjhCBOE8F/Yo2jazumEPAuMA6Wvu2wpqfvNc46pJDJXBTFf2zKQ4nqJY1WNMNTJbITiUYLulHSGYVsBVJUHA6HH5t9NazrCucdU5ywzuK8ZTQjve4xbiRMOv2yMZppGlBKfZ371O/8BY6zCINLY+oYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"exec\"\n        title=\"exec\"\n        src=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png\"\n        srcset=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/63868/execNode.png 250w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/0b533/execNode.png 500w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png 1000w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这段代码拿到lib/internal/bootstrap_node.js文件,将它编译解析并且转换成C++的函数最后执行。\b在lib/internal/bootstrap_node.js中其实就是一个匿名函数<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADBElEQVQ4y52U247bNhRF/RuJdaMkSryKulu+jO2ZuE3TvhT9/39ZhRV7ggkCFOjD1qEAYktrn0NuqlLSeY91Gjf1+MOC2020y4hpFKLMEGVCLhMKmRJtt0RRRBzHJEnyXp/aZGVFNR5pTm8080J/ONKeLoy3v+iWmet15HDes5vHVbVxlEXxS7PVUBQlOoyopke3A9Y5pDLodsR7RRsMJvSoZqD2HaZp0br+bpj8MHyab1JRkEqHChO6nZDKYoY9bn5B9Qest4yDwSrJqEqsLEjT7B07juIP+Js0u2ckyCvxyCtdVdSCLE/fJWRGIcWqUufr+33/fd+HPywyQRM62ssXmt2B7uVCd/nC8HYjHK+E3R7fNmscrg2r4d3s+aFcZj8hJzG5GZDtCeVa+tON/vqN+es/hN2Jy3ngeBgYrKaxlih6YiarogfyB8PCT9TDET8vDK9f2f3xN/3lhh8Xltcby+0bflgYx0DXGZwq6VVBWxfMtqbVFZWUjwzTlLyqkc6g+4Cd7h3XqNCRS0VdlTinMKYmBI31nsoFKutRLmCMJkvTH2OTpglCd6jhSDhcafdnwjhx/e3C8brnfB6YDgfm6xvLaWFsG8ZxRvmOQjtqVT/QoydygrQGN/fooLBjS7MfCYcdzRLwTU3fe3TTkusGpSTBVxhZUGcJeZqsgy6EeCCvhhbdt1RWrcMrTUCFkbI2aFXRd47aWIraonS9RqBKiSpyylxQ/GyoQqBZJtzQEE5nXOdY9h437fDzRCYSkmxLJrZE8ZY4jUjyiG30/VxHa92u6GuGubJUQ4scHfUc8NOE7nu0t/hlwc076qYhHF/QbYcd75Gc1uNZGY+oHMY1a3M294fpF9zhjWbsmI8TTdeTiZIsu5+eilzWJGm2dj0vK0Qu17UoJFlekGY5eVE+LgchEGlCsv1EGkfE289sP396INyHePu+jh6I8QMzfqzj+FljNmUpWE49tz9vvFwXTq9XjA/co/jV9fRf2lhl+P10w40H8tpQNQPKtwiR/S/DfwGj6A9fBUsu3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runCode\"\n        title=\"runCode\"\n        src=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png\"\n        srcset=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/63868/runOurJs.png 250w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/0b533/runOurJs.png 500w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png 1000w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png 1058w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里面先做一些挂载的操作(例如给js调用C++代码的挂载), 然后从命令行中获取到文件的名字并且读取文件进行warp,\b这个函数会被上面提到的\b位置去执行,这样node就加载并且执行了传入的server.js文件。</p>\n<h2>http.createServer()如何对网络请求提供服务</h2>\n<p>通过对上面代码的理解,node对网络请求提供\b服务其实是通过lib下的基础模块调用C++模块的代码来实现的,下面跟着http.createServer()来梳理下这个流程\nhttp.createServer(requestListener),它通过调用_http_server.js下的Server(requestListener)方法创建了一个net.Server(继承EventEmitter)并且将传入的构造函数绑定到request事件同时绑定了connection事件<br>\n上面的\b代码部分主要完成了一个server的创建.最后\b调用listen()方法的时候才能监听器对应的\b端口来对外提供服务.server.listen([port],[host],[backlog],[callback])其实调用的是net.Server的listen方法.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 895px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVQoz12Ry27bMAAE/R2NKPH9EEVKtBXbcdQmaeuc+/8/M0WMoKhzWOxtMNjdDcOAdZrDmpn3jTgf8ClRz9+Zt9+4OOK8xTtNLDPT44WyXrDWIISg7/t//ZGdUorRjyST8NphfELFivQTMUVicBjrkL6g4ox0GWstD113A32F7qSSjGGkhILXhtA20vYHt38hn35Sjm8sx43ltFHXjWU58LQUWnQEa2/wO0MpJZ3oEFLQdd/Q0x6/vqFiIZ7fcY9XyvHCus7MS+UwOq7HyuOcyVNGyuEeOAwSFwxln6gtUFogtcq0JlyWSPWAsgPK92gn6GWH8hIdFL4YpPkCFKKntcz79YkfrxdOL6/Mz7/I7YxPE6G02wEhV1I7MS4rxhhE97Fff0vfi8/+NNRakbMnpISJmUEZBu2xccTnijEalzKh7om1obW+s/rf8C9CdsvY254TIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen\"\n        title=\"listen\"\n        src=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n        srcset=\"/blog/static/ed775f0f74eb21887b354475a2e11427/63868/listen.png 250w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/0b533/listen.png 500w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png 895w\"\n        sizes=\"(max-width: 895px) 100vw, 895px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在net.Server的方法中主要对参数进行了判断,例如是否存在IP,port以及是否传出handle,通常的调用方法都是server.listen(port,callback) 这样会在特定的端口监听来自IPV4或者\u001cIPV6的网络请求,在listening事件触发的时候响应callback.下面在继续跟进listen\b方法.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVQoz5WS246bMBRF8xmTcLExBgMGnAAhhHQ6N0XtSJXax/7/j6wKMmmbTKRpH7bOkeWztbyPF3GSUjQDtukpMoN1DbYbKVyLlPIkIRAiJAxDhBBzDeeztz4815BFJCPSWJNaR5xXxIkhLdfEccy6NlQ2odAKZzQm0YRhQBD4BEFwU4tYKkxmyZseWzvc7oBtBxKTka9binYgL2uUUicqGSGEfJOYTc50M+H0nLo9MI4jPx8zjk8D7v5I2Wwpmh1lt8ftH7DdnqzaUEzRbHpM6UhNhu/7l4YqVmQqxeqMwFuxvLtjtVzOF33fI/C9uT+TXBBd0Z0MVYzUCVJF1HWJcyW5tajEEEXyYvhWZufzP0tRiu7lG/3LK8+vXzl+/0G3P6B0Om/3muBa7zKcgq36T1S7zxT9PTqv0HmJzibK9N3AR5oN3eGZ9uELxbohyS2m3mCqDUlWzF/kvwynnKrtSL0dkMLH91Z/yfv9rH8lXURSopOUKcvrL3Aro48MfwFwaTboCCOYlAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen2\"\n        title=\"listen2\"\n        src=\"/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png\"\n        srcset=\"/blog/static/5940d58735192e92131a71aab4c797d5/63868/listen2.png 250w,\n/blog/static/5940d58735192e92131a71aab4c797d5/0b533/listen2.png 500w,\n/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png 1000w,\n/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png 1116w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n继续跟进_listen2\b方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.39999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVRIx41VSXLjRhDkMzwigN53NDYCILhqGStCHvsL/v8z0tHNkUYaUbIOFQAOncjKyspe2bFFt5vxcNjix3nG7ejx748Ju7GB6g6w/R6buyf0pz9RjzvE+YTu8ID++B2+m2CbAX7YwtQtlDFYacURG4uNrXAKBYxREHUL6Tx0cFDWwsSYSzl/eXoPaRQYJyjLNYr1GmVR5FoRTkAVAXUca8NBDINwBMJTiMDALYVwFNwSSEehArtUzWEaCek4yrJCVV1qpbjEME2Iw4iH8w63uxHBaSjJ4LWElhxWCzgtwThDRSoQSnI9vyegsiwvgFpp3B8OmIceT02Fp44iaAmvBHqnEY1CNBLBKFBK88Fr9Qy6Yoxh6CNisLgPJe5qAiP5C2jnNIQQWCeNfh68Vi8MCWUgykO5GkwaEBVQlQWK9Q2KoshAN+sCxRtGFapXzF7XKrWhhYJretimRwgB0jUQNsKkSUuBxipYnabKfzH6gOmKEgLjasT5gGEecTxOmHdbLIctlv2UWx/6DZphA+M9XN1c2H0ESCiFoAxCaFTSg+oArgwEo2i1yAwrQrFOXntuufqflhnjGB/+Rnt8ROxnTG1EbTUUZ0gdEELeHvyMYQLkXKCdT2i2R7h2QPQ2MyuK97b4aMqvAAmkVNifntAvZ0idTC1RVeQNwFfAXgC5EKi3J8TlDN9P8N4h+fMrIOVv7a845xfjfvsD65tvKIp19t9X2Fxjv2KUIe2z8jWUNmDSgnKZQfPfiyL/5DlNytfvV/TNPtSuzq12bcB22WAzthiGGt0QEcZ9zjxTd9ChydnnhyUPz4aYXVCWxatdTpsiDYTrIHwLG9us4RA0pmhgnYWQAnlFqwpJomQzJiQoY0g+Jj9D44WhtBFh94A47THNHU63W5zujjjfHbA7LuiGHmGz5C0ZnIaRAi6ldLysq3EhS3DZFELgXcQy3SF4B+8EfLDQsYcKLZSPIMJCGA/t66vTfxNfydRcubxuyjcgLH3bLP4lcdY5fZ6/Xx++lomrZBnCVQbJEZZspA2qqrzE181Nrgz8icl/aSgMuPYwSYvYIQxb1Jsl69P0G5wff+D8+BeGeXnR6dNNYTpANzPa4wO6/T26w32+Hk07QxubB5EqefSjzXljbMIlmHb5vrCGo20sqPSQrobtRgjtYLsJ2vk3Zr52n1w0ZBI2tDA+QAqWbzbKOLiU4FLkPU+eS9omH1YpzijL4UEIfc+QMwHTLQj9iH7TY7ttcdx3mOcWm01A0zUQ2sJJhsZIaJ+2ZwcdInw3vrPRijAGUU+ol1uM3/9BN24wzNuckcVvN135TrP3OfkfVOAewXaWNUwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"handle\"\n        title=\"handle\"\n        src=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png\"\n        srcset=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/63868/handle.png 250w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/0b533/handle.png 500w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png 1000w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png 1171w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在这个方法中主要创建了一个server的handle并且绑定在之前传入的port并且在这个handle上添加\bonconnection的监听函数并且在nextTick\b的时候触发listening事件.createServerHandle其实做的是调用的\bC++层的接口,创建了一个TCP\b实例,并且将它监听到IPV4或者IPV6端口。\bnode处理网络请求实际是通过触发这个handle的connection事件实现的\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 944px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVQ4y4WUWXMaRxSF+RMJzAKzz3TPwizAsAmQwUJCyJJdseUtdvkhVXlO5Q/kn3+paWwsx0J5uNXT25nb59x7Wp7M8fM5opxyv+nz+SLm41rychkjspJAxKT1GcXZhny+Js1LbMui2+3S6/V+ipbt+vj5jHJ1yWDxjHxYUy4uyQZjoqzAdhx10LJsepb19WKXbrf3OKBlOziBJIhT/CAgSjLivERkBSKvsG1bZfPfaEC/gTzMtuU4NotlxbCQ3BVdPtY93g90bssevueqw5b1eDYP4xtoy7EdfMcnjBNCz8XtGThNWCam2UXXDTTNUGMTpqFjdrvoholhNmfMI1gzthzbJkkrqsWaejIgTSRJ6BN4LkKGlGXCYJhRlTF5kREmfbVXyIC+CIki8WOGPauHlBnTasGwLAhDHxl4+K6jvpMkIs2EGmUs8EWM6zjqp8L38Hwf6yiW4tBRB0xNw9B0tE4brdNB1zronQ7tdodOu1nT0Npt9Pavak/TNDRdV9+GutvB0DVaruMSeRGiUTavSAZT4mqMKGpEPiQvCpJyRJhkiHxAOpohqxrRzJMMWQxJBmOS0Yy4rGnZlo2Ufepn14zW1ww3N1TTGfPVjEE9URx5YROReq4vErwoxvUDvCYieViXqVpvWbaFCGPG/Slp3MdyXVV7nmth25ZS0TQMTNM4jI3Kam5+31Nrh1B16Ng9Ou1f0LX2YUM/8Glq+skWOxUt23FxZIG7eYN79QlPpATZCHdQENQVURQdfmIadE3zWCIne7npAlGMGN68J13tyGdrytWO6vme/OwcP4xw/BA3iHA8/wHQCcBe1yRIcsbbOxWT3W/k0xX9yYrybM3g2U6tTa5fUy0vVM09RUOrqcGqnij5D2oluI2qkUCkfcK0IEgygjhTih6ebP5kCkfARvr9/SdW272qv3K5JZAJ9WzB/v4zxWiKrCaq/oJQ4MYVfiiOfD7CoaV8zrLt76NyGBvb9bBth8biLMf56omHc6cN1nGUkfqRVJ3QdEfzfCljGn4f88KH7vIToB+E3P/5F7e//0F1fqVE6A/H1OsdIklVuXx7xY+XT2Toeh7bV+9Ybm8IkgJRjnE9n7A/xAslhq5jGIYyCl3Xnszu6NhVFVMWUnlfWcTUoz5lGTOblQwGKePJiMXFnsniHOsJsCPg9W7O7e2SzWbMze2KF7cr9i+WvH235XI74uWbO778/Q83r99jW/8D2IiyuTxne7Xg8nLOcl6xez5lvRxxdTHh+e6CVx/ecffhC9uX98g4VryeBGxEabhLs4Q0FUjfpR/5ZKGPb/eo5muW+zcImXzlsPckh/8C/oPY8Ao+dPAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"connection\"\n        title=\"connection\"\n        src=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n        srcset=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/63868/connection.png 250w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/0b533/connection.png 500w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png 944w\"\n        sizes=\"(max-width: 944px) 100vw, 944px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上面的代码中,底层的C++代码会在connetion的时候传入clientHandle,然后node会创建一个\bSocket实例并且在通过connection事件将这个Socket实例传入对应的回调函数。这样就用回到了lib/_http_server.js中对connection的监听函数中<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fed65a33502990495432004fc0039796/d0143/request.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB70lEQVQ4y32S2XLjIBRE5zOSCIRYBUKLLTlWvMUz8///dKakJK5yypmHBl5oDt33l1KKqqqwlaHdvDIc35nngctx5Hrccn7bMvcNb0NmHrfM24GubYlNpI41QgjKsrzp183QWjbDzOu0p8mB2lpab+mCo/UaYwyu6fBNR4gJURRIKVeTZf863wwX9bsTp8uZy2XkvBCeJoa+RbmAdh7rHLIoEKK4o/oyuzM0RuNyT+47NkOirQO7XBOMJuQel1rq3FGWCik/qYS8o7wZaq0Z8sAubdDG8VIIlFYIpVC6opQCXUq0FJhSrqqUWmNYYB4SLqX004Hp8ofjYcv7aeLvaeT3ceS4aXnfZg7jwDxNzLuJ9rMYt8Tw0NBatv3MbtyTkiM6y5ACXe3J3hKtRluPjRmXMsa6teGHX/4qpR0PnK8nrtdXDseRfuqxwfNcFBRLXkKs7Yri5W5cfiQ0dSJ3DW1OVOo+m0f6TrcaLsuSQwo1pZA8PT3z/FKsxQgpP2hWFcj1kvzvA6uh955pujDv9/RdJHvHNgWcNR+D3HTUKVN+DvBPuhF65/ExE2JcmwvWkGuLXWYzRlwd8XWNUiXlN6nqQzfCJcMUEmPosa5BNxPaGnSsMKHCpWVXuEZjo8bWGpfMeja+wrcWnw2VUavhP+s9cWr9hXq5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"request\"\n        title=\"request\"\n        src=\"/blog/static/fed65a33502990495432004fc0039796/00d43/request.png\"\n        srcset=\"/blog/static/fed65a33502990495432004fc0039796/63868/request.png 250w,\n/blog/static/fed65a33502990495432004fc0039796/0b533/request.png 500w,\n/blog/static/fed65a33502990495432004fc0039796/00d43/request.png 1000w,\n/blog/static/fed65a33502990495432004fc0039796/d0143/request.png 1025w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个方法主要对之前创建的\bSocket进行\b一些解析处理和方法绑定最后将生成的req,res通过request\b事件传入到回调函数中.这样就回到了http.createServer(requsestListener)中来完成特定业务的处理</p>\n<h2>总结</h2>\n<p>从以上的两部分，主要从两方面来整理了下node启动和执行服务代码,\b\bnode如何处理网络请求，但是node中还有很多有意思的东西还没有说清和弄明白.例如backlog 事件循环 v8_thread_pool_size(node的线程池)等等.\b</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null},"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null},{"id":"677560ca-a2b0-53d5-a873-d982f8f5b83e","html":"<h2>变量</h2>\n<p>在javascript中声明变量有下面的几种方式: var  / const(let)  下面来梳理下这几种声明变量方式的区别。</p>\n<table>\n<thead>\n<tr>\n<th>声明\b方式</th>\n<th>声明提升</th>\n<th>作用域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>let/const</td>\n<td>Temporal Dead Zone</td>\n<td>块级作用域</td>\n</tr>\n<tr>\n<td>var</td>\n<td>提升</td>\n<td>函数作用域, 进入到声明该变量的函数作用域分配空间并且初始化值为undefined,执行到赋值语句后进行赋值</td>\n</tr>\n</tbody>\n</table>\n<h3>var</h3>\n<p>在进入声明该变量的函数作用域的时候,会为其分配空间并且初始化值为undefined,在执行到对var赋值的语句的时候会对该变量进行赋值(如果没有赋值就是\bundefined)</p>\n<h3>let</h3>\n<p>在进入声明该变量的块级作用\b域的时候,会为其\b分配空间\b此时这个变量是未初始化的(引用一个未初始化的变量会导致引用\b错误),到达\b对该变量的赋值语句的时候\b进行变量的赋值(否则为undefined)。</p>\n<h3>const</h3>\n<p>跟let的行为类似,但是需要进行初始化的值(\b不允许修改指向)</p>\n<p>下面是一些简单的例子来帮助理解上面的点</p>\n<pre><code>let tmp = true;\nif (true) {\n    // 引用未初始化的变量引用错误\n    //  console.log(tmp); // ReferenceError\n\n    let tmp; // 初始化为undefined\n    console.log(tmp); // undefined\n\n    tmp = 123;\n    console.log(tmp); // 123\n}\nconsole.log(tmp);// true\n\nif (true) {\n  const func = function () {\n    console.log(myVar); // 3\n  };\n  let myVar = 3; \n  func();  \n}\n</code></pre>\n<p>在循环中var和let/const的表现</p>\n<pre><code>const arr = [];\nfor (var i=0; i &#x3C; 3; i++) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [3,3,3]  每个变量都指向一个绑定i 所以都为3\n\nconst arr = [];\nfor (var i of [0, 1, 2]) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [2,2,2]\n\nconst arr = [];\nfor (let i=0; i &#x3C; 3; i++) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [0,1,2]   每次为let创建一个当前值的绑定 所以为[0,1,2]\n\nconst arr = [];\nfor (const i of [0, 1, 2]) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [0,1,2]\n</code></pre>\n<h3>var和let声明变量对参数的影响</h3>\n<table>\n<thead>\n<tr>\n<th>声明方式</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>var</td>\n<td>声明的变量会覆盖函数的参数</td>\n</tr>\n<tr>\n<td>let/const</td>\n<td>重复定义</td>\n</tr>\n</tbody>\n</table>\n<h4>理解默认参数的行为</h4>\n<p>默认参数可以理解成let的行为  默认参数的访问范围是与函数体内部相隔离开的,只能访问到外部的变量</p>\n<pre><code>// OK: `y` accesses `x` after it has been declared\nfunction foo(x=1, y=x) {\n    return [x, y];\n}\nfoo(); // [1,1]\n\n// 在初始化x=y的时候 y处于TDZ 出现引用错误\nfunction bar(x=y, y=2) {\n    return [x, y];\n}\nbar(); // ReferenceError\n\n\nconst foo = 'outer';\nfunction bar(func = x => foo) {\n    const foo = 'inner';\n    console.log(func()); // outer\n}\nbar();  //  如果在这个例子的外部不存在foo 会引用错误\n\nfunction noParameter() {\n    throw new Error('no parameter');\n}\nfunction test(a = noParameter()) {\n    return a;\n}  // 使用默认参数来做参数的校验\n</code></pre>\n<h2>解构</h2>\n<p>解构是跟变量的操作关联到一起的,主要用于\b变量的声明,赋值,函数参数的定义\b以及提供默认\b值。对象解构的时候,会把右边的操作值转化成对象。数组解构的时候相当于调用数组的迭代器实现</p>\n<pre><code>const { length } = 'aaa';\nconsole.log(length) // 3\nconst [x, y] = new Set([1,2]);\nconsole.log(x,y); // 1 2  \n</code></pre>\n<p>在对数组进行解构的时候,还可以通过越过某些数组项或者\b\b通过剩余参数获取数组后面的值</p>\n<pre><code>const [,, x, y] = ['a', 'b', 'c', 'd']; // x = 'c'; y = 'd'\nconst [x,...y] = [1,2,3] // x 1 y [2,3]\n\nconst num = [1,2,3];\nconst b = [];\nb.push(...num); // 扩展符\n</code></pre>\n<p>也可以通过\b解构来进行赋值(解构的声明和赋值不能同步进行并且解构的赋值需要在外边包上括号)</p>\n<pre><code>const arr = [];\n({ bar: arr[0] } = { bar: true });\nconsole.log(arr); // [true]  \n</code></pre>\n<h2>\bES6 模块</h2>\n<p>ES6模块本质上是一种规定静态化的加载和导出代码的方式,通过编译时加载使基于代码的静态分析成为可能(webapck中的tree Shaking).CommonJs的模块(运行时加载)就是对象.</p>\n<h3>ES6模块的特点和CommonJs的对比</h3>\n<p>不能动态的引入并且引入是有提升的</p>\n<pre><code>// 不能动态的\b引入\nif (Math.random()) {\n  import 'foo'; // SyntaxError\n}  \n{\n  import 'foo'; // SyntaxError\n}\n// 引入的提升\nfoo();\nimport { foo } from 'my_module';\n</code></pre>\n<p>引入是只读的引用</p>\n<pre><code>// a.js \nexport let a = 100;\nexport const count = () => {\n  a++;\n}\n// b.js\nimport { a, count } from './a.js'\nconsole.log(a); // 100\ncount();\nconsole.log(a); // 101\na = 100; // error  a是只读的\n\n// CommonJs是值的\b复制,\b相当于修改一个值.\n</code></pre>\n<p>ES6的模块可以导出单个值,CommonJS必须导出一个对象.ES6的引入是只读的引用,CommonJs的引入对于基本类型是值的复制,复杂类型是引用.</p>\n<pre><code>// a.js  CommonJS值拷贝的例子\nlet a = 100;\nmodule.exports = { \n  a,\n  count: () => { a++ },\n};\n// b.js\nlet { a, count } = require('./a.js')\nconsole.log(a); //100\ncount();\nconsole.log(a); //100\na++; // 相当于对本模块的a变量进行了赋值\nconsole.log(a);  // 101\nconst b = require('./a.js'); // 会使用第一次require的结果\nconsole.log(b.a);  // 100\n\n// a.js  CommonJs 引用的例子\nlet a = {\n  name: 'haha',\n};\nmodule.exports = { \n  a,\n  setStr: (str) => { a.name = str; },\n};\n// b.js  \nlet { a, setStr } = require('./a.js')\nconsole.log(a); // { name: 'haha' }\nsetStr('ss');\nconsole.log(a); // { name: 'ss' }\na.name = 100;\nconsole.log(a);  // { name: 100 }\nconst b = require('./a.js');  // 仍然使用的是第一次的缓存结果 但是由于引用的设置 导致原来的值被修改了\nconsole.log(b);  // { a: { name: 100 }, setStr: function() {} }\n</code></pre>\n<p>CommonJs循环加载时\b,属于加载时执行.即脚本代码在require的时候,就会全部执行.一旦出现某个模块被循环加载,就只输出已经执行的部分,还未执行的部分不会输出.ES6模块属于动态只读引用. CommonJs在引用同一个模块的时候存在会使用第一次的缓存.</p>\n<pre><code>// b.js\nexports.done = false\nlet a = require('./a.js')\nconsole.log('b.js-1', a.done)\nexports.done = true\nconsole.log('b.js-2', '执行完毕')\n// a.js\nexports.done = false\nlet b = require('./b.js')\nconsole.log('a.js-1', b.done)\nexports.done = true\nconsole.log('a.js-2', '执行完毕')\n// c.js\nlet a = require('./a.js')\nlet b = require('./b.js')\nconsole.log('c.js-1', '执行完毕', a.done, b.done)\n\n输出:\nnode c.js\nb.js-1 false\nb.js-2 执行完毕\na.js-1 true\na.js-2 执行完毕\nc.js-1 执行完毕 true true\n\n// ES6 循环依赖 a.js\nimport { bar } from './b.js';\nbar(); // 'bar'\nexport function foo() {\n    console.log('foo');\n}\nbar(); // 'bar'\n\n// b.js\nimport {foo} from './a.js'; \nexport function bar() {\n   console.log('bar');\n}\n\n// CommonJs循环依赖  a.js\nconst { bar } = require('./b.js');\nmodule.exports = {\n  test: 1,\n}\n// b.js\nconst { test } = require('./a.js')\nconsole.log(test); // undefined\n</code></pre>\n<h3>动态引入</h3>\n<p>可以通过按需引入模块来优化首屏代体积</p>\n<pre><code>    import(\"module\").then(module => {\n        module.default();\n        module.namedExport();\n    });\n\n    // Or with async/await\n    (async () => {\n        const module = await import(\"module\");\n        module.default();\n        module.namedExport();\n    })();\n</code></pre>\n<h2>iterator(迭代器)</h2>\n<p>在ES6中的可以使用数组解构,for of等语句遍历数组、Map、Set是因为在ES6中默认为这些结构创建了[Symbol.iterator]方法.通过这个方法的调用返回一个可以遍历该数据结构的对象(iterator),通过这个对象来遍历数据结构的属性.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 883px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAy0lEQVQY05VQy4qEQAyc//8eb3rwrBcVRXwrKr4QFRVBxBoqyy64zGUCRSfV6UqnXgAwjiMcx0HTNCxx3/dHMKqqgud5WNf10Xtdl5wvksMwwDRN2LaNMAwRBAGSJEHf9/gfZVnCsiwRzrIMaZoK4jjGtm0/gl3XYZ5nHMch5L7vaNsW53liWRZ5QJ61YRjQdR1RFAnv+z7quv77rQiSVBRFGjVNg6qqcF1XBAgO4koEbaFQnucoikJyDn0I0g9ech2C+TRN+CZ+PX4DVbt5trPU9noAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iterator\"\n        title=\"iterator\"\n        src=\"/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png\"\n        srcset=\"/blog/static/0bcb228576a7ca1967151733aba51136/63868/iterator.png 250w,\n/blog/static/0bcb228576a7ca1967151733aba51136/0b533/iterator.png 500w,\n/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png 883w\"\n        sizes=\"(max-width: 883px) 100vw, 883px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>const iterable = {\n  [Symbol.iterator]() {\n      let step = 0;\n      const iterator = {\n          // iterators that are iterable\n          [Symbol.iterator]() {\n            return this;\n          }\n          next() {\n              if (step &#x3C;= 2) { step++;}\n              switch (step) {\n                  case 1:\n                      return { value: 'hello', done: false };\n                  case 2:\n                      return { value: 'world', done: false };\n                  default:\n                      // done\b表示是否到尾\n                      return { value: undefined, done: true };\n              }\n          }\n      };\n      return iterator;\n  }\n};\nconst iterator = iterable[Symbol.iterator]();\niterator.next();  // {  done: false, value: 'hello' }\niterator === iterator[Symbol.iterator]() // true\niterator.next();  // { done: false, value: 'world' }\n</code></pre>\n<h2>generator</h2>\n<p>生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。</p>\n<h3>generator方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Generator.prototype.next(value)</td>\n<td>返回一个{ done: true/false, value: 执行结果 }的对象,value是当次执行的入参</td>\n</tr>\n<tr>\n<td>Generator.prototype.return(value)</td>\n<td>返回给定的value值并结束生成器</td>\n</tr>\n<tr>\n<td>Generator.prototype.throw(exception)</td>\n<td>向生成器抛出异常，并恢复生成器的执行</td>\n</tr>\n</tbody>\n</table>\n<p>生成器函数有如下特性:</p>\n<ol>\n<li>\n<p>当一个generator函数被调用，函数体内代码并不立即执行。它返回一个遵循了迭代器协议的迭代器对象:它有next方法.</p>\n</li>\n<li>\n<p>执行生成器函数体内代码的唯一方法就是在返回的迭代器对象上调用next方法.每一次调用next，函数体内代码就执行到一个yield表达式处，这个表达式的右值赋值给迭代器。</p>\n</li>\n<li>\n<p>next方法也可以接受参数，使用参数调用将会用参数值替换上一条yield表达式的左值，然后执行并返回当前yield表达式的右值</p>\n<p>function* func() {\nconst y = yield 1;\nyield 2 + y;</p>\n<p>}\nconst generator = func();\ngenerator.next() // { value: 1, done: false }\ngenerator.next(100) // { value: 102, done: false }</p>\n</li>\n</ol>\n<h2>async function</h2>\n<p>async function是ES7提出的对异步调用的一种解决方案.通常可以通过下面的方式生成async function</p>\n<pre><code>async function foo() {\n}\nconst a = async function() {}\nlet obj = { async foo() { return 1; }}\nconst b = async () => { return 1 }\n</code></pre>\n<p>async函数执行结果返回<strong>promise</strong>.在async函数体内可以使用await来等待一个promise的状态变成settled(fulfilled or rejected)</p>\n<pre><code>async function foo() {\n  console.log('async func');\n  // await已经是一个微任务  \n  const ret = await 1\n  // const ret = await Promise.resove(1)\n  return ret;\n}\nfoo().then(value => {\n  console.log(value)\n})\nconsole.log('main')\n// 上面代码的输出是  async func  main 1\n</code></pre>\n<h3>async function实现原理</h3>\n<p>async function可以通过generator + promise来模拟。</p>\n<pre><code>function spawn(genF) {\n  return new Promise((resolve, reject) => {\n    const itr = genF()\n    function step(nextFn) {\n        let next;\n        try {\n            next = nextFn()\n        } catch(e) {\n            return reject(e)\n        }\n        if(next.done) {\n            return resolve(next.value)\n        }\n        Promise.resolve(next.value).then(function(v) {\n            step(function(){ return itr.next(v) });\n        }, function(v) {\n            step(function() { return itr.throw(v); })\n        })\n    }\n    step(function() { return itr.next(undefined); })\n  })\n}\n</code></pre>\n<h2>Reflect</h2>\n<p>Reflect是一个内置对象，提供了一些方法来完成javascript的操作。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Reflect.apply(target, thisArg, args )</td>\n<td>用户给函数绑定this并执行</td>\n</tr>\n<tr>\n<td>Reflect.get(target, name, receiver)</td>\n<td>返回target上的name属性，没有undefined，如果name在target上设置了getter，则读取函数的this绑定receiver</td>\n</tr>\n<tr>\n<td>Reflect.set(target, name, value, receiver)</td>\n<td>设置target对象的name属性的值为value, 如果name属性有setter函数，则setter函数的this绑定receiver</td>\n</tr>\n<tr>\n<td>Reflect.has(obj,name)</td>\n<td>判断对象上是否有对应的属性 相当于 name in obj</td>\n</tr>\n<tr>\n<td>Reflect.deleteProperty(obj,name)</td>\n<td>删除对象的属性 相当于 delete obj[name]</td>\n</tr>\n<tr>\n<td>Reflect.construct(target, args)</td>\n<td>target是对象的构造函数，args是参数数组，相当于new target(...args)</td>\n</tr>\n<tr>\n<td>Reflect.getPrototypeOf(obj)</td>\n<td>返回对象的__proto__属性, 相当于Object.getPrototypeof(obj)</td>\n</tr>\n<tr>\n<td>Reflect.setPrototypeOf(obj,newProto)</td>\n<td>设置对象的原型， 相当于Object.setPrototypeOf(obj, newProto)</td>\n</tr>\n<tr>\n<td>Reflect.defineProperty(target,propertyKey, attributes)</td>\n<td>相当于Object.defineProperty, 定义对象的属性</td>\n</tr>\n</tbody>\n</table>\n<pre><code>const myObject = {\n    foo: 1,\n    get name() {\n        return this.name\n    }\n}\nconst test = {\n    name: 'haha'\n}\nReflect.get(myObject, 'name', test) // haha \n</code></pre>\n<h2>Set和Map</h2>\n<h3>Set</h3>\n<p>Set对象是值的集合，可以按照拆入的顺序迭代它的元素且Set中的元素是唯一的。</p>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set.prototype.size</td>\n<td>返回Set对象中的值的个数</td>\n</tr>\n<tr>\n<td>Set.prototype.add(value)</td>\n<td>在set对象尾部添加一个元素，<strong>返回该set对象</strong></td>\n</tr>\n<tr>\n<td>Set.prototype.clear()</td>\n<td>移除set对象内的所有元素</td>\n</tr>\n<tr>\n<td>Set.prototype.delete(value)</td>\n<td>移除set中与这个值相等的元素</td>\n</tr>\n<tr>\n<td>Set.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在set中</td>\n</tr>\n<tr>\n<td>Set.prototype.keys()</td>\n<td>返回键值的遍历器 <strong>遍历顺序是插入顺序</strong></td>\n</tr>\n<tr>\n<td>Set.prototype.values()</td>\n<td>返回键值的遍历器</td>\n</tr>\n<tr>\n<td>Set.prototype.entries()</td>\n<td>返回键值对的遍历器</td>\n</tr>\n<tr>\n<td>Set.prototype.forEach()</td>\n<td>使用回调函数遍历每个成员</td>\n</tr>\n</tbody>\n</table>\n<h3>WeakSet</h3>\n<p>WeakSet与Set类似</p>\n<ol>\n<li>WeakSet的成员只能是对象不能是其他类型的值。</li>\n<li>WeakSet对对象的引用是弱引用,不能阻止垃圾回收机制。</li>\n<li>WeakSet不支持遍历</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WeakSet.prototype.add(value)</td>\n<td>在WeakSet对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>\n</tr>\n<tr>\n<td>WeakSet.prototype.delete(value)</td>\n<td>移除WeakSet对象内的所有元素</td>\n</tr>\n<tr>\n<td>WeakSet.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在WeakSet中</td>\n</tr>\n</tbody>\n</table>\n<h3>Map</h3>\n<p>Map对象可以保存键值对并且能够记住键的原始插入顺序，任何值(对象或者原始值)都可以作为Map的一个键或者值。在频繁删除键值或者对键值对的顺序有要求的场景，使用Map对象更加合适。</p>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map(new Map(args))</td>\n<td>构造函数, 具有Iterator接口且每个成员都是一个双元素数组的数据结构可以作为Map的构造函数参数</td>\n</tr>\n<tr>\n<td>Map.prototype.size</td>\n<td>返回Map对象中的值的个数</td>\n</tr>\n<tr>\n<td>Map.prototype.set(key,value)</td>\n<td>设置键名对应的键值为value(存在键名则更新键值), <strong>返回当前的Map对象</strong></td>\n</tr>\n<tr>\n<td>Map.prototype.get(key)</td>\n<td>读取对应key的键值，没有key返回undefined</td>\n</tr>\n<tr>\n<td>Map.prototype.has(key)</td>\n<td>返回布尔值，判断该键是否存在Map中</td>\n</tr>\n<tr>\n<td>Map.prototype.delete(key)</td>\n<td>如果Map对象中存在该元素，则移除它并返回true否则返回false</td>\n</tr>\n<tr>\n<td>Map.prototype.clear()</td>\n<td>移除Map对象内的所有元素</td>\n</tr>\n<tr>\n<td>Map.prototype.keys()</td>\n<td>返回键名的遍历器<strong>遍历顺序是插入顺序</strong></td>\n</tr>\n<tr>\n<td>Map.prototype.values()</td>\n<td>返回键值的遍历器</td>\n</tr>\n<tr>\n<td>Map.prototype.entries()</td>\n<td>返回键值对的遍历器</td>\n</tr>\n<tr>\n<td>Map.prototype.forEach()</td>\n<td>使用回调函数遍历每个成员</td>\n</tr>\n</tbody>\n</table>\n<h3>WeakMap</h3>\n<p>WeakMap与Map类似。</p>\n<ol>\n<li>WeakMap的键值只能是对象不能是其他类型的值。</li>\n<li>WeakMap对对象的引用是弱引用,不能阻止垃圾回收机制。</li>\n<li>WeakMap不支持遍历</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WeakMap.prototype.set(key,value)</td>\n<td>在WeakMap对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>\n</tr>\n<tr>\n<td>WeakMap.prototype.delete(value)</td>\n<td>移除WeakMap对象内的所有元素</td>\n</tr>\n<tr>\n<td>WeakMap.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在WeakMap中</td>\n</tr>\n<tr>\n<td>WeakMap.prototype.get(key)</td>\n<td>读取对应key的键值，没有key返回undefined</td>\n</tr>\n</tbody>\n</table>\n<h2>参考</h2>\n<p><a href=\"http://exploringjs.com/es2016-es2017/ch_async-functions.html\">Async functions</a>\n<a href=\"https://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">async函数的实现原理</a></p>","fields":{"readingTime":{"text":"17 min read"}},"frontmatter":{"title":"ES6基础语法","date":"2018-03-19","tags":"JavaScript","path":"/es6-basic","top":null,"summary":null},"title":"ES6基础语法","date":"2018-03-19","tags":"JavaScript","path":"/es6-basic","top":null,"summary":null},{"id":"7acf6bef-d171-5dc7-9fe9-3df0a659dc8d","html":"<h2>简介</h2>\n<p>运输层提供了运行在不同主机上的应用进程之间的逻辑通信，应用程序通过逻辑通信，运行在不同进程的主机好像直连一样(例如输出一个URI 就能找到对应主机的资源)。 运输层是直接与应用层打交道的网络层级。通过对运输层协议(TCP/UDP)的了解和传输机制的学习，能更好的帮助我们\b理解应用程序的行为。在阅读计算机网络自顶向下方法的运输层时整理了如下的笔记。</p>\n<h2>运输层基础</h2>\n<p>运输层通过多路复用与多路分解来实现将主机间的数据交付服务扩展成主机的进程间的交付服务。它对应用层提供了两种服务类型:</p>\n<ul>\n<li>基于连接的，可靠地服务(TCP)</li>\n<li>不基于连接的，不可靠的服务(UDP)</li>\n</ul>\n<h2>TCP</h2>\n<h3>TCP报文段结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 454px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABu0lEQVQoz22R646rIBRGff9XapM2fYEaTZpevBQUBKEgKBdltCdTck4mJ7N+7nxkf6ydVFU1jqMxZpqm8S9KqWEYmqa53+9SSmttnP/LTNNEKU0opeu6lmUJIeSc0w9a623blFKc82EYiqKglBJCMMaEEEqpEMJam3DOvfcIoThijAkh2rYFAFBKMcaU0izLuq4TQvR9zxjjnAshnHPfm733zjlrrfswjiMAoKoqAEBZlk3T1HVNCNFaG2NizHxI5AdrbQghtoAQXq9XQkhd1xDC2LmqKozxsixxk/d+nufkcrns9/s8zzHGp9Ppdrulabrb7Y7H4+FwiL2893VdAwAej0fbttZapZTWOun7PoTgnBNCZFn2fD4BAEVRCCGmadJaT9N0Pp/zPG+a5vF4RBfbti3LkjDGrLXxVIQQKeXr9YraIIRRct/3SikpZfxRNMIY+348z3PUMM9zLBlCkFKmaRqdjeMYM8MwMMaklAghKWUSpdsfGGO898aYuq4551LKZVmi5+jJex/NJV+/Mc8zQghCiBACAGit13UNP1iWJYSQvH9jXVfOedd1fd9jjJ1z7/d727b/Yn8AH0+bq1J7Cv0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP\"\n        title=\"TCP\"\n        src=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n        srcset=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/63868/fragment.png 250w,\n/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png 454w\"\n        sizes=\"(max-width: 454px) 100vw, 454px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>端口和目的端口用于TCP数据的\b多路复用和多路分解</li>\n<li>序号和确认号用于\b实现可靠数据传输</li>\n<li>TCP的连接状态保存在端系统中，这种链接的状态对网络层是不可见的。网络层只看到的数据报</li>\n<li>确认号可以理解成发送方期待接受方发送的下一段序列的初始字节编号。例如当A收到B发送的数据是500-600（不包括600）并且在累计确认下(前500的数据都得到确认) B在发送的报文中确认号就是600,A接收到报文后就会发送600之后的数据给B</li>\n<li>接收窗口用于实现拥塞控制(TCP慢启动)</li>\n<li>在6个标志字段中 ACK用于确认上一个已成功报文的确认 RST，SYN,FIN 用于连接的建立和拆除 PSH被设置的时候标志接受方应立即将数据交付给上层</li>\n</ul>\n<h3>流量控制</h3>\n<p>流量控制是发送方与接收方的一种速度匹配服务。在发送方与接收方都维持一个接收\b窗口的变量。假设该变量的值为rwnd，发送方必须保证\bLastByteSent - LastByteAcked &#x3C;= rwnd.\b假设接收方的缓存空间是RcvBuffer,必须保证 rwnd = RcvBuffer - [LastByteRcvd - LastByteRead].该窗口字段在接收端发送报文的时候会写到\bTCP报文的窗口字段。\b当接收端的窗口是0的时候，\b发送方接收到对应的\b报文将发送只有一个字节的数据报文段，此时接收端将接收这个报文并且清空自己的缓存空间(数据传送给上层)并且回复一个\brwnd大于0的报文段</p>\n<h3>TCP连接的建立与\b中断</h3>\n<h4>TCP连接的建立</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPElEQVQ4y21Ty07jMBSN+CF2iK/gQ/gdliyQumEkxKpUHakwmpRFxDNNUlJFQigPMrRJWgfHaRLH8R3BRaYwc1b29X2dc681AJBSAsBqtTo8PDw4OCCEKOMmbm9vj46OTNNUFk1KKYRo2xYAtre3d3Z2AKBtW7mBrusAIMuy3d3d8XisHDSsgM/7+/t7e3tFUaBFAVPbtr21taXrOgAIId4qA0BZloQQzvl8PnccJ89zQsi/bQshxuPx6+urIvUW7Pu+bduEEMbYYrFwHKff75v397913TTNNE2rqsLWOOcq11vbm7mbpqmqCs+r5fLx8XHqur90fTgcep6XJEkcx0j4g7MiJqWs67osSyVBJ2WZ56HjZL4/dd2zfv/6+poxZlnWdDrlnGuoR9u2Xdet12tKaVVVrCiuLi6GvV6/17MNw314iOM/nHNKKYqPxTQhBM4DJUmSZDQaDQeDn6enV4bhh2FZfxJWan0EA0CapsvlkjFGKR2NRufn51EUBVGE/HERmqbhnOd5jhaEhrtFCFmv13meB0Hw9PQ0dZwfx8eXl5e2bSdJ0jQNeuMKqCl+UZtzXtc1Tn4+nxuGMRgMTk5OdF2PojBN06Kgm/6a4oCjQrVV7rqugyC4ubmxLOvu7g5H9SnYt8rYIb5hRrUCcRy/vLxg8AfnzTUsy5JS+u1LoSsesiz7D2e8h2HoeR7OTH4FAFBKXddtmka843vbQghK6Ww2WywWz8/Pvu9PJpM4jr13WJbFGNv8sH8BdCuyVQ0e+JcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"三次握手\"\n        title=\"三次握手\"\n        src=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n        srcset=\"/blog/static/450ef929b273efe5395a856db3581d99/63868/connect.png 250w,\n/blog/static/450ef929b273efe5395a856db3581d99/0b533/connect.png 500w,\n/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>客户端在向服务端请求连接的时候，会向服务端发送\b一个SYN报文段。会随机选取一个client_isn\b作为序号字段放置在该SYN报文中。</li>\n<li>服务端在收到该报文后，会发送给客户端一个报文并且设置TCP的缓存和变量。该报文的ack字段是client_isn + 1,序号字段为server_isn,SYN比特为设置成1.代表当前服务器已经准备接收数据</li>\n<li>\b客户端在接收服务端的确认报文后会创建TCP的缓存和变量并且向服务端继续发送报文(此时的报文可以携带上\b上层的数据),其中ack字段是server_isn + 1,序号字段是client_isn + 1,SYN字段\b为0(此后的报文中SYN字段都为0).至此TCP连接建立成功。(三次握手是为了确定双方的序号)</li>\n</ol>\n<h4>TCP连接的中断</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACnUlEQVRIx4WVS2pyQRCF7+qyCFcgCK7AUYYhOnfgyEAgDl2BRIMKOjAPiCGaGI3vtyY+ovXzNZS0915/G5qr3V2nTlWdrnZERLbbrfz+/pr59/cn+/2e5cPXHqzp+m63k9lsJtPpVJbLpVl32Oj1elKr1eTj4+PI0A/M/gL49PQkLy8v0m63zZoDO4Cen5+lXC7L29ubrFYrDxs/wE6nI4+Pj5LP58232+2Ks9lsjIdMJiORSEQuLy8PTGHgN3Qd57lcTq6uriQcDsvd3Z04xWJREomExGIxSaVSZhK+bahMbcbNZlOSyaREo1G5vr6Wm5sbSafT4tze3kogEJBgMCj39/fy8PAgk8nEF4ipTkqlkoRCIbm4uJB4PC7ZbNakzcG4UCiYSg2HQ5nP53JquEFRRaVSOVpzKMB6vTZ/+v2+DAYDc3CxWJgvB1utlkm4eyAVdzSOfWA0GhkQNigWzgCGPY5+fn7MRBmcYQ/JHQHaiQYQA/cAkCIgYvYBYb6+vkqj0TgU0AM4Ho8PtwV2ypCQv7+/TX4JU3WKA1+GmlDU/vn5aUAxVPBTgzPk3Rb7EUPyBKNzVdbzhI8y7H0PIF7d1w4VEK4NCHNyXq/XTTo0DY5NlxyqhDQVGCIZDCkOwOSOdCCZ9/d3c1W1mI6CIRM2McQIcK2qtifN59mQVRp0DMIGiAkI4NxtioX+7IYBS9+iaCtCa3ZVMYY5QBQLcDtknGPnkQ2Di03IAJxqsLqOA5XZ19eXPyC5Y9pF8Zv2oLKaQw8gOaT8hOLuzu6urf/dwj4ChBkh24CnGJ4FBIRK8jb87z1xA9qyOWpfhFqtVs0L5s4hldZO4n6sqLz2SU/IDLqvPlCnQraZclP0/fF0G76wRMDnAN2ysn//Aw2QzK7dGbfNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP close\"\n        title=\"TCP close\"\n        src=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n        srcset=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/63868/close.png 250w,\n/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n(发送方和接受方都可以中断TCP连接)</p>\n<ol>\n<li>\b\b终止方向另一端发送一个TCP报文，其FIN比特位被\b设置成1</li>\n<li>接收方回复一个ACK报文并且发送一个FIN报文</li>\n<li>终止端回复一个ACK报文，至此两方为了维持TCP连接的缓存和变量都将\b清除(接受FIN端需要把自己剩余的信息发送完 才能发送FIN报文)</li>\n</ol>\n<h4>TCP客户端和服务端的状态转变</h4>\n<h5>TCP客户端客户端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB4klEQVQ4y42U144CMQxF5/8/CF54gDckiui9I3rvHa+OV4YwO0hrKcokE19fXzvxxLF2uy2ZTEaWy6Wuj8ejbDYbGQ6HMhgMZLfbyfV61X/M8XhcstmspNNpCYfD0mq1xHs+n2IDu1wuslqtFIQDs9lMarWaNBoNmU6nMh6PNeBisdAAj8dDwff7vc6eC3Y4HGS9Xr/WFoBxPp91NmMNaLValXq9rmvMc1OGmZkbyDV/Ntvt9uOfd7vdpNvtqhZEIiIsXWe/LMxkMxqNJJlMynw+V71fgFCnIKVSScVHK7QxZ5cBhg/aQoKRSqVU8/v9/k4ZkHK5/Ce9oDWAFIQBEPqx99KQqoVCIcnlcnI6nT6cgxhyHlaJREJisZj0+/23hnYYPYz2N0D/PkDNZvPDR9uGDRoY/aD+DcxfZc7Sn65pUahsPp+XSqWiTQywn6n7TcHoDDSnysw0PPvKEN0AAYy+oh/dKge1DekCVCwWtTsmk8kb0OgT9VuFg1K2m0UL0XofRbHOp4IuE+6nXb2gs0gDkV6v98sQ3SKRiD4EnU5HtSAag6qjbaFQUAfWFIF/3A4YIhfgprnHK8GTRQ8CaMyIxnWyFwbNACI9cwY8Go3q04WOfx6H/7SKewaGsCaYPRI/rcIZxDx6n2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"客户端状态变化\"\n        title=\"客户端状态变化\"\n        src=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n        srcset=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/63868/client-status.png 250w,\n/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>连接的建立 初始的时候TCP客户端处于CLOSED，\b当它需要与服务端建立TCP连接的时候，发送SYN字段，进入SYN_SENT状态. 当收到\b服务端对SYN报文的确认后，就进入ESTABLISHED状态，此刻TCP客户已经能发送和接收数据了</li>\n<li>连接的\b中断 客户端发送\bTCP报文(FIN字段被\b设置为1),进入FIN_WAIT_1,等待服务端的确认报文然后进入FIN_WAIT_2.等到服务端的FIN报文并且发送确认报文后，进入TIME_WAIT.最后进入CLOSED状态</li>\n</ol>\n<h5>TCP服务端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABxklEQVQ4y42Ux47DMAxE9f+flFOQ5JKDL+k9SO+9Vy4eASqCsIssAcGWRI9myLHc7XYTxuVykdPpJMfjUZ/MebdxOBzkfr9Lu92WdDotmUxGUqmUZLNZGQwGmk+Oq1ar0u12ZTabyfV6FeL5fHrw4XAo4/HYgz4eD1kul9JqtaRYLMp0OpUwXKPRkHK5LJVKRdbrtWe2WCxkv98r4Gg0UpDVaqV7rIfxfr/9cOEGySxavF4vncOYdwvmHGj7BqoMLdHkhCfGEa7vdjsvNwR1sEJ2s9nUuiCb4sdS7CMO3W63UqvVJEkS2Ww2OocYQxkCSqcmk4k2w1iHLO0dubCjppaPS3xT6C5dZJAcA8SSLVABMERo6Hw+FxzjWIQ2nUNOKO83hvYEEGXIxT44pd/vf7psgP9liBrA4j2HmZENdWTjtbDb8QfUF69SPxoJkfP5/Kkhk06no/rr9bomxvYJy2AeRGapVNJuw9QzNGRY2h8QA/1lH5jGJXFhovnpW5CDbcyvgFM6BaR2uVxOXW+mpXt0nxLQvUKhIL1eT+uL8dnHJvl8XnPssqAcDgD+FC4BYwcwtQWAmnI5kEdJ7EbCzBwCofDX+wGhXtIqR2SqKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"\b服务端变化\"\n        title=\"\b服务端变化\"\n        src=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n        srcset=\"/blog/static/884026a29f246f33aa0a88780176d2d5/63868/server-status.png 250w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/0b533/server-status.png 500w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>理解TIME_WAIT状态</h5>\n<ol>\n<li>可靠的实现TCP全双工连接的终止 主要close的一端 需要维持状态以防止最后一次的ACK对方收不到来进行网络重传</li>\n<li>TIME_WAIT阶段设置的超时时间会导致网络中迷失的分组丢失,这样在同样的端口创建新的TCP连接时候,不需要判断之前的数据.</li>\n</ol>\n<h3>拥塞控制</h3>\n<p>TCP使用的是端到端的拥塞控制，来防止网络拥塞时发生的各种问题(\b\b多余的分组,丢包\b等)。相比流量控制，拥塞控制是对网络拥塞的一种感知来控制发送的速度。流量控制是对接受方处理速度的一种速度调整。\n在TCP发送方维护一个拥塞\b窗口的变量来实现拥塞控制<br>\nLastByteSent - LastByteAcked &#x3C;= min { cwnd(接收窗口) , rwnd(拥塞窗口)}</p>\n<ul>\n<li>当发送\b方正确的收到确认报文的时候，他认为网络中无拥塞，不断的调整 cwnd</li>\n<li>当发送方超时\b未收到ack或者收到接收方三次\b\b\b冗余,需要降低发送速度</li>\n</ul>\n<h2>基础词汇解释</h2>\n<p>MSS 最大报文段长度<br>\n\b在不同的链路层协议上，其最大的传输\b单元(最大\b链路层帧长度)不同，这就导致了在\b封装到IP数据报的时候，需要适应底层的链路层长度。</p>\n<h2>TCP UDP 区别</h2>\n<ol>\n<li>TCP提供差错校验,重传等功能 UDP不提供对应的功能,UDP需要在应用程序中添加对应的逻辑来完成相应的功能</li>\n<li>UDP的数据报长度字段会随着数据发送给接收端,TCP是一种字节流协议,没有记录标记的长度(content-length) 主要是两者实现方式上的不同UDP是不面向连接的 也就是可以从一个套接字接受多个数据源 如果没有长度加以区分数据就会混乱.一个TCP套接字只对应着一个数据源,可以由应用层来决定数据的读取.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null},"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null},{"id":"5785a8e7-fb4f-52f2-975d-0390f116486d","html":"<h2>简介</h2>\n<p>在实际的工作中，发现自己对网络这方面的知识有些欠缺并且作为一个web开发者有必要了解网络中数据传输的基本过程，在阅读计算机网络自顶向下方法中把网络层的基础知识整理如下。主要分为三个方面网络层的基础，IP(网际协议)，相关协议简介来简单的学习下网络层。</p>\n<h2>基础</h2>\n<ul>\n<li>网络层提供的通信机制是多个协议族共同运行的结果。主要有以下三个组件：IP协议,路由选择协议,ICMP协议</li>\n<li>网络层提供的主要功能是提供分组的转发并且结合路由算法实现路由功能，也就是最终实现主机间的通信。运输层提供了主机上进程之间的通信。</li>\n<li>因特网的网络层提供的服务是一种尽力而为的服务，这样做能简化网络层的行为.当上层的服务需要对应的功能(例如运输层需要保证数据的按序接收等)时候，通过它自己去实现.</li>\n<li>网络层的有连接服务和无连接服务\n提供有连接服务和无连接服务的网络层形成了不同的网络体系。仅提供有连接服务计算机网络称为虚电路网络(ATM,帧中继)。仅提供无连接服务的网络称为数据报网络。</li>\n</ul>\n<h2>虚电路网络和数据报网络</h2>\n<h3>虚电路网络</h3>\n<ul>\n<li>连接建立 虚电路网络需要在路由器上维持连接信息，在虚电路建立阶段,需要在建立的路径上的路由器之间维持连接状态信息(对应连接的路径)，当连接建立后，这些路径信息存储在路由器的转发表中</li>\n<li>数据发送  发送对应的数据</li>\n<li>虚电路拆除 发送方通知网路层终止虚电路,在网络的路由器上就删除对应的路径信息</li>\n</ul>\n<h3>数据报网络</h3>\n<p>因特网是一种数据报网络，这种网络体系结构在发送数据的时候需要将目的端系统地址推进到网络中,通过逐个路由器的转发最终到达目的主机</p>\n<h2>网际协议</h2>\n<p>网际协议(IP)现在主要有两个版本：IPv4和IPv6<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 573px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABE0lEQVQY021Q2Y6DMAzk/39tW4ntwQIthENFCkkDCWlwnYNVG/Vpd2SNLM9Ylicp8nKa5uF2I6QxxsC6pml6znK0VmuN+HwXPh76cDiKafbeAwAizvOcMMalVFLKcRwpHZ1znHEhhPdeKTWOLFqfAH3XE9JM02StRUQpZbJtm3Nu28KyLPlPDgAhBO/8e1kWRTnNs7U2HjydzpSOIQRrrVIqqaqqKMq6rhm/L1pzxi7Xqm07pRSlVEoJAMMw7Hb78nKta8L4HQDWdRVCJMaYxwda68gAKyHN7mvftB0AxPlL+niMMZzzxDlnP0CMjN77vu2+0wNpWu89RuEtxdY59/r5FcYfAKxd12dZVtUEnv8gpv0LtNCK129tzhMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"数据报格式\"\n        title=\"数据报格式\"\n        src=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png\"\n        srcset=\"/blog/static/d9e150e3f381dd7aa397be1792845fb4/63868/IPv4.png 250w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/0b533/IPv4.png 500w,\n/blog/static/d9e150e3f381dd7aa397be1792845fb4/3c024/IPv4.png 573w\"\n        sizes=\"(max-width: 573px) 100vw, 573px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>字段解释</h3>\n<ul>\n<li>版本号 \b指示当前数据报使用的\bIP协议版本</li>\n<li>首部长度  数据报长度  IP数据报可以提供可变数量的选项，可以通过这两个字段来确定数据报的首部和数据的长度</li>\n<li>标识、标志、片偏移  在\b数据报传输给链路层的时候，由于不同链路层协议的\b产生的链路层帧不同，通过这三个字段来完成数据报的分片与重组</li>\n<li>生存时间(TTL) 保证一个分组不会在网络之前循环的转发，数据报信息每通过一次路由TTL字段减1.为0的时候必须丢弃改该数据报。</li>\n<li>协议  与运输层的那种协议传输数据(TCP/UDP)</li>\n<li>首部校验和  每次到达路由器的时候，路由器都会对数据报的IP首部进行校验，丢弃出错的分组信息</li>\n<li>源IP地址和目的IP地址  实现主机间的通信</li>\n<li>数据  承载上层协议的数据(TCP/UDP(应用层 HTTP SMTP) ICMP )</li>\n</ul>\n<h2>网络编址</h2>\n<h3>IP地址</h3>\n<p>IP地址可以对应理解成主机与物理链路的接口，在每个子网中，子网中的主机的网络前缀相同为X,后面的32-X位决定该子网具体\b能容纳下多少台主机</p>\n<h4>地址获取(DHCP)</h4>\n<p>在一个子网中，需要为每个主机分配IP地址来实现通信，这个的通常实现是通过DHCP\b协议(也可以通过\b静态的配置)，通过DHCP获取IP地址主要有以下四个阶段</p>\n<ol>\n<li>新连接的主机广播DHCP发现报文</li>\n<li>DHCP 服务器收到发现报文，广播DHCP提供报文(在\b子网中存在多个DHCP服务器)</li>\n<li>\b主机根据DHCP提供报文发送对应的DHCP响应报文，将之前DHCP的\b提供报文的数据回显</li>\n<li>DHCP ACk DHCP服务器确定\b请求，主机可以进行通信.</li>\n</ol>\n<h4>地址转换(NAT)</h4>\n<p>NAT是一种地址管理策略的实现。他通过在NAT路由器中维护NAT转换表来实现对外界统一请求的转发和请求到外界的转发。\n实现 子网中的主机通过端口A连接NAT路由器，NAT在收到数据包的时候\b创建一个新的端口B并将数据的源端口改为B，IP地址改为改子网对外的统一IP地址,外部服务收到对应的报文，\b响应报文到NAT路由器，NAT路由器查找NAT\b转换表找到刚才转换的端口A和初始的请求主机IP地址将响应报文发送对请求的主机</p>\n<h2>相关协议简介</h2>\n<h3>因特网控制报文协议(ICMP)</h3>\n<p>ICMP用于主机与路由器之间沟通网络层信息，ICMP是运行在IP协议层之上的，也就是IP数据报的数据部分是包括ICMP的数据报文的内容的(跟IP承载TCP/UDP报文一样)</p>\n<h2>理解路由</h2>\n<ol>\n<li>当主机想发送一个IP数据报的时候,它会查看自己的路由表。如果目的IP地址就是在本地网络，就直接将数据进行封装发送给目的主机.如果目的IP地址\b不在本局域网中,数据被封装然后发送给路由器(此时\b在数据链路层的帧的目的地址是路由器的物理地址,IP报头的目的IP仍然为原来的目的IP地址).</li>\n<li>路由器接收到对应的数据\b传递给网络层,如果目的IP是自身则自己处理这个数据\b(用于更新路由表等)否则查询路由表将数据进行转发。</li>\n</ol>\n<h2>基础词汇解释</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>丢包</td>\n<td>在路由器中存在着缓存结构来缓存需要发送或者接受待转发的分组.<br>当这个缓存过大超出其内存空间的时候，路由器就会丢弃该分组，造成丢包</td>\n</tr>\n<tr>\n<td>IP数据报分片</td>\n<td>由于不同数据链路层所能承载的最大传输数据单元(MTU)不同.IP数据报在数据链路层会被进行分片和重组</td>\n</tr>\n<tr>\n<td>CIDR 无类别域间路由</td>\n<td>它通过扩展IP的网络位数来实现将一个IP\b地址对应成多个IP地址的行为</td>\n</tr>\n<tr>\n<td>ARP 地址解析协议</td>\n<td>在数据链路层提供将网络层的IP地址转换为物理地址</td>\n</tr>\n</tbody>\n</table>","fields":{"readingTime":{"text":"9 min read"}},"frontmatter":{"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null},"title":"计算机基础之网络层","date":"2018-02-18","tags":"计算机基础","path":"/network","top":null,"summary":null},{"id":"176af9de-3c8b-52dc-8632-c4c56c195417","html":"<h2>简介</h2>\n<p>node中的Stream模块在很多基础的模块都有使用下面就从官网的文档和源码上学习下Steam模块的基础知识</p>\n<h2>基础</h2>\n<ol>\n<li>node.js 中有四种形式的流 可读(Readable)  可写(Writable)  可读可写(Duplex)   转换流(Transform)</li>\n<li>流在内部维护了一个链表来完成缓存数据的读取,流继承了EventEmitter,通过事件的监听来完成数据的获取</li>\n<li>在进行流的初始化的时候通过设置highWaterMark来控制缓存区的大小 当读写速度出现差异，存储的数据到达highWaterMark的时候，就会出现背压。这样读写流就会停止读或者写入</li>\n</ol>\n<h2>可写流</h2>\n<p>可写流是可以写入数据的目的地的抽象</p>\n<h3>事件</h3>\n<p>drain  stream.write(chunk) 会返回true false来通知当前流是否可写。当它返回false的时候  当前流再次可用的时候 会触发drain事件<br>\nerror  读写数据出现error的时候会触发这个事件 但是不会关掉流<br>\nfinish  在stream.end(chunk,encoding,callback)的时候在数据发送完毕后会触发finish事件，传入的callback作为监听函数</p>\n<h3>方法</h3>\n<p>writable.cork()/writable.uncork()\nbuffer缓存和清除缓存 调用的次数必须一致,在使用writable.uncork()的时候 推荐使用process.nextTick()<br>\nwritable.write(chunk,encoding,callback)  返回的true /false 通知当前是否可写\n结合drain事件来完成持续的写入(即使return false 仍然能完成数据的写入造成内存的占用 给垃圾回收造成压力)<br>\nwritable.destory(error) 关掉这个流<br>\nwritable.end(chunk,encoding,callback) 通知不会在有其他的写入,callback会变成finish事件的回调函数</p>\n<h2>可读流</h2>\n<p>可读流是可以被消耗的数据源的抽象\n可读流有两种状态: flowing paused</p>\n<ol>\n<li>在flowing状态下通过对data事件的监听获取数据。</li>\n<li>在paused状态下通过对_read(size)方法的调用来完成数据的读取.</li>\n</ol>\n<p>在node的lib/_stream_readable.js中,在构造函数中会通过传入的options来初始化流的状态</p>\n<pre><code>  this.buffer = new BufferList(); //  链表 \n  this.length = 0;  // 存储的长度\n  this.pipes = null;  //  pipe 数组 目的地 (初始的时候是null) \n  this.pipesCount = 0; // pipe 长度\n  this.flowing = null;  //  state  null true false (flowing paused) \n  this.ended = false;   \n  this.endEmitted = false; // 是否发送end事件\n  this.reading = false;   // 是否正在读取  \n</code></pre>\n<p>在上面的代码中this.flowing就是控制stream的状态是否是flowing或者paused 通过pipe unpipe 或者data事件的监听能切换状态 (当this.flowing为false的时候通过data事件的监听不会造成this.flowing变成true 必须调用stream.resume())\n在实现可读流的时候,需要实现_read(size)方法触发底层数据的读取.可以使用size(size会根据背压动态变化)来完成读取的流量控制</p>\n<h3>事件</h3>\n<p>data  当流准备发送数据的时候会触发data事件( 切换成flowing 或者read() 方法的调用)\nend 当可读流的数据都被消费后会触发end事件 通知无数据可读取\nreadable  通知当前有数据可以读取或者流数据的结尾会触发 通过监听readable然后通过read事件来完成数据的读取</p>\n<h3>方法</h3>\n<p>readable.isPaused() 返回流当前的状态(对应上面的this.flowing)<br>\nreadable.pause() 切换this.flowing = false<br>\nreadable.pipe(dest)<br>\n(1)可以一个src多个dest(对应上面代码的this.pipes)<br>\n(2)返回dest支持链式调用  a.pipe(a).pipe(b)<br>\n(3)背压的控制 通过在src上注册drain事件并且在write的时候根据dest的状态来写入完成背压的控制</p>\n<pre><code>    src.on('data', ondata);\n    function ondata(chunk) {\n      increasedAwaitDrain = false;\n      var ret = dest.write(chunk);\n        if (false === ret &#x26;&#x26; !increasedAwaitDrain) {\n          // If the user unpiped during `dest.write()`, it is possible\n          // to get stuck in a permanently paused state if that write\n          // also returned false.\n          // => Check whether `dest` is still a piping destination.\n          if (((state.pipesCount === 1 &#x26;&#x26; state.pipes === dest) ||\n               (state.pipesCount > 1 &#x26;&#x26; state.pipes.indexOf(dest) !== -1)) &#x26;&#x26;\n              !cleanedUp) {\n            debug('false write response, pause', src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n          }\n          src.pause();\n      }\n    }\n</code></pre>\n<p>当src接受到drain事件后会触发drain事件的监听函数重新完成数据的写入</p>\n<pre><code>//  pipe  end flag\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 &#x26;&#x26; EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n</code></pre>\n<h3>实现一个可读流</h3>\n<pre><code>const { Readable } = require('stream');\n// Stream 实现\nclass MyReadable extends Readable {\n  constructor(dataSource, options) {\n    super(options);\n    this.dataSource = dataSource;\n  }\n  // 继承了 Readable 的类必须实现这个函数\n  // 触发系统底层对流的读取\n  _read() {\n    const data = this.dataSource.makeData();\n    this.push(data);\n  }\n}\n// 模拟资源池\nconst dataSource = {\n  data: ['1','2','3','4','5','6','7','8'],\n  // 每次读取时 pop 一个数据\n  makeData() {\n    if (!dataSource.data.length) return null;\n    return dataSource.data.pop();\n  }\n};\nconst myReadable = new MyReadable(dataSource);\nmyReadable.setEncoding('utf8');\nmyReadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n</code></pre>\n<h4>从源码上理解上面的例子</h4>\n<p>通过data事件的监听</p>\n<pre><code>    Readable.prototype.on = function(ev, fn) {\n        const res = Stream.prototype.on.call(this, ev, fn);\n\n        if (ev === 'data') {\n        if (this._readableState.flowing !== false)\n          this.resume();\n        } else if (ev === 'readable') {\n        const state = this._readableState;\n        if (!state.endEmitted &#x26;&#x26; !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.emittedReadable = false;\n          if (!state.reading) {\n            process.nextTick(nReadingNextTick, this);\n          } else if (state.length) {\n            emitReadable(this, state);\n          }\n        }\n      }\n      return res;\n    };\n</code></pre>\n<p>当注册data事件的时候,会调用this.resume() 最后调用flow(stream) 来完成数据的持续读取</p>\n<pre><code>    function flow(stream) {\n      const state = stream._readableState;\n      debug('flow', state.flowing);\n      while (state.flowing &#x26;&#x26; stream.read() !== null);\n    }  \n    \n</code></pre>\n<h2>总结</h2>\n<p>上面就简单的介绍了下node中stream模块的基础知识,通过对流模块的学习能更好的帮助我们理解node中数据的发送处理过程,也可以尝试着去阅读一些简单的模块(send)来加深对Stream的理解.</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903588649500679\">Node.js可读流和可写流</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null},"title":"node中Stream流基础","date":"2018-02-04","tags":"Node","path":"/node-stream","top":null,"summary":null},{"id":"c3047e98-87f7-59a6-bbba-9d1cef17bd99","html":"<h2>简介</h2>\n<p>koa利用生成器来解决回调函数的嵌套问题，实现的十分巧妙，下面跟着官网的例子逐步学习下koa的实现原理<br>\n官网 <a href=\"http://koa.bootcss.com/\">koa</a></p>\n<h2>使用</h2>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n});\r\napp.listen(8080);  \n</code></pre>\n<p>这个例子很像在Node中构建HTTP服务器的例子</p>\n<pre><code>var http = require('http');\r\nhttp.createServer(function(req,res){\r\n    res.writeHead(200,{'Content-Type':'text/plain'});\r\n    res.end('hello world');  \r\n}).listen(8080);  \n</code></pre>\n<p>通过app.use()设定中间件 app.listen()监听特定的端口这样整个web服务器就启动了 那我们的关注点就到了这句话 var app = koa();<br>\nkoa的源码lib下有四个文件 application.js context.js request.js response.js  在koa的package.json中main属性的值指向的是lib/application.js 也就是整个web服务器的生成过程都在这个js中 下面我们逐步的解读下application.js的部分源码</p>\n<pre><code>module.exports = Application;\r\nfunction Application() {\r\n    if (!(this instanceof Application)) return new Application;//确保不通过new调用构造函数的时候返回正确的值\r\n    this.env = process.env.NODE_ENV || 'development';\r\n    this.subdomainOffset = 2;\r\n    this.middleware = [];//保存中间件的数组\r\n    this.proxy = false;\r\n    this.context = Object.create(context);\r\n    this.request = Object.create(request);\r\n    this.response = Object.create(response);//通过指定的原型创建对象\r\n }  \n</code></pre>\n<p>通过上面这段代码，也就是在调用这句话的时候 var app = koa()实际上就是生成了一个Application实例 在实例上有一个数组用于保存中间件 三个属性 context request response</p>\n<pre><code>var app = Application.prototype;\r\napp.listen = function(){\r\n    debug('listen');\r\n    var server = http.createServer(this.callback());//this.callback()就是请求来的处理函数\r\n    return server.listen.apply(server, arguments);  \r\n    //这里上文中Node构建HTTP服务的例子 似曾相识 \r\n};  \n</code></pre>\n<p>在http.createServer(this.callback())中this.callback()就是请求来的处理函数也就是app.callback()这个函数 正是这个函数实现了koa的中间件机制</p>\n<h2>中间件</h2>\n<p>在介绍中间件的原理之前 先上一个例子</p>\n<pre><code>var koa = require('koa');\r\nvar app = koa();\r\napp.use(function *(next){\r\n    console.log(1);\r\n    yield next;\r\n    console.log(2);\r\n});\r\napp.use(function *(next){\r\n    console.log(3);\r\n    yield next;\r\n    console.log(4);\r\n});\r\napp.use(function *(){\r\n    this.body = 'hello world';\r\n})；\r\napp.listen(3000);  \n</code></pre>\n<p>当对服务器发送一个请求的时候  会发现服务器的控制台log出的顺序是 1 3 4 2 下面我们来看一下这个神秘的app.callback()函数到底做了什么</p>\n<pre><code>app.use = function(fn){\r\n    if (!this.experimental) {\r\n      // es7 async functions are not allowed,\r\n      // so we have to make sure that `fn` is a generator function\r\n      assert(fn &#x26;&#x26; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function');\r\n    }\r\n    debug('use %s', fn._name || fn.name || '-');\r\n    this.middleware.push(fn);//将每次调用的生成器函数push到中间件数组\r\n    return this;//可以实现链式调用\r\n}; \n</code></pre>\n<p>app.use()就是收集所有设定的中间件，然后存储到数组中</p>\n<pre><code>app.callback = function(){\r\n  var fn = this.experimental\r\n    ? compose_es7(this.middleware)\r\n    : co.wrap(compose(this.middleware));\r\n  var self = this;  \r\n  return function handleRequest(req, res){\r\n    res.statusCode = 404;\r\n    var ctx = self.createContext(req, res);\r\n    onFinished(res, ctx.onerror);\r\n    fn.call(ctx).then(function handleResponse() {\r\n      respond.call(ctx);\r\n    }).catch(ctx.onerror);\r\n  }\r\n};  \n</code></pre>\n<p>app.callback()中的返回值 function handleRequest(req,res){}就是请求来的时候的处理函数 在这个处理函数中调用fn进行事件的处理 fn是什么呢？  我们只需要搞明白这句话 co.wrap(compose(this.middleware))</p>\n<p>第一步 compose对生成器函数数组进行了处理</p>\n<pre><code>function compose(middleware){\r\n  return function *(next){\r\n    if (!next) next = noop();\r\n    var i = middleware.length;\r\n    while (i--) {\r\n      next = middleware[i].call(this, next);//不断的获取后一个生成器对象 作为参数传入当前的生成器函数并且执行获得生成器对象\r\n    }\r\n    return yield *next;\r\n  }\r\n}\r\nfunction *noop(){}  \n</code></pre>\n<p>其实理解compose的作用要理解好通过app.use(function *(next) {}) 传递的生成器函数传递的next  整个compose的作用就是生成器函数的执行后进行从头到尾的串联 然后返回一个生成器<br>\n接下来就需要理解co的执行流程了</p>\n<h2>co源码解读</h2>\n<p>co是通过生成器避免了多个异步操作的回调嵌套</p>\n<pre><code>function *test() {\r\n  var a = yield readFile1();\r\n  var b = yield readFile2();\r\n}\n</code></pre>\n<p>简单理解co的作用就是首先获取之前执行的结果 保存下来当下次调用generator.next()的时候作为参数传入，这样就实现了异步操作的同步执行</p>\n<pre><code>function co(gen) {\r\n  var ctx = this;\r\n  var args = slice.call(arguments, 1)\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\r\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\r\n    onFulfilled();\r\n\r\n    function onFulfilled(res) {\r\n      var ret;\r\n      try {\r\n        ret = gen.next(res);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n\t}\r\n    function onRejected(err) {\r\n      var ret;\r\n      try {\r\n        ret = gen.throw(err);\r\n      } catch (e) {\r\n        return reject(e);\r\n      }\r\n      next(ret);\r\n    }\r\n    function next(ret) {  //这里使用promise进行了封装 当之前的异步调用完成后 就会在调用onFullfilled将这次执行结果的返回值传入\r\n      if (ret.done) return resolve(ret.value);\r\n      var value = toPromise.call(ctx, ret.value);\r\n      if (value &#x26;&#x26; isPromise(value)) return value.then(onFulfilled, onRejected);\r\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\r\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\r\n    }\r\n  });\r\n}\n</code></pre>\n<p>通过上面的代码阶段我们就学习了koa的中间件机制 其实ES7的异步函数就是实现的co所做的事</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null},"title":"koa","date":"2017-03-24","tags":"JavaScript","path":"/koa","top":null,"summary":null}]}}},"staticQueryHashes":[]}