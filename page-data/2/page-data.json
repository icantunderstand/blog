{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/2",
    "result": {"pageContext":{"pageAllCount":91,"group":[{"node":{"id":"33a16de5-5c3b-5ecb-9e17-c8782a7f6d22","html":"<p>本文通过图解的方式尝试生动的叙述React渲染组件的过程.</p>\n<h2>前置知识</h2>\n<h3>react渲染模式</h3>\n<ol>\n<li>Concurrent 模式  异步渲染模式,实现了基于任务的时间切片等特性</li>\n<li>legacy 模式 同步渲染模式,现在主要的渲染模式</li>\n</ol>\n<h3>react渲染阶段</h3>\n<ol>\n<li>render阶段  基于已有的Fiber树(current)构建workInprogress树 在workInprogress记录了需要进行更新的操作(effectList)</li>\n<li>commit阶段  commit分为以下三个阶段:</li>\n</ol>\n<ul>\n<li>before mutation  此时dom节点还没有渲染到页面中,执行getSnapshotBeforeUpdate周期函数和useEffect钩子函数</li>\n<li>mutation  渲染DOM 根据effectList的tag标注进行dom元素的更新,删除,替换等</li>\n<li>layout 执行useLayoutEffect等相关逻辑  进行current和workInprogress的替换</li>\n</ul>\n<h2>图解渲染</h2>\n<p>我们先假设我们的身份是React的好友,React是前端世界里面的一个一流的画师,我们希望他给我们画这样一幅画.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 370px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz4WS7Y7aMBBFeQsg+DOJnQQiCA3kQ93AgirBj+5WVd//WU6F0dK0u21/XNme0YzH53qSZTlKLCi6M/70g3xdo5TCGIPR+iGpFErKkPuXJmmaIqTEKIHf9khfstp37J+OdGXGabehWhUorT9sIKX8TRPnXNgYa4mTBL874KqWxBqiKEKKBfPbKmU4R9EixOTiHns3ofc+JKyNiWOLL1b43YBdVrRtwzAMQUVR0DQtz88D2aYm3z+xWpehVmv90KihJY7jMJnbNOw/H3l5+cr1eqXvey6XC6+v3+iPJ9yyJC23uNwHrnqEY5Ikyf3JxmCNwXmP2/a0XUdd1zRNEy46n88MhwMmX6OVRERzhBDvOAZT3hjemhfVjuTTgE098/nswW86nTKbze785IjbHxx/uawVebHEbHrSLA+FY2ffGI3d/fDb3FxWUlBWNe74nbz/QhLbvxb87x/+BPj+AExOixcKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"画的模板\"\n        title=\"画的模板\"\n        src=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png\"\n        srcset=\"/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/63868/draft.png 250w,\n/blog/static/bec0882c7e73e61b2e37a87e8db17ca0/1efb2/draft.png 370w\"\n        sizes=\"(max-width: 370px) 100vw, 370px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nReact大师稍加思索(babel)就把画的模板构想出下面的两张蓝图:<br>\n元素的语言表达\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 703px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz5WS4W6CMBRGfY3RFiilBaRUpsLEOZ3b+z/TWVozf22J/vhymzQ5Od/NXemyRDuLnWc2m55lPzCOPet1i1I5eZ6jlErzkax0VVHmOcPhTD8dca4lE5KXLEugX9ij0JUxhmhZWUd3uRCOC4dpYJ4Du12gqqrnDMuyJCZXEtO09PM7wXtqUyGkRMYIgZQigeNbSYmQKv1n8S3Evc2qrutkURQFxjma7yvj6cjneeL69cb5PBHmBT8f2dgKv93jlwtbv+Y09ny8euYx4FxzA1pr0VonS2tritZhnMH7lhA6hqGj9QN111PrEtcP1G3H2ho6axi7hjEMSShVbprmZmcMzjlyKVGxjpD3PFU5QmLlaBr39ejy/z8brRMwzmdP5C/gD6QJ/B4bz1bsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"语言表达\"\n        title=\"语言表达\"\n        src=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png\"\n        srcset=\"/blog/static/15014ea5ae1e57d91a06216d3982962b/63868/structDraft.png 250w,\n/blog/static/15014ea5ae1e57d91a06216d3982962b/0b533/structDraft.png 500w,\n/blog/static/15014ea5ae1e57d91a06216d3982962b/242e2/structDraft.png 703w\"\n        sizes=\"(max-width: 703px) 100vw, 703px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n元素结构\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 868px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 102%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQ4y5WU6Y7CMAyE+/4vyB8kJG5oOXogrrZBn3cn65Z2d4lkJXGd8dhjSJqmCXVdB/am/jmz+3P/u/f72ESXvvnA5/P55otxdQ+ww+D7zMrzPKxWq3A4HMx2u51Z27ZvDD3zN4aw4dHxeAy32818l8vFkuz3+zBWkdiOMgQQIBKw8w2Gihvt4RhgkRdhs9kYyHa7NXZjJf9bFFZVVaEoCjsDJoE+Ktlnhd18PjefV/vjklFZ5aJ2lmWxh/35/LVkqXw6ncL9fjfwx+MxqvLgHOLsMxQg4NfrNQIOqewt8RnEUGIAkKapGcOdpVkU588eemOgy7I0W6/XYblcxjuJNJ9DkxEBySpms9nMRuV8PtuAw44WYPhgvFgsOmxjyUKuysqUJHA6ndpDAPSIBXNiaMVkMomt8OUnEoGPNB8nquqnRmnqKwkYJ7HCzzv2DkMByqk/AwUrBtZSXKMEQxGIgPp3wdR8egjDqHz7Newkoc/EcKd8L1DiZwoQgrTTM5L58fAxMCam00N/6a+hAZZAWkoowBehpBywowW5SAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"元素结构\"\n        title=\"元素结构\"\n        src=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png\"\n        srcset=\"/blog/static/9f629706c2e341539b8d92bc7a0db691/63868/draw.png 250w,\n/blog/static/9f629706c2e341539b8d92bc7a0db691/0b533/draw.png 500w,\n/blog/static/9f629706c2e341539b8d92bc7a0db691/748b0/draw.png 868w\"\n        sizes=\"(max-width: 868px) 100vw, 868px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nReact真的是一个画术大师,他有两个最出色的技能:</p>\n<ol>\n<li>在脑海里面构想画图(workInprogress)然后一次画到画板上,画出的画大家都称赞道奇(首次渲染)</li>\n<li>在已有的画上修改(current => workInprogress) 画出的画既有原来画的痕迹又有新的神韵(触发更新)</li>\n</ol>\n<p>React欣然接受了这次的绘画任务,因为他很喜欢每次作画后大家对他的称赞,于是他开始作画了.</p>\n<h3>构思(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L991\">render阶段</a>)</h3>\n<p>React大师看了下自己空白的画布,决定先在脑海里面构造画的样子.React看到画的模板的时候第一时间是看到了各个节点之间的联系于是他对画的模板有了重新的构想.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 598px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQ4y5WUSa+CQBCE+f8/igN3Ew8ejYILsrjhAi5Am6+TNgPoi2+SzgDTXVNdNYP3eDyEuN/v8nw+5XA4SBzHkuf5O9brtZxOJ10nz2o+hecCNk0jaZrK7XYTBt8Z5/NZdrud1HX9P0AKsix7A+73+4+Af4EOALfbrRbTIkDH41FZI8XPDN1dq6rS4vl8LqvVSnzf101g3c/9CTBJEjVlPB7L9XrVZ4AxxnLc/P4GXt9lWgRkMpnoHIahLJdLKctSTSOXPKtx5wFDc5m2GWjGKIpCgQG9XC4argRfWzaXeW7bVrVjwDoIApWD2Gw2yhpQq7UYnEMOMkBmEME3WDFolzyAjUSn5b7AOBxFkYxGI5lOp3oWYU27rFurMMQo5HC7fAOaIWjFkaEAdzmTLgMYIQeG0QkbuVeyw5C2aAV2gMLAbY1iO/iz2UxnOkAWY9kBtJ8A75xBNsAAnIcRMyC2xmzfTEvP1Y9FBs9mgp1FdOXWsGY5DFh/BYQhorOz/a4Wi4UKz3faxDTyueesIwHRATRQ9EAz+w/CmKCQAjZiHddZZ0YSujFjBlePwn64m35ad2/MCzzXa7RrdkvIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fiber结构\"\n        title=\"fiber结构\"\n        src=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png\"\n        srcset=\"/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/63868/fiberStruct.png 250w,\n/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0b533/fiberStruct.png 500w,\n/blog/static/7d569de679597cd68a5ef34fc2a3c0cb/0c69d/fiberStruct.png 598w\"\n        sizes=\"(max-width: 598px) 100vw, 598px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个是React画师特有的作画方式,还是我上次跟他一起喝醉他说漏的,哈哈我就这样把他的秘密告诉大家了,大家还是装作不知道让React来给大家讲他作画的过程把.<br>\nReact: 我在作画的时候主要思考了两件事:</p>\n<ul>\n<li>怎么把画的模板对应成更好解读的结构(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiber.new.js#L110\">Fiber结构</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1543\">performUnitOfWork</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L782\">completeWork</a>)</li>\n<li>如何在构思的过程中把绘画的思路记录下来在画的过程一蹴而就(effectList 创建节点)</li>\n</ul>\n<p>经过一番构思,React想好了绘画的思路\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 885px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y52U2W7CMBBF8/+fhQRIUF54YhGITewBwpaExJnqTDup24aqraWRrVmu7yx2kCSJOOdU8jyXx+Mht9tN0CP3+13SJC3tiH/2BX1ggCiKopDz+Sz7/V7CMJTdbieHw0EFW579EZD9er0qw+l0KqPxSBlyyb8YsgA8Ho+6A3S5XOR0Oqkty7JKoG+ApMOCTRRFEu7DN4ajkaYOIDYC8LXd4rQcBkgTACXN5XKpAJwBYI/jWGu4WCyUMb7EcMYOAcQuCtI01RS3260GrddrBfFv5qLJZKJCw7BTCpoGe7/GCgiD1Wolw+FQU7X0bIwAJP3xeKwXowNos9mUoDZ6CogCllCHgQG63GmwZYAfPugh0O/3pdfrfYwVDKmJpQcIyx8jdjpu6dpl/vrUFH9sqsbAasxu5akaH1iXKRs7U5qgNxCYAWSAvp8vPzPMnQZTO9Ltdru6W4pV/srQ/xy+PjEAo1Mk8/lcBoOBglcB/o7hew0BsadJPel8VUxZw2cMC/dRQzqN8JKshpUMnwFqU1yhbGq1mtYuiROdv09Nyd3PgPYv2tNikBlezvE91gEnbfs0fAIKaOOQPTJlg+CAM/W1C2ezmTSbzdKODlCLQcAJ5MnCCCDBfAYWYIBm/7qCVqslnU7nTV465bndbkuj0VBW9Xpd8KvSlbHv8got71ieyO6scwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"render阶段\"\n        title=\"render阶段\"\n        src=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png\"\n        srcset=\"/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/63868/renderPhase.png 250w,\n/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/0b533/renderPhase.png 500w,\n/blog/static/6e618ddaea0eda1a9a47096488fb6ba9/efc66/renderPhase.png 885w\"\n        sizes=\"(max-width: 885px) 100vw, 885px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>挥墨(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1008\">commit阶段</a>)</h3>\n<p>在挥墨这个阶段对于React大师其实是小菜一碟了,因为费心的事情已经在构思阶段解决了,他主要根据之前的构思思路(effectList等)去作画就好,不过大师的作画方式还是不同于一般画师的</p>\n<ul>\n<li>在开始作画之前他要喝一杯酒,他私下跟我说这杯酒会影响之后的作画(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1800\">before mutation</a>阶段 周期函数钩子),我心想也是喝多了肯定不能画了吧</li>\n<li>在作画中,他又老能搞出一些新花样(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1818\">mutation</a> <a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1842\">layout</a> 组件添加到视图 生命周期函数执行),正是这些每次不同的新奇花样让他成为一个出色的画师</li>\n<li>在绘画后脑海中那个构思图成为了真实的画(<a href=\"https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1829\">workInprogress => current</a>)</li>\n</ul>\n<h2>fiber链表结构</h2>\n<p>fiber单链表结构的一些优点:</p>\n<ul>\n<li>可中断和恢复的任务 单链表结构允许React在多个帧中中断和恢复渲染任务，通过将任务切分小的单元，这样有助于提高用户界面响应性和避免出现卡顿</li>\n<li>优先级控制 可以通过链表实现高优先级任务的优先执行</li>\n<li>轻量化和内存管理 单链表对比双链表相对轻量，降低内存的占用</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/7159118990999191582\">React Fiber不就是个链表么</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"图说React渲染流程","date":"2024-02-05","tags":"React","path":"/react-render-interpretation","top":null,"summary":null}}},{"node":{"id":"1ba2a148-c3ca-5c80-b86f-ba5af48c9143","html":"<p>埋点在产品功能迭代和排查问题等场景能提供数据基础，以下梳理项目中使用的埋点方式</p>\n<h2>手动埋点</h2>\n<p>手动埋点是显示的在代码中插入代码，这种方式在精准性和定制化能力上更优，过多的手动埋点会增加项目的维护成本和影响系统的性能等。</p>\n<h2>自动化埋点</h2>\n<p>自动化相比手动埋点方式</p>\n<ul>\n<li>减少了人工的工作、数据收集方便也更加全面。适用于快速迭代中获取产品的相关用户数据。</li>\n<li>缺少灵活性 一些高阶数据诉求的埋点仍然需要手动添加实现</li>\n</ul>\n<h3>自动化埋点的一些实现方式</h3>\n<p>自动化埋点在于通过程序的方式去减少手动埋点的代码量，实现一些基础埋点比如PV/点击/停留时间的打点等，替代一部分自动化埋点的能力来降低整体项目埋点的压力，为项目卸压。</p>\n<h4>代码注入</h4>\n<p>通过babel插件的方式，对已有的元素的Click事件进行拼接，添加埋点逻辑，这样在出现点击行为的时候就自动实现了埋点的上报。</p>\n<pre><code>    // 简单示例\n    module.exports = function ({ types: t }) {\n        return {\n            visitor: {\n            FunctionDeclaration(path) {\n                // 在这里你可以添加逻辑来判断是否需要修改这个特定的函数\n                // 这里简单地选择所有函数，并添加一个新的 console.log 语句\n\n                const originalBody = path.node.body;\n                // 插图新的语句\n                const newStatement = t.expressionStatement(\n                    t.callExpression(t.memberExpression(t.identifier('console'), t.identifier('log')), [t.stringLiteral('New logic added!')])\n                );\n\n                path.node.body = t.blockStatement([newStatement, ...originalBody]);\n            },\n            },\n        };\n    };\n</code></pre>\n<h4>监听(观察者模式)</h4>\n<p>观察者模式能实现模块间的解耦，在实现自动化埋点的时候，可以在被观察者出现数据变更的时候，做对应的通过埋点逻辑</p>\n<pre><code>    import { observable, reaction } from 'mobx'\n\n    const searchParam = observable({\n        name: '',\n        age: '',\n    })\n    reaction(\n        () => ({ ...searchParam }),\n        (newValue, oldValue) => { \n            //发送埋点逻辑\n            sendEvent('搜索参数变更', {\n                newValue, \n                oldValue,\n            })\n        }\n    )\n</code></pre>\n<h4>提取范式</h4>\n<p>在人工埋点的基础上，通过抽象去减少人工埋点的代码，比如</p>\n<ul>\n<li>页面的PV可以在路由切换的时候去自动的打点</li>\n<li>项目通用参数可以在埋点函数中统一加入通用参数</li>\n<li>类似页面加载时长埋点可以提取通用的hook实现</li>\n</ul>\n<h2>埋点上的一些注意和思考</h2>\n<p>埋点主要是为了从数据侧拿到一些数据信息辅助后面的迭代规划。埋点能实现以下的功能</p>\n<ul>\n<li>用户行为分析</li>\n<li>业务决策支持</li>\n<li>性能监控</li>\n<li>异常监控</li>\n</ul>\n<p>需要注意的是埋点也需要进行治理</p>\n<ul>\n<li>维护性 开发一个项目通篇都是埋点代码那这个项目的可读性就很差了。</li>\n<li>性能\n<ul>\n<li>缓存队列 可以通过缓存队列 一次完成多个埋点的发送</li>\n<li>设置采样率</li>\n<li>减少触发频次  比如在端内场景通过bridge埋点涉及跟客户端通信，有可能会阻塞当前的UI操作，可以等待用户空闲的时候再进行埋点，例如react native中可以通过InteractionManager的runAfterInteractions来执行埋点逻辑</li>\n</ul>\n</li>\n</ul>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"埋点方案梳理","date":"2023-12-28","tags":"工程化","path":"/track-event","top":null,"summary":""}}},{"node":{"id":"a1e61cce-6af5-5210-a1d9-45d04f2a460b","html":"<p>广告平台投中阶段的广告列表有着交互复杂，逻辑分散等特点，导致在长期的业务迭代中容易变成‘老大难’。在进行技术方案设计的时候需要考虑好模块之间的依赖和防劣化的能力，才能满足业务的长期发展。下面是自己在迭代过程中对技术方案设计的一些思考。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 972px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/473c65e756e0a861a042fe5ebbc63256/95c6e/plan.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB7OUZsL//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQECEiEx/9oACAEBAAEFAmMryasw3WEf/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAEDAQE/ATV//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BCf/EABcQAAMBAAAAAAAAAAAAAAAAAAAQMUH/2gAIAQEABj8CpVhi/8QAHBAAAgICAwAAAAAAAAAAAAAAABEBITFBkbHx/9oACAEBAAE/IZldsjeiTyZyjuDZ0E1WdH//2gAMAwEAAgADAAAAEGQ//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERMf/aAAgBAwEBPxBaFh//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/EATrJl//xAAcEAACAwEAAwAAAAAAAAAAAAABEQAhMVFhcbH/2gAIAQEAAT8QAsDOgfZ5r9YwLW1gw+mysU5MrqMUBkaKf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plan\"\n        title=\"plan\"\n        src=\"/blog/static/473c65e756e0a861a042fe5ebbc63256/95c6e/plan.jpg\"\n        srcset=\"/blog/static/473c65e756e0a861a042fe5ebbc63256/0479a/plan.jpg 250w,\n/blog/static/473c65e756e0a861a042fe5ebbc63256/41099/plan.jpg 500w,\n/blog/static/473c65e756e0a861a042fe5ebbc63256/95c6e/plan.jpg 972w\"\n        sizes=\"(max-width: 972px) 100vw, 972px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>基础层</h2>\n<h3>性能建设</h3>\n<p>拆包/按需加载 @babel/plugin-syntax-dynamic-import<br>\n大文件扫描(针对build结果扫描)\n页面性能</p>\n<h3>约束防劣化卡口</h3>\n<ul>\n<li>\n<p>文件强约束(max-len卡口/complexity复杂度卡口)</p>\n</li>\n<li>\n<p>基础组件修改代码提交提示</p>\n<pre><code>#! /bin/bash shell\n// 需要重点关注的目录\nSUB='src/post/weeklyReport'\nCOMPARE=\"master\"\nLINE=\"-----------------------------\"\n// 默认对比master\nif [[ $1 ]]; then\n    COMPARE=$1\nfi\narray=$(git diff --quite $COMPARE --name-only)\nresultArr=()\necho $LINE\n\nif [[ $array ]]; then\n       for i in $array\n        do\n            // 改动的文件中命中了匹配规则\n            if [[ \"$i\" == *\"$SUB\"* ]]; then\n            resultArr+=(\"$i\")\n            fi\n        done \nfi\nresultLength=${#resultArr[@]} \necho $resultLength\n// \nif [ \"$resultLength\" -gt 0 ]; then \n    echo '修改了关键内容，请注意改动范围'\n    for i in \"${resultArr[@]}\"\n        do\n            echo $i\n        done\nfi\n</code></pre>\n</li>\n</ul>\n<h3>配置化能力</h3>\n<ul>\n<li>表格基础展示项配置化实现</li>\n<li>文案类/筛选项下发</li>\n</ul>\n<h2>工具层</h2>\n<h3>工具函数/getter方法</h3>\n<p>通用计算逻辑提取工具函数\n依赖数据计算逻辑提取全局getter方法</p>\n<h3>列表操作封装</h3>\n<p>封装列表操作相关逻辑,在视图层和数据层之间增加一个桥梁，这样数据层和视图层能相对解耦，代码逻辑清晰，\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 642px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fa3dc47ff2757330f866b046d310c6c5/46b1b/mvc.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9NCKP/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAEAAgMAAAAAAAAAAAAAAAABABEQYXH/2gAIAQEAAT8hvcOwbMk//9oADAMBAAIAAwAAABBTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABgQAQEBAQEAAAAAAAAAAAAAAAEAIREx/9oACAEBAAE/EEKmLg3cQMB3wkOeQAwv/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mvc\"\n        title=\"mvc\"\n        src=\"/blog/static/fa3dc47ff2757330f866b046d310c6c5/46b1b/mvc.jpg\"\n        srcset=\"/blog/static/fa3dc47ff2757330f866b046d310c6c5/0479a/mvc.jpg 250w,\n/blog/static/fa3dc47ff2757330f866b046d310c6c5/41099/mvc.jpg 500w,\n/blog/static/fa3dc47ff2757330f866b046d310c6c5/46b1b/mvc.jpg 642w\"\n        sizes=\"(max-width: 642px) 100vw, 642px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n使用MVC模型之后，将原本糅合在数据层的页面逻辑分离，可维护性增加，调用逻辑也更加清晰</p>\n<h3>统一弹层方法</h3>\n<p>通过统一的弹层方法，约束弹层内容的按需加载(lazy/Suspense/@babel/plugin-syntax-dynamic-import)并且在方法内部管理显隐状态</p>\n<h2>日志</h2>\n<p>通过对相关逻辑的封装，就能通过在入口处统一实现打点逻辑，比如调用打开弹层的方法的入口就可以实现埋点逻辑</p>\n<h2>数据层</h2>\n<h3>store模块依赖注入</h3>\n<p>比较简单的方案是在模块初始化时传入依赖的模块去减少查询依赖的代码逻辑，也可以借助一些实现依赖注入的库<a href=\"https://github.com/wessberg/DI\">DI</a>等实现依赖的管理</p>\n<h3>Loading态接管</h3>\n<p>通过<a href=\"https://github.com/jpillora/xhook\">xhook</a>对特定接口进行接管，完成自动化的loading态处理</p>\n<pre><code>const useLoading = (url: string) => {\n  const [loading, setLoading] = useState(false)\n  xhook.before(function (request) {\n      if (request.url === url) {\n          setLoading(true)\n      }\n\n    });\n  xhook.after(function (request) {\n      if (request.url === url) {\n          setLoading(false)\n      }\n\n  });\n  return {\n      loading\n  }\n}\n\nexport default useLoading\n</code></pre>\n<h3>数据变更通知</h3>\n<p>通过在store初始化的时候传入配置，在对应值变更的时候执行对应的逻辑, 通过mobx的reaction完成变化的通知，完成模块间的解耦</p>\n<h2>组件层</h2>\n<p>组件层有基础组件和功能模块。基础组件是纯的UI展示类组件，这部分组件需要控制业务逻辑的入侵，在上层进行逻辑的分发控制。功能模块是列表内相对独立的模块，可以通过较少的属性传递完成逻辑的收敛。</p>\n<h2>2023.11.21</h2>\n<ul>\n<li>对技术债的理解\n在引入一种新的解决方案比如useContext这种，对业务入侵很多。他虽然解决了属性跨层级传递的问题但是对组件的复用度有一定的影响。主要先要想明白A才去做B.比如先做好基础组件的拆分在这个基础上去组合技术方案</li>\n<li>视图/数据层\n<ol>\n<li>视图层尽可能减少数据层面的操作，只要UI逻辑。操作逻辑通过封装逻辑调用数据层接口实现</li>\n<li>数据层要做好依赖的管理和拆分，防止出现改不动的现象。通过通知或者监听变更的方式去完成视图层与数据层的解耦</li>\n</ol>\n</li>\n</ul>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"列表技术方案设计(迭代版)","date":"2023-12-27","tags":"工程化","path":"/code-refactor","top":null,"summary":null}}},{"node":{"id":"5c7a7b03-c4dc-5d9a-83cb-50676898ba2a","html":"<h2>受控组件/非受控组件</h2>\n<ul>\n<li>受控组件依赖于state,通过onChange => state => value 适合频繁数据处理表单逻辑场景(校验)</li>\n<li>非受控组件不依赖于state,通过操作dom更新和获取值 适合简单提交表单场景</li>\n</ul>\n<h2>单页应用/多页应用</h2>\n<table>\n<thead>\n<tr>\n<th>对比</th>\n<th>单页应用</th>\n<th>多页应用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>优点</td>\n<td>页面切换快，当前页面刷新</td>\n<td>利于SEO</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>不利于SEO，需要做服务端路径处理和应用内前进后退逻辑</td>\n<td>切页需要重新加载资源，有卡顿空白的问题</td>\n</tr>\n</tbody>\n</table>\n<h2>前端架构模型(MVC/MVP/MVVM)</h2>\n<h3>MVC</h3>\n<h4>客户端MVC</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 821px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/c8ed590ff80f4f312af2f12c503c4b14/02cd5/mvc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.20000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAChklEQVQ4y51U32vTUBTu3+ijj4IPPgg+C/rkXhR8ElSw4HSCujE3qGOjbGhbtrK5rWN27dr015LbNmmTNj+bJrn5JL/WNm1FPHA5N+Sc757zne/eBGLmuq6/PFNGYwiKgZ631BH66giSNgIN/0dx05b4G+BFo4t0oYHsFYdMkcVGnsHmSR1j214OOA0Q7SkNvk8rLN5+TuHd1xRerG7h7koST7fysKk7d3jkE9OVTfaBv2zx2DuvIV2o4c3+Je6tZfFo+xiW48wAToPOVGhZFhzHCZZtwxiZqAsDEElBW1JQ5SXwsjY5MUbVXMuCIICQNnheAEcIhKEC05kkW9TFQNXB1OvgOA6NRgOEEFBKbytd2LJnqmnBmeKKhgkOpehrRjgYF3Dp8qEIso4SkcAICspdGUx3iOu2dMtZJBdJH+GsKYARVFQFDRVeQaHZQ2egBRVGgddExMFvDqnDS2xnC/iYKeHVfhGdoTbThWKYyJUINg5+YT2dx1r6BM93CsjXukGFEWClLSJT6uDL3iGeJTfx4MNP3F8/RktU/DkYlu3TIKoGsuU2Pu1k8HJ1Ew9ff8Od5A+kimwIGHLV5AfIXd3grM4jdXGDld0LPNk9h2yYAHV8MC9UVDTkr1m/zVylg/dHVTz+fopcvTt/UzySZd1ArdP3yPCJt20bLMuiWq2i1WyCcBzEfi8cihP4aCiGYYDneYii6EumL/CotAgyZTbAD/XpSYNhGJTLZT/e+55WQKSChCdiXdf9JM3zpom2KOOo1pkkhDpTVRXD4RDSYOBXHb8tMzqMyR62NV76ACzT7owO41dQluW5R2NRbBw0sehErx2vvfiL8i+2ENA0TfR6vf8C/APdFF89KhKOygAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"客户端mvc\"\n        title=\"客户端mvc\"\n        src=\"/blog/static/c8ed590ff80f4f312af2f12c503c4b14/02cd5/mvc.png\"\n        srcset=\"/blog/static/c8ed590ff80f4f312af2f12c503c4b14/63868/mvc.png 250w,\n/blog/static/c8ed590ff80f4f312af2f12c503c4b14/0b533/mvc.png 500w,\n/blog/static/c8ed590ff80f4f312af2f12c503c4b14/02cd5/mvc.png 821w\"\n        sizes=\"(max-width: 821px) 100vw, 821px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>用户操作视图后，调用Controller接口发起数据更新</li>\n<li>Controller调用Model接口做数据变更，Model发起数据变更通知</li>\n<li>数据监听数据变更通知，完成页面更新</li>\n</ol>\n<h4>服务端MVC</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 958px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/3129270341e242661c4b265a71992503/b97f6/serverMvc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 117.60000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABcSAAAXEgFnn9JSAAADaUlEQVQ4y5VUaW/bRhDVLy/6oTHQfmgDxG2cFHIQO02iVimCGnXdFnac2EIEkzIp6zQtUqKuSKR4UzxEcV9BmlKoWGqQBZYLzuy+nTfzZjO4HST+EIL00DQNo9EIkiRBURT4vr/iT+0Pk5XOJA6ycM5ms3hGQxRFUBSFwWCAQqGA+Xy+9C/2ROcIIZsBLctCu92GqqqgaAq5X3Ngyyy2f9yG4zjgeT6+yDCMzYAJ5pKC67rxWmWvsLf7FO0bAS/3X8S2iHaaenLmboSf5iX6vu8w+IP5F6fXReTpQwwtaQVouXdThGlA07KQ1Y/wbfsXfE3tYNv/E8cjCphF4ayA3Y1wLaBtIWse4Xs5j3u1J/gJf+F4/AWAS2dCPsrjXv0AO7U8HjI5PORe4bxd+nLZhGEIL/DhkwCTyQStVgu+46EriDB0Iy7IdDpFEATrq5wYSJjYOsoA96vP8c27R9gq/Iz71y9xo4gIZgGkiQy+xcfSWShhM2B4azNsExRfBs1foXRzhTO2iKk9RegECIM5FFWJtZqu9AKQELKaw08HM2nincSg5HB4q7Hg1M66/MWZSv7pjOd5UWuRfr8f50w3dLieB13X8UQ9wndSDl+VdvCD+xpH4yI8w4Hr3dI1TTPud9M0P0YYIff7fULTdFwAVVPjPo1oPRJeY6u1h3vlXWx1n+Gwe47A9uG4DmzbhiAIYBgGHMetpxxVL02pLnJghSoqYgOXfAW98WDpd10nvnQ2i1vxLqBn23CTZK97ytbZVc24m0PH9yGaFuF1Ax3LhmjZsBJJRFJKz+hQpAbTkOBOx9DVHixjCMtUEtkQOiNOFDyTdbLbHWJXHOC5PkVj+GFxbVoasc1xXMiDAozxMdrNA7jaWwy7F+E8TAC7iorfNJs8bnB4XLtG3nTR/DBaAUxTjQGHRRjSKZiLHFztHMMunQCCzvQkGdlCkeyVWOxflpF9fwG+P9gIGLUeSx+izv6OZuUAlVIeFfY0TDbRma6m48VoQh5clLBNXSKv2xAk+X8jtJQS5P4/KJ7tw9fPoY7LYTBPisLLE2QHEnlQaSCaTyUN3GcoD8UzyL2/0Si/gimdoNcufsyhrGk4qdbISbWGN7U63tQakFR13au8fI0E/hqNOotm8wr1GoNer/P5Xl6nw03aTOvwP6OZFu6jb6HuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"服务端mvc\"\n        title=\"服务端mvc\"\n        src=\"/blog/static/3129270341e242661c4b265a71992503/b97f6/serverMvc.png\"\n        srcset=\"/blog/static/3129270341e242661c4b265a71992503/63868/serverMvc.png 250w,\n/blog/static/3129270341e242661c4b265a71992503/0b533/serverMvc.png 500w,\n/blog/static/3129270341e242661c4b265a71992503/b97f6/serverMvc.png 958w\"\n        sizes=\"(max-width: 958px) 100vw, 958px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>用户发起页面请求</li>\n<li>服务端根据路由规则把请求交给特定的Controller处理，Controller完成数据的组合和页面模版渲染</li>\n<li>服务端将渲染结果返回给客户端，客户端完成页面的渲染</li>\n</ol>\n<h3>MVP(Model-View-Presenter)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 816px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/590878340d780c4ae198215c2be61b28/b4098/mvp.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkUlEQVQ4y61Uy27TQBTNL7KFD0AClizYsGJFhVQkJBaIRQNqF62qFlXlkVDRRyiBttRp2qZumyZObMdx7PHbTmzHB42dIDulEUJc6cq2fOfMPXPumRwmIoqiOGno7gCK3YdieVDtJA13cK0uHbk/gSV1Eb5fiPhcaeIr28FOjcdi+RLrTHOiNpu5NNjkzluVC7ycf4f8SgEzc6u48/QtZouV+N9wGmAajLZHv8IwRPlcQJFpYP3HGWbW9nHrVREP1/bj2nB4nW5MOY0+4grDG8D0BlAMC8dtGQIxwakW2K6OumImGwYBWq0WeJ6HLMsQBAGapmXPkEZDMRGONneDIYLRu9QR0RZECKKIOteCZtogug6WZXFyeoquLCMIAuQoNUVRoKoqdF3HpURgmQbaHQkqIdCICsdx4jQtC0Q3ICokXjzwfehEBVF6IIoMRMMEkILRhWdNHucdgjNBQeVKQI3roNYU4XlehkXP7qPKK+BUB03igtc91GUTxPaylA+bMgpMEx/3WBQOLvGmdI6Fch3hcJgoOxJCNR0Ujzgsbx1idYfBwhcGz94zYLheIsq4kGl0sXncxtxKAU9eL+PefAmPP1RixcejQkMxHWzXRORXi5jNL+PBi0Xczu9guy6NAZMOftZFbBw1UKrxmCuxuL/0DY/WDxCNOxwBaraLzWoDe3UJn6ptPN84wd2lXew2pCzlYZTMomw44GQNvh+g7/uxa9IDT59BGMai+L4fC0RZxINt2za63S4IIfHTICpOGzyOWr2UJRMrpk1wU+SogqZpwnVd6IaBvmOjykkoX0m/HZFx0hQfZ7ycpR7FdP6mo6nWGy+m3VqWNfWauhFw8vqiQQ+53+//P0Bqcrkn/xPgL/6nXF5brCTVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mvp\"\n        title=\"mvp\"\n        src=\"/blog/static/590878340d780c4ae198215c2be61b28/b4098/mvp.png\"\n        srcset=\"/blog/static/590878340d780c4ae198215c2be61b28/63868/mvp.png 250w,\n/blog/static/590878340d780c4ae198215c2be61b28/0b533/mvp.png 500w,\n/blog/static/590878340d780c4ae198215c2be61b28/b4098/mvp.png 816w\"\n        sizes=\"(max-width: 816px) 100vw, 816px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>用户操作页面，调用Presenter</li>\n<li>Presenter直接调用Model接口更新数据</li>\n<li>Model更新后通过观察者模式通知Presenter</li>\n<li>Presenter接受更新通知后调用View接口更新视图</li>\n</ol>\n<h3>MVVM(Model-View-ViewModel)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 802px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/de322df9e4495cc53c6668e371dfa750/5a6dd/mvvm.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 90.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC3ElEQVQ4y52US28SYRSGWbpz6d4/4NpfYIxLtyaaGLcu3LjwFqMxURPjpSGp0WDqvV6iwUu10NK01Yq1WpBKaWUoUGCGucAwwzDA8BiGTm/WRD3JyTfJfOc573fm/cbHuuh0Ou4q6yajcYG30QRD0TmCH2YZiiYIxTJEP4b4FPQTftnP68Hr3Hw1zKk33wnOCm6tbyugVDEYnlmg/1EQ//0X9A0848adQR6GZxD8e2ie3YZ+YQec8TF45SD77sUJTCb+DBS1GhPJAp/TspvRtMxkSiSSkkn17aVxfjuVSzvh3DYGrhxmd2AG//j3HtCDdFfvuaTqhGMZRuNZRuJLvPsmMBLLEEnkeR4awz9wh/O3Ahz393PgVpBdfSEuhGNrCj2QF5bdJF/W+LZUIlWQyUoqObnKT1FjWauzoNjESwbT+SrTWZlIKseCpG1U6DiOm55Ss9mi3mzjrLyv6VWyhSKSoqBIJRzbYnN061aBlmVRLBSoqAqptIBULtNotlbV1wwDWVEoKwrpfBHdMNdAdGi2nTWFXlHVtBBEjcWShlQ1mS9p5JQadqu9QUm7A3MFlWXNJK+Z5FQDoaxT1IzeDL1jZaQK4XiW0fgSIzGB4HSa22NJ8mptdSx0OrTabaZSBd59WWTo8zxvp1MEInMMRhd7CleBosZ4ssiz0BQXbz7k5KMxjj7/wk+pwvrGrVabmYzMk+EprgUec6LvPkcCYS6PJFaATm9j97jDsxkmfuR5MJHk2NMo+++OM+8BV/a1HYcPyRyRRI5QbImr72McejDJ6aGvG43dchx000KtmcwvlylXaogVnebKDNd71rJtzLqFaTUw6g23zmzY+Gzbplqtous6mqZh1HQkWeXTwjJb3aLNnt0cLlCWZRcoSRKqIpMrSbyaFfDmuxnmOWOr9P2pU9dC/KWqDQp/6+J+xZZ7Mzr/A9xqTl2/mWb9t5/GfwO7cxVFsWfkf1T4C04gPZhNV0RxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mvvm\"\n        title=\"mvvm\"\n        src=\"/blog/static/de322df9e4495cc53c6668e371dfa750/5a6dd/mvvm.png\"\n        srcset=\"/blog/static/de322df9e4495cc53c6668e371dfa750/63868/mvvm.png 250w,\n/blog/static/de322df9e4495cc53c6668e371dfa750/0b533/mvvm.png 500w,\n/blog/static/de322df9e4495cc53c6668e371dfa750/5a6dd/mvvm.png 802w\"\n        sizes=\"(max-width: 802px) 100vw, 802px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>用户操作页面，调用ViewModel更新Model</li>\n<li>Model更新触发ViewModel更新</li>\n<li>ViewModel和View有双向绑定，视图自动更新</li>\n</ol>\n<h2>react diff</h2>\n<p>react的diff策略基于以下三点:</p>\n<ul>\n<li>DOM节点的跨层级移动操作较少</li>\n<li>相同类型组件有相同的DOM结构，不同类型的组件有不同的DOM结构</li>\n<li>对于同一层级的一组子节点，可以通过唯一id进行区分</li>\n</ul>\n<p>对于以上三点，有以下的更新策略</p>\n<ul>\n<li>tree diff 对虚拟Dom分层diff,不存在直接删除不考虑移动的复用</li>\n<li>component diff  不同类型组件直接替换，同类型组件可以通过组件的属性变化来判断是否需要更新</li>\n<li>element diff React提供了三种节点操作：插入(INSERT_MARKUP)/移动(MOVE_EXISTING)/删除(REMOVE_NODE)来达到同类型子节点复用的目的</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/deae9f75a214638be06f63c42e3174cc/081d5/elementDiff.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABPklEQVQoz3WTCa6DMAxEuf+puAA3AFSWtipL2buw+ev5yxV0sRTFiZPxjJ0467oKxmy+Wd/3crlcZBiG3f6yLFJVlWRZJtM0ve5jznZhh+d5ltvtJl3XyTiOkue5ghIDoG1bjT+fT03IGcNxDKwoCmXEAAgAAyXm+77c73eNEwOU9fl81vgHoOd5cjqdpGkaGfr/C8iq61oHviVifb1edbZy/JTMocPhoHLKopQwDHUPuXEc6x4SoyiS4/G4k7tjyAWMA7BBhrFAOgZ7mFNTZku0A9wyZAaQOgVBoGvqRJMYNCRNU00G0OPx+AQ0MNd1NTMsYNZ3vc7UjT2tZ1VrMltbc7aEXoC8Kdghw54Jly0JTGEGED7JyrJU/6dke8w0AnDk0CAAMZrAM8EAS5Jkx067/P5Tvv2c91/0zTeGf5VwVkJJR/hYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"element diff\"\n        title=\"element diff\"\n        src=\"/blog/static/deae9f75a214638be06f63c42e3174cc/00d43/elementDiff.png\"\n        srcset=\"/blog/static/deae9f75a214638be06f63c42e3174cc/63868/elementDiff.png 250w,\n/blog/static/deae9f75a214638be06f63c42e3174cc/0b533/elementDiff.png 500w,\n/blog/static/deae9f75a214638be06f63c42e3174cc/00d43/elementDiff.png 1000w,\n/blog/static/deae9f75a214638be06f63c42e3174cc/081d5/elementDiff.png 1264w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>react fiber reconciler过程</h2>\n<p>reconciler分为render阶段和commit阶段</p>\n<ul>\n<li>任务调度-scheduler阶段  通过调度器的requestIdleCallback或requestAnimationFrame在浏览器空闲时执行任务</li>\n<li>render阶段利用已有的fiber tree生成workInprogressFiber render阶段可以被高优先打断</li>\n<li>commit阶段是更新阶段，将render阶段需要更新的操作执行，commit阶段有三个主要阶段钩子\n<ol>\n<li>before mutation-执行DOM操作前执行，会执行getSnapshotBeforeUpdate/componentDidUpdate</li>\n<li>mutation-执行DOM操作</li>\n<li>layout阶段(执行DOM操作之后) 尺寸变化会触发页面重排</li>\n</ol>\n</li>\n</ul>\n<h2>自定义hook实现</h2>\n<h3>useDebounceValue</h3>\n<pre><code>const useDebounce = (value, delay = 500) => {\n    const [debouncedValue, setDebouncedValue] = useState(\"\");\n    const timerRef = useRef();\n\n    useEffect(() => {\n        timerRef.current = setTimeout(() => setDebouncedValue(value), delay);\n\n        return () => {\n        clearTimeout(timerRef.current);\n        };\n    }, [value, delay]);\n\n    return debouncedValue;\n};\n</code></pre>\n<h2>高阶组件/render props</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/react-hoc\">高阶组件/render props</a></p>\n<h2>前端路由</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/history\">前端路由</a></p>\n<h2>react事件系统</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/react-event\">React 事件系统源码解读</a></p>\n<h2>react hooks</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/react-hooks\">react hooks</a><br>\n<a href=\"https://icantunderstand.github.io/blog/thinking-in-react\">聊聊我对React Hooks的理解</a></p>\n<h2>react渲染过程</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/react-render-interpretation\">图说React渲染流程</a><br>\n<a href=\"https://icantunderstand.github.io/blog/react-render\">React render流程梳理</a></p>\n<h2>前端状态管理</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/state-control\">当我们聊状态管理的时候我们在聊什么</a></p>\n<h2>react更新任务调度</h2>\n<p><a href=\"https://icantunderstand.github.io/blog/react-setstate\">setState源码分析</a><br>\n<a href=\"https://icantunderstand.github.io/blog/react-scheduler\">从Scheduler包来看React的任务调度</a></p>\n<h2>react server component</h2>\n<p><a href=\"https://www.plasmic.app/blog/how-react-server-components-work\">How React server components work: an in-depth guide</a></p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/7099810539315920926\">react 中 ReactElement 与 Fiber 的关系</a><br>\n<a href=\"https://www.plasmic.app/blog/how-react-server-components-work\">How React server components work: an in-depth guide</a>\n<a href=\"https://juejin.cn/post/7159118990999191582\">React Fiber不就是个链表么</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"react基础知识梳理","date":"2023-08-15","tags":"React","path":"/base-react-summary","top":null,"summary":null}}},{"node":{"id":"0ae5779e-bf32-5ee1-bc37-cd3bc37f9819","html":"<h2><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction</a></h2>\n<p>在项目中需要根据配置生成Async Function来保证配置的串行执行，Async Function在创建的时候只能访问到全局作用域的变量，需要注意。在node中可以通过<a href=\"https://github.com/nodejs/node/issues/9474\">vm.runInNewContext</a>来解决。</p>\n<h2>变量</h2>\n<p>在javascript中声明变量有下面的几种方式: var  / const(let)  下面来梳理下这几种声明变量方式的区别。</p>\n<table>\n<thead>\n<tr>\n<th>声明方式</th>\n<th>声明提升</th>\n<th>作用域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>let/const</td>\n<td>Temporal Dead Zone</td>\n<td>块级作用域</td>\n</tr>\n<tr>\n<td>var</td>\n<td>提升</td>\n<td>函数作用域, 进入到声明该变量的函数作用域分配空间并且初始化值为undefined,执行到赋值语句后进行赋值</td>\n</tr>\n</tbody>\n</table>\n<h3>var</h3>\n<p>在进入声明该变量的函数作用域的时候,会为其分配空间并且初始化值为undefined,在执行到对var赋值的语句的时候会对该变量进行赋值(如果没有赋值就是undefined)</p>\n<h3>let</h3>\n<p>在进入声明该变量的块级作用域的时候,会为其分配空间此时这个变量是未初始化的(引用一个未初始化的变量会导致引用错误),到达对该变量的赋值语句的时候进行变量的赋值(否则为undefined)。</p>\n<h3>const</h3>\n<p>跟let的行为类似,但是需要进行初始化的值(不允许修改指向)</p>\n<p>下面是一些简单的例子来帮助理解上面的点</p>\n<pre><code>let tmp = true;\nif (true) {\n    // 引用未初始化的变量引用错误\n    //  console.log(tmp); // ReferenceError\n\n    let tmp; // 初始化为undefined\n    console.log(tmp); // undefined\n\n    tmp = 123;\n    console.log(tmp); // 123\n}\nconsole.log(tmp);// true\n\nif (true) {\n  const func = function () {\n    console.log(myVar); // 3\n  };\n  let myVar = 3; \n  func();  \n}\n</code></pre>\n<p>在循环中var和let/const的表现</p>\n<pre><code>const arr = [];\nfor (var i=0; i &#x3C; 3; i++) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [3,3,3]  每个变量都指向一个绑定i 所以都为3\n\nconst arr = [];\nfor (var i of [0, 1, 2]) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [2,2,2]\n\nconst arr = [];\nfor (let i=0; i &#x3C; 3; i++) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [0,1,2]   每次为let创建一个当前值的绑定 所以为[0,1,2]\n\nconst arr = [];\nfor (const i of [0, 1, 2]) {\n    arr.push(() => i);\n}\narr.map(x => x()); // [0,1,2]\n</code></pre>\n<h3>var和let声明变量对参数的影响</h3>\n<table>\n<thead>\n<tr>\n<th>声明方式</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>var</td>\n<td>声明的变量会覆盖函数的参数</td>\n</tr>\n<tr>\n<td>let/const</td>\n<td>重复定义</td>\n</tr>\n</tbody>\n</table>\n<h4>理解默认参数的行为</h4>\n<p>默认参数可以理解成let的行为  默认参数的访问范围是与函数体内部相隔离开的,只能访问到外部的变量</p>\n<pre><code>// OK: `y` accesses `x` after it has been declared\nfunction foo(x=1, y=x) {\n    return [x, y];\n}\nfoo(); // [1,1]\n\n// 在初始化x=y的时候 y处于TDZ 出现引用错误\nfunction bar(x=y, y=2) {\n    return [x, y];\n}\nbar(); // ReferenceError\n\n\nconst foo = 'outer';\nfunction bar(func = x => foo) {\n    const foo = 'inner';\n    console.log(func()); // outer\n}\nbar();  //  如果在这个例子的外部不存在foo 会引用错误\n\nfunction noParameter() {\n    throw new Error('no parameter');\n}\nfunction test(a = noParameter()) {\n    return a;\n}  // 使用默认参数来做参数的校验\n</code></pre>\n<h2>解构</h2>\n<p>解构是跟变量的操作关联到一起的,主要用于变量的声明,赋值,函数参数的定义以及提供默认值。对象解构的时候,会把右边的操作值转化成对象。数组解构的时候相当于调用数组的迭代器实现</p>\n<pre><code>const { length } = 'aaa';\nconsole.log(length) // 3\nconst [x, y] = new Set([1,2]);\nconsole.log(x,y); // 1 2  \n</code></pre>\n<p>在对数组进行解构的时候,还可以通过越过某些数组项或者通过剩余参数获取数组后面的值</p>\n<pre><code>const [,, x, y] = ['a', 'b', 'c', 'd']; // x = 'c'; y = 'd'\nconst [x,...y] = [1,2,3] // x 1 y [2,3]\n\nconst num = [1,2,3];\nconst b = [];\nb.push(...num); // 扩展符\n</code></pre>\n<p>也可以通过解构来进行赋值(解构的声明和赋值不能同步进行并且解构的赋值需要在外边包上括号)</p>\n<pre><code>const arr = [];\n({ bar: arr[0] } = { bar: true });\nconsole.log(arr); // [true]  \n</code></pre>\n<h2>ES6 模块</h2>\n<p>ES6模块本质上是一种规定静态化的加载和导出代码的方式,通过编译时加载使基于代码的静态分析成为可能(webapck中的tree Shaking).CommonJs的模块(运行时加载)就是对象.</p>\n<h3>ES6模块的特点和CommonJs的对比</h3>\n<p>不能动态的引入并且引入是有提升的</p>\n<pre><code>// 不能动态的引入\nif (Math.random()) {\n  import 'foo'; // SyntaxError\n}  \n{\n  import 'foo'; // SyntaxError\n}\n// 引入的提升\nfoo();\nimport { foo } from 'my_module';\n</code></pre>\n<p>引入是只读的引用</p>\n<pre><code>// a.js \nexport let a = 100;\nexport const count = () => {\n  a++;\n}\n// b.js\nimport { a, count } from './a.js'\nconsole.log(a); // 100\ncount();\nconsole.log(a); // 101\na = 100; // error  a是只读的\n\n// CommonJs是值的复制,相当于修改一个值.\n</code></pre>\n<p>ES6的模块可以导出单个值,CommonJS必须导出一个对象.ES6的引入是只读的引用,CommonJs的引入对于基本类型是值的复制,复杂类型是引用.</p>\n<pre><code>// a.js  CommonJS值拷贝的例子\nlet a = 100;\nmodule.exports = { \n  a,\n  count: () => { a++ },\n};\n// b.js\nlet { a, count } = require('./a.js')\nconsole.log(a); //100\ncount();\nconsole.log(a); //100\na++; // 相当于对本模块的a变量进行了赋值\nconsole.log(a);  // 101\nconst b = require('./a.js'); // 会使用第一次require的结果\nconsole.log(b.a);  // 100\n\n// a.js  CommonJs 引用的例子\nlet a = {\n  name: 'haha',\n};\nmodule.exports = { \n  a,\n  setStr: (str) => { a.name = str; },\n};\n// b.js  \nlet { a, setStr } = require('./a.js')\nconsole.log(a); // { name: 'haha' }\nsetStr('ss');\nconsole.log(a); // { name: 'ss' }\na.name = 100;\nconsole.log(a);  // { name: 100 }\nconst b = require('./a.js');  // 仍然使用的是第一次的缓存结果 但是由于引用的设置 导致原来的值被修改了\nconsole.log(b);  // { a: { name: 100 }, setStr: function() {} }\n</code></pre>\n<p>CommonJs循环加载时,属于加载时执行.即脚本代码在require的时候,就会全部执行.一旦出现某个模块被循环加载,就只输出已经执行的部分,还未执行的部分不会输出.ES6模块属于动态只读引用. CommonJs在引用同一个模块的时候存在会使用第一次的缓存.</p>\n<pre><code>// b.js\nexports.done = false\nlet a = require('./a.js')\nconsole.log('b.js-1', a.done)\nexports.done = true\nconsole.log('b.js-2', '执行完毕')\n// a.js\nexports.done = false\nlet b = require('./b.js')\nconsole.log('a.js-1', b.done)\nexports.done = true\nconsole.log('a.js-2', '执行完毕')\n// c.js\nlet a = require('./a.js')\nlet b = require('./b.js')\nconsole.log('c.js-1', '执行完毕', a.done, b.done)\n\n输出:\nnode c.js\nb.js-1 false\nb.js-2 执行完毕\na.js-1 true\na.js-2 执行完毕\nc.js-1 执行完毕 true true\n\n// ES6 循环依赖 a.js\nimport { bar } from './b.js';\nbar(); // 'bar'\nexport function foo() {\n    console.log('foo');\n}\nbar(); // 'bar'\n\n// b.js\nimport {foo} from './a.js'; \nexport function bar() {\n   console.log('bar');\n}\n\n// CommonJs循环依赖  a.js\nconst { bar } = require('./b.js');\nmodule.exports = {\n  test: 1,\n}\n// b.js\nconst { test } = require('./a.js')\nconsole.log(test); // undefined\n</code></pre>\n<h3>动态引入</h3>\n<p>可以通过按需引入模块来优化首屏代体积</p>\n<pre><code>    import(\"module\").then(module => {\n        module.default();\n        module.namedExport();\n    });\n\n    // Or with async/await\n    (async () => {\n        const module = await import(\"module\");\n        module.default();\n        module.namedExport();\n    })();\n</code></pre>\n<h2>iterator(迭代器)</h2>\n<p>在ES6中的可以使用数组解构,for of等语句遍历数组、Map、Set是因为在ES6中默认为这些结构创建了[Symbol.iterator]方法.通过这个方法的调用返回一个可以遍历该数据结构的对象(iterator),通过这个对象来遍历数据结构的属性.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 883px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAy0lEQVQY05VQy4qEQAyc//8eb3rwrBcVRXwrKr4QFRVBxBoqyy64zGUCRSfV6UqnXgAwjiMcx0HTNCxx3/dHMKqqgud5WNf10Xtdl5wvksMwwDRN2LaNMAwRBAGSJEHf9/gfZVnCsiwRzrIMaZoK4jjGtm0/gl3XYZ5nHMch5L7vaNsW53liWRZ5QJ61YRjQdR1RFAnv+z7quv77rQiSVBRFGjVNg6qqcF1XBAgO4koEbaFQnucoikJyDn0I0g9ech2C+TRN+CZ+PX4DVbt5trPU9noAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iterator\"\n        title=\"iterator\"\n        src=\"/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png\"\n        srcset=\"/blog/static/0bcb228576a7ca1967151733aba51136/63868/iterator.png 250w,\n/blog/static/0bcb228576a7ca1967151733aba51136/0b533/iterator.png 500w,\n/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png 883w\"\n        sizes=\"(max-width: 883px) 100vw, 883px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>const iterable = {\n  [Symbol.iterator]() {\n      let step = 0;\n      const iterator = {\n          // iterators that are iterable\n          [Symbol.iterator]() {\n            return this;\n          }\n          next() {\n              if (step &#x3C;= 2) { step++;}\n              switch (step) {\n                  case 1:\n                      return { value: 'hello', done: false };\n                  case 2:\n                      return { value: 'world', done: false };\n                  default:\n                      // done表示是否到尾\n                      return { value: undefined, done: true };\n              }\n          }\n      };\n      return iterator;\n  }\n};\nconst iterator = iterable[Symbol.iterator]();\niterator.next();  // {  done: false, value: 'hello' }\niterator === iterator[Symbol.iterator]() // true\niterator.next();  // { done: false, value: 'world' }\n</code></pre>\n<h2>generator</h2>\n<p>生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。</p>\n<h3>generator方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Generator.prototype.next(value)</td>\n<td>返回一个{ done: true/false, value: 执行结果 }的对象,value是当次执行的入参</td>\n</tr>\n<tr>\n<td>Generator.prototype.return(value)</td>\n<td>返回给定的value值并结束生成器</td>\n</tr>\n<tr>\n<td>Generator.prototype.throw(exception)</td>\n<td>向生成器抛出异常，并恢复生成器的执行</td>\n</tr>\n</tbody>\n</table>\n<p>生成器函数有如下特性:</p>\n<ol>\n<li>\n<p>当一个generator函数被调用，函数体内代码并不立即执行。它返回一个遵循了迭代器协议的迭代器对象:它有next方法.</p>\n</li>\n<li>\n<p>执行生成器函数体内代码的唯一方法就是在返回的迭代器对象上调用next方法.每一次调用next，函数体内代码就执行到一个yield表达式处，这个表达式的右值赋值给迭代器。</p>\n</li>\n<li>\n<p>next方法也可以接受参数，使用参数调用将会用参数值替换上一条yield表达式的左值，然后执行并返回当前yield表达式的右值</p>\n<pre><code> function* func() {\n     const y = yield 1;\n     yield 2 + y;\n }\n const generator = func();\n generator.next() // { value: 1, done: false }\n generator.next(100) // { value: 102, done: false }  \n</code></pre>\n</li>\n</ol>\n<h2>async function</h2>\n<p>async function是ES7提出的对异步调用的一种解决方案.通常可以通过下面的方式生成async function</p>\n<pre><code>async function foo() {\n}\nconst a = async function() {}\nlet obj = { async foo() { return 1; }}\nconst b = async () => { return 1 }\n</code></pre>\n<p>async函数执行结果返回<strong>promise</strong>.在async函数体内可以使用await来等待一个promise的状态变成settled(fulfilled or rejected)</p>\n<pre><code>async function foo() {\n  console.log('async func');\n  // await已经是一个微任务  \n  const ret = await 1\n  // const ret = await Promise.resove(1)\n  return ret;\n}\nfoo().then(value => {\n  console.log(value)\n})\nconsole.log('main')\n// 上面代码的输出是  async func  main 1\n</code></pre>\n<h3>通过generator + promise来模拟async function</h3>\n<p>async function可以通过generator + promise来模拟。</p>\n<pre><code>function spawn(genF) {\n  return new Promise((resolve, reject) => {\n    const itr = genF()\n    function step(nextFn) {\n        let next;\n        try {\n            next = nextFn()\n        } catch(e) {\n            return reject(e)\n        }\n        if(next.done) {\n            return resolve(next.value)\n        }\n        Promise.resolve(next.value).then(function(v) {\n            step(function(){ return itr.next(v) });\n        }, function(v) {\n            step(function() { return itr.throw(v); })\n        })\n    }\n    step(function() { return itr.next(undefined); })\n  })\n}\n</code></pre>\n<h2>Reflect</h2>\n<p>Reflect是一个内置对象，提供了一些方法来完成javascript的操作。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Reflect.apply(target, thisArg, args )</td>\n<td>用户给函数绑定this并执行</td>\n</tr>\n<tr>\n<td>Reflect.get(target, name, receiver)</td>\n<td>返回target上的name属性，没有undefined，如果name在target上设置了getter，则读取函数的this绑定receiver</td>\n</tr>\n<tr>\n<td>Reflect.set(target, name, value, receiver)</td>\n<td>设置target对象的name属性的值为value, 如果name属性有setter函数，则setter函数的this绑定receiver</td>\n</tr>\n<tr>\n<td>Reflect.has(obj,name)</td>\n<td>判断对象上是否有对应的属性 相当于 name in obj</td>\n</tr>\n<tr>\n<td>Reflect.deleteProperty(obj,name)</td>\n<td>删除对象的属性 相当于 delete obj[name]</td>\n</tr>\n<tr>\n<td>Reflect.construct(target, args)</td>\n<td>target是对象的构造函数，args是参数数组，相当于new target(...args)</td>\n</tr>\n<tr>\n<td>Reflect.getPrototypeOf(obj)</td>\n<td>返回对象的__proto__属性, 相当于Object.getPrototypeof(obj)</td>\n</tr>\n<tr>\n<td>Reflect.setPrototypeOf(obj,newProto)</td>\n<td>设置对象的原型， 相当于Object.setPrototypeOf(obj, newProto)</td>\n</tr>\n<tr>\n<td>Reflect.defineProperty(target,propertyKey, attributes)</td>\n<td>相当于Object.defineProperty, 定义对象的属性</td>\n</tr>\n</tbody>\n</table>\n<pre><code>const myObject = {\n    foo: 1,\n    get name() {\n        return this.name\n    }\n}\nconst test = {\n    name: 'haha'\n}\nReflect.get(myObject, 'name', test) // haha \n</code></pre>\n<h2>Set和Map</h2>\n<h3>Set</h3>\n<p>Set对象是值的集合，可以按照拆入的顺序迭代它的元素且Set中的元素是唯一的。</p>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set.prototype.size</td>\n<td>返回Set对象中的值的个数</td>\n</tr>\n<tr>\n<td>Set.prototype.add(value)</td>\n<td>在set对象尾部添加一个元素，<strong>返回该set对象</strong></td>\n</tr>\n<tr>\n<td>Set.prototype.clear()</td>\n<td>移除set对象内的所有元素</td>\n</tr>\n<tr>\n<td>Set.prototype.delete(value)</td>\n<td>移除set中与这个值相等的元素</td>\n</tr>\n<tr>\n<td>Set.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在set中</td>\n</tr>\n<tr>\n<td>Set.prototype.keys()</td>\n<td>返回键值的遍历器 <strong>遍历顺序是插入顺序</strong></td>\n</tr>\n<tr>\n<td>Set.prototype.values()</td>\n<td>返回键值的遍历器</td>\n</tr>\n<tr>\n<td>Set.prototype.entries()</td>\n<td>返回键值对的遍历器</td>\n</tr>\n<tr>\n<td>Set.prototype.forEach()</td>\n<td>使用回调函数遍历每个成员</td>\n</tr>\n</tbody>\n</table>\n<h3>WeakSet</h3>\n<p>WeakSet与Set类似</p>\n<ol>\n<li>WeakSet的成员只能是对象不能是其他类型的值。</li>\n<li>WeakSet对对象的引用是弱引用,不能阻止垃圾回收机制。</li>\n<li>WeakSet不支持遍历</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WeakSet.prototype.add(value)</td>\n<td>在WeakSet对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>\n</tr>\n<tr>\n<td>WeakSet.prototype.delete(value)</td>\n<td>移除WeakSet对象内的所有元素</td>\n</tr>\n<tr>\n<td>WeakSet.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在WeakSet中</td>\n</tr>\n</tbody>\n</table>\n<h3>Map</h3>\n<p>Map对象可以保存键值对并且能够记住键的原始插入顺序，任何值(对象或者原始值)都可以作为Map的一个键或者值。在频繁删除键值或者对键值对的顺序有要求的场景，使用Map对象更加合适。</p>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map(new Map(args))</td>\n<td>构造函数, 具有Iterator接口且每个成员都是一个双元素数组的数据结构可以作为Map的构造函数参数</td>\n</tr>\n<tr>\n<td>Map.prototype.size</td>\n<td>返回Map对象中的值的个数</td>\n</tr>\n<tr>\n<td>Map.prototype.set(key,value)</td>\n<td>设置键名对应的键值为value(存在键名则更新键值), <strong>返回当前的Map对象</strong></td>\n</tr>\n<tr>\n<td>Map.prototype.get(key)</td>\n<td>读取对应key的键值，没有key返回undefined</td>\n</tr>\n<tr>\n<td>Map.prototype.has(key)</td>\n<td>返回布尔值，判断该键是否存在Map中</td>\n</tr>\n<tr>\n<td>Map.prototype.delete(key)</td>\n<td>如果Map对象中存在该元素，则移除它并返回true否则返回false</td>\n</tr>\n<tr>\n<td>Map.prototype.clear()</td>\n<td>移除Map对象内的所有元素</td>\n</tr>\n<tr>\n<td>Map.prototype.keys()</td>\n<td>返回键名的遍历器<strong>遍历顺序是插入顺序</strong></td>\n</tr>\n<tr>\n<td>Map.prototype.values()</td>\n<td>返回键值的遍历器</td>\n</tr>\n<tr>\n<td>Map.prototype.entries()</td>\n<td>返回键值对的遍历器</td>\n</tr>\n<tr>\n<td>Map.prototype.forEach()</td>\n<td>使用回调函数遍历每个成员</td>\n</tr>\n</tbody>\n</table>\n<h3>WeakMap</h3>\n<p>WeakMap与Map类似。</p>\n<ol>\n<li>WeakMap的键值只能是对象不能是其他类型的值。</li>\n<li>WeakMap对对象的引用是弱引用,不能阻止垃圾回收机制。</li>\n<li>WeakMap不支持遍历</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法(属性)</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WeakMap.prototype.set(key,value)</td>\n<td>在WeakMap对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>\n</tr>\n<tr>\n<td>WeakMap.prototype.delete(value)</td>\n<td>移除WeakMap对象内的所有元素</td>\n</tr>\n<tr>\n<td>WeakMap.prototype.has(value)</td>\n<td>返回一个布尔值, 表示该值是否在WeakMap中</td>\n</tr>\n<tr>\n<td>WeakMap.prototype.get(key)</td>\n<td>读取对应key的键值，没有key返回undefined</td>\n</tr>\n</tbody>\n</table>\n<h2>node中模块加载机制</h2>\n<ul>\n<li>\n<p>路径解析(Resolution) 根据模块标识找出对应模块入口的绝对路径</p>\n<ul>\n<li>如果是文件，会自动按照后缀.js、.json、.node进行文件后缀补齐</li>\n<li>如果是目录 会查找目录下的package.json,读取main字段并加载指定的模块，如果没有package.json就尝试加载目录下的index.js、index.json、index.node</li>\n<li>非文件路径 非原生模块会按照node_modules目录逐级查找，在查找全局目录</li>\n</ul>\n</li>\n<li>\n<p>加载(Loading) 如果是JSON或者js文件,将文件读入内存。如果是内置原生模块将其动态链接库加载动当前Node.js进程</p>\n</li>\n<li>\n<p>包装(Wrapping) 将文件内容包装进一个函数，建立模块作用域，将exports, require, module等作为参数注入</p>\n<pre><code>  (function(exports, require, module, __filename, __dirname) {\n      // Module code actually lives in here\n  });\n</code></pre>\n</li>\n<li>\n<p>执行(Evaluation) 传入参数，执行包装得到的参数</p>\n</li>\n<li>\n<p>缓存(Caching) 函数执行完毕后，将module缓存起来，并将module.exports作为require的返回值</p>\n</li>\n</ul>\n<h2>node部署实现大规模并发处理</h2>\n<ul>\n<li>容器化技术 使用Docker或者Kubernetes部署多个Node.js实例</li>\n<li>使用反向代理技术将请求转发给多个Node.js实例</li>\n<li>使用PM2(cluster)管理node.js进程的启动, PM2会创建多个子进程来运行同一个应用程序的多个实现，每个子进程会监听相同的端口</li>\n</ul>\n<h2>monorepo</h2>\n<p>monorepo是一种单一仓库的软件开发结构，通过将相同业务的多个项目集合一个项目中进行版本控制。主要解决了以下的问题:</p>\n<ul>\n<li>代码共享 对于跨项目的共享模块、组件、库有好处</li>\n<li>一致的构建和部署 monorepo为项目提供一致的构建和部署流程，减少项目之间的差异</li>\n<li>统一的版本控制 所用项目共享相同的版本控制历史，使得跨项目的版本控制更好管理能统一的进行版本回退等</li>\n<li>原子提交 提交是原子性的，避免了跨项目的不一致性</li>\n<li>协同开发 开发者可以很容易的访问和修改整个仓库的代码，提供了工作的效率</li>\n<li>统一的依赖管理 monorepo允许仓库级别的管理依赖项，确保所有版本使用相同的依赖项版本</li>\n<li>一体化测试 可以实施一体化测试</li>\n</ul>\n<h2>webpack模块联邦</h2>\n<p>模块联邦用于解决模块的共享和加载的问题。它允许你在不同的webpack构建之间共享JavaScript模块，相比npm包管理的方式它实现更加灵活的代码共享方式，可以实现动态加载并减少的依赖管理等问题</p>\n<pre><code>// 主应用\nconst ModuleFederationPlugin = require(\"webpack/lib/container/ModuleFederationPlugin\");\n\nmodule.exports = {\n    // ...\n    plugins: [\n        new ModuleFederationPlugin({\n            name: \"mainApp\", // 主应用的名字\n            remotes: { // 远程模块配置 名称入口文件\n                remoteApp: \"remoteApp@http://localhost:3001/remoteEntry.js\",\n            },\n            // 共享模块\n            shared: [\"lodash\"],\n        }),\n    ],\n};\n\n// 远程应用\nconst ModuleFederationPlugin = require(\"webpack/lib/container/ModuleFederationPlugin\");\n\nmodule.exports = {\n    // ...\n    plugins: [\n        new ModuleFederationPlugin({\n            name: \"remoteApp\", // 远程应用的名字\n            filename: \"remoteEntry.js\", // 远程应用的入口文件\n            exposes: { // 指定要共享出去的模块\n                \"./Button\": \"./src/Button\",\n            },\n            // 共享模块\n            shared: [\"lodash\"],\n        }),\n    ],\n};\n\n// 主应用中的代码 动态加载远程模块\n\nconst remoteApp = import(\"remoteApp/Button\");\n\nremoteApp.then((Button) => {\n    // 使用远程模块\n    const button = new Button();\n    document.body.appendChild(button);\n});\n</code></pre>\n<h3>webpack模块联邦的优势</h3>\n<ul>\n<li>动态加载模块 模块联邦可以在运行时加载模块，从而实现更加灵活的模块加载</li>\n<li>模块共享 不需要通过npm管理依赖项，降级了项目依赖关系的复杂性同时提高的构建效率</li>\n<li>独立部署和自治  不同应用可独立部署和自治</li>\n<li>可细粒度控制 选择性的共享模块</li>\n</ul>\n<h2>babel编译React代码生成AST的过程</h2>\n<ul>\n<li>词法分析(Lexical Analysis) 将源代码字符串分解成一系列令牌，包括JSX语法中的标签、属性等</li>\n<li>语法分析(Parsing) 将令牌序列转换成抽象语法树(AST),其中每个节点代表JSX的元素属性等</li>\n<li>转换(Transformation) 对AST进行遍历修改，将JSX语法转换成对应的JavaScript代码(这里可以添加babel插件,  @babel/preset-env  @babel/preset-react @babel/plugin-transform-runtime)</li>\n<li>生成(Code Generation) 将修改后的AST装换成最终的JavaScript代码</li>\n</ul>\n<h2>造成内存泄露一些情况</h2>\n<ul>\n<li>\n<p>未释放的事件监听器 当DOM元素被删除和替换时，未移除相应事件的监听器，导致相应的DOM节点无法回收</p>\n<pre><code>  var element = document.getElementById('example');\n  element.addEventListener('click', function() {\n      // 一些处理代码\n  });\n\n  // 移除DOM元素\n  document.body.removeChild(element);\n</code></pre>\n</li>\n<li>\n<p>循环引用 两个对象相互引用，当对象不在使用的时候但是他们的引用关系让JavaScript引擎认为他们仍在使用中，所以不会被回收</p>\n<pre><code>  let obj1 = {};\n  let obj2 = {};\n\n  obj1.ref = obj2;\n  obj2.ref = obj1;\n\n  // 解除引用\n  obj1 = null;\n  obj2 = null;\n</code></pre>\n</li>\n<li>\n<p>定时器/IntersectionObserver/ResizeObserver/MutationObserver 等在不需要的时候 需要清除</p>\n</li>\n<li>\n<p>Promises，Observables，EventEmitters 设置监听器的模型都有可能造成内存泄露</p>\n</li>\n<li>\n<p>全局对象存储 相当于不断增加内存</p>\n</li>\n<li>\n<p>新增DOM结构</p>\n</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"http://exploringjs.com/es2016-es2017/ch_async-functions.html\">Async functions</a><br>\n<a href=\"https://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">async函数的实现原理</a><br>\n<a href=\"http://www.ayqy.net/blog/node%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/\">Node模块加载机制</a></p>","fields":{"readingTime":{"text":"24 min read"}},"frontmatter":{"title":"JavaScript基础梳理","date":"2023-08-10","tags":"JavaScript","path":"/base-js-summary","top":null,"summary":null}}},{"node":{"id":"4e0a2370-65e7-5150-acb4-0d6001cad4b2","html":"<h2>盒模型</h2>\n<p>当对一个元素进行布局的时候,渲染引擎会根据CSS-Box模型(box-sizing)将对应元素表示为一个矩形盒子.理解好盒模型能让我们更好的理解生成元素的大小和布局.生成布局的盒子由以下的属性决定\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/705cc/box.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABkklEQVQoz52S3UobQRiGc1VegFDBE4Vqq9Rjr6DQIz30xDsoQknbg0CCFgqKmFIFNdskNhip1F+oFsTEg6wmutn5e2RmXJKupaWd5Zllvu/dl3dnJhNFEVJoRKwccSzdWynDddimVquxt1en2bxCSeM1Xa8RQvV9KxFCkAnblxRKU+SDZxSCCUe+9JzF8gRvi2PMZ4eZWxjkzepTV7O9ROeZJLc9yqfdWbQ2ZJqtI16vDXDW+MKPS0vg+HlVoX6wxsfVLMvF92xWljhvlh/6Pe1Zo8LJxTpLwTSxiLzhu/Vh7DDKToB2S9rXXfa/HfB1p87h91NfNH3gtTbZys4rYnHnDbOfnyCVdBj7GI1BI6Wg02kThi1ubzu9XgIapTTd+Ibl6st+wyGUUkgpfQhjHOmR1Pv7zlB0eoaN1qEztGkspFP8AatVUhGlEyZ7iP7NHqXX6Zq2yWGlmuxhePxwymXHr6f4d84bVU4vNvgQTCNE19/D/PYL8qVxd8f+lUJpktzWCMXdGbQyZKRUj3/jfwHuAf3PF8lVSwfnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"盒模型\"\n        title=\"盒模型\"\n        src=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/00d43/box.png\"\n        srcset=\"/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/63868/box.png 250w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/0b533/box.png 500w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/00d43/box.png 1000w,\n/blog/static/36bd581a4099780e9b0bd11f1e4ac71f/705cc/box.png 1071w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nbox-sizing是设置盒模型的属性，分为IE盒模型(border-box)和W3C标准盒模型(content-box).</p>\n<ol>\n<li>W3C标准盒模型(content-box): 属性width和height只包含content, 不包含 padding border, 标准盒模型的实际宽度 = border-left + padding-left + content(width) + padding-right + border-right</li>\n<li>IE盒模型(border-box):  属性width 包含content, padding, border. IE盒模型的实际宽度 = content(width)</li>\n</ol>\n<h2>布局</h2>\n<h3>Box</h3>\n<p>Box是CSS布局的基本单位.元素的类型和display共同决定着这个Box类型.不同的Box类型会参与到不同的格式化上下文中.</p>\n<ul>\n<li>block-level: display属性为 block, table, list-item.</li>\n<li>inline-level: display属性为 inline-block, inline-table,inline</li>\n</ul>\n<h3>布局模式</h3>\n<p>在进行布局的时候，浏览器采用一种dirty位系统，如果某个呈现器（需要渲染布局的元素）发生了更改，将其自身或者子代标记为dirty，则需要布局，在进行布局的时候，元素会确认自己宽度和高度.</p>\n<ol>\n<li>父呈现器确认自己的宽度</li>\n<li>父呈现器依次处理子呈现器\n<ol>\n<li>放置子呈现器（设置x y 坐标)</li>\n<li>如果有必要，调用子呈现器的布局</li>\n</ol>\n</li>\n<li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用</li>\n<li>将dirty设置为false</li>\n</ol>\n<h3>布局上下文</h3>\n<p>布局上下文决定在渲染容器中各种盒子的布局方式,主要有以下几种:</p>\n<ul>\n<li>块级格式化上下文(BFC)</li>\n<li>行级格式化上下文(IFC)</li>\n<li>网格布局格式化上下文(GFC)</li>\n<li>自适应格式化上下文(FFC)</li>\n</ul>\n<h4>BFC(Block formatting context)</h4>\n<p>BFC(块级格式化上下文)规定内部的block-level box的布局方式</p>\n<h5>生成规则</h5>\n<ol>\n<li>根元素，即HTML元素</li>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为inline-block、table-cell、table-caption</li>\n<li>position的值为absolute或fixed</li>\n</ol>\n<h5>布局规则</h5>\n<ol>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此(浮动元素不会撑开父元素的高度，父元素变成BFC的时候就会包含浮动元素的高度)。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。不与float box重叠.</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h5>作用</h5>\n<ul>\n<li>自适应两栏布局</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n<li>可以包含浮动元素——清除内部浮动</li>\n<li>属于不同的BFC时可以阻止margin重叠</li>\n</ul>\n<h4>FFC(flexbox)</h4>\n<p>FFC就是CSS3所说的弹性盒子布局. 详细的使用指南可以参考这篇<a href=\"https://css-tricks.com/snippets/a-guide-to-flexbox/\">A Complte Guide to Flexbox </a></p>\n<h2>定位</h2>\n<p>Box一共有以下三种定位方式:</p>\n<ol>\n<li>Normal flow: 包括块级的格式上下文, 行级的格式化上下文, 相对定位的(position relative)的块级和inline-block</li>\n<li>Float: 这种情况脱离了文档流,但是会影响之后元素的content(环绕)</li>\n<li>绝对定位(position absolute): 脱离文档流, 不会影响之后元素的位置和内容</li>\n</ol>\n<h3>position</h3>\n<p>position相关属性及含义</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>absolute</td>\n<td align=\"center\">绝对定位,相对于static以外的第一个父元素进行定位</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td align=\"center\">绝对定位,相对于浏览器窗口进行定位</td>\n</tr>\n<tr>\n<td>relative</td>\n<td align=\"center\">相对定位,相对与正常位置进行定位</td>\n</tr>\n<tr>\n<td>static</td>\n<td align=\"center\">默认值,没有定位.</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td align=\"center\">粘性布局 可以认为是固定定位和相对定位的结合.元素在跨越特定阈值前为相对定位,之后为固定定位</td>\n</tr>\n</tbody>\n</table>\n<h3>float</h3>\n<p>浮动是一种脱离文档流，对之后或者之前的盒子中的content flow产生影响的一个属性</p>\n<ul>\n<li>区别于绝对定位，绝对定位也是脱离文档流 但是它不会对之后之前的盒子产生影响</li>\n<li>浮动元素会产生一个块级框,即使它本身是一个行内元素</li>\n</ul>\n<h4>浮动规则</h4>\n<ol>\n<li>浮动元素的左右外边界不能超出其包含块的左右内边界</li>\n<li>浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动的(或右浮动)元素的右（或左)边界，除非后出现的浮动元素的顶端在先出现浮动元素的底端下面（防止浮动元素之间的覆盖）</li>\n<li>左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边 右浮动元素的左外边界不会在其左边左浮动元素的右外边界的左边</li>\n<li>一个浮动元素的顶端不能比其父元素的内顶端更高   浮动元素的顶端不能比之前所有的浮动元素的顶端或块级元素更高</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/46e51/float1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.799999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA10lEQVQY05WRzWrCYBBFP3BR9z5ki1YQmtRW81NR69JNgw/g+4jvkWzkm5EocU6JaaVdBNoLZzNwL/cyLh88omGIPAXtBCEyGiHvK+RwQFQR7xGRG6pKnue40jn4K50OlCVXVRVcLmDGt+pQx3SKLZfYfN7OYoGlb9hHdjPbT75C66bOBwEkCRZF7cQxNh7DZsNpv0f6fWw4xO4fsNkMO5+bQO9x1X8m93rYdssvz10XylMzuW6o4TOSpkgct5MkyMsrkmXIbodGUXObTJD1+vooPR4pioJPcH1oF5VRdrwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"float示例1\"\n        title=\"float示例1\"\n        src=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/00d43/float1.png\"\n        srcset=\"/blog/static/f34f810f7eb4c2b060f907a520df70cd/63868/float1.png 250w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/0b533/float1.png 500w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/00d43/float1.png 1000w,\n/blog/static/f34f810f7eb4c2b060f907a520df70cd/46e51/float1.png 1003w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里例子中三个元素均为浮动元素,包含块的宽度固定,由于规则2 导致第二个浮动元素bbb移动到aaa下面.由于4的限制，浮动元素ccc的顶端是跟bbb一致的，不能超过bbb或者跟aaa平齐.<br>\n5. 如果源文档中一个浮动元素之前出现了另一个元素 浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高<br>\n6. 左浮动元素必须向左尽可能的远 右浮动元素必须向右尽可能的远 位置越高 就会向左或者向右尽可能的远<br>\n7. 浮动元素与正常内容流重叠的情况:\n1. 行内框与一个浮动元素重叠的时候，其边框 背景 和内容都在该浮动元素之上显示.\n2. 块框与一个浮动元素重叠时候 其边框和背景在该浮动之下显示 内容在浮动元素之上显示</p>\n<h2>居中</h2>\n<p>可以阅读下自己之前翻译的一篇文章<a href=\"https://www.cnblogs.com/tiantianwaigong/p/5291370.html\">CSS居中完全指南翻译</a></p>\n<h2>滚动</h2>\n<p>当元素的子元素比父元素高且父元素overflow设置为scroll的时候，子元素在移动过程中会触发父元素的scroll事件</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th align=\"center\">定义</th>\n<th align=\"right\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clientHeight</td>\n<td align=\"center\">与元素的高度有关,代表元素的高度加上padding(不包括border、水平滚动条的高度、margin),对于inline元素该属性的值为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>clientWidth</td>\n<td align=\"center\">与clientHeight相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetHeight</td>\n<td align=\"center\">与元素的高度有关,不同于clientHeight,它包括border、水平滚动条的高度,不包括margin.对于inline元素该属性为0</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>offsetWidth</td>\n<td align=\"center\">与offsetWidth相似</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>scrollHeight</td>\n<td align=\"center\">当出现滚动时,scrollHeight代表元素内容的高度(包括在不在内容区域的内容)  当一个元素出现滚动, 它的相关属性 判读元素是否滚动到底部 scrollHeight - scrollTop === clientHeight</td>\n<td align=\"right\">只读</td>\n</tr>\n<tr>\n<td>scrollTop</td>\n<td align=\"center\">当元素出现滚动的时候,scrollTop代表元素可见内容距离该元素顶部的高度.不存在滚动条的时候,scrollTop为0</td>\n<td align=\"right\">可读可写</td>\n</tr>\n<tr>\n<td>offsetTop</td>\n<td align=\"center\">获取当前元素跟offsetParent父元素顶部(position不为static的父元素)的距离,不随滚动变化</td>\n<td align=\"right\">只读</td>\n</tr>\n</tbody>\n</table>\n<h3>实现滚动的思路</h3>\n<ol>\n<li>锚点 通过在页面中设置锚点能在实现跳转到页面相应位置的目的,这种方式也比较好操作.缺点是需要在url中添加其他信息</li>\n<li>scrollTop 直接设置scrollTop来实现定位，如果scrollTop设置超过元素的scrollHeight,元素会被定位到最底部</li>\n<li>scrollIntoView(alignToTop)</li>\n</ol>\n<ul>\n<li>alignToTop默认是true 通过item.scrollIntoView()/item.scrollIntoView(true)会使元素的顶部跟可视区域的顶部对齐</li>\n<li>item.scrollIntoView(false)会使元素的底部跟可视区域的底部对齐</li>\n</ul>\n<h2>文本溢出省略显示</h2>\n<h3>单行文本溢出</h3>\n<pre><code>text-overflow: ellipsis:\noverflow: hidden;\nwhite-space: nowrap;  \n</code></pre>\n<h3>多行文本溢出</h3>\n<pre><code>display: -webkit-box;\n-webkit-box-orient: vertical;\n// 行数\n-webkit-line-clamp: 2;\noverflow: hidden;\n</code></pre>\n<h2>动画</h2>\n<ul>\n<li>\n<p>js方案: window.requestAnimationFrame, 通过cancelAnimationFrame可以取消动画</p>\n</li>\n<li>\n<p>css方案: keyframes</p>\n<pre><code>// 声明关键帧动画\n@keyframes slidein {\n  // 起始\n  from {\n    transform: translateX(0%);\n  }\n\n  to {\n    transform: translateX(100%);\n  }\n}\n// 使用动画\np {\n  animation-duration: 3s;\n  animation-name: slidein;\n}\n</code></pre>\n</li>\n</ul>\n<h2>移动端适配方案</h2>\n<h3>viewport</h3>\n<ul>\n<li>布局视窗  浏览器窗口css布局区域，默认viewport为980</li>\n<li>视觉视窗  设备显示网页的区域</li>\n<li>理想视窗  针对当前设备最理想的展示页面的视窗，不会出现横向滚动条，理想视窗也是终端设备屏幕的宽度</li>\n</ul>\n<h3>viewport设置</h3>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no, minimum-sacle=1, maximum-scale=1\" >\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义</th>\n<th>设置值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>width</td>\n<td>视口的宽度(像素)</td>\n<td>正整数或者device-width</td>\n</tr>\n<tr>\n<td>height</td>\n<td>视口的高度(像素)</td>\n<td>正整数或者device-height</td>\n</tr>\n<tr>\n<td>initial-scale</td>\n<td>初始缩放值</td>\n<td>整数或者小数，小数为缩放</td>\n</tr>\n<tr>\n<td>maximum-scale</td>\n<td>最大缩放值</td>\n<td>整数或者小数</td>\n</tr>\n<tr>\n<td>minimum-scale</td>\n<td>定义缩放最小值</td>\n<td>整数或者小数</td>\n</tr>\n<tr>\n<td>user-scalable</td>\n<td>定义用户是否可以缩放</td>\n<td>yes/no</td>\n</tr>\n</tbody>\n</table>\n<h3>布局方案</h3>\n<p>适配的目的是不同的设备上拥有统一的界面，在设置布局视窗等于视觉视窗后，通过调节页面字体大小来实现适配目的</p>\n<h4>rem方案</h4>\n<p>rem是相对单位，以HTML元素的font-size为比例进行计算</p>\n<pre><code>function setRem() {\n    // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改\n    const scale = document.documentElement.clientWidth / 750;\n    document.documentElement.style.fontSize = scale + 'px';\n}\nsetRem();\nwindow.onresize = setRem;\n</code></pre>\n<h4>vw/vh方案</h4>\n<p>vw/vh方案是根据视口的宽度和高度进行适配 1vw等于window.innerWidth的1%  如果设计稿是750 1vw=7.5px</p>\n<h4>响应式布局</h4>\n<p>通过媒体查询实现不同屏幕上的适配</p>\n<h2>css优先级</h2>\n<pre><code>!important > 行内样式 > id > class(伪类 属性) > 标签 > * > 继承 > 默认\n</code></pre>\n<h2>三列布局</h2>\n<p>三列布局是左右固定宽度，中间元素宽度自适应的布局方案</p>\n<h3>流体布局</h3>\n<pre><code>&#x3C;div id=\"container\">\n  &#x3C;div id=\"left\">left&#x3C;/div>\n  &#x3C;div id=\"right\">right&#x3C;/div>\n  &#x3C;div id=\"main\">main&#x3C;/div>\n&#x3C;/div>\n#left {\n  width: 50px;\n  float: left;\n  height: 100px;\n}\n#right {\n  width: 50px;\n  float: right;\n  height: 100px;\n}\n#main {\n  margin: 0 50px;\n  height: 100px;\n}  \n</code></pre>\n<h3>flex布局</h3>\n<pre><code>&#x3C;div id=\"container\">\n  &#x3C;div id=\"left\">left&#x3C;/div>\n  &#x3C;div id=\"main\">main&#x3C;/div>\n  &#x3C;div id=\"right\">right&#x3C;/div>\n&#x3C;/div>\n#container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n#left {\n  width: 50px;\n  height: 100px;\n}\n#right {\n  width: 50px;\n  height: 100px;\n}\n#main {\n  flex: 1;\n  height: 100px;\n}\n</code></pre>\n<h3>BFC方案</h3>\n<p>BFC不与float区域重合</p>\n<pre><code>&#x3C;div class=\"container\">\n    &#x3C;div class=\"left\">left&#x3C;/div>\n    &#x3C;div class=\"right\">right&#x3C;/div>\n    &#x3C;div class=\"main\">main&#x3C;/div>\n&#x3C;/div>\n#left {\n  float: left;\n  width: 50px;\n  height: 100px;\n}\n#right {\n  width: 50px;\n  float: right;\n  height: 100px;\n}\n#main {\n  /* 生成bfc */\n  overflow: scroll;\n}  \n</code></pre>\n<h3>双飞翼布局</h3>\n<p>使用负margin可以让主体先加载，其实是float的变式</p>\n<pre><code>&#x3C;div class=\"container\">\n    &#x3C;div class=\"content\">\n      &#x3C;div class=\"main\">main&#x3C;/div>\n    &#x3C;/div>      \n    &#x3C;div class=\"left\">left&#x3C;/div>\n    &#x3C;div class=\"right\">right&#x3C;/div>\n&#x3C;/div>\n#content {\n  float: left;\n  width: 100%\n}\n#left {\n  float: left;\n  width: 50px;\n  margin-left: -100%;\n  height: 100px;\n}\n#right {\n  width: 50px;\n  float: right;\n  margin-left: -100px\n}\n#main {\n  margin-left: 50px;\n  margin-right: 50px;\n}\n</code></pre>\n<h3>圣杯布局</h3>\n<pre><code>&#x3C;div class=\"container\">\n    &#x3C;div class=\"main\">main&#x3C;/div>  \n    &#x3C;div class=\"left\">left&#x3C;/div>\n    &#x3C;div class=\"right\">right&#x3C;/div>\n&#x3C;/div>\n #container {\n  margin-left: 100px;\n  margin-right: 100px;\n}\n#left {\n  float: left;\n  width: 100px;\n  margin-left: -100%;\n  height: 100px;\n  position: relative;\n  left: -100px;\n}\n#right {\n  width: 100px;\n  float: left;\n  position: relative;\n  right: -100px;\n  margin-left: -100px\n}\n#main {\n  float: left;\n  width: 100%;\n}\n</code></pre>\n<h3>table布局</h3>\n<pre><code>&#x3C;div id=\"container\">\n  &#x3C;div id=\"left\">left&#x3C;/div>    \n  &#x3C;div id=\"main\">main&#x3C;/div>\n  &#x3C;div id=\"right\">right&#x3C;/div>\n&#x3C;/div>\n#container {\n  display: table;\n  width: 100%;\n}\n#left, #right, #main {\n  display: table-cell;\n}\n#left {\n  width: 100px;\n}\n#right {\n  width: 100px;\n}\n</code></pre>\n<h3>绝对定位布局</h3>\n<pre><code>&#x3C;div class=\"container\">\n  &#x3C;div class=\"main\">main&#x3C;/div>  \n  &#x3C;div class=\"left\">left&#x3C;/div>\n  &#x3C;div class=\"right\">right&#x3C;/div>\n&#x3C;/div>\n.container {\n  width: 100%;\n  position: relative;\n}\n.left {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100px;\n  background: red;\n}\n.right {\n  position: absolute;\n  right: 0;\n  top: 0;\n  background: blue;\n  width: 100px;\n}\n.main {\n  background: yellow;\n  margin: 0 100px;\n}\n</code></pre>\n<h2>css选择器</h2>\n<pre><code>td:nth-child(2n+1) // 奇数行\ntd:nth-child(2n) // 偶数行\n</code></pre>\n<h2>用css画图形</h2>\n<pre><code>&#x3C;div id=\"container\">\n&#x3C;/div>\n\n// css画出个圆形\n#container {\n  width: 100px;\n  height: 100px;\n  background: blue;\n  border-radius: 50%;\n}\n\n// css画一个半圆\n#container {\n  width: 100px;\n  height: 50px;\n  border-radius: 100px 100px 0 0;\n  background: blue;\n}\n\n// css画一个四分之一圆\n#container {\n  width: 100px;\n  height: 100px;\n  border-radius: 100px 0 0 0;\n  background: blue;\n}\n// css 画一个椭圆\n#container {\n  width: 100px;\n  height: 50px;\n  background: blue;\n  border-radius: 100px/50px;\n}\n\n// css画一个三角形\n#container {\n  width: 0px;\n  height: 0px;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid black;\n}\n\n// css画一个左上三角\n #container {\n  width: 0px;\n  height: 0px;\n  border-top: 100px solid red;\n  border-right: 100px solid transparent; \n}\n</code></pre>\n<h2>参考链接</h2>\n<p><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#4_1\">浏览器的工作原理:新式网络浏览器幕后揭幕</a><br>\n<a href=\"https://www.zhihu.com/question/24529373/answer/29135021\">css脱离文档流是什么意思</a><br>\nCSS权威指南<br>\n<a href=\"https://www.w3.org/TR/CSS21/visuren.html\">Visual formatting model</a><br>\n<a href=\"https://juejin.im/post/5909db2fda2f60005d2093db\">关于CSS-BFC深入理解</a><br>\n<a href=\"https://juejin.cn/post/6953091677838344199\">移动端适配的5种方案</a></p>","fields":{"readingTime":{"text":"17 min read"}},"frontmatter":{"title":"CSS基础总结","date":"2023-08-08","tags":"CSS","path":"/css-basic","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":2,"pageCount":16,"additionalContext":{"pageAllCount":91}}},
    "staticQueryHashes": []}