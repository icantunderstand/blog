{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/h5-performance",
    "result": {"data":{"markdownRemark":{"html":"<p>h5性能优化可以总结为如下的几个方向:</p>\n<ul>\n<li>将请求时间线上的行为提前执行</li>\n<li>将请求时间线上不紧急的后置</li>\n<li>将资源从最近的位置提供给页面</li>\n</ul>\n<p>在讨论h5加载性能的时候主要有以下角色:</p>\n<ul>\n<li>Native容器</li>\n<li>用户(开发的视角)</li>\n<li>服务端(数据 页面)</li>\n<li>h5页面</li>\n</ul>\n<p>本文会结合优化的方向从不同角色的角度总结h5优化的一些通用方案。</p>\n<h2>Native容器优化</h2>\n<ul>\n<li>Webview池 通过提前初始Webview和Webview复用降低Webview初始化时间</li>\n<li><a href=\"https://icantunderstand.cn/cross-platform-prefetch\">数据预取</a> 容器侧提供数据预取能力，提前数据加载</li>\n<li>DNS连接 容器提前建立与h5页面相同域名的DNS链接</li>\n<li><a href=\"https://icantunderstand.cn/cross-platform-offline\">离线包</a> 通过离线包可以直接加载提前下载好的本地资源展示</li>\n</ul>\n<h2>h5页面内优化</h2>\n<ul>\n<li>预连接 dns-pretch, preconnect</li>\n<li>资源包拆分 框架和业务代码进行拆包，框架层使用更长的缓存策略来减少框架代码的请求</li>\n<li>页面资源加载 图片懒加载、路由懒加载、小图内联</li>\n<li>js执行优化 缓存计算结果、WebWorker、GPU渲染、长列表</li>\n</ul>\n<h2>服务端优化</h2>\n<ul>\n<li>api聚合服务 前端侧可以通过一个请求聚合多个后端请求，后端在内网完成数据的聚合</li>\n<li>CDN容灾策略</li>\n<li>服务端渲染 可以完成数据请求组装和页面html的流式返回(renderToNodeStream)</li>\n</ul>\n<h2>用户</h2>\n<ul>\n<li>功能取舍 低端机放弃一些功能保证页面更流畅</li>\n<li>骨架屏 使用骨架屏在数据未返回时给用户更好的体验</li>\n<li><a href=\"https://blog.ihanai.com/2020/12/comparison-of-solution-for-same-layer-render.html\">同层渲染</a></li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://tech.meituan.com/2017/06/09/webviewperf.html\">WebView性能、体验分析与优化</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work\">渲染页面：浏览器的工作原理</a>\n<a href=\"https://blog.ihanai.com/2020/12/comparison-of-solution-for-same-layer-render.html\">同层渲染方案比较</a></p>","frontmatter":{"date":"2021-07-25","path":"/h5-performance","title":"web性能优化总结"}}},"pageContext":{"readingTime":"3 min read"}},
    "staticQueryHashes": []}