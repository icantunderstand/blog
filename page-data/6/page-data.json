{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/6",
    "result": {"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"bea11739-7593-5a8a-b65f-c2cc62d73599","html":"<p>这里记录下2022读过的书，也是通过记录来督促自己丰富自己的眼界</p>\n<p>2022年已阅读: 40本</p>\n<p>2022读书感悟:\r\n最开始以为读书能看懂世界，觉得能增加所谓的阅历，其实发现多个看世界的视角就好</p>\n<p>推荐指数0 - 5(带有个人的喜好)</p>\n<p>0 ~ 3 不推荐 踩雷\r\n3.5 ~ 3 一般 有时间可以看看，没时间就看下书的目录翻翻\r\n4  推荐 看后感觉不错，有内容收获\r\n4.5 很推荐 收获很多或者内容精彩\r\n5 极力推荐  佳作</p>\n<h2>《半小时漫画历史系列》- 陈磊</h2>\n<h3>推荐指数 5</h3>\n<p>原来发现历史是这么有趣，原来晦涩的朝代故事在笔者轻松的表达下竟然那么引人入胜，非常适合在闲暇的时候当历史简版读物来看。</p>\n<h2>《动物农场》- 乔治·奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>经典之作。这本书描写了动物农场的一场反抗活动，对现实社会有影射意义，思考我们是不是也在一个农场中，只是压迫的程度大小，要跳出来看自己的生活。</p>\n<h2>《1984》- 乔治.奥威尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>是看完动物农场才看的《1984》. 书中塑造了一种恐怖绝望的氛围会跟着主人公体验到从拥有希望到绝望的过程，在小说的故事中文明、历史似乎都可以被改写。读完会有疑惑就是书中描绘的社会是否会在现实中呈现，如果生活在那样的社会应该是十分的压抑的。</p>\n<h2>《为什么是中国》- 金一南</h2>\n<h3>推荐指数 4</h3>\n<p>这本书主要介绍中国近代以来的发展历史，其实作为中国人会感觉到自豪，中国在社会实践上走的是一条充满实践的道路</p>\n<h2>《胜者思维》- 金一南</h2>\n<h3>推荐指数 4.5</h3>\n<p>本书中金一南通过对中国历史发展从军事的角度进行总结，一些思路在其他的领域也很有价值，比如领导者的领导作用、权力的下放与担责</p>\n<h2>《认知觉醒: 开启自我改变的原动力》- 周岭</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中的对思维方式表达改变了我之前对思维方式的思考，思维是可以训练，我们对自己也不应该固步自封，很推荐看这本。</p>\n<h2>《柳林风声》- 肯尼斯·格雷厄姆</h2>\n<h3>推荐指数 4.5</h3>\n<p>这是一本适合大人和孩子一起看的童话书，书中的小动物形象跃然纸上，有的时候你会为书中的蛤蟆扼腕叹息，认为它罪有应得，会喜欢上对人和善的鼹鼠。在阅读的过程中仿佛你就进入了这个童话的世界，跟着动物们一起探索，历险。</p>\n<h2>《时间的形状:相对论史话》- 汪洁</h2>\n<h3>推荐指数 5</h3>\n<p>非常通俗易懂的科普读物 作者通过讲故事的方式把比较硬核的理论通俗易懂地讲出来。了解到相对论等理论的发展过程,发现人类的探索欲也觉得人类很渺小.这是一本充满科学内核的科普“小说”。称它为小说是因为你会被一个个故事所吸引。非常推荐</p>\n<h2>《宇宙的琴弦》- 格林</h2>\n<h3>推荐指数 3.5</h3>\n<p>弦论的科普读物。书中的论证的过程和思考的方式有一定的启发作用</p>\n<h2>《中国新基建：未来布局与行动路线》</h2>\n<h3>推荐指数 3.5</h3>\n<p>这本书比较全面地介绍了新基建的方向、图谱、路径。需要意识到与别人的差距也要切实的看到中国的进度，建立中国自信</p>\n<h2>《花猫三丫上房了》 - 叶广岑</h2>\n<h2>《土狗老哥闯祸了》 - 叶广岑</h2>\n<h2>《耗子大爷起晚了》- 叶广岑</h2>\n<h3>推荐指数 4.5</h3>\n<p>非常生动的童年故事，读起来会有很多温馨的瞬间。不是童话却有童话的感觉</p>\n<h2>《这就是中国: 走向世界的力量》 - 张维为</h2>\n<h3>推荐指数 4.5</h3>\n<p>这本书的内容很多，值得反复阅读。主要包括我们是怎么崛起的、我们为什么会崛起、我们的制度优势、需要建立中国自信(有自己的视角看问题和解读问题，建立自己的话语体系)等。在开始阅读的时候会觉得鸡血貌似多了一点，在逐渐阅读大部分后发现自己之前的一些想法不够成熟。书中的视角是从国家的角度来阐释发展，其实映射到个人也有一定的价值。非常推荐。</p>\n<h2>《超越期待：松浦弥太郎的人生经营原则》- 松浦弥太郎</h2>\n<h3>推荐指数 2</h3>\n<p>书的内容围绕着作者的人生态度和处事原则的细致总结，读起来相对来说缺少面的陈述，不推荐</p>\n<h2>《献给阿尔吉侬的花束》 - 丹尼尔·凯斯</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完有些伤感，小说通过日记的方式叙述查理从不聪明到聪明又回归到愚钝的状态，作者对心理变化的描述入微，读起来感觉在跟查理经历着这一切。这本书有许多的现实反射，比如</p>\n<ul>\n<li>查理的妈妈小时候对查理的不认同，导致查理性格上的讨好和迫切的希望获得别人的认可，可见在孩子幼年的时候塑造一个健全的人格的重要性</li>\n<li>如何接受和认识自身的问题 在没变聪明之前查理过得很开心，在经历了变聪明又变不聪明之后查理的心态无法回到之前的状态，这里也情有可原。文中有两个查理体现在聪明程度的差异，在我们自身上是否在其他方面也有另一个查理呢，在暗处观察着自己。</li>\n</ul>\n<h2>《西方哲学史:从古希腊到当下》- 奎纳尔·希尔贝克 尼尔斯·吉列尔</h2>\n<h3>推荐指数 4.5</h3>\n<p>整本书比较详细的描写了人类历史发展阶段的哲学思考过程.我们现在的社会发展成当前的模式是在前人的思考基础上的,从这个角度去阅读和理解本书是一个不错的角度</p>\n<h2>哪有没时间这回事(白金版) - 纪元</h2>\n<h3>推荐指数 3</h3>\n<p>对时间的管理上有一定的启发</p>\n<h2>聪明的投资者(第四版) - 本杰明·格雷格姆 贾森·兹威格</h2>\n<h3>推荐指数 4.5</h3>\n<p>价值投资的观点并不过时。书中主要介绍格雷厄姆对价值，对投资的一些思考。</p>\n<h2>股票大作手回忆录 埃德温·勒菲弗</h2>\n<h3>推荐指数 3.5</h3>\n<p>作为利弗莫尔一生在”投机“生涯的回忆录，记录视角上会感觉一个经历了大起大落的人在你耳边叙述他的一生。</p>\n<h2>时间尽头的咖啡馆 约翰·史崔勒基</h2>\n<h3>推荐指数 4</h3>\n<p>一本简短的小说，通过故事的方式引领你的思考-关于生命的意义。找到问题的答案仍然需要自己的积极思考</p>\n<h2>斯坦福极简经济学 蒂莫西·泰勒</h2>\n<h3>推荐指数 4.5</h3>\n<p>书中通过简单的例子阐述宏观和微观经济学的基本概念，读起来兴趣盎然。经济学有助于我们改变对世界的认识，推荐这本。</p>\n<h2>养育你内心的小孩 丛非从</h2>\n<h3>推荐指数 4</h3>\n<p>这本书从心理学的角度上介绍了安全、自由、价值、意义、亲密等对行为产生的影响。我们对于外界的行为起因是我们的内心有一定的冲突，要不停的认识自己。</p>\n<h2>火星编年史 雷·布拉德伯里</h2>\n<h3>推荐指数 4.5</h3>\n<p>很喜欢作者对人类文明发展的克制表达，是一本有诗意却有些悲凉色彩的科幻小说</p>\n<h2>邓小平时代 傅高义</h2>\n<h3>推荐指数 4.5</h3>\n<p>对历史的细节有了更多的了解。邓爷爷一辈子起起伏伏，一直在为中国发展贡献着力量，阅读过程中会感觉一个亲切而坚定的人跃然纸上，作者在写作本书的时候对历史的细节有足够的求证力图还原真实的历史。阅读本书了解到了什么是中国特色社会主义制度，为什么会有经济特区，发展才是硬道理等等，祖国的今天得来不易，以史为鉴才能走得更好，感恩前人。</p>\n<h2>法治的细节</h2>\n<h2>圆圈正义: 作为自由前提的信念  罗翔</h2>\n<h3>推荐指数 4.5</h3>\n<p>读完这两边书让我对法治的概念有了基本的思考，也了解到要接受自己的局限性，多思考。</p>\n<h2>李光耀观天下 李光耀</h2>\n<h3>推荐指数 4</h3>\n<p>跟随李光耀先生的视角看了一次世界.在看待中国问题上还是存在一些西方的视角不过也的确看到了发展中出现的问题。在其他区域的发展上从政治经济上看的很广,有全局的视野</p>\n<h2>鼠疫 加缪</h2>\n<h3>推荐指数 4.5</h3>\n<p>在新冠疫情的背景下看这本书更加有感触。书中散发着作者对于生活坚定的力量。</p>\n<h2>用经济思维看懂世界格局·亚欧大陆经济整合--新体系伟大力量的源泉 徐伯赢</h2>\n<h3>推荐指数 5</h3>\n<p>本书从经济学的角度来探讨世界格局，覆盖了美、欧、中东、东南亚、日本、中国在经济领域的历史，读起来兴趣盎然。在探讨的视角是也比较宏观。</p>\n<ul>\n<li>日本和东南亚就像今天中国发展的镜子，如何解决房地产泡沫问题、如何寻找经济发展替换地产经济的问题，发展方式的选择问题(合作共赢还是胜者通吃)、金融领域的开放问题等，有不错的借鉴意义</li>\n<li>欧债危机暴露了很多问题，看似表面团结的欧盟(英国与欧洲大陆国家，欧洲大陆核心国与非核心国)由于国家经济政策不同和整个欧盟产业结问题容易产生一些隐藏的问题。欧盟似乎应该在更加统一的财政政策和独立于美国的政策上发力</li>\n<li>对比其他国家和区域，我们的发展路线是在全球化背景下实践一条合作发展，互利共赢的道路，虽然我们现在也面临很多的问题(法制的建设等)，希望这些问题会越来越好，附上这本书结尾的话: 士不可以不弘毅，任总而道远</li>\n</ul>\n<h2>PDCA循环工作法 冈村拓郎</h2>\n<h3>推荐指数 3.5</h3>\n<p>PDCA循环工作法的实践书籍，对于一些细节和思考上有收获。适合快读</p>\n<h2>纳闷集 匡扶</h2>\n<h3>推荐指数 3</h3>\n<p>漫画集，通过漫画和搞笑的表达方式叙述了温暖的故事</p>\n<h2>战胜华尔街 彼得·林奇 约翰·罗瑟查尔德</h2>\n<h3>推荐指数 4</h3>\n<p>之前读过股票大作手回忆录-利弗莫尔的回忆录，是第三方视角记录的有些内容就会存在失真，收获有限。这本书是彼得·林奇个人写的自传，本书从头到尾都在基于他投资选股的内容进行阐述，在对周期股的概念、长期价值投资的坚定、选股思考的逻辑都有不错的收获</p>\n<h2>自洽: 在不确定的日子里向内看 史欣悦</h2>\n<h3>推荐指数 3.5</h3>\n<p>自洽是一个向内沟通的过程，自己之前有段时间工作相对忙碌，在那段时间里很少的考虑到自己本身的一些想法，被一件一件推着往前走。比较缺少对做的事情的一些思考。最近时常会蹦出来一些想法当时如果这么做会更好。在快的节奏里面如果保持自己的节奏(内心)很重要，需要不断的跟自己沟通，丰富自己的认知。</p>\n<h2>看懂世界格局的第一本书 王伟</h2>\n<h3>推荐指数 4</h3>\n<p>通过本书了解到了很多历史的细节和全面的视角,对了解世界格局和经济很有帮助.比如日本、苏联、东南亚国家的发展都对现在有借鉴价值</p>\n<h2>认知世界的经济学 珍大户</h2>\n<h3>推荐指数 4</h3>\n<p>作为入门读物,在需求供给、弹性、利率等方面通过例子讲解的很清晰.书中有些例子有些刻意为之但是瑕不掩瑜</p>\n<h2>随风去野 白关</h2>\n<h3>推荐指数 4</h3>\n<p>跟随生动的插画与作者一起经历了骑行过程中的人、事、景色，是一次不错的体验</p>\n<h2>海龟交易法则 柯蒂斯·费思</h2>\n<h3>推荐指数 3</h3>\n<p>本书是作者个人的经历介绍.海龟交易法阐述了在市场中交易的基本原则,控制风险、控制仓位、止损、止盈等.从书中的收获是在市场中要掌握自己的优势，发挥自己的优势。 建议关键章节详细看</p>\n<h2>中国近代通史(全10册) - 中国社会科学院近代史研究所</h2>\n<h3>推荐指数 5</h3>\n<p>从鸦片战争到中华人民共和国成立，这本书详细的介绍了中国近代史的细节。在阅读的过程中会有历史在眼前重演的错觉，会有遗憾、不解、叹息等情绪。历史仿佛能启发人的思考，以史为鉴可以正衣冠应该说的就是这个道理，对近代史感兴趣的话推荐这本书</p>\n<h2>荒原狼 赫尔曼·黑塞/涂媛媛译</h2>\n<h3>推荐指数 3.5</h3>\n<p>书中的荒原狼可以理解是黑塞本人或者自我抗争的一种表现，书中有很多光怪陆离的表达手法读起来还不错</p>\n<h2>局外人 加缪</h2>\n<h3>推荐指数 4</h3>\n<p>加缪的小说很像有人在你身边讲故事，通过平淡且扎实的叙事方式推进故事的演进</p>","fields":{"readingTime":{"text":"19 min read"}},"frontmatter":{"title":"读书目录-2022","date":"2022-03-01","tags":"读书目录","path":"/book-list-2022","top":null,"summary":null}}},{"node":{"id":"1b1c7935-f51a-5457-ab19-ba556fcdbc0b","html":"<h2><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/\">JavaScript. The Core: 2nd Edition</a></h2>\n<p>这篇文章介绍JavaScript的一些核心概念，包括对象、原型链、闭包、this、执行上下文等，适合温故知新</p>\n<h2><a href=\"http://www.ayqy.net/blog/%E7%90%86%E8%A7%A3git-submodules/\">理解Git Submodules</a></h2>\n<p>这篇文章介绍了包管理通用的几种方式: npm packages/monorepo/git submodules.\r\nnpm packages的管理方式基于npm的版本控制方式实现子模块更新，更适合管理底层库、基础依赖。这类代码的变更相对较少，主repo更多使用的是子repo编译后的代码产物<br>\nmonorepo 适用于服务于同一功能的多个模块的组合方式，模块之间功能划分清晰，依赖清晰。解决方案有<a href=\"https://github.com/lerna/lerna\">lerna</a>和yarn的<a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">workspaces</a>.monorepo的优势是可以在一个仓库内完成不同包模块功能的测试，不需要关注子repo的版本问题。劣势是需要解决node_module的依赖问题、编译流程、主repo体积问题等。业务不相关的模块建议直接拆仓维护，自治的成本反而更低。<br>\ngit submodules跟monorepo的理念相近，都直接依赖子repo的源码进行开发。git submodules优势是可以实现子repo的共享源码能力(相对于编译后产物的优势)，可以实现功能的复用(npm packages/微前端)。</p>\n<h2><a href=\"https://blog.plasmic.app/posts/how-react-server-components-work/\">How React server components work: an in-depth guide</a></h2>\n<p>这篇文章详细的介绍了React Server Components的实现机制，通过React Server Components可以更好的实现bundle体积的减少，渲染时间的加快,值得后续的关注</p>\n<h2><a href=\"https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/\">Improving JavaScript Bundle Performance With Code-Splitting</a></h2>\n<p>这篇文章详细的介绍了使用Code Split的细节和关注点</p>\n<h2><a href=\"https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html\">Use Streams to Build High-Performing Node.js Applications</a></h2>\n<p>这篇文章详细的介绍了node中stream流的使用细节，通过例子的方式讲解了流的状态，背压等概念。</p>\n<h2><a href=\"https://www.developerway.com/posts/how-to-write-performant-react-code\">How to write performant React code: rules, patterns, do's and don'ts</a></h2>\n<p>这篇文章通过例子的方式介绍react代码的优化方式，阅读过后能发现出平时一些不注意的点</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null}}},{"node":{"id":"92fa80bd-9d39-56b8-a31c-217e4af6d020","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#single-spa\">single-spa简单用法</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#\">子应用配置</a></li>\n<li>1.2. <a href=\"#-1\">主应用配置</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#single-spa-1\">single-spa源码分析</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">启动</a></li>\n<li>2.2. <a href=\"#-1\">子应用挂载/切换</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">关于微前端的一些总结思考</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\r\n\tnumbering=true\r\n\tautoSave=true\r\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>微前端是应用组装的一种模式,本文从single-spa的使用方式入手逐步深入到single-spa的源码实现了解微前端的实现方式</p>\n<h2>1. <a name='single-spa'></a>single-spa简单用法</h2>\n<p>single-spa通过子应用与主应用约定交互协议实现微前端应用,在具体的交互中:</p>\n<ul>\n<li>子应用需要暴露应用生命周期方法,例如bootstrap、mount、unmount</li>\n<li>主应用与子应用约定激活规则</li>\n<li>主应用根据挂载规则动态的切换应用状态并且执行对应子应用的生命周期方法</li>\n</ul>\n<p>下面的例子分别从子/主应用的角度梳理下single-spa实现微前端方案的配置方式,在例子中定义了一个主应用(baseapp), 两个子应用(app1, app2).</p>\n<h3>1.1. <a name=''></a>子应用配置</h3>\n<p>single-spa基于js Entry的方式实现微前端方案,在子应用导出的js模块中需要包含子应用的生命周期函数方法，这里的两个子应用都以create-react-app创建的react应用举例,实例代码已上传到<a href=\"https://github.com/icantunderstand/microappdemo\">微前端demo</a></p>\n<ol>\n<li>使用create-react-app创建子应用 npx create-react-app app1</li>\n<li>进入到对应的目录\r\nnpm run eject // 将创建项目的配置弹出\r\nnpm install single-spa-react -S</li>\n<li>修改项目的webpack配置,修改输出文件(这里仅为测试使用)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAADCElEQVQ4y32U25KjNhRF/RuTNiAkQCAk7hdjbOxup6YmmYf8/9esFHJ3TzoP87DrSAW1ap+LzqFpGsIwJIpCCtfQrht26LG1QciQSAQIGSDigCAI/L+/06Gua3+I45g4FuTOUdSWsq+p5oGya+iuqz9LlXA8BgTHJ9zr+B8FAYcPh0IIlFK4ccL2zdNlP9AsE+PrDTf06CIlySIym6CyGJnEZEaRForUKGQac6iq6hMoPXCmXVeqaULmOdm4UKwbWT+TTVfK7YF2BhFHCClQWnqQSmN/P7Rt+8WhLg2m3VN2pFaTVgbdOnRjKeeWvLXkTnuHSaHI3NNtWioffcpRFD0dSkk1LozbG918Zr496JcV7WqK+Uo+XsjnjXy6oLuZOAqRMkaIyNd/jwfn3BegjGOyLKNvaoa+p20auqZhmUbGtqZzJWtXsTSOU10yVyWjM6ytozWagzGGMPwAKrSxlOMFd/uJu//ELG/Uj38orz9o2p6hssyu4LpDq5LJGr7PHX1ZcK4tB2vtL4dKUXY93WVluF2opwk39tTzTLOc0EXC0Blql9PanLEraZuCebA4q+lb8xWolESlgtQIilqhnSR3e7EjtJUUTUbeZmSl8k1IzLMpWZX4mLrkKzCWkngfA6NIbELe56RV6iULhW4ysir134qxQGqJdgm5S0ly6fUJjIQgTxS39cJ9u/N6f7BOM9tp4XW7s44Tr7cb1/OZbb3weHvQjyc/e5GIvMIo/NXlUAhOOmGdF+6P7zz++pveGX4sHY+p5trV2DSlVAojJU7GzFlCEEZE7+945xymafLpRiJm1gmZ0ZjR4c4OOxr6a0V9LjH7soglodhfiPIjthvYG5mmqb/vD8M7FO8Op1RStR3tefXdrWzC4gpSKfnj5cU7EVHoo4xCOhlx/P+2+aihB2bquW3GAXeeqK5nYrOXRGDzjGMY8e0l4Nsx4BgENFHIy8tz0xzfo18OvgZCsGSSrau5LQPb1HGbR26nnmur+bMvOFcZo5EMecycx1z8qKQkWn5uoH8BNYv4/t4Q+IAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wepack修改配置\"\n        title=\"wepack修改配置\"\n        src=\"/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png\"\n        srcset=\"/blog/static/0b818be146d1f3df7220cfad8a318320/63868/webpackConfig.png 250w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/0b533/webpackConfig.png 500w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png 1000w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png 1186w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n4. 修改子应用代码</p>\n<pre><code>    import React from 'react';\r\n    import ReactDOM from 'react-dom';\r\n    import './index.css';\r\n    import singleSpaReact from 'single-spa-react'\r\n    import App from './App'; // App是子应用的入口 \r\n\r\n    // 使用single-spa-react产生子应用的生命周期方法\r\n    const reactLifecycles = singleSpaReact({\r\n        React,\r\n        ReactDOM,\r\n        rootComponent: App,\r\n        errorBoundary(err, info, props) {\r\n            // https://reactjs.org/docs/error-boundaries.html\r\n            return (\r\n            &#x3C;div>This renders when a catastrophic error occurs&#x3C;/div>\r\n            );\r\n        },\r\n    });\r\n\r\n    export const bootstrap = reactLifecycles.bootstrap;\r\n    export const mount = reactLifecycles.mount;\r\n    export const unmount = reactLifecycles.unmount;  \n</code></pre>\n<ol start=\"4\">\n<li>\n<p>构建子应用,生成入口文件，这里通过serve提供静态服务的方式提供入口js Entry的访问，在实际中可以使用nginx或者cdn的形式提供访问</p>\n<pre><code> npm run build\r\n serve -s -l 3001 build // 指定端口 \n</code></pre>\n</li>\n</ol>\n<h3>1.2. <a name='-1'></a>主应用配置</h3>\n<ol>\n<li>\n<p>使用create-react-app创建主应用 npx create-react-app baseapp</p>\n</li>\n<li>\n<p>安装微前端依赖</p>\n<p>npm install single-spa react-router-dom -S</p>\n</li>\n<li>\n<p>主应用增加与子应用配置代码</p>\n<pre><code> import React from 'react';\r\n import ReactDOM from 'react-dom';\r\n import { BrowserRouter as Router, Link } from 'react-router-dom'\r\n import history from 'history/browser';\r\n import './index.css';\r\n import { registerApplication, start } from 'single-spa'\r\n\r\n async function loadApp(libraryUrl, libraryName) {\r\n     // 打包的webpack配置是umd模式 直接挂载在window上\r\n     if(window[libraryName]) {\r\n         return window[libraryName]\r\n     }\r\n     // 加载并且等待js执行\r\n     await new Promise((resolve, reject) => {\r\n         const script = document.createElement('script')\r\n         script.src = libraryUrl\r\n         script.onload = resolve\r\n         script.onerror = reject\r\n         document.body.appendChild(script)\r\n     })\r\n     return window[libraryName]\r\n }\r\n\r\n // 子应用可以通过走服务端下发配置 \r\n const apps = [\r\n     {\r\n         name: 'app1',\r\n         // 子应用加载方法，加载对应的js Entry\r\n         app: () => loadApp('http://localhost:3001/app1.js', 'app1'),\r\n         // 子应用激活方法\r\n         activeWhen: location => location.pathname.startsWith('/app1'),\r\n         // 共享属性\r\n         customProps: {}\r\n     },\r\n     {\r\n         name: 'app2',\r\n         app: () => loadApp('http://localhost:3002/app2.js', 'app2'),\r\n         activeWhen: location => location.pathname.startsWith('/app2'),\r\n         customProps: {}\r\n     }\r\n ]\r\n // 注册子应用\r\n for(let i = 0; i &#x3C; apps.length; i++) {\r\n     registerApplication(apps[i])\r\n }\r\n // 启动single-spa提供微服务能力\r\n start()\r\n // 渲染主应用\r\n ReactDOM.render(\r\n     &#x3C;div>\r\n         this is base app\r\n         &#x3C;Router history={history}>\r\n         // 子应用入口\r\n         &#x3C;div>&#x3C;Link to=\"app2\"  >app2&#x3C;/Link>&#x3C;/div>\r\n         &#x3C;div>&#x3C;Link to=\"app1\" >app1&#x3C;/Link>&#x3C;/div>\r\n     &#x3C;/Router>\r\n     &#x3C;/div>,\r\n     document.getElementById('root')\r\n );\n</code></pre>\n</li>\n<li>\n<p>启动主应用，就能看到两个子应用聚合成一个应用，点击对应的调整也能正常切换</p>\n</li>\n</ol>\n<p><img src=\"/blog/35257e241336dfb4aa08e94db8b4aec4/run.gif\" alt=\"引用切换\"></p>\n<h2>2. <a name='single-spa-1'></a>single-spa源码分析</h2>\n<p>single-spa的源码可以分成两个阶段来看: 启动阶段和子应用挂载(切换)阶段.下面就分别从这两个阶段看single-spa的执行过程</p>\n<h3>2.1. <a name='-1'></a>启动</h3>\n<p>在启动主应用的时候，通过registerApplication注册子应用和start方法启动微前端\r\n在registerApplication中主要对子应用的入参进行了格式化处理然后将子应用推入全局的数据保存，然后执行应用切换的主函数reroute做首次应用的加载逻辑</p>\n<pre><code>export function registerApplication(\r\n    appNameOrConfig,\r\n    /** 子应用异步加载函数 需要返回带有生命周期的模块导出 */\r\n    appOrLoadApp,\r\n    /** 应用激活函数 */\r\n    activeWhen,\r\n    /** 共享属性 */\r\n    customProps\r\n    ) {\r\n    // 子应用入参格式化处理\r\n    const registration = sanitizeArguments(\r\n        appNameOrConfig,\r\n        appOrLoadApp,\r\n        activeWhen,\r\n        customProps\r\n    );\r\n    /** 推入全局的子应用数组 */\r\n    apps.push(\r\n        assign(\r\n        {\r\n            loadErrorTime: null,\r\n            /** 应用状态 */\r\n            status: NOT_LOADED,\r\n            parcels: {},\r\n            devtools: {\r\n            overlays: {\r\n                options: {},\r\n                selectors: [],\r\n            },\r\n            },\r\n        },\r\n        registration\r\n        )\r\n    );\r\n    if (isInBrowser) {\r\n        ensureJQuerySupport();\r\n        /** 执行应用切换的主函数 */\r\n        reroute();\r\n    }\r\n}\n</code></pre>\n<p>在reroute中会对子应用加载状态进行分类(appsToUnload\\appsToUnmount\\appsToLoad\\appsToMount)然后根据是否运行过start函数走不同触发逻辑:</p>\n<ol>\n<li>\n<p>未运行过start函数,走app初始化加载逻辑(js Entry下载)</p>\n</li>\n<li>\n<p>运行过start函数,走app挂载/切换逻辑</p>\n<pre><code> export function start(opts) {\r\n     // start控住通过全局变量控住整个应用挂载状态\r\n     // 二次调用start 触发对应的子应用挂载\r\n     started = true;\r\n     if (opts &#x26;&#x26; opts.urlRerouteOnly) {\r\n         setUrlRerouteOnly(opts.urlRerouteOnly);\r\n     }\r\n     if (isInBrowser) {\r\n         reroute();\r\n     }\r\n }\r\n /** 执行应用切换的主函数 */\r\n export function reroute(pendingPromises = [], eventArguments) { \r\n     /** 应用处于切换状态中,推入到待处理的peopleWaitingOnAppChange 等待后续统一处理 */\r\n     if (appChangeUnderway) {\r\n         return new Promise((resolve, reject) => {\r\n         peopleWaitingOnAppChange.push({\r\n             resolve,\r\n             reject,\r\n             eventArguments,\r\n         });\r\n         });\r\n     }\r\n     /** 获取当前子应用的状态数组 */\r\n     /** 在getAppChanges中根据传入的activeWhen进行判断 首次应用应该处于appsToLoad数组中 */\r\n     const {\r\n         /** 移除状态 */\r\n         appsToUnload,\r\n         /** 卸载状态 */\r\n         appsToUnmount,\r\n         /** 加载状态 */\r\n         appsToLoad,\r\n         /** 即将挂载状态 */\r\n         appsToMount,\r\n     } = getAppChanges();\r\n     let appsThatChanged,\r\n         navigationIsCanceled = false,\r\n         oldUrl = currentUrl,\r\n         newUrl = (currentUrl = window.location.href);\r\n     // 是否运行过start函数 走应用切换逻辑\r\n     if (isStarted()) {\r\n         appChangeUnderway = true;\r\n         appsThatChanged = appsToUnload.concat(\r\n         appsToLoad,\r\n         appsToUnmount,\r\n         appsToMount\r\n         );\r\n         return performAppChanges();\r\n     } else {\r\n         // 未运行过start函数走app初始化加载逻辑\r\n         appsThatChanged = appsToLoad;\r\n         return loadApps();\r\n     }\r\n     /** 省略若干代码 */\r\n }\n</code></pre>\n</li>\n</ol>\n<p>loadApps通过微任务的方式加载js Entry然后在对应的app对象设置子应用的生命周期函数</p>\n<pre><code>/** 加载子应用js Entry */\r\nfunction loadApps() {\r\n    return Promise.resolve().then(() => {\r\n        /** 通过微任务的方式加载appsToLoad 在加载完毕后在\r\n        * 对应的app对象上设置暴露的生命周期方法\r\n        */\r\n        const loadPromises = appsToLoad.map(toLoadPromise);\r\n\r\n        return (\r\n        Promise.all(loadPromises)\r\n        /** 触发路由事件 首次加载可忽略这里 */\r\n            .then(callAllEventListeners)\r\n            // there are no mounted apps, before start() is called, so we always return []\r\n            .then(() => [])\r\n            .catch((err) => {\r\n            callAllEventListeners();\r\n            throw err;\r\n            })\r\n        );\r\n    });\r\n}\n</code></pre>\n<h3>2.2. <a name='-1'></a>子应用挂载/切换</h3>\n<p>在single-spa启动的时候,会监听路由事件然后再触发路由事件和执行reroute方法</p>\n<pre><code>/** 路由事件监听 */\r\nwindow.addEventListener(\"hashchange\", urlReroute);\r\nwindow.addEventListener(\"popstate\", urlReroute);\r\n/** patchedUpdateState也会触发urlReroute */patchedUpdateState\r\nwindow.history.pushState = patchedUpdateState(\r\n    window.history.pushState,\r\n    \"pushState\"\r\n);\r\nwindow.history.replaceState = patchedUpdateState(\r\n    window.history.replaceState,\r\n    \"replaceState\"\r\n);\r\n\r\nfunction urlReroute() {\r\n    reroute([], arguments);\r\n}\n</code></pre>\n<p>所以app挂载切换的主逻辑都在reroute的performAppChanges中,主要做了:</p>\n<ul>\n<li>\n<p>派发single-spa自定义事件</p>\n</li>\n<li>\n<p>执行移除/卸载状态应用的生命周期函数</p>\n</li>\n<li>\n<p>执行挂载应用的生命周期函数(依赖卸载/移除的执行tryToBootstrapAndMount)</p>\n<p>function performAppChanges() {</p>\n<pre><code>  return Promise.resolve().then(() => {\r\n      /** 派发single-spa自定义事件 */\r\n      /** 省略若干代码 */\r\n      // 执行需要移除/卸载状态应用的生命周期函数并且删除对应的生命周期函数\r\n      // 重置应用状态\r\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\r\n      const unmountUnloadPromises = appsToUnmount\r\n          .map(toUnmountPromise)\r\n          .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\r\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\r\n      const unmountAllPromise = Promise.all(allUnmountPromises);\r\n      unmountAllPromise.then(() => {\r\n      window.dispatchEvent(\r\n          new CustomEvent(\r\n          \"single-spa:before-mount-routing-event\",\r\n          getCustomEventDetail(true)\r\n          )\r\n      );\r\n      });\r\n\r\n      // 子应用的加载和bootstrap生命周期函数执行\r\n      const loadThenMountPromises = appsToLoad.map((app) => {\r\n          return toLoadPromise(app).then((app) =>\r\n              tryToBootstrapAndMount(app, unmountAllPromise)\r\n          );\r\n      });\r\n      // 子应用挂载和mount生命周期函数的执行\r\n      const mountPromises = appsToMount\r\n          .filter((appToMount) => appsToLoad.indexOf(appToMount) &#x3C; 0)\r\n          .map((appToMount) => {\r\n              return tryToBootstrapAndMount(appToMount, unmountAllPromise);\r\n      });\r\n      /** 省略若干代码 */\r\n  });\r\n  }\r\n  // tryToBootstrapAndMount依赖之前需要unLoad和unMount的应用周期函数执行完毕\r\n  function tryToBootstrapAndMount(app, unmountAllPromise) {\r\n      if (shouldBeActive(app)) {\r\n          return toBootstrapPromise(app).then((app) =>\r\n          unmountAllPromise.then(() =>\r\n              shouldBeActive(app) ? toMountPromise(app) : app\r\n          )\r\n          );\r\n      } else {\r\n          return unmountAllPromise.then(() => app);\r\n      }\r\n  }\n</code></pre>\n</li>\n</ul>\n<p>以上梳理了single-spa实现微前端的主体流程</p>\n<h2>3. <a name='-1'></a>关于微前端的一些总结思考</h2>\n<p>在讨论使用一个技术方案的时候,主要考虑点这项技术方案是否能解决当前或者未来项目中遇到的问题,微前端的优势在于项目的组合(新老项目平滑过渡\\项目功能共享\\应用拆分\\流程解耦)等但同时也增加了项目维护的一些成本,需要结合项目和业务发展方向进行探索使用</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://juejin.cn/post/6862661545592111111\">微前端框架 之 single-spa 从入门到精通</a><br>\n<a href=\"https://blog.yuanziwen.cn/2019/12/18/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E8%90%BD%E5%9C%B0%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF\">微前端时代思考与实践</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/fy3qri\">你可能并不需要微前端</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/rhduwc\">微前端的核心价值</a></p>","fields":{"readingTime":{"text":"11 min read"}},"frontmatter":{"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null}}},{"node":{"id":"0b27f584-b861-5413-95a0-31af314832ad","html":"<p>不同的微前端框架会提供沙盒环境来实现不同微前端应用的隔离.本文梳理JavaScript中沙盒的实现方式，有助于学习微前端方案的技术细节.</p>\n<h2>前置概念</h2>\n<h3>沙盒</h3>\n<p>沙盒是一种安全机制可以为程序提供隔离的执行环境，沙盒中提供用后即回收的磁盘及内存空间，在沙盒中对网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是被严格限制的.JavaScript沙盒是通过语法层面的限制来实现代码执行的隔离.</p>\n<h3>Proxy</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>可以实现对对象属性访问的代理，通过Proxy的使用可以实现JavaScript代码执行的沙盒模式</p>\n<h3>with</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with\">with</a>语句可以扩展当前的执行上下文</p>\n<pre><code>const a = { name: 1111 }\r\nwith(a) {\r\n    console.log(name) // 1111\r\n}\n</code></pre>\n<h2>沙盒的实现方式</h2>\n<p>沙盒的实现方式上主要分为:</p>\n<ul>\n<li>单实例沙盒: 同一个时刻只有一个微应用实例存在，当前资源被这个应用独占，需要解决的主要问题是应用切换的时候变量污染清理和再次启动时的变量恢复</li>\n<li>多实例沙盒: 资源不是应用独占，需要解决资源共享、通信等问题</li>\n</ul>\n<h3>ProxySandbox(单实例沙盒)</h3>\n<p>基于Proxy的拦截和设置功能，通过Proxy拦截对全局对象的修改记录，在应用切换的时候还原全局对象</p>\n<pre><code>    /** 设置全局对象属性 */\r\n    const setWindowProp = (prop, value) => {\r\n        window[prop] = value\r\n    }\r\n\r\n    class SandBox {\r\n        name;\r\n        /** 代理对象 需要通过该对象操作沙盒 */\r\n        proxy = null;\r\n        /** 新增的修改 */\r\n        addedPropsMap = new Map();\r\n        /** 沙盒期间更新的修改 */\r\n        modifiedOriginValueProps = new Map();\r\n        /** 当前沙盒所做的修改 用于还原当前的沙盒 */\r\n        currentUpdatedProps = new Map();\r\n        /** 激活沙盒 */\r\n        active() {  \r\n            this.currentUpdatedProps.forEach((v, p) => {\r\n                setWindowProp(p, v)\r\n            })\r\n        }\r\n        /** 沙箱卸载 */\r\n        inactive() {\r\n            /** 修改的属性还原 */\r\n            this.modifiedOriginValueProps.forEach((v, p) => {\r\n                setWindowProp(p, v)\r\n            })\r\n            /** 增加的属性清空 */\r\n            this.addedPropsMap.forEach((_, p) => {\r\n                setWindowProp(p, undefined)\r\n            })\r\n        }\r\n        constructor(name) {\r\n            this.name = name;\r\n            const fakeWindow = Object.create(null)\r\n            const {\r\n                addedPropsMap,\r\n                modifiedOriginValueProps,\r\n                currentUpdatedProps,\r\n            } = this\r\n            const proxy = new Proxy(fakeWindow, {\r\n                get(target, prop) {\r\n                    return window[prop]\r\n                },\r\n                set(_, prop, value) {\r\n                    if(!window.hasOwnProperty(prop)) {\r\n                        /** window上没有该属性 新增 */\r\n                        addedPropsMap.set(prop, value)\r\n                    } else if(!modifiedOriginValueProps.hasOwnProperty(prop)) {\r\n                        /** window上有该属性且未更新,记录 */\r\n                        const originValue = window[prop] \r\n                        modifiedOriginValueProps(prop, originValue)\r\n                    }\r\n                    /** 记录当前沙盒的更新 */\r\n                    currentUpdatedProps.set(prop, value)\r\n                    /** 更新全局属性 */\r\n                    setWindowProp(prop, value)\r\n                    return true\r\n                }\r\n            })\r\n            this.proxy = proxy\r\n        }\r\n    }\r\n\r\n    const newSandBox = new SandBox('app')\r\n    const proxyWindow = newSandBox.proxy\r\n    proxyWindow.appName = 'app'\r\n    console.log(window.appName, proxyWindow.appName) // app app\r\n    newSandBox.inactive()\r\n    console.log(window.appName, proxyWindow.appName) // undefined undefined\r\n    newSandBox.active()\r\n    console.log(window.appName, proxyWindow.appName) // app app\n</code></pre>\n<h3>snapshotSandbox(单实例沙盒)</h3>\n<p>快照沙盒是在不支持Proxy的环境下，通过将window对象属性都复制到快照对象上然后再激活和卸载的时候对激活期间的diff进行添加或者回退.这个方案的对比方案较复杂，比如考虑到原型链的修改与还原问题，一般不作为沙盒方案的首选.</p>\n<pre><code>class SnapshotSandbox {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.proxy = window;\r\n        this.type = 'Snapshot';\r\n        this.sandboxRunning = true;\r\n        this.windowSnapshot = {};\r\n        this.modifyPropsMap = {};\r\n        this.active();\r\n    }\r\n    //激活\r\n    active() {\r\n        // 记录当前快照\r\n        this.windowSnapshot = {};\r\n        iter(window, (prop) => {\r\n            this.windowSnapshot[prop] = window[prop];\r\n        });\r\n\r\n        // 恢复之前的变更\r\n        Object.keys(this.modifyPropsMap).forEach((p) => {\r\n            window[p] = this.modifyPropsMap[p];\r\n        });\r\n\r\n        this.sandboxRunning = true;\r\n    }\r\n    //还原\r\n    inactive() {\r\n        iter(window, (prop) => {\r\n            if (window[prop] !== this.windowSnapshot[prop]) {\r\n                // 记录变更，恢复环境\r\n                this.modifyPropsMap[prop] = window[prop];\r\n            \r\n                window[prop] = this.windowSnapshot[prop];\r\n            }\r\n        });\r\n        this.sandboxRunning = false;\r\n    }\r\n}\r\n\r\nconst sandbox = new SnapshotSandbox();\r\nconst proxyWindow = sandbox.proxy\r\nsandbox.active();\r\nproxyWindow.appName = 'app'\r\nconsole.log(proxyWindow.appName, window.appName) // app app\r\nsandbox.inactive();\r\nconsole.log(proxyWindow.appName, window.appName) // undefined undefined\n</code></pre>\n<h3>多实例沙盒</h3>\n<p>多实例沙盒是Proxy实现的单实例的变种版，在Proxy实现的单实例沙盒中，Proxy的handler的get/set是直接操作的全局对象,多实例版本在handler的get/set中操作沙盒自己维护的对象，从而实现多实例模式</p>\n<pre><code>class MultiProxySandbox {\r\n    name;\r\n    proxy = null;\r\n    /** context 传入多实例沙盒共享数据 */\r\n    constructor(name, context={}){\r\n        this.name = name;\r\n        const fakeWindow = Object.create({});\r\n        const proxy =  new Proxy(fakeWindow,{\r\n        set(target, name, value){\r\n            /** 返回共享属性  */\r\n            if(Object.keys(context).includes(name)){\r\n                context[name] = value;\r\n            }\r\n            target[name] = value;\r\n        },\r\n        get(target,name){\r\n            // 优先使用共享对象\r\n            if(Object.keys(context).includes(name)){\r\n                return context[name];\r\n            }\r\n            if( typeof target[ name ] === 'function' &#x26;&#x26; /^[a-z]/.test(name)){\r\n            return target[ name ].bind &#x26;&#x26; target[ name ].bind( target );\r\n            } else {\r\n            return target[ name ];\r\n            }\r\n        }\r\n        })\r\n        this.proxy = proxy\r\n        return proxy\r\n    }\r\n}\r\n\r\nconst context = { document: window.document, globalData:'abc'};\r\nconst newSandBox1 = new MultiProxySandbox('app1',context);\r\nconst newSandBox2 = new MultiProxySandbox('app2',context);\r\nnewSandBox1.appName = 'app1'\r\nnewSandBox2.appName = 'app2'\r\nconsole.log(newSandBox1.appName, newSandBox2.appName, window.appName) // app1 app2 undefined\r\nconsole.log(newSandBox1.globalData, newSandBox2.globalData) // abc abc\n</code></pre>\n<h2>附录</h2>\n<p><a href=\"https://juejin.cn/post/6844904066225537037\">字节跳动的微前端沙盒实践</a><br>\n<a href=\"https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg\">前端微服务在字节跳动的打磨与应用</a><br>\n<a href=\"https://cloud.tencent.com/developer/article/1748172\">谈谈微前端领域的js沙箱实现机制</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null}}},{"node":{"id":"011fb285-6a43-58d8-b531-1d89a194852f","html":"<h3><a href=\"https://alexkondov.com/tao-of-react/\">Tao of React - Software Design, Architecture &#x26; Best Practices</a></h3>\n<p>这篇文章介绍了React开发中的一些‘最佳’实践,比如组件逻辑拆分、项目的目录设计、react常见的写法等，可以将其中的一些点作为code review时候的一些参考点</p>\n<h3><a href=\"https://blog.tericcabrel.com/implement-server-sent-event-in-node-js/\">Implement Server-Sent Events in Node.js and React</a></h3>\n<p>这篇文章介绍nodejs中server-sent events的实现服务端推送，看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventSource#browser_compatibility\">兼容性</a>上还可以。在有node中间层的服务可以尝试这种方案</p>\n<h3><a href=\"https://blog.molecule.dev/the-only-custom-react-hooks-we-use/\">The only two custom React hooks we ever really use</a></h3>\n<p>这篇文章介绍了两个自定义的hooks,可以在项目中尝试下</p>\n<ul>\n<li>useAsyncExtendedState  实现state的部分更新，更新state的时候只需要传入需要更新的属性即可.</li>\n<li>userPromise 异步事件的管理(cancal, reset)</li>\n</ul>\n<h3><a href=\"https://thoughtspile.github.io/2021/11/15/unintentional-layout-effect/\">useEffect sometimes fires before paint</a></h3>\n<p>这篇文章介绍了react hook-useEffect和useLayoutEffect触发时机和结合使用的一些注意事项</p>\n<h3><a href=\"https://thoughtspile.github.io/2022/01/17/jsx-conditionals/\">Good advice on JSX conditionals</a></h3>\n<p>这篇文章介绍在React中写JSX的一些建议写法，有利于规范的形成，比如禁止嵌套三元运算符也能防止代码出现不可预知的错误</p>\n<h3><a href=\"https://blog.saeloun.com/2022/01/13/react-18-usedefferedvalue-hook\">Sneak peek into React 18 useDeferredValue hook</a></h3>\n<p>这篇文章介绍React 18中useDeferredValue hook.通过useDeferredValue可以实现指定优先级的渲染任务.</p>\n<h3><a href=\"https://www.robinwieruch.de/react-event-bubbling-capturing/\">React: Event Bubbling and Capturing</a></h3>\n<p>这篇文章通过图解和例子的方式比较生动的介绍了React中事件的处理机制，可以作为温习</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null}}},{"node":{"id":"230920f1-f676-5708-98fc-0c2ef60a8196","html":"<h2><a href=\"https://web.dev/aspect-ratio/\">aspect-ratio CSS property</a></h2>\n<p>通过aspect-ratio可以直接为容器设置宽高比</p>\n<h2>React</h2>\n<h3><a href=\"https://www.joshfinnie.com/blog/using-webassembly-created-in-rust-for-fast-react-components/\">Using WebAssembly (created in Rust) for Fast React Components</a></h3>\n<p>一篇React结合WebAssembly的介绍文章</p>\n<h3><a href=\"https://alexsidorenko.com/\">A Visual Guide to React Rendering -xxx</a></h3>\n<p>很不错的介绍react相关api和基本概念的文档</p>\n<h3><a href=\"https://joshcollinsworth.com/blog/introducing-svelte-comparing-with-react-vue\">Introducing Svelte, and Comparing Svelte with React and Vue</a></h3>\n<p>一篇介绍Svelte与react和vue的对比文章，通过这篇文章发现Svelte的确在某些情况较react/vue有一定优势，可以保持关注度</p>\n<h3><a href=\"https://devtrium.com/posts/react-typescript-using-generics-in-react\">React &#x26; TypeScript: use generics to improve your types</a></h3>\n<p>这篇文章结合useState的例子介绍react中泛型的使用</p>\n<h2>项目设计</h2>\n<h3><a href=\"https://dev.to/mbarzeev/creating-a-react-component-with-tdd-2jn8\">Creating a React component with TDD</a></h3>\n<p>在react项目中引入TDD的案例文章</p>\n<h3><a href=\"https://engineering.udacity.com/react-folder-structure-for-enterprise-level-applications-f8384eff162b\">React folder structure for enterprise level applications</a></h3>\n<p>React项目文件组织的推荐方式，文件的组织、文档、技术方案都是项目整体架构的一部分，需要给予关注</p>\n<h2>前端库</h2>\n<h3><a href=\"https://github.com/breejs/bree\">Bree</a></h3>\n<p>Bree is the best job scheduler for Node.js and JavaScript with cron, dates, ms, later, and human-friendly support</p>\n<h3><a href=\"https://github.com/DominicTobias/react-image-crop\">React Image Crop</a></h3>\n<p>An image cropping tool for React with no dependencies</p>\n<h3><a href=\"https://github.com/pubkey/rxdb\">RxDB</a></h3>\n<p>RxDB是基于PouchDB的一套响应式数据库存储方案</p>\n<h3><a href=\"https://github.com/dexie/Dexie.js\">Dexie.js</a></h3>\n<p>在IndexedDB基础上进行封装，提供更好用的查询api和降低IndexedDB的使用成本</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":6,"pageCount":15,"additionalContext":{"pageAllCount":87}}},
    "staticQueryHashes": []}