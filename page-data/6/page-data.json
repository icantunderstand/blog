{"componentChunkName":"component---src-templates-index-js","path":"/6","result":{"pageContext":{"pageAllCount":86,"group":[{"node":{"id":"e88dde7e-fd25-5606-b4a9-8cd74b7e55be","html":"<h2><a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/\">JavaScript. The Core: 2nd Edition</a></h2>\n<p>这篇文章介绍JavaScript的一些核心概念，包括对象、原型链、闭包、this、执行上下文等，适合温故知新</p>\n<h2><a href=\"http://www.ayqy.net/blog/%E7%90%86%E8%A7%A3git-submodules/\">理解Git Submodules</a></h2>\n<p>这篇文章介绍了包管理通用的几种方式: npm packages/monorepo/git submodules.\nnpm packages的管理方式基于npm的版本控制方式实现子模块更新，更适合管理底层库、基础依赖。这类代码的变更相对较少，主repo更多使用的是子repo编译后的代码产物<br>\nmonorepo 适用于服务于同一功能的多个模块的组合方式，模块之间功能划分清晰，依赖清晰。解决方案有<a href=\"https://github.com/lerna/lerna\">lerna</a>和yarn的<a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">workspaces</a>.monorepo的优势是可以在一个仓库内完成不同包模块功能的测试，不需要关注子repo的版本问题。劣势是需要解决node_module的依赖问题、编译流程、主repo体积问题等。业务不相关的模块建议直接拆仓维护，自治的成本反而更低。<br>\ngit submodules跟monorepo的理念相近，都直接依赖子repo的源码进行开发。git submodules优势是可以实现子repo的共享源码能力(相对于编译后产物的优势)，可以实现功能的复用(npm packages/微前端)。</p>\n<h2><a href=\"https://blog.plasmic.app/posts/how-react-server-components-work/\">How React server components work: an in-depth guide</a></h2>\n<p>这篇文章详细的介绍了React Server Components的实现机制，通过React Server Components可以更好的实现bundle体积的减少，渲染时间的加快,值得后续的关注</p>\n<h2><a href=\"https://www.smashingmagazine.com/2022/02/javascript-bundle-performance-code-splitting/\">Improving JavaScript Bundle Performance With Code-Splitting</a></h2>\n<p>这篇文章详细的介绍了使用Code Split的细节和关注点</p>\n<h2><a href=\"https://blog.appsignal.com/2022/02/02/use-streams-to-build-high-performing-nodejs-applications.html\">Use Streams to Build High-Performing Node.js Applications</a></h2>\n<p>这篇文章详细的介绍了node中stream流的使用细节，通过例子的方式讲解了流的状态，背压等概念。</p>\n<h2><a href=\"https://www.developerway.com/posts/how-to-write-performant-react-code\">How to write performant React code: rules, patterns, do's and don'ts</a></h2>\n<p>这篇文章通过例子的方式介绍react代码的优化方式，阅读过后能发现出平时一些不注意的点</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2022-2-1-前端快报","date":"2022-02-10","tags":"前端快报","path":"/2022-2-1","top":null,"summary":null}}},{"node":{"id":"3f01dcef-3d31-579e-9d68-f2ea5cd487a7","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#single-spa\">single-spa简单用法</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#\">子应用配置</a></li>\n<li>1.2. <a href=\"#-1\">主应用配置</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#single-spa-1\">single-spa源码分析</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#-1\">启动</a></li>\n<li>2.2. <a href=\"#-1\">子应用挂载/切换</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">关于微前端的一些总结思考</a></li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li><a href=\"#-1\">参考</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>微前端是应用组装的一种模式,本文从single-spa的使用方式入手逐步深入到single-spa的源码实现了解微前端的实现方式</p>\n<h2>1. <a name='single-spa'></a>single-spa简单用法</h2>\n<p>single-spa通过子应用与主应用约定交互协议实现微前端应用,在具体的交互中:</p>\n<ul>\n<li>子应用需要暴露应用生命周期方法,例如bootstrap、mount、unmount</li>\n<li>主应用与子应用约定激活规则</li>\n<li>主应用根据挂载规则动态的切换应用状态并且执行对应子应用的生命周期方法</li>\n</ul>\n<p>下面的例子分别从子/主应用的角度梳理下single-spa实现微前端方案的配置方式,在例子中定义了一个主应用(baseapp), 两个子应用(app1, app2).</p>\n<h3>1.1. <a name=''></a>子应用配置</h3>\n<p>single-spa基于js Entry的方式实现微前端方案,在子应用导出的js模块中需要包含子应用的生命周期函数方法，这里的两个子应用都以create-react-app创建的react应用举例,实例代码已上传到<a href=\"https://github.com/icantunderstand/microappdemo\">微前端demo</a></p>\n<ol>\n<li>使用create-react-app创建子应用 npx create-react-app app1</li>\n<li>进入到对应的目录\nnpm run eject // 将创建项目的配置弹出\nnpm install single-spa-react -S</li>\n<li>修改项目的webpack配置,修改输出文件(这里仅为测试使用)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAADEUlEQVQ4y32U647bNhSE/RqpLV51sShS94stW7K3mwDdogX6/i/zFdJuNkh+5MeAJETMGZ3hmUNd1wghUFKQlTXl/YHrO4oqR5kIqU4oc0LqiCiK9ru/w6Gqqn2jtUZrRVYGsqog7yqKqSNva8p1prj0aBtzOkVEJ7GTR5Eg2s8fiASHT4VKYa2lGCfyvsL1LUXXU15H2peVom9J8wSbChJvMalGJ4rYWWxuiJ3BJJpDWZafhMYaimGivN/w44g6nzmOM9F9JeonjuOCfHwlLh1KC5RRmGwj1nsBZSSHpml+Uph4R9YUnLuA9Sm6dNjGY+qC5FJjm4I0pJhU7cqS8K42Lt7X/ZellO8KjcGPV9r1T+rLTP94pb3eMaFCTStivCOmB2JcUO2EkRHGaJSSe/+lkhxCCD8RGq1J0pSmrmi6jqqu2Yybhp6hqehCwb0JzLVnrgoupWMMOUvtaV3GwTmHEN8JLanzZMMd8/wX8/IP+vqKff0PtbxRNR1j8Fx9zmMjLQsmn/M2NgzuzL0sOHjvfyi0lnxTtdxonnfCNOKHjjBNlPOFNLf0bU4VMlqfMTSOpj5z6QuCT+ma/FfCzXpJ7CRZpUnDBoPZn4oiqxPSJib2BlsYTGGIgyUu32GD/ZlQG4PMDNpZjI9JugxTxpgyQTlL3CTYKtm/ZcMZnW0FLWmIsWez45NQKkVuLev1xnpfea4v3IaBZZx4Lg9uXc9jWblfLizzzMvzhbafUPbd3Q1Cih8uC6WZE8M8Tiyv33j+9Ubnc/6eKr72gbUOBGvxRlNoTakkV6uJpEJ+zPHGcxi3idgqaM010SQuIxsDbi5w45lm8fg5J68dUhsipVDW7k9sjjUmjkmSZD9vg7ErVB8KL1YRmoZyvuGGlrKw3PyZxBj+OB53JVsqbasRgl6eOP2aNt97KJTiEivSEEjHHncbcesVWZRIqQjnlJOQfDlFfIkEp0jQRkeOxwixJc3xPXH2cNh7oDQ3K3nUnnVqWfqadehYx5q1ivlWp9y8ZTxL+lRySQSLk9jN4Ux/JtD/HNz2qyS1fusAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wepack修改配置\"\n        title=\"wepack修改配置\"\n        src=\"/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png\"\n        srcset=\"/blog/static/0b818be146d1f3df7220cfad8a318320/63868/webpackConfig.png 250w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/0b533/webpackConfig.png 500w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/00d43/webpackConfig.png 1000w,\n/blog/static/0b818be146d1f3df7220cfad8a318320/1843f/webpackConfig.png 1186w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n4. 修改子应用代码</p>\n<pre><code>    import React from 'react';\n    import ReactDOM from 'react-dom';\n    import './index.css';\n    import singleSpaReact from 'single-spa-react'\n    import App from './App'; // App是子应用的入口 \n\n    // 使用single-spa-react产生子应用的生命周期方法\n    const reactLifecycles = singleSpaReact({\n        React,\n        ReactDOM,\n        rootComponent: App,\n        errorBoundary(err, info, props) {\n            // https://reactjs.org/docs/error-boundaries.html\n            return (\n            &#x3C;div>This renders when a catastrophic error occurs&#x3C;/div>\n            );\n        },\n    });\n\n    export const bootstrap = reactLifecycles.bootstrap;\n    export const mount = reactLifecycles.mount;\n    export const unmount = reactLifecycles.unmount;  \n</code></pre>\n<ol start=\"4\">\n<li>\n<p>构建子应用,生成入口文件，这里通过serve提供静态服务的方式提供入口js Entry的访问，在实际中可以使用nginx或者cdn的形式提供访问</p>\n<pre><code> npm run build\n serve -s -l 3001 build // 指定端口 \n</code></pre>\n</li>\n</ol>\n<h3>1.2. <a name='-1'></a>主应用配置</h3>\n<ol>\n<li>\n<p>使用create-react-app创建主应用 npx create-react-app baseapp</p>\n</li>\n<li>\n<p>安装微前端依赖</p>\n<p>npm install single-spa react-router-dom -S</p>\n</li>\n<li>\n<p>主应用增加与子应用配置代码</p>\n<pre><code> import React from 'react';\n import ReactDOM from 'react-dom';\n import { BrowserRouter as Router, Link } from 'react-router-dom'\n import history from 'history/browser';\n import './index.css';\n import { registerApplication, start } from 'single-spa'\n\n async function loadApp(libraryUrl, libraryName) {\n     // 打包的webpack配置是umd模式 直接挂载在window上\n     if(window[libraryName]) {\n         return window[libraryName]\n     }\n     // 加载并且等待js执行\n     await new Promise((resolve, reject) => {\n         const script = document.createElement('script')\n         script.src = libraryUrl\n         script.onload = resolve\n         script.onerror = reject\n         document.body.appendChild(script)\n     })\n     return window[libraryName]\n }\n\n // 子应用可以通过走服务端下发配置 \n const apps = [\n     {\n         name: 'app1',\n         // 子应用加载方法，加载对应的js Entry\n         app: () => loadApp('http://localhost:3001/app1.js', 'app1'),\n         // 子应用激活方法\n         activeWhen: location => location.pathname.startsWith('/app1'),\n         // 共享属性\n         customProps: {}\n     },\n     {\n         name: 'app2',\n         app: () => loadApp('http://localhost:3002/app2.js', 'app2'),\n         activeWhen: location => location.pathname.startsWith('/app2'),\n         customProps: {}\n     }\n ]\n // 注册子应用\n for(let i = 0; i &#x3C; apps.length; i++) {\n     registerApplication(apps[i])\n }\n // 启动single-spa提供微服务能力\n start()\n // 渲染主应用\n ReactDOM.render(\n     &#x3C;div>\n         this is base app\n         &#x3C;Router history={history}>\n         // 子应用入口\n         &#x3C;div>&#x3C;Link to=\"app2\"  >app2&#x3C;/Link>&#x3C;/div>\n         &#x3C;div>&#x3C;Link to=\"app1\" >app1&#x3C;/Link>&#x3C;/div>\n     &#x3C;/Router>\n     &#x3C;/div>,\n     document.getElementById('root')\n );\n</code></pre>\n</li>\n<li>\n<p>启动主应用，就能看到两个子应用聚合成一个应用，点击对应的调整也能正常切换</p>\n</li>\n</ol>\n<p><img src=\"/blog/35257e241336dfb4aa08e94db8b4aec4/run.gif\" alt=\"引用切换\"></p>\n<h2>2. <a name='single-spa-1'></a>single-spa源码分析</h2>\n<p>single-spa的源码可以分成两个阶段来看: 启动阶段和子应用挂载(切换)阶段.下面就分别从这两个阶段看single-spa的执行过程</p>\n<h3>2.1. <a name='-1'></a>启动</h3>\n<p>在启动主应用的时候，通过registerApplication注册子应用和start方法启动微前端\n在registerApplication中主要对子应用的入参进行了格式化处理然后将子应用推入全局的数据保存，然后执行应用切换的主函数reroute做首次应用的加载逻辑</p>\n<pre><code>export function registerApplication(\n    appNameOrConfig,\n    /** 子应用异步加载函数 需要返回带有生命周期的模块导出 */\n    appOrLoadApp,\n    /** 应用激活函数 */\n    activeWhen,\n    /** 共享属性 */\n    customProps\n    ) {\n    // 子应用入参格式化处理\n    const registration = sanitizeArguments(\n        appNameOrConfig,\n        appOrLoadApp,\n        activeWhen,\n        customProps\n    );\n    /** 推入全局的子应用数组 */\n    apps.push(\n        assign(\n        {\n            loadErrorTime: null,\n            /** 应用状态 */\n            status: NOT_LOADED,\n            parcels: {},\n            devtools: {\n            overlays: {\n                options: {},\n                selectors: [],\n            },\n            },\n        },\n        registration\n        )\n    );\n    if (isInBrowser) {\n        ensureJQuerySupport();\n        /** 执行应用切换的主函数 */\n        reroute();\n    }\n}\n</code></pre>\n<p>在reroute中会对子应用加载状态进行分类(appsToUnload\\appsToUnmount\\appsToLoad\\appsToMount)然后根据是否运行过start函数走不同触发逻辑:</p>\n<ol>\n<li>\n<p>未运行过start函数,走app初始化加载逻辑(js Entry下载)</p>\n</li>\n<li>\n<p>运行过start函数,走app挂载/切换逻辑</p>\n<pre><code> export function start(opts) {\n     // start控住通过全局变量控住整个应用挂载状态\n     // 二次调用start 触发对应的子应用挂载\n     started = true;\n     if (opts &#x26;&#x26; opts.urlRerouteOnly) {\n         setUrlRerouteOnly(opts.urlRerouteOnly);\n     }\n     if (isInBrowser) {\n         reroute();\n     }\n }\n /** 执行应用切换的主函数 */\n export function reroute(pendingPromises = [], eventArguments) { \n     /** 应用处于切换状态中,推入到待处理的peopleWaitingOnAppChange 等待后续统一处理 */\n     if (appChangeUnderway) {\n         return new Promise((resolve, reject) => {\n         peopleWaitingOnAppChange.push({\n             resolve,\n             reject,\n             eventArguments,\n         });\n         });\n     }\n     /** 获取当前子应用的状态数组 */\n     /** 在getAppChanges中根据传入的activeWhen进行判断 首次应用应该处于appsToLoad数组中 */\n     const {\n         /** 移除状态 */\n         appsToUnload,\n         /** 卸载状态 */\n         appsToUnmount,\n         /** 加载状态 */\n         appsToLoad,\n         /** 即将挂载状态 */\n         appsToMount,\n     } = getAppChanges();\n     let appsThatChanged,\n         navigationIsCanceled = false,\n         oldUrl = currentUrl,\n         newUrl = (currentUrl = window.location.href);\n     // 是否运行过start函数 走应用切换逻辑\n     if (isStarted()) {\n         appChangeUnderway = true;\n         appsThatChanged = appsToUnload.concat(\n         appsToLoad,\n         appsToUnmount,\n         appsToMount\n         );\n         return performAppChanges();\n     } else {\n         // 未运行过start函数走app初始化加载逻辑\n         appsThatChanged = appsToLoad;\n         return loadApps();\n     }\n     /** 省略若干代码 */\n }\n</code></pre>\n</li>\n</ol>\n<p>loadApps通过微任务的方式加载js Entry然后在对应的app对象设置子应用的生命周期函数</p>\n<pre><code>/** 加载子应用js Entry */\nfunction loadApps() {\n    return Promise.resolve().then(() => {\n        /** 通过微任务的方式加载appsToLoad 在加载完毕后在\n        * 对应的app对象上设置暴露的生命周期方法\n        */\n        const loadPromises = appsToLoad.map(toLoadPromise);\n\n        return (\n        Promise.all(loadPromises)\n        /** 触发路由事件 首次加载可忽略这里 */\n            .then(callAllEventListeners)\n            // there are no mounted apps, before start() is called, so we always return []\n            .then(() => [])\n            .catch((err) => {\n            callAllEventListeners();\n            throw err;\n            })\n        );\n    });\n}\n</code></pre>\n<h3>2.2. <a name='-1'></a>子应用挂载/切换</h3>\n<p>在single-spa启动的时候,会监听路由事件然后再触发路由事件和执行reroute方法</p>\n<pre><code>/** 路由事件监听 */\nwindow.addEventListener(\"hashchange\", urlReroute);\nwindow.addEventListener(\"popstate\", urlReroute);\n/** patchedUpdateState也会触发urlReroute */patchedUpdateState\nwindow.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    \"pushState\"\n);\nwindow.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    \"replaceState\"\n);\n\nfunction urlReroute() {\n    reroute([], arguments);\n}\n</code></pre>\n<p>所以app挂载切换的主逻辑都在reroute的performAppChanges中,主要做了:</p>\n<ul>\n<li>\n<p>派发single-spa自定义事件</p>\n</li>\n<li>\n<p>执行移除/卸载状态应用的生命周期函数</p>\n</li>\n<li>\n<p>执行挂载应用的生命周期函数(依赖卸载/移除的执行tryToBootstrapAndMount)</p>\n<p>function performAppChanges() {</p>\n<pre><code>  return Promise.resolve().then(() => {\n      /** 派发single-spa自定义事件 */\n      /** 省略若干代码 */\n      // 执行需要移除/卸载状态应用的生命周期函数并且删除对应的生命周期函数\n      // 重置应用状态\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      const unmountUnloadPromises = appsToUnmount\n          .map(toUnmountPromise)\n          .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n      unmountAllPromise.then(() => {\n      window.dispatchEvent(\n          new CustomEvent(\n          \"single-spa:before-mount-routing-event\",\n          getCustomEventDetail(true)\n          )\n      );\n      });\n\n      // 子应用的加载和bootstrap生命周期函数执行\n      const loadThenMountPromises = appsToLoad.map((app) => {\n          return toLoadPromise(app).then((app) =>\n              tryToBootstrapAndMount(app, unmountAllPromise)\n          );\n      });\n      // 子应用挂载和mount生命周期函数的执行\n      const mountPromises = appsToMount\n          .filter((appToMount) => appsToLoad.indexOf(appToMount) &#x3C; 0)\n          .map((appToMount) => {\n              return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n      });\n      /** 省略若干代码 */\n  });\n  }\n  // tryToBootstrapAndMount依赖之前需要unLoad和unMount的应用周期函数执行完毕\n  function tryToBootstrapAndMount(app, unmountAllPromise) {\n      if (shouldBeActive(app)) {\n          return toBootstrapPromise(app).then((app) =>\n          unmountAllPromise.then(() =>\n              shouldBeActive(app) ? toMountPromise(app) : app\n          )\n          );\n      } else {\n          return unmountAllPromise.then(() => app);\n      }\n  }\n</code></pre>\n</li>\n</ul>\n<p>以上梳理了single-spa实现微前端的主体流程</p>\n<h2>3. <a name='-1'></a>关于微前端的一些总结思考</h2>\n<p>在讨论使用一个技术方案的时候,主要考虑点这项技术方案是否能解决当前或者未来项目中遇到的问题,微前端的优势在于项目的组合(新老项目平滑过渡\\项目功能共享\\应用拆分\\流程解耦)等但同时也增加了项目维护的一些成本,需要结合项目和业务发展方向进行探索使用</p>\n<h2>4. <a name='-1'></a>参考</h2>\n<p><a href=\"https://juejin.cn/post/6862661545592111111\">微前端框架 之 single-spa 从入门到精通</a><br>\n<a href=\"https://blog.yuanziwen.cn/2019/12/18/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E8%90%BD%E5%9C%B0%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF\">微前端时代思考与实践</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/fy3qri\">你可能并不需要微前端</a><br>\n<a href=\"https://www.yuque.com/kuitos/gky7yw/rhduwc\">微前端的核心价值</a></p>","fields":{"readingTime":{"text":"11 min read"}},"frontmatter":{"title":"single-spa源码解读","date":"2022-01-19","tags":"JavaScript","path":"/single-spa","top":null,"summary":null}}},{"node":{"id":"5e7fd69f-b19b-561c-a302-2c7d94a46537","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#\">前置概念</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#-1\">沙盒</a></li>\n<li>1.2. <a href=\"#Proxy\">Proxy</a></li>\n<li>1.3. <a href=\"#with\">with</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#-1\">沙盒的实现方式</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#ProxySandbox\">ProxySandbox(单实例沙盒)</a></li>\n<li>2.2. <a href=\"#snapshotSandbox\">snapshotSandbox(单实例沙盒)</a></li>\n<li>2.3. <a href=\"#-1\">多实例沙盒</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">附录</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>不同的微前端框架会提供沙盒环境来实现不同微前端应用的隔离.本文梳理JavaScript中沙盒的实现方式，有助于学习微前端方案的技术细节.</p>\n<h2>1. <a name=''></a>前置概念</h2>\n<h3>1.1. <a name='-1'></a>沙盒</h3>\n<p>沙盒是一种安全机制可以为程序提供隔离的执行环境，沙盒中提供用后即回收的磁盘及内存空间，在沙盒中对网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是被严格限制的.JavaScript沙盒是通过语法层面的限制来实现代码执行的隔离.</p>\n<h3>1.2. <a name='Proxy'></a>Proxy</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>可以实现对对象属性访问的代理，通过Proxy的使用可以实现JavaScript代码执行的沙盒模式</p>\n<h3>1.3. <a name='with'></a>with</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with\">with</a>语句可以扩展当前的执行上下文</p>\n<pre><code>const a = { name: 1111 }\nwith(a) {\n    console.log(name) // 1111\n}\n</code></pre>\n<h2>2. <a name='-1'></a>沙盒的实现方式</h2>\n<p>沙盒的实现方式上主要分为:</p>\n<ul>\n<li>单实例沙盒: 同一个时刻只有一个微应用实例存在，当前资源被这个应用独占，需要解决的主要问题是应用切换的时候变量污染清理和再次启动时的变量恢复</li>\n<li>多实例沙盒: 资源不是应用独占，需要解决资源共享、通信等问题</li>\n</ul>\n<h3>2.1. <a name='ProxySandbox'></a>ProxySandbox(单实例沙盒)</h3>\n<p>基于Proxy的拦截和设置功能，通过Proxy拦截对全局对象的修改记录，在应用切换的时候还原全局对象</p>\n<pre><code>    /** 设置全局对象属性 */\n    const setWindowProp = (prop, value) => {\n        window[prop] = value\n    }\n\n    class SandBox {\n        name;\n        /** 代理对象 需要通过该对象操作沙盒 */\n        proxy = null;\n        /** 新增的修改 */\n        addedPropsMap = new Map();\n        /** 沙盒期间更新的修改 */\n        modifiedOriginValueProps = new Map();\n        /** 当前沙盒所做的修改 用于还原当前的沙盒 */\n        currentUpdatedProps = new Map();\n        /** 激活沙盒 */\n        active() {  \n            this.currentUpdatedProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n        }\n        /** 沙箱卸载 */\n        inactive() {\n            /** 修改的属性还原 */\n            this.modifiedOriginValueProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n            /** 增加的属性清空 */\n            this.addedPropsMap.forEach((_, p) => {\n                setWindowProp(p, undefined)\n            })\n        }\n        constructor(name) {\n            this.name = name;\n            const fakeWindow = Object.create(null)\n            const {\n                addedPropsMap,\n                modifiedOriginValueProps,\n                currentUpdatedProps,\n            } = this\n            const proxy = new Proxy(fakeWindow, {\n                get(target, prop) {\n                    return window[prop]\n                },\n                set(_, prop, value) {\n                    if(!window.hasOwnProperty(prop)) {\n                        /** window上没有该属性 新增 */\n                        addedPropsMap.set(prop, value)\n                    } else if(!modifiedOriginValueProps.hasOwnProperty(prop)) {\n                        /** window上有该属性且未更新,记录 */\n                        const originValue = window[prop] \n                        modifiedOriginValueProps(prop, originValue)\n                    }\n                    /** 记录当前沙盒的更新 */\n                    currentUpdatedProps.set(prop, value)\n                    /** 更新全局属性 */\n                    setWindowProp(prop, value)\n                    return true\n                }\n            })\n            this.proxy = proxy\n        }\n    }\n\n    const newSandBox = new SandBox('app')\n    const proxyWindow = newSandBox.proxy\n    proxyWindow.appName = 'app'\n    console.log(window.appName, proxyWindow.appName) // app app\n    newSandBox.inactive()\n    console.log(window.appName, proxyWindow.appName) // undefined undefined\n    newSandBox.active()\n    console.log(window.appName, proxyWindow.appName) // app app\n</code></pre>\n<h3>2.2. <a name='snapshotSandbox'></a>snapshotSandbox(单实例沙盒)</h3>\n<p>快照沙盒是在不支持Proxy的环境下，通过将window对象属性都复制到快照对象上然后再激活和卸载的时候对激活期间的diff进行添加或者回退.这个方案的对比方案较复杂，比如考虑到原型链的修改与还原问题，一般不作为沙盒方案的首选.</p>\n<pre><code>class SnapshotSandbox {\n    constructor(name) {\n        this.name = name;\n        this.proxy = window;\n        this.type = 'Snapshot';\n        this.sandboxRunning = true;\n        this.windowSnapshot = {};\n        this.modifyPropsMap = {};\n        this.active();\n    }\n    //激活\n    active() {\n        // 记录当前快照\n        this.windowSnapshot = {};\n        iter(window, (prop) => {\n            this.windowSnapshot[prop] = window[prop];\n        });\n\n        // 恢复之前的变更\n        Object.keys(this.modifyPropsMap).forEach((p) => {\n            window[p] = this.modifyPropsMap[p];\n        });\n\n        this.sandboxRunning = true;\n    }\n    //还原\n    inactive() {\n        iter(window, (prop) => {\n            if (window[prop] !== this.windowSnapshot[prop]) {\n                // 记录变更，恢复环境\n                this.modifyPropsMap[prop] = window[prop];\n            \n                window[prop] = this.windowSnapshot[prop];\n            }\n        });\n        this.sandboxRunning = false;\n    }\n}\n\nconst sandbox = new SnapshotSandbox();\nconst proxyWindow = sandbox.proxy\nsandbox.active();\nproxyWindow.appName = 'app'\nconsole.log(proxyWindow.appName, window.appName) // app app\nsandbox.inactive();\nconsole.log(proxyWindow.appName, window.appName) // undefined undefined\n</code></pre>\n<h3>2.3. <a name='-1'></a>多实例沙盒</h3>\n<p>多实例沙盒是Proxy实现的单实例的变种版，在Proxy实现的单实例沙盒中，Proxy的handler的get/set是直接操作的全局对象,多实例版本在handler的get/set中操作沙盒自己维护的对象，从而实现多实例模式</p>\n<pre><code>class MultiProxySandbox {\n    name;\n    proxy = null;\n    /** context 传入多实例沙盒共享数据 */\n    constructor(name, context={}){\n        this.name = name;\n        const fakeWindow = Object.create({});\n        const proxy =  new Proxy(fakeWindow,{\n        set(target, name, value){\n            /** 返回共享属性  */\n            if(Object.keys(context).includes(name)){\n                context[name] = value;\n            }\n            target[name] = value;\n        },\n        get(target,name){\n            // 优先使用共享对象\n            if(Object.keys(context).includes(name)){\n                return context[name];\n            }\n            if( typeof target[ name ] === 'function' &#x26;&#x26; /^[a-z]/.test(name)){\n            return target[ name ].bind &#x26;&#x26; target[ name ].bind( target );\n            } else {\n            return target[ name ];\n            }\n        }\n        })\n        this.proxy = proxy\n        return proxy\n    }\n}\n\nconst context = { document: window.document, globalData:'abc'};\nconst newSandBox1 = new MultiProxySandbox('app1',context);\nconst newSandBox2 = new MultiProxySandbox('app2',context);\nnewSandBox1.appName = 'app1'\nnewSandBox2.appName = 'app2'\nconsole.log(newSandBox1.appName, newSandBox2.appName, window.appName) // app1 app2 undefined\nconsole.log(newSandBox1.globalData, newSandBox2.globalData) // abc abc\n</code></pre>\n<h2>3. <a name='-1'></a>附录</h2>\n<p><a href=\"https://juejin.cn/post/6844904066225537037\">字节跳动的微前端沙盒实践</a><br>\n<a href=\"https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg\">前端微服务在字节跳动的打磨与应用</a><br>\n<a href=\"https://cloud.tencent.com/developer/article/1748172\">谈谈微前端领域的js沙箱实现机制</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null}}},{"node":{"id":"323785b4-f7d7-591d-a250-aee7abdc366b","html":"<h3><a href=\"https://alexkondov.com/tao-of-react/\">Tao of React - Software Design, Architecture &#x26; Best Practices</a></h3>\n<p>这篇文章介绍了React开发中的一些‘最佳’实践,比如组件逻辑拆分、项目的目录设计、react常见的写法等，可以将其中的一些点作为code review时候的一些参考点</p>\n<h3><a href=\"https://blog.tericcabrel.com/implement-server-sent-event-in-node-js/\">Implement Server-Sent Events in Node.js and React</a></h3>\n<p>这篇文章介绍nodejs中server-sent events的实现服务端推送，看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventSource#browser_compatibility\">兼容性</a>上还可以。在有node中间层的服务可以尝试这种方案</p>\n<h3><a href=\"https://blog.molecule.dev/the-only-custom-react-hooks-we-use/\">The only two custom React hooks we ever really use</a></h3>\n<p>这篇文章介绍了两个自定义的hooks,可以在项目中尝试下</p>\n<ul>\n<li>useAsyncExtendedState  实现state的部分更新，更新state的时候只需要传入需要更新的属性即可.</li>\n<li>userPromise 异步事件的管理(cancal, reset)</li>\n</ul>\n<h3><a href=\"https://thoughtspile.github.io/2021/11/15/unintentional-layout-effect/\">useEffect sometimes fires before paint</a></h3>\n<p>这篇文章介绍了react hook-useEffect和useLayoutEffect触发时机和结合使用的一些注意事项</p>\n<h3><a href=\"https://thoughtspile.github.io/2022/01/17/jsx-conditionals/\">Good advice on JSX conditionals</a></h3>\n<p>这篇文章介绍在React中写JSX的一些建议写法，有利于规范的形成，比如禁止嵌套三元运算符也能防止代码出现不可预知的错误</p>\n<h3><a href=\"https://blog.saeloun.com/2022/01/13/react-18-usedefferedvalue-hook\">Sneak peek into React 18 useDeferredValue hook</a></h3>\n<p>这篇文章介绍React 18中useDeferredValue hook.通过useDeferredValue可以实现指定优先级的渲染任务.</p>\n<h3><a href=\"https://www.robinwieruch.de/react-event-bubbling-capturing/\">React: Event Bubbling and Capturing</a></h3>\n<p>这篇文章通过图解和例子的方式比较生动的介绍了React中事件的处理机制，可以作为温习</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null}}},{"node":{"id":"cc4079ca-b1c7-595d-8587-228c1e489fd6","html":"<h2><a href=\"https://web.dev/aspect-ratio/\">aspect-ratio CSS property</a></h2>\n<p>通过aspect-ratio可以直接为容器设置宽高比</p>\n<h2>React</h2>\n<h3><a href=\"https://www.joshfinnie.com/blog/using-webassembly-created-in-rust-for-fast-react-components/\">Using WebAssembly (created in Rust) for Fast React Components</a></h3>\n<p>一篇React结合WebAssembly的介绍文章</p>\n<h3><a href=\"https://alexsidorenko.com/\">A Visual Guide to React Rendering -xxx</a></h3>\n<p>很不错的介绍react相关api和基本概念的文档</p>\n<h3><a href=\"https://joshcollinsworth.com/blog/introducing-svelte-comparing-with-react-vue\">Introducing Svelte, and Comparing Svelte with React and Vue</a></h3>\n<p>一篇介绍Svelte与react和vue的对比文章，通过这篇文章发现Svelte的确在某些情况较react/vue有一定优势，可以保持关注度</p>\n<h3><a href=\"https://devtrium.com/posts/react-typescript-using-generics-in-react\">React &#x26; TypeScript: use generics to improve your types</a></h3>\n<p>这篇文章结合useState的例子介绍react中泛型的使用</p>\n<h2>项目设计</h2>\n<h3><a href=\"https://dev.to/mbarzeev/creating-a-react-component-with-tdd-2jn8\">Creating a React component with TDD</a></h3>\n<p>在react项目中引入TDD的案例文章</p>\n<h3><a href=\"https://engineering.udacity.com/react-folder-structure-for-enterprise-level-applications-f8384eff162b\">React folder structure for enterprise level applications</a></h3>\n<p>React项目文件组织的推荐方式，文件的组织、文档、技术方案都是项目整体架构的一部分，需要给予关注</p>\n<h2>前端库</h2>\n<h3><a href=\"https://github.com/breejs/bree\">Bree</a></h3>\n<p>Bree is the best job scheduler for Node.js and JavaScript with cron, dates, ms, later, and human-friendly support</p>\n<h3><a href=\"https://github.com/DominicTobias/react-image-crop\">React Image Crop</a></h3>\n<p>An image cropping tool for React with no dependencies</p>\n<h3><a href=\"https://github.com/pubkey/rxdb\">RxDB</a></h3>\n<p>RxDB是基于PouchDB的一套响应式数据库存储方案</p>\n<h3><a href=\"https://github.com/dexie/Dexie.js\">Dexie.js</a></h3>\n<p>在IndexedDB基础上进行封装，提供更好用的查询api和降低IndexedDB的使用成本</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null}}},{"node":{"id":"78fb9a8d-a295-5d20-8c43-9a4a98d296ef","html":"<h2>1. <a name=''></a>跨端相关</h2>\n<h3>1.1. <a name='Flipperhttps:fbflipper.com'></a><a href=\"https://fbflipper.com/\">Flipper</a></h3>\n<p>Flipper是调试react native的桌面工具，相对于之前的远程调试(模拟JS运行在本地浏览器)，Flipper的调试都基于当前react native的运行环境，使用体验上也比远程调试的方式好一些.</p>\n<h3>1.2. <a name='Elecruehttps:github.comRajvirSingh1313Elecrue'></a><a href=\"https://github.com/RajvirSingh1313/Elecrue\">Elecrue</a></h3>\n<p>Elecrue是一个生成Electron模板应用的工具，做一些辅助的Electron应用可以尝试使用这个工具</p>\n<h2>2. <a name='React'></a>React相关</h2>\n<h3>2.1. <a name='whatsnewinreact18https:yagmurcetintas.comjournalwhats-new-in-react-18'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-react-18\">what's new in react 18?</a></h3>\n<p>这篇文章介绍了React 18的新特性，其中<a href=\"https://github.com/reactwg/react-18/discussions/21\">Automatic batching</a>值得关注</p>\n<h3>2.2. <a name='react-usehttps:github.comstreamichreact-use'></a><a href=\"https://github.com/streamich/react-use\">react-use</a></h3>\n<p>react-use是一个hooks的工具函数库，需要对应的hooks实现的时候可以参考</p>\n<h3>2.3. <a name='react-loadablehttps:github.comjamiebuildsreact-loadable'></a><a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a></h3>\n<p>react-loadable是基于webpack dynamic import实现的动态加载组件的库，看它的实现其实不难，感悟是要到通用的问题要学会抽象的提取并且设计解决方案，比如loadable的loading设置时间，超时时间等，都是在解决开发中的问题。webpack还有splitChunk实现chunk的拆分。</p>\n<h3>2.4. <a name='react-queryhttps:react-query.tanstack.comoverview'></a><a href=\"https://react-query.tanstack.com/overview\">react-query</a></h3>\n<p>相对于Redux，react-query减少了很多模板代码的编写，减少了代码的理解成本。能让你falling into the pit of success.<a href=\"https://tkdodo.eu/blog/react-query-as-a-state-manager\">React Query as a State Manager</a>这篇是在官网上看到的react-query做状态管理的例子。</p>\n<h2>3. <a name='Javascript'></a>Javascript相关</h2>\n<h3>3.1. <a name='whatsnewines2022https:yagmurcetintas.comjournalwhats-new-in-es2022'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-es2022\">what's new in es2022?</a></h3>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":6,"pageCount":15,"additionalContext":{"pageAllCount":86}}},"staticQueryHashes":[]}