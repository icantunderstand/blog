{"componentChunkName":"component---src-templates-index-js","path":"/6","result":{"pageContext":{"pageAllCount":89,"group":[{"node":{"id":"5e7fd69f-b19b-561c-a302-2c7d94a46537","html":"<!-- vscode-markdown-toc -->\n<ul>\n<li>\n<ol>\n<li><a href=\"#\">前置概念</a></li>\n</ol>\n<ul>\n<li>1.1. <a href=\"#-1\">沙盒</a></li>\n<li>1.2. <a href=\"#Proxy\">Proxy</a></li>\n<li>1.3. <a href=\"#with\">with</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li><a href=\"#-1\">沙盒的实现方式</a></li>\n</ol>\n<ul>\n<li>2.1. <a href=\"#ProxySandbox\">ProxySandbox(单实例沙盒)</a></li>\n<li>2.2. <a href=\"#snapshotSandbox\">snapshotSandbox(单实例沙盒)</a></li>\n<li>2.3. <a href=\"#-1\">多实例沙盒</a></li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li><a href=\"#-1\">附录</a></li>\n</ol>\n</li>\n</ul>\n<!-- vscode-markdown-toc-config\n\tnumbering=true\n\tautoSave=true\n\t/vscode-markdown-toc-config -->\n<!-- /vscode-markdown-toc -->\n<p>不同的微前端框架会提供沙盒环境来实现不同微前端应用的隔离.本文梳理JavaScript中沙盒的实现方式，有助于学习微前端方案的技术细节.</p>\n<h2>1. <a name=''></a>前置概念</h2>\n<h3>1.1. <a name='-1'></a>沙盒</h3>\n<p>沙盒是一种安全机制可以为程序提供隔离的执行环境，沙盒中提供用后即回收的磁盘及内存空间，在沙盒中对网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是被严格限制的.JavaScript沙盒是通过语法层面的限制来实现代码执行的隔离.</p>\n<h3>1.2. <a name='Proxy'></a>Proxy</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>可以实现对对象属性访问的代理，通过Proxy的使用可以实现JavaScript代码执行的沙盒模式</p>\n<h3>1.3. <a name='with'></a>with</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with\">with</a>语句可以扩展当前的执行上下文</p>\n<pre><code>const a = { name: 1111 }\nwith(a) {\n    console.log(name) // 1111\n}\n</code></pre>\n<h2>2. <a name='-1'></a>沙盒的实现方式</h2>\n<p>沙盒的实现方式上主要分为:</p>\n<ul>\n<li>单实例沙盒: 同一个时刻只有一个微应用实例存在，当前资源被这个应用独占，需要解决的主要问题是应用切换的时候变量污染清理和再次启动时的变量恢复</li>\n<li>多实例沙盒: 资源不是应用独占，需要解决资源共享、通信等问题</li>\n</ul>\n<h3>2.1. <a name='ProxySandbox'></a>ProxySandbox(单实例沙盒)</h3>\n<p>基于Proxy的拦截和设置功能，通过Proxy拦截对全局对象的修改记录，在应用切换的时候还原全局对象</p>\n<pre><code>    /** 设置全局对象属性 */\n    const setWindowProp = (prop, value) => {\n        window[prop] = value\n    }\n\n    class SandBox {\n        name;\n        /** 代理对象 需要通过该对象操作沙盒 */\n        proxy = null;\n        /** 新增的修改 */\n        addedPropsMap = new Map();\n        /** 沙盒期间更新的修改 */\n        modifiedOriginValueProps = new Map();\n        /** 当前沙盒所做的修改 用于还原当前的沙盒 */\n        currentUpdatedProps = new Map();\n        /** 激活沙盒 */\n        active() {  \n            this.currentUpdatedProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n        }\n        /** 沙箱卸载 */\n        inactive() {\n            /** 修改的属性还原 */\n            this.modifiedOriginValueProps.forEach((v, p) => {\n                setWindowProp(p, v)\n            })\n            /** 增加的属性清空 */\n            this.addedPropsMap.forEach((_, p) => {\n                setWindowProp(p, undefined)\n            })\n        }\n        constructor(name) {\n            this.name = name;\n            const fakeWindow = Object.create(null)\n            const {\n                addedPropsMap,\n                modifiedOriginValueProps,\n                currentUpdatedProps,\n            } = this\n            const proxy = new Proxy(fakeWindow, {\n                get(target, prop) {\n                    return window[prop]\n                },\n                set(_, prop, value) {\n                    if(!window.hasOwnProperty(prop)) {\n                        /** window上没有该属性 新增 */\n                        addedPropsMap.set(prop, value)\n                    } else if(!modifiedOriginValueProps.hasOwnProperty(prop)) {\n                        /** window上有该属性且未更新,记录 */\n                        const originValue = window[prop] \n                        modifiedOriginValueProps(prop, originValue)\n                    }\n                    /** 记录当前沙盒的更新 */\n                    currentUpdatedProps.set(prop, value)\n                    /** 更新全局属性 */\n                    setWindowProp(prop, value)\n                    return true\n                }\n            })\n            this.proxy = proxy\n        }\n    }\n\n    const newSandBox = new SandBox('app')\n    const proxyWindow = newSandBox.proxy\n    proxyWindow.appName = 'app'\n    console.log(window.appName, proxyWindow.appName) // app app\n    newSandBox.inactive()\n    console.log(window.appName, proxyWindow.appName) // undefined undefined\n    newSandBox.active()\n    console.log(window.appName, proxyWindow.appName) // app app\n</code></pre>\n<h3>2.2. <a name='snapshotSandbox'></a>snapshotSandbox(单实例沙盒)</h3>\n<p>快照沙盒是在不支持Proxy的环境下，通过将window对象属性都复制到快照对象上然后再激活和卸载的时候对激活期间的diff进行添加或者回退.这个方案的对比方案较复杂，比如考虑到原型链的修改与还原问题，一般不作为沙盒方案的首选.</p>\n<pre><code>class SnapshotSandbox {\n    constructor(name) {\n        this.name = name;\n        this.proxy = window;\n        this.type = 'Snapshot';\n        this.sandboxRunning = true;\n        this.windowSnapshot = {};\n        this.modifyPropsMap = {};\n        this.active();\n    }\n    //激活\n    active() {\n        // 记录当前快照\n        this.windowSnapshot = {};\n        iter(window, (prop) => {\n            this.windowSnapshot[prop] = window[prop];\n        });\n\n        // 恢复之前的变更\n        Object.keys(this.modifyPropsMap).forEach((p) => {\n            window[p] = this.modifyPropsMap[p];\n        });\n\n        this.sandboxRunning = true;\n    }\n    //还原\n    inactive() {\n        iter(window, (prop) => {\n            if (window[prop] !== this.windowSnapshot[prop]) {\n                // 记录变更，恢复环境\n                this.modifyPropsMap[prop] = window[prop];\n            \n                window[prop] = this.windowSnapshot[prop];\n            }\n        });\n        this.sandboxRunning = false;\n    }\n}\n\nconst sandbox = new SnapshotSandbox();\nconst proxyWindow = sandbox.proxy\nsandbox.active();\nproxyWindow.appName = 'app'\nconsole.log(proxyWindow.appName, window.appName) // app app\nsandbox.inactive();\nconsole.log(proxyWindow.appName, window.appName) // undefined undefined\n</code></pre>\n<h3>2.3. <a name='-1'></a>多实例沙盒</h3>\n<p>多实例沙盒是Proxy实现的单实例的变种版，在Proxy实现的单实例沙盒中，Proxy的handler的get/set是直接操作的全局对象,多实例版本在handler的get/set中操作沙盒自己维护的对象，从而实现多实例模式</p>\n<pre><code>class MultiProxySandbox {\n    name;\n    proxy = null;\n    /** context 传入多实例沙盒共享数据 */\n    constructor(name, context={}){\n        this.name = name;\n        const fakeWindow = Object.create({});\n        const proxy =  new Proxy(fakeWindow,{\n        set(target, name, value){\n            /** 返回共享属性  */\n            if(Object.keys(context).includes(name)){\n                context[name] = value;\n            }\n            target[name] = value;\n        },\n        get(target,name){\n            // 优先使用共享对象\n            if(Object.keys(context).includes(name)){\n                return context[name];\n            }\n            if( typeof target[ name ] === 'function' &#x26;&#x26; /^[a-z]/.test(name)){\n            return target[ name ].bind &#x26;&#x26; target[ name ].bind( target );\n            } else {\n            return target[ name ];\n            }\n        }\n        })\n        this.proxy = proxy\n        return proxy\n    }\n}\n\nconst context = { document: window.document, globalData:'abc'};\nconst newSandBox1 = new MultiProxySandbox('app1',context);\nconst newSandBox2 = new MultiProxySandbox('app2',context);\nnewSandBox1.appName = 'app1'\nnewSandBox2.appName = 'app2'\nconsole.log(newSandBox1.appName, newSandBox2.appName, window.appName) // app1 app2 undefined\nconsole.log(newSandBox1.globalData, newSandBox2.globalData) // abc abc\n</code></pre>\n<h2>3. <a name='-1'></a>附录</h2>\n<p><a href=\"https://juejin.cn/post/6844904066225537037\">字节跳动的微前端沙盒实践</a><br>\n<a href=\"https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg\">前端微服务在字节跳动的打磨与应用</a><br>\n<a href=\"https://cloud.tencent.com/developer/article/1748172\">谈谈微前端领域的js沙箱实现机制</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"前端沙盒的实现方式","date":"2022-01-18","tags":"JavaScript","path":"/sandbox","top":null,"summary":null}}},{"node":{"id":"323785b4-f7d7-591d-a250-aee7abdc366b","html":"<h3><a href=\"https://alexkondov.com/tao-of-react/\">Tao of React - Software Design, Architecture &#x26; Best Practices</a></h3>\n<p>这篇文章介绍了React开发中的一些‘最佳’实践,比如组件逻辑拆分、项目的目录设计、react常见的写法等，可以将其中的一些点作为code review时候的一些参考点</p>\n<h3><a href=\"https://blog.tericcabrel.com/implement-server-sent-event-in-node-js/\">Implement Server-Sent Events in Node.js and React</a></h3>\n<p>这篇文章介绍nodejs中server-sent events的实现服务端推送，看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventSource#browser_compatibility\">兼容性</a>上还可以。在有node中间层的服务可以尝试这种方案</p>\n<h3><a href=\"https://blog.molecule.dev/the-only-custom-react-hooks-we-use/\">The only two custom React hooks we ever really use</a></h3>\n<p>这篇文章介绍了两个自定义的hooks,可以在项目中尝试下</p>\n<ul>\n<li>useAsyncExtendedState  实现state的部分更新，更新state的时候只需要传入需要更新的属性即可.</li>\n<li>userPromise 异步事件的管理(cancal, reset)</li>\n</ul>\n<h3><a href=\"https://thoughtspile.github.io/2021/11/15/unintentional-layout-effect/\">useEffect sometimes fires before paint</a></h3>\n<p>这篇文章介绍了react hook-useEffect和useLayoutEffect触发时机和结合使用的一些注意事项</p>\n<h3><a href=\"https://thoughtspile.github.io/2022/01/17/jsx-conditionals/\">Good advice on JSX conditionals</a></h3>\n<p>这篇文章介绍在React中写JSX的一些建议写法，有利于规范的形成，比如禁止嵌套三元运算符也能防止代码出现不可预知的错误</p>\n<h3><a href=\"https://blog.saeloun.com/2022/01/13/react-18-usedefferedvalue-hook\">Sneak peek into React 18 useDeferredValue hook</a></h3>\n<p>这篇文章介绍React 18中useDeferredValue hook.通过useDeferredValue可以实现指定优先级的渲染任务.</p>\n<h3><a href=\"https://www.robinwieruch.de/react-event-bubbling-capturing/\">React: Event Bubbling and Capturing</a></h3>\n<p>这篇文章通过图解和例子的方式比较生动的介绍了React中事件的处理机制，可以作为温习</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2022-1-1-前端快报","date":"2022-01-01","tags":"前端快报","path":"/2022-1-1","top":null,"summary":null}}},{"node":{"id":"cc4079ca-b1c7-595d-8587-228c1e489fd6","html":"<h2><a href=\"https://web.dev/aspect-ratio/\">aspect-ratio CSS property</a></h2>\n<p>通过aspect-ratio可以直接为容器设置宽高比</p>\n<h2>React</h2>\n<h3><a href=\"https://www.joshfinnie.com/blog/using-webassembly-created-in-rust-for-fast-react-components/\">Using WebAssembly (created in Rust) for Fast React Components</a></h3>\n<p>一篇React结合WebAssembly的介绍文章</p>\n<h3><a href=\"https://alexsidorenko.com/\">A Visual Guide to React Rendering -xxx</a></h3>\n<p>很不错的介绍react相关api和基本概念的文档</p>\n<h3><a href=\"https://joshcollinsworth.com/blog/introducing-svelte-comparing-with-react-vue\">Introducing Svelte, and Comparing Svelte with React and Vue</a></h3>\n<p>一篇介绍Svelte与react和vue的对比文章，通过这篇文章发现Svelte的确在某些情况较react/vue有一定优势，可以保持关注度</p>\n<h3><a href=\"https://devtrium.com/posts/react-typescript-using-generics-in-react\">React &#x26; TypeScript: use generics to improve your types</a></h3>\n<p>这篇文章结合useState的例子介绍react中泛型的使用</p>\n<h2>项目设计</h2>\n<h3><a href=\"https://dev.to/mbarzeev/creating-a-react-component-with-tdd-2jn8\">Creating a React component with TDD</a></h3>\n<p>在react项目中引入TDD的案例文章</p>\n<h3><a href=\"https://engineering.udacity.com/react-folder-structure-for-enterprise-level-applications-f8384eff162b\">React folder structure for enterprise level applications</a></h3>\n<p>React项目文件组织的推荐方式，文件的组织、文档、技术方案都是项目整体架构的一部分，需要给予关注</p>\n<h2>前端库</h2>\n<h3><a href=\"https://github.com/breejs/bree\">Bree</a></h3>\n<p>Bree is the best job scheduler for Node.js and JavaScript with cron, dates, ms, later, and human-friendly support</p>\n<h3><a href=\"https://github.com/DominicTobias/react-image-crop\">React Image Crop</a></h3>\n<p>An image cropping tool for React with no dependencies</p>\n<h3><a href=\"https://github.com/pubkey/rxdb\">RxDB</a></h3>\n<p>RxDB是基于PouchDB的一套响应式数据库存储方案</p>\n<h3><a href=\"https://github.com/dexie/Dexie.js\">Dexie.js</a></h3>\n<p>在IndexedDB基础上进行封装，提供更好用的查询api和降低IndexedDB的使用成本</p>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-12-1-前端快报","date":"2021-12-07","tags":"前端快报","path":"/2021-12-07","top":null,"summary":null}}},{"node":{"id":"78fb9a8d-a295-5d20-8c43-9a4a98d296ef","html":"<h2>1. <a name=''></a>跨端相关</h2>\n<h3>1.1. <a name='Flipperhttps:fbflipper.com'></a><a href=\"https://fbflipper.com/\">Flipper</a></h3>\n<p>Flipper是调试react native的桌面工具，相对于之前的远程调试(模拟JS运行在本地浏览器)，Flipper的调试都基于当前react native的运行环境，使用体验上也比远程调试的方式好一些.</p>\n<h3>1.2. <a name='Elecruehttps:github.comRajvirSingh1313Elecrue'></a><a href=\"https://github.com/RajvirSingh1313/Elecrue\">Elecrue</a></h3>\n<p>Elecrue是一个生成Electron模板应用的工具，做一些辅助的Electron应用可以尝试使用这个工具</p>\n<h2>2. <a name='React'></a>React相关</h2>\n<h3>2.1. <a name='whatsnewinreact18https:yagmurcetintas.comjournalwhats-new-in-react-18'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-react-18\">what's new in react 18?</a></h3>\n<p>这篇文章介绍了React 18的新特性，其中<a href=\"https://github.com/reactwg/react-18/discussions/21\">Automatic batching</a>值得关注</p>\n<h3>2.2. <a name='react-usehttps:github.comstreamichreact-use'></a><a href=\"https://github.com/streamich/react-use\">react-use</a></h3>\n<p>react-use是一个hooks的工具函数库，需要对应的hooks实现的时候可以参考</p>\n<h3>2.3. <a name='react-loadablehttps:github.comjamiebuildsreact-loadable'></a><a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a></h3>\n<p>react-loadable是基于webpack dynamic import实现的动态加载组件的库，看它的实现其实不难，感悟是要到通用的问题要学会抽象的提取并且设计解决方案，比如loadable的loading设置时间，超时时间等，都是在解决开发中的问题。webpack还有splitChunk实现chunk的拆分。</p>\n<h3>2.4. <a name='react-queryhttps:react-query.tanstack.comoverview'></a><a href=\"https://react-query.tanstack.com/overview\">react-query</a></h3>\n<p>相对于Redux，react-query减少了很多模板代码的编写，减少了代码的理解成本。能让你falling into the pit of success.<a href=\"https://tkdodo.eu/blog/react-query-as-a-state-manager\">React Query as a State Manager</a>这篇是在官网上看到的react-query做状态管理的例子。</p>\n<h2>3. <a name='Javascript'></a>Javascript相关</h2>\n<h3>3.1. <a name='whatsnewines2022https:yagmurcetintas.comjournalwhats-new-in-es2022'></a><a href=\"https://yagmurcetintas.com/journal/whats-new-in-es2022\">what's new in es2022?</a></h3>","fields":{"readingTime":{"text":"2 min read"}},"frontmatter":{"title":"2021-11-2-前端快报","date":"2021-11-10","tags":"前端快报","path":"/2021-11-10","top":null,"summary":null}}},{"node":{"id":"f8414df6-bcbe-5abe-af66-071c3b4aa351","html":"<h3>基础知识</h3>\n<h2><a href=\"https://jakearchibald.com/2021/cors/\">How to win at CORS</a></h2>\n<p>CROS看这篇就够了</p>\n<h2>React Native相关</h2>\n<p><a href=\"https://formidable.com/blog/2019/react-codegen-part-1/\">The New React Native Architecture Explained</a>这个系列文章介绍了React Native架构升级的一些核心概念，包括Turbo Modules,Fabric, JSI等，可以快速的了解架构升级背后的原理。可以结合<a href=\"https://www.cnblogs.com/ludashi/p/15381067.html\">React Native之新架构中的Turbo Module实现原理分析</a>来深入到原理部分。</p>\n<h2>项目管理&#x26;设计</h2>\n<h3><a href=\"https://blog.codinghorror.com/falling-into-the-pit-of-success/\">Falling Into The Pit of Success</a></h3>\n<p>一篇关于系统设计的文章，在进行系统设计的时候我们要思考在使用系统的时候如何让用户获得使用上的收益而不是通过一些手段去弥补系统的漏洞</p>\n<h3><a href=\"https://yonigoldberg.medium.com/fighting-javascript-tests-complexity-with-the-basic-principles-87b7622eac9a\">Writing clean JavaScript tests with the BASIC principles</a></h3>\n<p>在业务开发中，会因为业务的压力导致单测执行粒度不够，KPI式的单测覆盖率目标并不能保证有效的单测。比如前端做单测，在哪些维度做单测的尝试是值得考虑的(基础组件，核心api处理逻辑等)，这边文章讨论了单测执行过程中的一些问题并且给出了如何写单测的原则建议，很有意义。在附一个<a href=\"https://www.zhihu.com/question/27081528/answer/1872155062\">知乎关于单测的讨论</a></p>\n<h3><a href=\"https://mp.weixin.qq.com/s/g5ZjQt9F1UUryisEW1csSA\">这可能是大型复杂项目下数据流的最佳实践</a></h3>\n<p>这篇是关于项目治理的文档，数据流的设计与拆分，领域模块的隔离都有借鉴意义值得学习。项目的治理要早否则根深蒂固就积重难返了。</p>\n<h2>React</h2>\n<h3>hooks实践</h3>\n<p><a href=\"https://devtrium.com/posts/react-typescript-how-to-type-hooks\">React &#x26; TypeScript: how to type hooks (a complete guide)</a><br>\n<a href=\"https://thoughtspile.github.io/2021/10/18/non-react-state/\">How to replace useState with useRef and be a winner</a></p>\n<h3><a href=\"https://www.zhihu.com/question/468249924/answer/1968728853\">知乎上关于hooks的讨论</a></h3>\n<p>其中beeplin的回答有很多借鉴意义，思考到项目的设计问题</p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-11-1-前端快报","date":"2021-11-03","tags":"前端快报","path":"/2021-11-03","top":null,"summary":null}}},{"node":{"id":"ea186f12-6741-57d1-9751-230edd265c28","html":"<h2><a href=\"https://blog.openreplay.com/using-recoil-instead-of-redux-for-state-management-in-react-applications\">Recoil</a></h2>\n<p><a href=\"https://github.com/facebookexperimental/Recoil\">Recoil</a>是facebook出品的react状态管理库,这篇文章介绍了Recoil的简单使用。Recoil的特点是它通过写react的方式完成了状态管理，不像redux会在代码中引入更多的概念，值得一试</p>\n<h2><a href=\"http://www.ayqy.net/blog/cross-platform-pains/\">跨端方案的三大困境</a></h2>\n<p>跨端开发是主流app都会采用的方案，跨端的方式在短时间内可以尽快的试错跑通流程，相对于纯h5方案也有一定的性能优势，这篇文档主要介绍跨端开发中的一些思考点，对这些问题深入的思考能帮助更好的发展跨端技术。</p>\n<h2><a href=\"https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838\">React Native at Airbnb: The Technology</a></h2>\n<p>Airbnb关于React Native实践的系列文章，从中也能启发出很多跨端开发的思考点</p>\n<h2><a href=\"https://dev.to/adamdbradley/introducing-partytown-run-third-party-scripts-from-a-web-worker-2cnp\">Introducing Partytown 🎉: Run Third-Party Scripts From a Web Worker</a></h2>\n<p>现在的web开发通常需要引入很多第三方sdk来统计业务信息等，这些sdk的执行会增长用户的可交互时间，<a href=\"https://github.com/BuilderIO/partytown\">partytown</a>可以通过worker来运行第三方sdk来减少主页面js的执行时间，现阶段partytown还处于实验阶段，值得后续关注</p>\n<h2><a href=\"https://calibreapp.com/blog/bundle-size-optimization#lazy-load-third-party-resources-with-facades\">Small Bundles, Fast Pages: What To Do With Too Much JavaScript</a></h2>\n<p>这篇文章介绍系统的介绍了优化js包体积大小的方式，其实对momentjs使用的例子很有意思，优化其实不是一蹴而就的，废弃项目这个的momentjs可以从禁止momentjs使用的提示开始</p>\n<h2><a href=\"https://prateeksurana.me/blog/javascript-developer-guide-to-browser-cookies/\">A JavaScript developer’s guide to browser cookies</a></h2>\n<p>cookie拿来吧你</p>\n<h2><a href=\"https://github.com/mithi/react-philosophies\">https://github.com/mithi/react-philosophies</a></h2>\n<p>这篇文章介绍react中组件设计，性能优化的一些最佳实践方式，很有借鉴意义的文章。相关的文档还有<a href=\"https://kentcdodds.com/blog/dont-sync-state-derive-it\">Don't Sync State. Derive It!</a></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"2021-10-第一期","date":"2021-10-09","tags":"前端快报","path":"/2021-10-1","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":6,"pageCount":15,"additionalContext":{"pageAllCount":89}}},"staticQueryHashes":[]}