{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/9",
    "result": {"pageContext":{"pageAllCount":90,"group":[{"node":{"id":"b01b3c20-e1da-5302-8c89-7076361a2c51","html":"<p>在<a href=\"https://icantunderstand.github.io/blog/webview-store\">一起学跨端技术-Webview缓存</a>中介绍了几种常用的缓存实现方案，几种方案都各有优缺点。其实h5页面加载过程可以类比成CPU在运行时动态获取数据，从寄存器中读取数据对比从磁盘中读取数据的时间是相差极大的。那h5页面加载的时候有没有一种方案可以绕过耗时较大的网络获取数据阶段直接加载内容展示呢？离线化就是这种解决方案。通过离线包的动态下发可以让用户在打开页面的时候直接加载已经在app中存储的离线化资源从而加速页面的展示。本文从以下两个方面介绍离线包的实现过程:</p>\n<ul>\n<li>离线包分发过程</li>\n<li>端内加载离线包过程</li>\n</ul>\n<h2>离线包分发过程</h2>\n<p>离线包的分发流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 907px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnElEQVQ4y4WS167CQAxE8/8/h0QEQfReQk0oSSjy1RnJuStA4sFa72Z9PONNVFWV3e93ez6fCvLj8Whpmtput7PtdluH71n3+319Tr7ZbOx8PlsEoCgKW6/XOjydTrqwWq2053w+n6sB++l0aqPRyLrdro3HY+v3+4rZbGaLxeIfyGWKALJOJhMVAGClgBUYZwBpxNlwOJQAzqNvlh36btWDbx4uBCey7MDH46Eoy1JFXAzDQRR6E/YoY0ScHw4Hi4DwCFhEMuoAYKXVaqmAvNPpyCb3yOM4ltVer2fNZlPfGEs9wzzPJfl6varbcrnUBeAMm2IaMjdyoP4YQJktdR+WyS+Xi2VZpias3ogcheS32033uOMrwqQQaBgOJl6vl2aGdVQnSSLV5ED8Ib0m8kKHkaMACwyZi1hpNBqyyYzb7bZs8yh8D8XUwBAc7ilA0WAwUBNy/xe9YVgTfYOFagms8Sfwe2CZWQJjZu8iPoAhlMGzAvJHAETOWH4qDLtRhD1UUMjwUQocGHvyn8AQ6i8HkOBBPIDxO71b/gMnvXNQcp6IjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"分发\"\n        title=\"分发\"\n        src=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png\"\n        srcset=\"/blog/static/e435443c1f4cf311506e3ed3631074b5/63868/broadcast.png 250w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/0b533/broadcast.png 500w,\n/blog/static/e435443c1f4cf311506e3ed3631074b5/142fb/broadcast.png 907w\"\n        sizes=\"(max-width: 907px) 100vw, 907px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n分发流程中主要涉及4种角色:</p>\n<ul>\n<li>离线配置平台 配置平台可以提供离线配置能力、离线包管理(上传、禁用、清空)、离线包使用统计、离线包准入审核(自动(包大小限制)+人工(解决特殊case))</li>\n<li>离线配置服务 配置服务主要提供服务层能力，实现离线配置服务，离线包更新服务，离线资源上传下载服务、离线资源使用统计服务</li>\n<li>离线SDK 端内接入离线SDK，SDK主要与离线配置服务进行交互，完成离线资源的管理和接入配置能力</li>\n<li>Native侧  实现拦截请求在特定的协议下接入离线资源</li>\n</ul>\n<h2>离线包加载过程</h2>\n<p>离线包的加载流程如下图:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQ4y32UWa+CQAyF5///Mx95IMYouKOouOKGS83XpDfDON6HpjDLOaenBdc0jRD3+/0vn89n8df9PTL7l8ultWbhwksc3G63crvdvojIrC+XS6mq6ouwBWiHZ7OZ5Hku4/G4BUY8Hg85HA6yXq8V1Fdp4XwGAKfTqSRJoqAxwLquZT6fa3CeNc5YdiaVBfOvKAo5Ho8S8/f1eklZlrLb7RQQxfv9Xm2CzAHACwAc4BJlxzyElPP9fl+yLFPi4XAok8lEA3AHOhssrFYr6fV6qgDQ0B/zEDsABJx3BKGYd3e9XlUdGZM3m40SLBYLXQtVvt9vbQpdhoA7NIjQks0/gjJRl6apmh5TCDkKKRWQ0WgknU5HgwpbXUYRyiiHHHaZZ5QNBgMFPJ1O2hDsYTrUQ78kACmZC7CHgDYFANgcovr5fGpEBxvmbrf7s9MoZA+facTXYIcKMZwL5BggJeIVwDarPz89AGFlhCg95iEkNhHhd94CtKFFgeXwjxL+Wf792xg7CukWOabQ9yum8AMub8+9QkzZbwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"加载\"\n        title=\"加载\"\n        src=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png\"\n        srcset=\"/blog/static/85d2a579802aafb31cddfcf549a0cd72/63868/load.png 250w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/0b533/load.png 500w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/00d43/load.png 1000w,\n/blog/static/85d2a579802aafb31cddfcf549a0cd72/25260/load.png 1113w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在端加载离线资源的过程中可以分为两个方面:</p>\n<ul>\n<li>离线SDK更新离线配置和离线资源 离线SDK通过与离线配置服务交互完成离线配置和离线包资源更新</li>\n<li>Web容器加载离线资源</li>\n</ul>\n<p>下面从代码层面简单介绍下加载离线资源的实现</p>\n<h3>离线配置</h3>\n<p>离线需要有一定的配置能力，比如禁用、特定的前缀支持离线化等。通过对离线配置的解析，Web容器就知道在打开对应页面是否的具体行为。这个过程是约定协议的过程。</p>\n<h3>加载离线资源</h3>\n<p>在<a href=\"https://icantunderstand.github.io/blog/jsbridge\">Hybrid开发-JSBridge原理</a>中通过拦截请求在特定的协议下可以实现javascript和Native的通信，那么在特定的协议下其实也可以实现离线包的加载能力。</p>\n<pre><code>// 定义请求资源类型映射\nprivate HashMap&#x3C;String, String > resourceMimeTypeMap  = new HashMap&#x3C;String, String>();\npublic CustomWebViewClient() {\n    super();\n    resourceMimeTypeMap.put(\"html\", \"text/html\");\n    resourceMimeTypeMap.put(\"js\", \"application/javascript\");\n}\n@Override\npublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n    // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n    Uri uri = request.getUrl();\n    String scheme = uri.getScheme();\n    String host = uri.getHost();\n    String path = uri.getPath();\n    // 处理资源加载离线包场景\n    // 协定 域名为www.test.com 且 path是local的走加载离线包逻辑\n    if(host.equals(new String(\"www.test.com\")) &#x26;&#x26; path.startsWith(\"/local\")) {\n        InputStream in = null;\n        String pageNamePath = path.split(\"/\")[2];\n        String type = pageNamePath.split(\"\\\\.\")[1];\n        String mimeType = \"text/plain\";\n        if(resourceMimeTypeMap.containsKey(type)) {\n            mimeType = resourceMimeTypeMap.get(type);\n        }\n        try {\n            // 加载本地离线资源\n            in = view.getContext().getAssets().open(pageNamePath);\n        } catch(IOException e) {\n          // 处理处理本地无离线资源 请求网络\n          return super.shouldInterceptRequest(view, request);\n        }\n        // 将本地读取的的内容进行类型映射后通过WebResourceResponse返回\n        WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", in);\n        return response;\n    }\n    return super.shouldInterceptRequest(view, request);\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 706px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADg0lEQVRIx+WWXUybZRTHn5WvQaFv2/ft2kIFRqgbHWbqHGGBTnEujdNIBpRBgjcmBo0yJ4lZskggfBhCsuxiiUYIXHJrwsW80HhhHBfTzGnQaLYJLZJsYx/EOIW29Geep5Z0fExJXhONJ/nl/J9zzvPvafopXnz5JH7/XoqLSzAMVwo9I+sGum6ovNbP6LndHnwlj1Bbe4ipqSmEXSvAphXgLXbj9rhw6DZ0w47T0NANDaeuUbbbh6c43fuzLrPLjlO3Y+xyICyCUCiE8Bi78Tqq8BkBfK4AXseeDfiMfRTrVZv2Sj1VlBgBnNZSGhqOIJ4ofIeOskuEfZ/S+eRFXj84zWFxgWd3fEyDSPGMuLCm08i+nOs88AVdh76iY/9HPBc8jjiaf54uEeNVscgbOXfp2nmPTnGH13b8TSy3ObXzPh1ihiO1xxEhyyhn98C5g79z7qkY5+tivC1W6BIrvKWIZeSNnBTLnBJJXhFRHq88jHjJMcpIBQwHYgxVxnjPn+BdI64441jhtO03TmsP4z5ntDhvFs2xr7wWcXbwfeau/MqXn8zy/fRNLn8WYWZ6gSufR7j+9V3u/JTk1rU4i9cTm3LrapylKHx7MUro6POID0c/4ObtBS5/c4kbiz/z47Xv+OGqZIZ7vyySiiRbR6q3cCNKuDWMmJiY4GGxmkiSXE2yugWJ+Kqam5uN0NbWhhgfH1eFeDxOMimHVlVOo3ZIbr2hnJcRiawzTCQSDxiZZrjd+EcNT5wwe0MzDaPRKOFw2FzDlpYWsw1N3rCpqen/Zmj6q9zc3PwvNzT9KZtqKD/LphrOz8/T2Nj4X3wfbpcN3zZjY2OqsLy8rH6otkssFlP3Z2dnU4aTk5OYEUtLS7S2tiLk8x4ZGaG/v5+hoSH6+vro7e1VenBwUNHT06P66bPUsib1wMAAw8PDdHd3p/4fCiHIpLCwkIqKigdqdXV1ZGdnr52lbm9vZ/3dmpoahNVqVQO5ublYLBYcDgcej0dpWcvKyqK8vJyioiKlJVJXV1erezk5OeTl5SnD+vp6hK7rOJ1OhdSapmGz2UjXZZZb2+12pSVSFxQUrN0zDIP8/HyCwSBCNwxcLpcqpvmr8/qa2+3Gai1MGe4ydOyatrZNJnJ4K515luTl5vLCsWOIygNPszdQTVlpqXqkzbZZb5S5pdfrxe9/FH9gPyWPBfkD9GZ9jWzUPEsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"成功加载离线资源\"\n        title=\"成功加载离线资源\"\n        src=\"/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png\"\n        srcset=\"/blog/static/2a4c23295151170c16b9a53887eda09b/63868/loadsuccess.png 250w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/0b533/loadsuccess.png 500w,\n/blog/static/2a4c23295151170c16b9a53887eda09b/9f21b/loadsuccess.png 706w\"\n        sizes=\"(max-width: 706px) 100vw, 706px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"一起学跨端技术-离线包","date":"2021-07-22","tags":"跨端技术","path":"/cross-platform-offline","top":null,"summary":null}}},{"node":{"id":"6b8e80fe-a035-556b-b871-f4c4ffc7e118","html":"<p>跨端开发中h5加载性能优化是一个老生常谈的问题。h5在开发上有着迭代快、试错成本低的优势，但是h5的性能问题也是一个无法绕过的问题。加载慢、体验差是通常在考虑技术选型时候的一个顾虑点。本系列会以Webview性能优化为切入点尝试了解跨端开发中的技术方案来更好的辅助业务的开发。</p>\n<p>充分利用Webview的缓存(存储)机制能有效的提升h5的加载速度,通常有如下的方案可以实现缓存的过程:</p>\n<ul>\n<li>h5缓存机制</li>\n<li>Application Cache</li>\n<li>浏览器存储</li>\n</ul>\n<h2>h5缓存机制</h2>\n<p>h5缓存是指浏览器根据文件网络传输中的一些字段来确认是否使用已经缓存的文件，具体可以参考<a href=\"https://icantunderstand.github.io/blog/web-store\">缓存那些事</a><br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVQoz22SzY6bMBSF8/zddNF1q64rtX2ESO2imheYdFPRhAwJJJAQfgwG+6uOgUwqjSXLNvfy3XOuvfIewGPtjnEscQ68t1h7wLkG5zxlWdL3HSHTt3i/A/Z4H4epPexwLmc1AR1dF2FMxvF4pq5PdN0T45hQ14YoiqjrKgCdE+wzxnwiit7z/PyOOP4AfMT7NSup8xOVYfAcj0eapp3PjtPpxO1243VcgSe8/8XttqYs1zTND+An8HtSOAFluw+ApmlmNY7z+UxVVfR9jzEtbWvIsoKyrJl1zK2Y1pVg3rsZaEmS5K5IMQHrusYYQ57nYf/ysqco8iBgGOyCDPmrBy/BooBStAyBlDgMA1mWhXMcx2GvAloVk5tZ4Y4k+UaSfMeYiDg+UFWvPZNVAbuu43A40LZtgFwul9AeQfVN8QB07i/7/RfS9CvW/iFJ0vuNqvLSAv2w2WyC5fv1XK8hplVFxnH837K1Y6isigswTdOgQla32214k+q1zuqvYppFUUzAx0sZxyEokM3HoRwVkUX1Vz8KqlVz6V+wLNDjW3yELHNRq+ek9a2x5P4Dh85Sl/bdd+YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"h5缓存机制\"\n        title=\"h5缓存机制\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/63868/cache.png 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/0b533/cache.png 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/00d43/cache.png 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/0f529/cache.png 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Application Cache</h2>\n<p>Application Cache主要是做应用的离线化配置，它跟h5通过缓存头实现的缓存机制相对独立。通过在html中引入manifest属性开启Application Cache.</p>\n<pre><code>&#x3C;html manifest=\"example.appcache\">\n...\n&#x3C;/html>\n\nCACHE MANIFEST\n# Version 1\n// CACHE下声明的文件将在首次加载后进行缓存\nCACHE:\nscript/scriptfilename1.js\ncss/cssfilename.css\nimages/imagename1.png\nimages/imagename2.jpg\nimages/imagename3.png\n// FALLBACK定义离线状态下的规则 \nFALLBACK:\n// images下的资源都将使用images/imagename4.png替代\nimages/ images/imagename4.png\n// 缓存白名单 应用对Network下的请求都会绕过缓存请求服务器\nNETWORK:\nimages/imagename5.png\n\n// 端侧在初始化Webview的时候开启Application Cache \nWebSettings webSettings = webView.getSettings();\n// 允许执行JS\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n</code></pre>\n<p>在使用Application Cache需要注意以下几点:</p>\n<ul>\n<li>有同源限制，缓存大小限制(5MB)</li>\n<li>需要更新缓存文件的时候，需要同步更新manifest文件</li>\n<li>manifest声明中的文件无法下载时会导致无法更新到最新的缓存，浏览器将使用旧的缓存文件(推荐一些几乎不更新的文件使用Application Cache)</li>\n<li>可以在业务代码中通过window.applicationCache相关api实现缓存资源的手动触发更新</li>\n</ul>\n<h2>浏览器存储</h2>\n<p>通过浏览器提供的api实现数据的存储和缓存功能。</p>\n<h3>Dom Storage</h3>\n<p>Dom Storage指的是LocalStorage和SessionStorage。LocalStorage是持久存储，SessionStorage是会话存储。他们都通过key-value的方式来对简单的数据进行存储。Dom Storage存储空间为5MB有同源限制。</p>\n<pre><code>WebSettings webSettings = webView.getSettings();\nwebSettings.setJavaScriptEnabled(true);\nwebSettings.setAppCacheEnabled(true);\n// Webview初始化开启Dom Storage\nwebSettings.setDomStorageEnabled(true);\n\n// javascript\n// 设置键值\nwindow.localStorage.setItem('name', 'haha')\n// 读取键值\nwindow.localStorage.getItem('name')  // 返回\"haha\"\n</code></pre>\n<h3>IndexedDB</h3>\n<p>IndexedDB可以通过数据库的方式对数据进行存储，它的存储空间相对于Dom Storage大很多。通常可以基于封装IndexedDB的库来实现数据的存储。IndexedDB的使用方式可以参考<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<h2>参考</h2>\n<p><a href=\"https://webplatform.github.io/docs/apis/appcache/ApplicationCache/\">ApplicationCache</a><br>\n<a href=\"https://www.html5rocks.com/zh/tutorials/appcache/beginner/\">应用缓存初级使用指南</a><br>\n<a href=\"https://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>","fields":{"readingTime":{"text":"4 min read"}},"frontmatter":{"title":"一起学跨端技术-Webview缓存","date":"2021-07-21","tags":"跨端技术","path":"/webview-store","top":null,"summary":null}}},{"node":{"id":"743bd4e6-3437-513e-a516-b525ec1dee0c","html":"<p>Android中可以使用异步消息处理机制来完成主线程和子线程任务调度，本文主要介绍使用Handler实现消息通信的过程。</p>\n<h2>Handler</h2>\n<h3>基本概念</h3>\n<p>使用Handler实现异步消息需要以下的组件:</p>\n<ul>\n<li>Message\n发送消息传递的数据对象</li>\n<li>Handler\n负责消息的传递和处理</li>\n<li>MessageQueue\n负责保存当前线程中的发送的Message，每个线程只能有一个MessageQueue</li>\n<li>Looper\n负责管理线程中的MessageQueue，将MessageQueue中的Message不停的取出给Handler处理。每个线程只有一个Looper</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 814px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxzQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAQABBQJp/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQESExQf/aAAgBAQABPyG2301CwGUf/9oADAMBAAIAAwAAABAjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExcYGRsf/aAAgBAQABPxAoWhxEaUveYagcl+RXQfIANVP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Handler实现结构\"\n        title=\"Handler实现结构\"\n        src=\"/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg\"\n        srcset=\"/blog/static/86b2a15f43db42534948074b87746b3e/0479a/Handler.jpg 250w,\n/blog/static/86b2a15f43db42534948074b87746b3e/41099/Handler.jpg 500w,\n/blog/static/86b2a15f43db42534948074b87746b3e/e51eb/Handler.jpg 814w\"\n        sizes=\"(max-width: 814px) 100vw, 814px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>例子实现</h3>\n<p>下面的例子中布局文件中定义了一个TextView和Button，在Button点击的时候通过发送Message来实现TextView内容的更新。 使用Handler处理异步消息主要有如下的步骤:</p>\n<ul>\n<li>\n<p>初始化Looper(Looper.prepare)和MessageQueue(Looper.loop)</p>\n</li>\n<li>\n<p>根据当前的Looper创建Handler并重写handleMessage方法</p>\n</li>\n<li>\n<p>在子线程中通过Handler发送Message传递数据</p>\n</li>\n<li>\n<p>主线程处理数据(UI显示)</p>\n</li>\n<li>\n<p>主线程退出后清除Handler的任务/关闭Looper</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n  // 定义更新按钮文旦的标识\n  public static  final  int UPDATE_TEXT = 1;\n  private TextView textView;\n  private Handler handler;\n  private Runnable runnable;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    textView = (TextView) findViewById(R.id.textView);\n    Button button = (Button) findViewById(R.id.button);\n    if(Looper.myLooper() == null) {\n      // 初始化当前线程的Looper 通过判断保证当前线程只有一个Looper\n      Looper.prepare();\n      // 开始线程中的MessageQueue\n      Looper.loop();\n    }\n    // 创建Handler  创建Handler必须执行Looper\n    handler = new Handler(Looper.myLooper()) {\n      @Override\n      public void handleMessage(@NonNull Message msg) {\n        // 重写消息处理方法\n        switch (msg.what) {\n          case UPDATE_TEXT:\n            // 获取传递的数据\n            String content = msg.getData().getString(\"content\");\n            textView.setText(content);\n            break;\n        }\n        super.handleMessage(msg);\n      }\n    };\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n          // 在子线程中通过Handler发送Message\n          runnable = new Runnable() {\n            @Override\n            public void run() {\n              // 这里可以做一些耗时操作\n              Message message = new Message();\n              Bundle bundle = new Bundle();\n              bundle.putString(\"content\", \"you click me!!!\");\n              message.setData(bundle);\n              message.what = UPDATE_TEXT;\n              handler.sendMessage(message);\n            }\n          };\n          runnable.run();\n        }\n    });\n  }\n  @Override\n  protected void onDestroy() {\n    // 可以在这里清除runnable/终止消息的处理\n    handler.removeCallbacks(runnable);\n    Looper.myLooper().quit();\n    super.onDestroy();\n  }\n}\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/blog/54c35e9eba49d7862bdca4f06c052160/showHandler.gif\" alt=\"使用Handler\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-异步消息处理","date":"2021-07-09","tags":"跨端技术","path":"/android-async","top":null,"summary":null}}},{"node":{"id":"d49efd27-23e6-5f40-ba34-533df32251e2","html":"<p>Hybrid混合开发相对于单一的客户端开发有着开发周期短，迭代快的优势，但是Hybrid模式开发的页面存在着一定的缺陷，比如性能问题、缺乏客户端能力等。通过JSBridge这个桥梁可以实现客户端能力的打通，赋予了Hybrid应用更强的端能力。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 838px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcElEQVQ4y42U2Y7CMAxF+/8/SJ8qSksXukJXKNSjY8lVBmZEI0W249wb23HiDcMgZVlKVVVSFIX0fS+Px0Pn7XbT9bqudaKz3/xd121Y5DiO4qHgZCABLssi9/tdzuezbmY2TbPZz+dT/WDXdVUsNj7PNjAgAggxG06nk8zzLFEUSdu2moFLiG7DglFCiN4JIcqyTNI0VcnkAPxuhLsJAcRxLFZj6nm5XD5S/kpIagDQIbTakS4S+/V6bQT/ElJcZJ7neltERJqskT4AOgD/NE2qUw4G2A9CUiMy3/cVFIahBEGgAFKjRYjscDhs0aIzOByOj5St9wBatNfrVcuANNuyIf2vNWTRLuV4PCoZkZI+NSVaMqEMu2/Z6kZE2OyB2Ozdt8yi2zbUyYjQqes7ob2UX4TUjIF0Ce2FJEmipDQ2oL9eCmsbIRdBqwC2t2wp2+fAQdguoX0mdIhhPYAQ2qTH7DfhENoFEBP93e9i4foBsVCB7aDDCl4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"JS\"\n        title=\"JS\"\n        src=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png\"\n        srcset=\"/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/63868/JSBridge.png 250w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/0b533/JSBridge.png 500w,\n/blog/static/b3d8e916f6b411fbcf30d403e8bb1cde/a1dd2/JSBridge.png 838w\"\n        sizes=\"(max-width: 838px) 100vw, 838px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nJSBridge作为客户端和H5的通信的桥梁，可以承接如下的能力:</p>\n<ul>\n<li>鉴权能力 JSBridge调用能力鉴权，白名单，黑名单等</li>\n<li>胶水能力 JSBridge兼容代码，做版本控制等调用透明</li>\n<li>测试能力 提供测试方法，方便测试</li>\n<li>Scope(配置)能力 能基于配置产出精简版、目标版本JSBridge</li>\n</ul>\n<p>下面以Android代码为例，介绍JSBridge的实现方式。</p>\n<h2>Js调用Native</h2>\n<p>Js调用Native通常有如下的方案:</p>\n<ul>\n<li>拦截请求(shouldOverrideUrlLoading/shouldInterceptRequest)</li>\n<li>拦截特定方法(prompt/alert/confirm)</li>\n<li>客户端注入JSBridge(addJavascriptInterface)</li>\n</ul>\n<h3>拦截请求</h3>\n<p>在安卓初始化Wevview的时候可以设定WebViewClient，WebViewClient主要功能是处理Webview加载时的通知和请求事件等。通过重写WebViewClient的shouldOverrideUrlLoading/shouldInterceptRequest就可以实现拦截h5的请求从而实现端能力调用。\n实现思路如下:</p>\n<ul>\n<li>定义JSBridge实现Jsb方法</li>\n<li>定义JSBManager管理Jsb的调用</li>\n<li>实现拦截方法的重写</li>\n<li>H5侧调用</li>\n</ul>\n<h4>定义JSBridge方法类</h4>\n<pre><code>// 以下例子均省略import语句 \npublic class JSBridge {\n  // 需要考虑callback和入参一致性问题\n  public void showToast(JSONObject jsonObject) {\n      try {\n          Toast.makeText(MainActivity.context, jsonObject.getString(\"content\"), Toast.LENGTH_LONG).show();\n      } catch(Exception e) {\n      }\n  }\n}\n</code></pre>\n<h4>定义JSBManager管理Jsb的调用</h4>\n<pre><code>public class JsbManager {\n  // 通过HashMap获取JSBridge定义的所有方法\n  public static Map&#x3C;String, Method> methodMap = new HashMap&#x3C;>();\n  public void init() {\n      Method[] methods = JSBridge.class.getDeclaredMethods();\n      for(Method method : methods) {\n          methodMap.put(method.getName(), method);\n      }\n  }\n}\n</code></pre>\n<h4>实现拦截方法的重写</h4>\n<p>以下以shouldOverrideUrlLoading方法的重写为例子。在例子中定义的通信协议是myjsb://method?params。通过在拦截方法中对请求进行解析就可以实现调用对应客户端method的逻辑。</p>\n<pre><code>public class CustomWebViewClient extends WebViewClient {\n    private JsbManager jsbManager = new JsbManager();\n    private JSBridge jsBridge = new JSBridge();\n    public void initJsb() {\n        // 初始jsbManager和jsBridge实例\n        jsbManager.init();\n        jsBridge = new JSBridge();\n    }\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        // 处理jsb 协议情况  只拦截jsb协议的url 其他放行\n        Uri uri = request.getUrl();\n        String scheme = uri.getScheme();\n        if(scheme.equals(new String(\"myjsb\"))) {\n            // 获取方法名 入参\n            String methodName = uri.getAuthority();\n            String query = uri.getQuery();\n            try {\n                JSONObject jsonObject = new JSONObject(query);\n                Method method = jsbManager.methodMap.get(methodName);\n                // 调用对应的客户端逻辑\n                method.invoke(jsBridge,jsonObject);\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n}\n// 主活动代码逻辑\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 创建WebViewClient\n        CustomWebViewClient webViewClient = new CustomWebViewClient();\n        // 调用JSBridge初始逻辑\n        webViewClient.initJsb();\n        WebView webView = (WebView) findViewById(R.id.webView);\n        // 设置WebViewClient处理webviewt通知，请求等\n        webView.setWebViewClient(webViewClient);\n        // 开启调试功能\n        webView.setWebContentsDebuggingEnabled(true);\n        WebSettings webSettings = webView.getSettings();\n        // 允许执行JS\n        webSettings.setJavaScriptEnabled(true);\n        // 这里加载项目本地的html文件方便调试\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n}\n</code></pre>\n<h4>H5侧调用</h4>\n<pre><code>    &#x3C;body>\n        &#x3C;div>this page test JSB&#x3C;/div>\n        &#x3C;script>\n          // 通过创建iframe发起JSBridge调用\n          function iframeCall(url) {\n            let iframe = document.createElement('iframe')\n            iframe.src = url\n            iframe.style.display = 'none'\n            document.documentElement.appendChild(iframe)\n            setTimeout(() => { document.documentElement.removeChild(iframe) })\n          }\n          function callJsb(method, params) {\n            let url = `myjsb://`\n            if(!method) {\n              return\n            }\n            url += `${method}`\n            if(!!params) {\n              url += `?${encodeURIComponent(JSON.stringify(params))}`\n            }\n            iframeCall(url)\n          }\n          callJsb('showToast', { content: 'xiaohong' })\n        &#x3C;/script>\n    &#x3C;/body>\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 196.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAnCAYAAAAPZ2gOAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+1US09TQRQeGwh90Pb29kFppQ9BVAghGjfqQorFaNyZCCt3CBSoMa6IhkRiDCYmBqMxRU34ObSEFlalYCIkbuTRCra29N62n5nR2/SF1IorPMmXc+Y7c89jZs4lOl4DTq+AoUmL5pNGaHRyaHkldAYleKOS+ZpbeLQ4TeAMCuiMyiLwRhXbr9UrwPFqEDN/Gm36PrTqXWhvuoZzVjfOWtxw6lywq3tg1/TAoXHBoXUxuxA2dQ/aDL3otLlxpqkPdlM3SLuqH/dsn3DXGoK3O8zwuPcj7nBB9BE/bpIAblQA5am/nwth4moEE5c+w+2YArmoHsQDkoOH7GCUfIW3fpfpMbKLcdkuxk/8QqFdwNF9w2QH94kIt3wG5Hz9MJ5bgVeXU3h5QcSHWxk84gSMkTS8VWKcJPGQANfr34JcMQ/hRTvwrCOO6c4UpjtSeNqaxJQjiSlndXjijGP6FHDb+gZkaNADiMDulzTi21nEd7JIRLP4Hqse37YFQABez/hARsdGQSVLo9YoOWSYfvd+FsTj8bCFIIjIZXM1QRR+FjPrKwgoiiJyuVxNFdJvWcDZ/wGPacBS5B/vb5JVDJjJZA6ehEMqrxgwlUpBEASk02kGuml/fz8frOoKR0ZGsLm5iXA4jOXlZaytrWF1dRXr6+uMq7llqSrp7LLZ7N+1LJGlZ/fHLf+zWz7mo1eoDzrXwuSHXkrpDR80OZKuusJq7aqejfTYY7EYtra2GKLRKJLJZFkHZaNHhc4t/UEUIpFIYGNjA0tLSwyRSAR7e3tl+2hiKj6fD8Tr9eKoZG5uDmRgYID9DBYWFhAMBrG4uAi/389silAoxHyBQIDZEjc/P5//huqVlRVMTk6CKJVKEEKKwHFc0Voul0Or1RZxFosFKpWqiKurqwNpbGwsIx0ORxFnMplgs9mYLZPJmO7q6oLZbC5LTHQ6HdRqdR40AXVIa41GA4VCwThqS1xDQwNodxJHwTozGAwwGo1FoBUdxlXaQ2MRvV6PowSx2+3geZ5Fp5Ac0rqUK/UX8rTKH4LefgGruMzUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"拦截请求实现调用\"\n        title=\"拦截请求实现调用\"\n        src=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png\"\n        srcset=\"/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/63868/overrideUrlCall.png 250w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/0b533/overrideUrlCall.png 500w,\n/blog/static/69c4f6e5f0ec62ff288282e3bb7c3890/ebf47/overrideUrlCall.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>使用iframe发送消息的方式会存在消息丢失，参数限制等问题，可以通过消息队列和拦截shouldInterceptRequest方法来实现。</p>\n<h3>拦截特定方法</h3>\n<p>在初始化WebView的时候可以同步设置WebChromeClient，WebChromeClient主要是辅助WebView处理Js对话框，标题等操作，通过拦截WebChromeClient相应的方法同样可以实现调用端能力。</p>\n<h4>实现WebChromeClient</h4>\n<pre><code>public class CustomWebChromeClient extends WebChromeClient {\n    @Override\n    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\n        // 此处举例为主 直接弹端toast\n        // 实现上跟拦截url一致\n        Log.d(\"mesage\", message.startsWith(\"myjsb\")+ \"\");\n        if(message.startsWith(\"myjsb\")) {\n            Toast.makeText(MainActivity.context, \"PropmtCall\", Toast.LENGTH_LONG).show();\n            // 此时js调起了 需要JsPromptResult.confirm(result)\n            return true;\n        } else {\n            return super.onJsPrompt(view, url, message, defaultValue, result);\n        }\n    }\n}\n// 在初始化WebView的时候设置WebChromeClient\nCustomWebChromeClient webChromeClient = new CustomWebChromeClient();\nwebView.setWebChromeClient(webChromeClient);\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.prompt('myjsb://')\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 199.60000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEklEQVRIx+2U309bVRzAD9BCgdv23tt7ewsKq6nIBnWLcWYJ0RfjlLin6UzmHjQLyWYcbcfMKsZkPvrj0YRAoegMITz45xAShiYGWGIMIUQEWlrbjzmnu3jpHIPFx57kk/P9fs/3+znn9qGipydOxLSJOd040S5sK4ptOVgRBzviYJlRumLPKWSsah5kb9SOKceLiT6EbnYSMv3YsTCmrdEZ8qOFW9GtNoxogLDVSnevTlePrmLDDih0+9F5JIAWaqUz7Cesa4g+4xIX7HFes8d486XPuTj4BW+dGedccIyBtgzJ9tsMtKUVycBtBgMZhayf8acZev4ub788zjsDX5FwhhCva99yvf0PPgr+Sjr+kNHeh2STv3PV9wvviQdcESsHvO9B5pfFA64bv3E3uc6XyR1etUYQ77ZPcS8E48ZfZLVd7nXvkRK7jDXtcaelcDS+Ahmxx6fiT+4IuKDdQlwUOb4+Bd+d3eOb0/t8P7RPShS5KQp8cmx2yAg43zaKuPFGjoVrMPvBLvevFvnhSpGfrp2MHz/c4eeP4dK5UcT9uVlqqwxUH8XVE1JWU2OfZRD5fE1YKpWpVDg5f1cp7deE6XQGMTtbE5bLZarV6jMhZ+XKZOqEz7IawoawIWwIG8JjCt1/YW9cT/3ZU4Xe/Umv8kqf+snuQKVSOUDW3Lhe+kSh95Pk4NbWFqurq6ytral9fX2d7e3to184MzOjkmKxqA5KpZLaZb6xscHKygqLi4ssLS2xvLzM5ubmQY9LoVBQjlQqhVhYWOD/WtlsFjEyMsLc3BzT09Pk83lyuRyTk5MqlsifROZTU1MqdusTExOHZubn5xkeHkYIIahH07RDeTAYxOfzHaolEonH5lRPR0cHLS0tKmlublYyx3FoamrC7/erPRaLYZqmimWfpL+/X/XKGZlLh7xYyEZd1xWGYRAOh9WBjN2aHAyFQgc1iXyI7PXWpEtYto1t21iWpbDr8uPW3FiYeu2WSCRyJLL5v2IX5TANxOmz54mf6sWy/r3NHfLiFdWfSV6Ix+kbfIV/AHs5ocTNraY7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"重写Prompt方法调用\"\n        title=\"重写Prompt方法调用\"\n        src=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png\"\n        srcset=\"/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/63868/overridePrompt.png 250w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/0b533/overridePrompt.png 500w,\n/blog/static/a06b5060a7a0c62f3aa004ed02d87c42/ebf47/overridePrompt.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>客户端注入JSBridge</h3>\n<p>通过<a href=\"https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String)\">addJavascriptInterface</a>可以在初始化WebView的时候将客户端的调用逻辑暴露给H5。</p>\n<h4>实现JSInterface</h4>\n<pre><code>    public class JsInterface {\n        private Context context;\n        public JsInterface(Context context) {\n            this.context = context;\n        }\n        // JsInterface需要用@JavascriptInterface注解才可以被调用\n        @JavascriptInterface\n        public void showToast(String content) {\n            Toast.makeText(this.context, content, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    // 在初始WebView的时候注入interface\n    webView.addJavascriptInterface(new JsInterface(context), \"myjsb\");\n</code></pre>\n<h4>H5调用</h4>\n<pre><code>    window.myjsb.showToast(\"Interface\")  \n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 688px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 200.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADaklEQVRIx+2Vy09TQRTGB+jDK9D29j76UEyJIo9gfGCqJmowrtwQaMHIxoWJ8rJaCUaif4EL3oSFqAs3rliZCBFiXLKHiCECoRASiLzEtpT29jMz9dbyqoXgSif5Zc75euabczt3cslZ52UIvABZssJqOQJJlCGJFoYoUGTIkg1221EWx7Tf0DpZis1Wiw3EaMqEwawDL3Gw2HlkGjXIMupgEHTgZT2Mog6SPQs5uQJMkp7Bb5oPsfoskxYGEwdi54vhtD1AidyAi8fuo7TAi2uFXpRIDcjX16DocC0KuRoUHKpBIVcbp4irRYG+Bqf5elwv9uLq8Uacc1SBnDDcwF3Rh9vZX1F/bBqeXB+enJnDHWECZeQzXOTLrpSTMdzSj6Pp1AyeFH9DleMtyCmDC03aEJpNfjRxP/BM8sOr+YEHxI9GTQCPMnanMSMAb1oA9eQ7HpII3BnvQAp0LjRnRtB+IYTnRSF0X9nAUz6EeySIOhJEbQrUkQA8BKgg70Eu5bnwuiKMF2VBvCwPorcsiN7yIF651vGqIpgSvRUBvKkEHpe+B6m6WYnYUABE90mEOXz8NAhS6Y4ZKpEoFCWKqII9EwkrzOPDB2pY+cuQmkX3RyQS63BwMMFQ/XE/47/hP2uoKApjp/dM3XBPhsnGnzrfZri6uspYXFzE0tISVlZWWL6wsMC6TrXDvr4+ELfbjdnZWUxPT2NkZASTk5Ms9/l8GB8fjxenYtjf33+wjzw0NPQXD+X/TTlYw8Q52SGpcVLDVE51a82eOqTF6uukxls3/GOHanEoFML8/DympqbYDZqbm8Pa2lryjxS9elTc2NjYRDgcht/vx8zMDMbGxjA6OoqJiQksLy9vq11fX2eGAwMDINXV1TioMTw8DOJ0OtHd3Y2Ojg50dnayuaWlJZ53dXWhra2NaTSmGoXmra2tLG5vb0dPTw88Hg8Ix3EghGyC5/ltmiAIm3Kr1QqDwbCtjhiNRmg0mjharRYWiwV6vZ7l6enpbKHNZmOxTqdDWloacnJyWB2N6Rpay5qjO9OOEsnOzo7HZrMZdFOq0VjVaE43UjVVJ4IgQpIkiKIYZ2u+k0bzRI3FkgRilUWYTEaYzQL7n3aDLkqWsw55E0je+VLknczHEbt9x85UEo22IssyHA4HjucX4yfjfpxnxqZHBAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"interface调用\"\n        title=\"interface调用\"\n        src=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png\"\n        srcset=\"/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/63868/callInterface.png 250w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/0b533/callInterface.png 500w,\n/blog/static/ed43999980c970f7b14ebacfdbb9cd6b/ebf47/callInterface.png 688w\"\n        sizes=\"(max-width: 688px) 100vw, 688px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>Native调用Js</h2>\n<p>Nativa调用Js通常有如下的方案:</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></li>\n<li><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></li>\n</ul>\n<p>以下例子在H5中都定义了全局函数供Native调用</p>\n<pre><code>    function testNativeCall() {\n      console.log(\"nativeCallJs\")\n      return 'nativeCallJs'\n    }\n</code></pre>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#loadUrl(java.lang.String)\">loadUrl</a></h3>\n<p>可以通过webView.loadUrl(\"javascript: testNativeCall()\")发起调用(需要等待Js执行完成)。loadUrl的方式会刷新页面且无法获取js的回调。</p>\n<h3><a href=\"https://developer.android.com/reference/android/webkit/WebView#evaluateJavascript(java.lang.String,%20android.webkit.ValueCallback%3Cjava.lang.String%3E)\">evaluateJavascript</a></h3>\n<pre><code>webView.evaluateJavascript(\"javascript: testNativeCall()\", new ValueCallback&#x3C;String>() {\n    @Override\n    public void onReceiveValue(String value) {\n        return;\n    }\n});\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 198.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAABYlAAAWJQFJUiTwAAADPUlEQVRIx+1US08TURi9hSK0DG3n1SkEgRYlKAoGVoqPhZqwAF0pJi6MC9EIGoGFBlpRsRF5FAqJEH6AUXGlfwVIWFgKBASBYELaTqFwzL3N1PIqj7AwkZucfI97vnPPdOaW5OblQ+BF2JQs2GxZkCQrZFmBJFoZREFGVmY2A821vgbKtcoKREGC3e4AsQgcMiypkBQzRNkMznQMnCkNFskAQTayaMvmkXmcZzkvG2Ng+6KR8TlzGkxmDqSAv4GrOe9RrrSg4pQbVefaUFXchjLuJYpTnChJdbGo5fEoSmrGlew3uFn6DpVFnTiTUwFSzr1GLf8b9wx+1Np+4rF1Bs8Lf+Gu3o/bxIfqBLhFfuA+N4mG/Bm8OLmMi0oDyHWDBy1mwKkE4FJCeJsfwjNdEPW6EBr1KhqTE0Cvop6EUEeW0UCAS8YmkMvEg1YFaC8Jwn0ijPbiMJ6SEGpICA/3jADqCHBe3wRSc82Db0+Ajw8C+PxIxacaFUO1Kr7WqRiqi8ZEoJwvtUF8rwfulDeDfBjoRXRFcPAVnX3V6gLxeqOCK+EI1iLrB8JqOCrocrpAenujgpFIBOvr6wcCnWWCrm0E97uOBP9rwdXV1W2/MW1op8O2CPb19e3qYF8OOzs7EQwGsbi4iLm5ORaXlpawsLDAsG+HHR0dbHB8fBzDw8OYmprC9PQ0/H4/Jicn/4FHPvSXcnRTDl9w84vYCfGcXR3uxWk8d88ON39Ka2trsd6eHWrkcDiM+fl5+Hy+GCYmJtjVXFlZ2Vmwp6eHFaqqstMpKCEQCGB2dhajo6MMIyMjGBsbY/ed3n3K0fj0cLqcTifI4OAgDmu53W6Q6upqDAwMoLu7G16vl8Wuri7Qn4LWNNLa4/HEehT0T0WboU/Z39+PyspKEEIINsNisWyozWYzDAbDhl5hYeGWueTkZJD09HSW6PV6JCUlwWg0wmq1spz2dDodZFmGIAgsT0lJYXsOhwMZGRkxHtXgOA6EEnmej4G6o0Stpvu0NplMiOdSI9R5/CzdJ5IkMweSJMWwXb1bT8uJKFBXPERRTAhKTrRHn4xqkdOlF2DPy91wmkaKx3a9v3sSHHY7Cs6W4Q880qCTlgwo4gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"evaluate调用js\"\n        title=\"evaluate调用js\"\n        src=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png\"\n        srcset=\"/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/63868/evaluateJS.png 250w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/0b533/evaluateJS.png 500w,\n/blog/static/b941b4ef1b5f1a77e48fa6db88525cb3/1e043/evaluateJS.png 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>参考</h2>\n<p><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a>\n<a href=\"https://juejin.cn/post/6844903840588759048\">跨端技能必备之JSBridge</a>\n<a href=\"https://juejin.cn/post/6844903856418062350\">从零开始写一个 JSBridge</a></p>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Hybrid开发-JSBridge原理","date":"2021-07-07","tags":"跨端技术","path":"/jsbridge","top":null,"summary":null}}},{"node":{"id":"09619f27-782b-59fc-93f7-749e19e44ed8","html":"<p>在前端页面开发中，通常会将数据层和UI层进行隔离，这样能更好的做到职责的分离。在安卓开发中ViewModel可以实现UI的数据管理能力，结合LiveData的观察通知能力可以做到页面与数据视图的更新绑定，更有效的组织页面逻辑。</p>\n<h2>ViewModel</h2>\n<p>View能有效的做到视图和数据的分离，数据共享能力。\n<img src=\"./androidStatic/androidViewModel/viewmodel.png\" alt=\"ViewModel作用\"></p>\n<h3>ViewModel生命周期</h3>\n<p>ViewModel对象存在的时间范围是获取ViewModel时传递给ViewModelProvider的生命周期。ViewModel将一直留在内存中，直到限定其存在时间范围的Lifecycle永久消失：对于Activity，是在Activity完成时；而对于 Fragment，是在 Fragment 分离时。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkklEQVQ4y6WU208TQRTG+a99Uh/UGH3VaIgvPvkEGMGAPICXekVDsS3UloJZe9n7dtu9X2Z+ZhdbDdZC4yYnZ2Zy5ttz+b5ZklLmUkpx3sTECymyXIg8F6UXM2J/WREcLxUL/vObYEgpkylglmXSNE05GAxK3x8M5Nh1ZK3ry+WXinz86kQ+evVDtvVIQi6jNJJxFslc5MX9EkMI8RuwKGY8HmPbNqPRCMuyiUOfphpy53mH26tVbm8c0xhEuJHGoXZAU//KKBpOk5wCTjKeVY6XCHYbGk8rh2wf9NDHOXagcjQPsDhJ01SqqoqiKPT7/dLrukaYZHTtgO+qg2J6xBmY/iUAix5aloWmaZimia7r2I6DzGIyt8ew3yZ1FMhjDF+jeRHgv0qWgU3QfEF/b41RbQM8DSMwOFKrNLU5gJNeTk2Isz+MFKLXdxls3sTfuQFGHSOyaZk12lZjAUApygx9R+Pd+iN2Vh7yZu0BTu8Yw9fZa1f4cvIeN3QuByjEWQdOrIRr6wpXV5pcWTlhv5cyDAZsfVjn5f4249hdjDa2n/HsS48nO3VWP/2g56Q4oUbLrM8vuZhyEAQU5HZdF8/ziMKAIBE0ui4fDxWqpxZeDNaENvOGkiSJHA6HdLtd2u12SZ+h65LGIalnEboGiWeCyDB89WLa/Hot/hQ85S4ZE3QqnH7awP22C6GN7uscadVFpXe2laMe4cdltN37jCv3QKtjRQ4tvUbbaODFo9kZFo9DlmVF6aWlSUImQA4VzO1bKBs3MDavk7W2UH2davc9tf4eTmD+W8vFIIredTqdUnq+75PneRFeBE+5+fn0LVv7a2ztr9LS6otJ7y8pznlgL1DKbGP2+WKAk6mfX88C/AlUyUhxrEpdmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ViewModel生命周期\"\n        title=\"ViewModel生命周期\"\n        src=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png\"\n        srcset=\"/blog/static/a16d8eb6c5388ad144fb59e3930274eb/63868/cycle.png 250w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/0b533/cycle.png 500w,\n/blog/static/a16d8eb6c5388ad144fb59e3930274eb/29492/cycle.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>LiveData</h2>\n<p>LiveData是一种可观察的数据存储类，它具有生命周期感知能力，可以遵循其他应用组件(如Activity、Fragment、Service)的生命周期进行数据的更新通知。使用LiveData有通常有以下的三个步骤:</p>\n<ul>\n<li>在ViewModel中创建LiveData实例保存数据</li>\n<li>创建可以定义OnChange()方法的<a href=\"https://developer.android.com/reference/androidx/lifecycle/Observer?hl=zh-cn\">Observer</a>对象</li>\n<li>在界面控制器中使用<a href=\"https://developer.android.com/reference/androidx/lifecycle/LiveData?hl=zh-cn#observe(android.arch.lifecycle.LifecycleOwner,%0Aandroid.arch.lifecycle.Observer%3CT%3E)\">observe()</a>方法将创建的Observer对象附加到LiveData对象</li>\n</ul>\n<h3>添加依赖</h3>\n<p>使用LiveData需要引入ViewModel</p>\n<pre><code>dependencies {\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation \"androidx.lifecycle:lifecycle-viewmodel:2.3.1\"\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n</code></pre>\n<h3>在ViewModel中创建LiveData对象</h3>\n<pre><code>public class MyViewModel extends ViewModel {\n    private MutableLiveData&#x3C;String> title;\n    public MutableLiveData&#x3C;String> getTitle() {\n        if (title == null) {\n            // 网络请求、读取文件etc\n            title = new MutableLiveData&#x3C;String>(\"哈哈\");\n        }\n        return title;\n    }\n} \n</code></pre>\n<h3>在界面中使用LiveData数据</h3>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyViewModel myViewModel;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        TextView textView = (TextView) findViewById(R.id.textView);\n        // 获取ViewModel\n        myViewModel = new ViewModelProvider(this).get(MyViewModel.class);\n        // 创建Observer\n        final Observer&#x3C;String> titleObserver = new Observer&#x3C;String>() {\n            @Override\n            public void onChanged(String s) {\n                textView.setText(s);\n            }\n        };\n        myViewModel.getTitle().observe(this, titleObserver);\n        Button button = (Button) findViewById(R.id.button);\n        // 定义button的点击事件 更改ViewModel的数据\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                myViewModel.getTitle().setValue(\"我变了\");\n            }\n        });\n    }\n}\n</code></pre>\n<p><img src=\"/blog/d9632f4d22fc8dd9b600386ab2ade7dc/showLiveData.gif\" alt=\"使用LiveData\"></p>","fields":{"readingTime":{"text":"3 min read"}},"frontmatter":{"title":"一起学Android-页面数据管理(ViewModel&LiveData)","date":"2021-07-02","tags":"跨端技术","path":"/android-view-model","top":null,"summary":null}}},{"node":{"id":"18f81a43-93e0-5cd2-aa8e-b21265c68aec","html":"<p>应用程序在运行时需要占用系统的存储空间来实现加载代码运行、存储运行时数据等功能。理解内存空间的管理策略能让我们更好的理解代码在系统中运行的机制。本文从代码运行时存储开始逐步介绍V8的垃圾回收机制。</p>\n<h2>运行时存储</h2>\n<h3>堆存储</h3>\n<ul>\n<li>主要存储全局变量,引用类型</li>\n<li>动态分配，可分配动态空间，有垃圾回收机制参与空间管理</li>\n<li>总存储空间大(通常分配给应用的空间有限制)，查找效率低</li>\n<li>堆空间被应用的线程间共享</li>\n</ul>\n<h3>栈存储</h3>\n<ul>\n<li>主要存储局部变量(基础数据类型)、指针、函数执行片段(function frames)</li>\n<li>由系统分配，通常存储限定大小的数据，栈片段弹出后空间释放</li>\n<li>栈结构后进先出(LIFO),访问效率高</li>\n<li>多线程应用每个线程都有一个栈存储空间</li>\n</ul>\n<h2>内存管理</h2>\n<p>通常说的内存管理都是指对堆内存空间的管理，以下介绍V8中的内存管理方式。<br>\n在V8中运行的程序会被分配如下的内存空间(Resident Set)\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACd0lEQVQoz23LX0wSARwH8HvoqYde22o91kubbj20zH8Tpw+ZpjMn1ioLzywljAORSRqKcIIgJ3hcd7RQ1OafkNWdoilq2siMXeLBwTEOway57EXsvaHV1tb22Xe/73f7AYEoH5lf5qa93ExaxLN4dHAzXnbOS8+s0qSPpj7Q076N2VXm0KZnNbiwshmNAdEQS7UZJI80cjncItV2NmpkkE4mg6HmLnejqRPSK4wPlYYmlRYSVdvzq7ECoS2rHBuV2mMhBoiHwg51X5bGXGLGi7qRcjks6LGUIHie1mhvtLZo2qQLZTJPlWysJrccO37DdlJEHKtEUYkjHg4CXDgyK9XratRIQw8CwqgINoM6MwjrhWoX2Ce+7RTVD4gluESMP7jzWnhrqvrmq+KrEy+kozzLACE2wnYY/A3tAah747EmAHUzrYZgh4GGoI12pVuud0mNnnaUUo0Mgl3D9RonqEUqlHNyPceyQJDldp6oEuC9xKOmhLhpq+7udotyF1d8s2bsolk/iJzvaMYemr2D6KyZpy0Xztjzz/eeO/G2tjLK8ennpLqLF0u2FMotRSvf3JxQdX61Pd02F3+xlG2j15PIlR1rVbyv11F02XmtcKSiiBBcnL9fy0ViQIhh9wkshVn3bWkpzJrC0RSOHjxHDwafHTiwFDHw047u9RuHLp0dFWROlmbjmafe1wljXAxYD/PU1DLpWiJdR/kb5V6hKB9F+kj3O9K19GbSO0yMO/ExJzE+hL2cGCY/hXnAE4gLetfzej7m6/+RA6+VWfyl/f5ceC29GNYFJvpIgYkuNPmpzzzg55OLTPz/gof+VO9m7K9FhvfzyV+uIZYSosOVRgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"V8内存结构\"\n        title=\"V8内存结构\"\n        src=\"/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png\"\n        srcset=\"/blog/static/51d594675e95270d44f2ba31e0459f30/63868/V8.png 250w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/0b533/V8.png 500w,\n/blog/static/51d594675e95270d44f2ba31e0459f30/d9199/V8.png 960w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>V8堆内存结构</h3>\n<ul>\n<li>(New Space)新生区</li>\n</ul>\n<p>新分配对象或者存活期较短的对象都会存储到新生区</p>\n<ul>\n<li>(Old Space)老生区</li>\n</ul>\n<p>新生区经过垃圾回收会晋升到老生区</p>\n<ul>\n<li>Old pointer space 保存有指向其他对象的对象</li>\n<li>Old data space 存放只包含原始数据对象(无指向其他对象指针)、字符串、封箱的数字以及未封箱的双精度数字数组</li>\n<li>(Large object space)大对象区</li>\n</ul>\n<p>存储超过超过1MB大小的对象，垃圾回收不会处理大对象区。</p>\n<ul>\n<li>(Code-space)代码区</li>\n</ul>\n<p>存储代码，唯一有运行权限的存储空间</p>\n<ul>\n<li>Cell space, property cell space, and map space</li>\n</ul>\n<p>这些空间保存大小一致的对象</p>\n<h3>V8垃圾回收</h3>\n<p>V8的垃圾回收机制只作用于内存空间的新生区和老生区，由于在新生区和老生区存储数据的类型(大小，存活时间)等不同，垃圾回收在新生区和老生区使用不同的策略实现。</p>\n<h3>新生区垃圾回收</h3>\n<p>新生使用Scavenger算法</p>\n<ul>\n<li>新生区内存一分为二,每部分空间称为semispace. 在运行时只有一个semispace处于使用中,使用状态的semispace称为From空间,空闲状态的semispace称为To空间</li>\n<li>在分配对象的时候会先从From空间分配对象，当From空间无法存储没有足够的空间存储新对象的时候触发垃圾回收</li>\n<li>在进行垃圾回收的时候会检查From空间的存活对象将存活对象复制到To空间,完成复制后From空间和To空间会进行角色互换</li>\n</ul>\n<h4>新生区晋升到老生区</h4>\n<p>在新生区的垃圾回收中满足以下两个条件，可以移动到老生区存储。</p>\n<ul>\n<li>当对象从From空间复制到To空间的时候,如果它经历过一次Scavenge回收会把该对象从From空间复制到老生区</li>\n<li>当对象从From空间复制到To空间的时候如果To空间使用超过25%则这个对象直接复制到老生区</li>\n</ul>\n<h3>老生区垃圾回收</h3>\n<p>老生区由于存活占比较大,使用Scavenge算法并不科学。在老生区使用Mark-Sweep-Compact来实现垃圾回收。</p>\n<ul>\n<li>Mark</li>\n</ul>\n<p>只标记存活的对象，如果循环引用但是无法被标也会被清除(解决循环引用问题)</p>\n<ul>\n<li>垃圾回收器会在内部创建一个根列表(全局对象,本地函数的局部变量和参数,当前嵌套调用链上的其他函数的变量和参数),用于从根节点出发去寻找可以被访问的变量</li>\n<li>垃圾回收器从所有根节点出发遍历其可以访问到的子节点标记为活动节点,不能到达的节点为非活动节点</li>\n<li>Sweep 释放非活动节点空间</li>\n<li>Compact 整理内存空间，将存活对象占用的空间移动到一起，减少内存间隙</li>\n</ul>\n<p>由于垃圾回收会暂停应用的执行，V8的垃圾回收机制又通过增量回收(incremental GC)、并行标记(Concurrent marking)、并行清除整理(Concurrent sweeping/compacting)、(懒整理)Lazy sweeping等手段结合优化回收效率。</p>\n<h2>参考</h2>\n<p><a href=\"https://deepu.tech/memory-management-in-programming/\">Demystifying memory management in modern programming languages</a><br>\n<a href=\"https://deepu.tech/memory-management-in-v8/\">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a><br>\n<a href=\"https://juejin.cn/post/6844904016325902344\">一文搞懂V8引擎的垃圾回收</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"聊聊Node的内存管理","date":"2021-07-01","tags":"Node","path":"/node-memory","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":9,"pageCount":15,"additionalContext":{"pageAllCount":90}}},
    "staticQueryHashes": []}