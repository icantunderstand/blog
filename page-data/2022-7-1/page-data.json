{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2022-7-1",
    "result": {"data":{"markdownRemark":{"html":"<h2><a href=\"https://h3manth.com/ES2022/\">ES2022 Features!</a></h2>\n<p>这篇文章介绍ES2022的Features。</p>\n<h2><a href=\"https://mikevdv.dev/blog/2022-06-23-stop-the-screen-going-to-sleep-with-javascript\">Stop The Screen Going To Sleep With JavaScript</a></h2>\n<p>这篇文章介绍WakeLock api的使用方法。WakeLock用于防止用户屏幕变暗或者锁屏。<a href=\"https://github.com/richtr/NoSleep.js/\">NoSleep.js</a>就是封装了WakeLock的能力来实现对应的功能.</p>\n<p>NoSleep功能实现:</p>\n<ul>\n<li>在支持wakeLock的设备上使用wakeLock</li>\n<li>在老的ios设备上  通过设置当前href和window.stop的定时器来激活页面</li>\n<li>其他情况通过设置一个循环播放的video标签来实现</li>\n</ul>\n<h2>工具</h2>\n<h3><a href=\"https://github.com/wbkd/react-flow\">react-flow</a></h3>\n<p>react绘制图表和流程图的工具库</p>\n<h2>想法</h2>\n<h3>关于前端页面设计</h3>\n<ul>\n<li>作为前端开发似乎很容易直接从页面的角度去考虑实现，因为接触的UI就是最直观的图形输入。但是页面不光是简单的UI展示，后面还承载着数据的流动。从数据流去思考业务的逻辑和设计实现页面和业务逻辑的分离。数据承接逻辑，页面承接UI渲染组合能更好的服务于页面的扩展。</li>\n</ul>\n<h3>react hooks的理解</h3>\n<p>hooks是react暴露给外部的接口。这个是react增加hooks提供的一个比较重要的能力。比如react query通过hooks的能力桥接了queryClient.</p>\n<h2>源码解读</h2>\n<h3><a href=\"https://github.com/pierpo/react-archer\">react-archer</a>源码分析</h3>\n<p>react-archer通过箭头线绘制React节点之间的关联关系。它的实现主要:</p>\n<ul>\n<li>维护全局的节点关联关系(逻辑抽象 封装)</li>\n<li>解耦节点渲染和箭头线渲染(解耦)</li>\n</ul>\n<h4>节点关系处理逻辑</h4>\n<pre><code>    // 子节点注册逻辑\n    const registerTransitions = (newRelations: Array&#x3C;RelationType>) => {\n        // 格式化节点配置\n        const newSourceToTarget = generateSourceToTarget(id, newRelations);\n        assertContextExists(context);\n        // 更新全局节点配置\n        context.registerTransitions(id, newSourceToTarget);\n    }\n\n    // 根节点更新逻辑\n    const _registerTransitions = useCallback(\n        (elementId: string, newSourceToTargets: SourceToTargetType[]): void => {\n            // 节点关系在根节点中通过useState进行更新维护 触发组件更新\n            setSourceToTargetsMap((previousValue) => ({\n                ...previousValue,\n                [elementId]: newSourceToTargets,\n            }));\n        },\n        [],\n    );\n</code></pre>\n<h4>箭头渲染逻辑</h4>\n<p>在根组件中通过SvgArrows渲染节点连接逻辑</p>\n<pre><code>// 遍历节点关系数据 依次渲染\n{getSourceToTargets(props.sourceToTargetsMap).map((currentRelation) => (\n    &#x3C;AdaptedArrow\n      key={JSON.stringify({\n        source: currentRelation.source,\n        target: currentRelation.target,\n      })}\n      source={currentRelation.source}\n      target={currentRelation.target}\n      label={currentRelation.label}\n      style={currentRelation.style || {}}\n      startMarker={props.startMarker}\n      endMarker={props.endMarker}\n      endShape={props.endShape}\n      strokeColor={props.strokeColor}\n      strokeWidth={props.strokeWidth}\n      strokeDasharray={props.strokeDasharray}\n      noCurves={props.noCurves}\n      lineStyle={props.lineStyle}\n      offset={props.offset}\n      parentCoordinates={parentCoordinates}\n      refs={props.refs}\n      uniqueId={props.uniqueId}\n    />\n))}\n\n// 使用getBoundingClientRect和配置项计算绘制箭头的位置 最后使用svg进行关联线的绘制\nexport const getPointCoordinatesFromAnchorPosition = (\n    position: AnchorPositionType,\n    index: string,\n    parentCoordinates: Vector2,\n    refs: Record&#x3C;string, HTMLElement>,\n): Vector2 => {\n    const rect = getRectFromElement(refs[index]);\n\n    if (!rect) {\n        return new Vector2(0, 0);\n    }\n\n    const absolutePosition = computeCoordinatesFromAnchorPosition(position, rect);\n    return absolutePosition.substract(parentCoordinates);\n};\n</code></pre>","frontmatter":{"date":"2022-07-01","path":"/2022-7-1","title":"2022-7-1-前端快报"}}},"pageContext":{"readingTime":"4 min read"}},
    "staticQueryHashes": []}