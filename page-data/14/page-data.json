{"componentChunkName":"component---src-templates-index-js","path":"/14","result":{"pageContext":{"pageAllCount":87,"group":[{"node":{"id":"d9a2727c-f773-51a0-ae91-74deed50be73","html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.下面从几个方面来拆分这个小例子来重新学习下XMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,顺序对应着请求的方法、地址、是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中增加query的方法进行数据的发送并且在调用send方法时必须send(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, 注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error 请求发生错误的时候的监听函数</li>\n<li>loadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>xhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载并且可以通过download进行文件名的设置.这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件名,这个时候可以通过设置responseType为blob,生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的时数据上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么上传阶段完成是mock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的切分上传阶段和数据接收阶段的比例来完成对用户接受更合理的进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>作为一个web前端开发者离不开XMLHttpRequest的使用,以上通过对xhr基础的介绍和自己在项目中遇到的问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null}}},{"node":{"id":"627714b4-755f-5558-b731-9a17d8bbe360","html":"<h2>简介</h2>\n<p>在看深入浅出node.js这本书的过程中,遇到了几个容易迷糊的概念,例如阻塞I/O、非阻塞I/O、同步、异步。下面主要从I/O模型上对上面的概念进行理解.</p>\n<h2>基本概念</h2>\n<p>I/O复用指的是内核具有当进程指定的I/O条件就位的时候通知进程的能力.</p>\n<h2>I/O模型</h2>\n<ol>\n<li>阻塞式I/O 在发生系统调用(I/O)的时候,对应的系统调用直到相应的操作完成或者错误时才返回.(例如在进行网络IO时,需要等待网络数据的就绪完成读取才会完成系统调用的返回)</li>\n<li>非阻塞式I/O 进程可以把一个套接字设置成非阻塞模式.这样当通过该套接字进行相关I/O操作并且需要进程进行等待的时候(例如通过网络读取数据,但是数据并没有就绪的时候), 内核不能将该进程投入睡眠而是返回一个错误标识(轮询)</li>\n<li>I/O复用模型 通过select或者poll来对多个相关的描述符进行监听(此时进程阻塞在select和 poll的调用上)),当描述符状态就绪的时候,返回可读条件然后在通过系统调用来完成对应的I/O操作</li>\n<li>信号驱动式I/O模型 通过开启套接字的信号驱动式I/O的功能并且添加相应的信号处理函数,当套接字准备好读取的时候,通过信号通知进程来完成响应的I/O操作.这种模式进程是不被阻塞的</li>\n<li>异步I/O模型  通告系统调用告知内核相应的操作,然后内核在完成相应的操作后会通知进程.这个过程中进程是不被阻塞的.</li>\n</ol>\n<h2>同步VS异步</h2>\n<p>同步,异步的概念区分上在于实际上发生系统I/O的时候,是否会阻塞进程.因此上面的前四种模式都是同步I/O,只有最后一种是异步I/O</p>\n<h2>select</h2>\n<p>int select(int maxfdpl, fd_set *readset, fd_set *writeset,fd_set *exceptset, const struct timeeval *timeout) 该函数允许进程指示内核等待多个事件中的任何一个发生,在其实一个或者多个事件发生后或者经历了一定时间后唤起进程.该函数的当有描述符就位的时候返回描述符的数目,超时返回0,若出错返回-1,下面对主要的参数进行分析</p>\n<ul>\n<li>timeout 告知内核等待所指定的描述符中任何一个就绪所花的时间.\n<ol>\n<li>当该timeout结构的代表的值均为0的时候,表示无需等待直接返回</li>\n<li>当设定一定时间的时候,表示当select返回的时候,不能超过该时间</li>\n<li>当设置为空指针的时候,表示select会一直等待直至有响应的描述符就绪</li>\n</ol>\n</li>\n<li>readset writeset  exceptset  表示让内核检测响应的读,写,异常描述符,当有响应的描述符就位时返回.</li>\n<li>maxfdpl 指定待测试的描述符的个数</li>\n</ul>\n<h2>node如何实现高性能的异步I/O</h2>\n<p>参考自己之前整理的一篇blog<a href=\"https://www.cnblogs.com/tiantianwaigong/p/6234961.html\">node的异步I/O</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null}}},{"node":{"id":"99c9b30a-e728-507a-9299-d6242ca4ad7f","html":"<h2>简介</h2>\n<p>网络套接字是应用层和传输层的桥梁。套接字提供了应用层与系统内核的交互的能力来完成数据的发送和接收.下面主要从套接字的几个基础api来介绍套接字并且结合tcp来理解网络应用对外提供服务的整体过程.</p>\n<h2>基础api</h2>\n<ol>\n<li>在使用套接字发送数据时将数据从应用进程的缓冲区写入到套接字的发送缓冲区，来完成数据的发送.</li>\n<li>通过对套接字函数的调用可以获取套接口的一个描述(一个套接口可以对应多个套接字描述),当内核中不存在套接字的描述符的引用的时候,内核会触发该套接字的close.</li>\n<li>基本TCP客户/服务器程序的套接字函数调用过程</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 873px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB6klEQVQ4y5VT25KiMBD1/z/MB6t884qgYhEFBJKQK52kmdJMMe7s1K5zHqhKyOk+fbp7Nr6Nvu/X6/Vut9Nax5vZm0xEFEKkaVqWpbX2/2REHMeRMZYkyel0EkJcLpeyLIdheDczPhFCkFKmaZrn+VuZXxFCMMYQQuq6BoBf18w53+/3RVF8NwwRlVKTnm9lRwDA4XAghEz3syipbdvdbne73SZJPzq3WCyWy6X3/iuz955SmiRJVVVCiBCC9x4RrbX3+905h4j+CSGE1nqSM4uBGWNpmrZtG9tojPHeE0Lm8/l2u7XWaq1jrCjtUzYitm3bNE2apk3TaK3DE7GllNJhGKZUxpjJrQfZOSelVEp1XSeltNYCgDGGMdZ1HWMMAIZh6Lquqqrz+VxVVV3XUsoHGQCcc+M4/m31q2HOOa11lmWEkBgdER/kWMY/yNOcZFlWVVV8HEL4JMduvZbHGMvz/HK5aK2998YYSunxeLxer5xzKeUjs3Ouf2K/30e3o7HGGCllLCp+h2EQQiil/hjPEELf95vN5n6/x3+ICACU0q7rXntjnvhyO5KVUnVdc86NMQBgreWcE0Ji8wGg73tKaVEUcWx+txha67Zt42JzzgHAez/7cQemNY6Ix7IsV6tVkiRFUcQR+AAp44e3Q8OxXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"套接字基础api\"\n        title=\"套接字基础api\"\n        src=\"/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png\"\n        srcset=\"/blog/static/488016f75fa3e6b554b97157803a13e8/63868/api.png 250w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/0b533/api.png 500w,\n/blog/static/488016f75fa3e6b554b97157803a13e8/35751/api.png 873w\"\n        sizes=\"(max-width: 873px) 100vw, 873px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>socket(int family, int type, int protocal) 默认产生一个主动的套接字 其中family字段指明协议族如Ipv4,Ipv6等, type为套接字类型如SOCK_STREAM(字节流套接字), SOCK_DGRAM(数据报套接字) protocal指的是由前两个参数决定的协议说明 例如tcp传输协议  UDP传输协议</li>\n<li>connect(int socket, const strcut *servaddr, socklen_t addrlen) 在TCP套接字状态下调用此方法会激发TCP的三次握手.几种常见的网络错误也是在这个阶段出现了\n<ul>\n<li>如果发送了SYN,在经过TCP的超时重试之后仍然没有收到对应的ACK,此时显示ETIMEOUT超时</li>\n<li>收到RST(复位) 通常对应的对方没有正在监听的服务器、TCP想断开一个已有的连接、TCP收到一个不存在连接上的分节</li>\n</ul>\n</li>\n<li>bind(int sockfd, const struct *myaddr, socklen_t addrlen)  将一个本地协议地址绑定到一个套接字\n<ul>\n<li>在绑定地址上,在服务端上的一般都绑定到特定的端口 对IP地址进行0.0.0.0(INADDR_ANY)绑定(为了处理服务器有多个网络接口), 最后由系统内核指定IP地址  在客户端一般有内核指定IP地址和端口</li>\n</ul>\n</li>\n<li>listen(int sockfd, int backlog) 将一个从主动状态转为被动状态,指示内核接受指向该套接字的请求\n<ul>\n<li>backlog参数代表着未完成连接队列和已完成连接队列之和.在正常的三次握手的过程中,一个未完成连接的条目存活的时间是最后一次客户端对服务端ACK的确定(RTT)</li>\n<li>设置成较大的backlog是为了扩大为完成连接数目的队列.当为队列数目是满的时候,TCP会忽略该分组,这样TCP将重发SYN而不是显示连接错误等</li>\n</ul>\n</li>\n<li>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) 从已完成队列中返回一个已完成的连接\n<ul>\n<li>区分监听套接字和已连接套接字  监听套接字在服务器的整个生命周期只存在一个,连接套接字是为每个接受的请求都会创建的</li>\n</ul>\n</li>\n<li>fork 创建自身进程的一个副本\n<ul>\n<li>fork的调用会在父进程和子进程中进行返回,通过区分返回值来区分父进程和子进程</li>\n<li>子进程共享共享父进程fork之前的所有描述符(注意在fork的时候关闭对应的描述符)</li>\n</ul>\n</li>\n<li>int shutdown(int sockfd, int howto) howto指明如何关闭改套接字是关闭读的部分还是写的部分,这样能防止关闭套接字时候无法处理到达的网路请求返回数据</li>\n</ol>\n<h2>相关参考链接</h2>\n<p><a href=\"http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html\">tcp backlog</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"计算机基础之socket","date":"2018-07-15","tags":"计算机基础","path":"/node-socket","top":null,"summary":null}}},{"node":{"id":"b3d4eea3-bcd1-54be-82e3-ecc3aca713b9","html":"<h2>简介</h2>\n<p>通过对运输层和网络层的基础知识的学习,了解到他们分别提供了基于主机进程间的通信和主机间的通信,这都基于数据链路层实现的上述功能,下面通过对数据链路层的学习来了解数据是如何通过相应的数据链路来实现传输和交付的</p>\n<h2>基础</h2>\n<p>1 在通信路径上连接相邻通信节点的通信信道称为链路。链路层协议将网络层的数据报封装成链路层帧来实现数据在链路节点间的移动。\n2 链路层主要提供的服务有数据报的成帧,链路的接入(无线链路,有线链路),可靠交付,差错检测和纠正.链路层的功能主要在网络适配器(NIC)上来实现相应的功能\n3 链路层通信通过MAC地址(LAN地址或者物理地址)来实现,所以一个通信的具体过程会涉及到三种地址:</p>\n<ol>\n<li>主机名</li>\n<li>IP地址</li>\n<li>MAC地址</li>\n</ol>\n<h2>地址解析协议(ARP)</h2>\n<h3>ARP的作用和寻址过程</h3>\n<p>ARP提供的是同一个子网和路由器的网络层地址到MAC地址的转换.主机会在内存中维护一个ARP表,这个表保存着一定时间内该子网内主机IP地址和MAC地址的映射.当目的主机的IP地址在ARP表中时,发送主机通过封装链路层帧目的MAC地址为保存的目的MAC地址将数据推送进数据链路层.当ARP表中没有响应的条目的时候,发送主机通过MAC广播地址发送APR广播分组,这样子网内所有的主机都会处理该分组,符合该IP地址的主机会发送ARP响应分组,将自己的MAC地址通知给请求发并且更新请求方的ARP表</p>\n<h2>以太网</h2>\n<h3>以太网基础</h3>\n<p>以太网是基于之前的各种协议实现的一种局域网技术,它提供给网络层无连接服务.</p>\n<h3>以太网帧结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 884px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVQY0z2LTUvbYACA80PEHzC9CLrLKlLGDuJgpTI3vzpE2EUZyHbRIt5kh6FsggeL2po0PSiryeL7NhVddVK1TWcjJbXWFisxpB9C0tqlJjbv0E0fntvDg5mmiRBSlUr27DyTzpbVa4RQWa2kkplqtYYQusv3mA8+gkmiVJALSkkVc2IumytIRVmSxXMpk8rqNf3fdFUsyZeyWf8/GrqRlwpaVcMOufhxIq1UtJKqXpXL+aKyuxdJZy5EOV+rm9c3xs2tKSTP4ryg6beabvwx6mpVi0bixZKCPaUTnZunjgDXQfNW6miQjVlgygZiL9bCr8FRZzBlBUL7hmBhEh0waYVCFys4AlzbOj8Vu8AmmajNz7W6wccNboyJWtxwiuXH/L/mNw+ee7efeMPTW8euHd61f7IQijsB1+zbf0kEvgR/fw6fYv1L4JkLNs3gvR7Y6wYts95hcntg0T9OMq1zqw1fqdHVkPP7Tye9N7G2NYSzjd+o9jlv9yL4BCNY1zLT5wuOkvQbAr4l4AhJ2wh2iPjhwKn3JDPgC3bj0L4C7B7GvgJ6cPiOhB981KtlaiYU/Qscvja2c8oD8QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"以太网帧结构\"\n        title=\"以太网帧结构\"\n        src=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png\"\n        srcset=\"/blog/static/64a1e61b92a99322bca67ee8586e7e5a/63868/dataLink.png 250w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/0b533/dataLink.png 500w,\n/blog/static/64a1e61b92a99322bca67ee8586e7e5a/136a2/dataLink.png 884w\"\n        sizes=\"(max-width: 884px) 100vw, 884px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>前同步码 主要用于在发送方和接收方进行时钟的同步</li>\n<li>目的MAC地址 当接受方收到对应的链路层帧的时候,当该帧的目的MAC地址是本机的MAC或者是广播地址的时候,数据字段的内容就是向上传递给网络层进行处理</li>\n<li>源地址 发送方的MAC地址</li>\n<li>类型字段 用于与上一层的某协议相结合</li>\n<li>数据 网络层数据报</li>\n<li>CRC 循环冗余检测用于接受方检测是否存在差错</li>\n</ul>\n<h2>交换机</h2>\n<p>链路层交换机主要提供转发和过滤的功能.过滤是指决定一个帧是否被转发到某个接口还是将其废弃的功能.转发指一个帧具体应该被转向那个接口.</p>\n<h3>交换机的转发过程</h3>\n<p>交换机通过自学习的特性定期的维护自身的交换机表.表的条目分别是MAC地址,接口,时间.当交换机收到一个帧的时候,会根据该帧的目的地址做出不同的行为</p>\n<ol>\n<li>如果交换表中没有该MAC地址的时候,交换机就会向它所有的端口转发该帧</li>\n<li>当交换机接受到该帧的端口MAC地址和目的地址相同的时候,丢弃该帧.</li>\n<li>当交换机表中存在相应的条目的时候,将该帧转发到相应的端口</li>\n</ol>\n<h2>web页面请求的详细过程</h2>\n<p>可以结合前两篇来理解这个过程(DHCP HTTP  UDP CIDR IP MAC(ARP))  里面涉及的编制 寻址 传输等相关协议</p>\n<h2>思考</h2>\n<ol>\n<li>网络协议虽然是分层的，但实际的实现上层与层之前的界限并没有那么清晰,不能割裂的去学习网络协议模型,要从整体上理解网络协议的整体过程</li>\n<li>在具体功能的实现上,例如数据链路层通过MAC地址进行通信而不是依赖网络层的IP地址,这样就能使数据链路层与其他种数据格式对接,增加独立性</li>\n<li>层与层之前的功能不具有强依赖关系,例如数据链路层是能够通过CRC循环冗余检测来实现差错检测和恢复的,网络层自己实现了本身的差错检测,在实现一个大型的系统的时候,功能到底是依赖于上层还是自己去维护(稳定性)都是值得考虑的点</li>\n</ol>","fields":{"readingTime":{"text":"7 min read"}},"frontmatter":{"title":"计算机基础之数据链路层","date":"2018-06-18","tags":"计算机基础","path":"/data-link","top":null,"summary":null}}},{"node":{"id":"4a2c57bb-e06c-5beb-a596-a9352d6e71d9","html":"<h2>简介</h2>\n<p>在初学node的时候,都会在学习到下面的这个例子:</p>\n<pre><code>const http = require('http');\nconst server = http.createServer(function(req,res) {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('okay');\n});\nserver.listen(8080,function() {\n  console.log('server is on');\n});  \n</code></pre>\n<p>上面的例子就创建了一个最简单的web服务,当通过浏览器访问本地的8080端口的时候页面就会输出okay。下面主要从两个方面来理解node如何加载和运行这段代码来提供服务的。</p>\n<h2>node代码结构(基于node V6.11.0)</h2>\n<p>下面就是node的代码结构,在lib中主要是node提供的标准库(例如http等模块),在src模块主要是node的入口文件和node提供给lib的C++接口.在deps中主要包含了DNS解析,http解析,事件循环和跨平台的异步IO的实现等.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 932px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABB0lEQVQ4y62STU+EMBRFWasLE93KAKV8tDhAS9FAYTIMBtf+Aifj3v+/uqadxGh04XRcnDT9yMm779XLshxaa/S9RpKkoDRxgpAYnBfwzKaqakzTDmmaIQwj+yCOqcVJ2DQK2+0EISTW6/Ik0Q+hiVnXAsMwYlmeoVRrL8+KLIRA1/Uoy+oz7tfVKfI8P1mhi+yXCiXa9sH271+mrJSyMt9ffZuuc2QpGzsUrQfbS/N9zoicQsgGfT+AscJizmJT4R85CulRyLMMQ9fhnjOQIACNIiSEnEZMQKMQBcvh0eoRzWZBwCV8JrBy5C6vYVzezfyG9OUd19MBl+MrrjZ7Jy7GPW53B3wAKwuBpW1A2esAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node代码结构\"\n        title=\"node代码结构\"\n        src=\"/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png\"\n        srcset=\"/blog/static/38795164842a3beb02db9ed01e44311f/63868/nodeSrc.png 250w,\n/blog/static/38795164842a3beb02db9ed01e44311f/0b533/nodeSrc.png 500w,\n/blog/static/38795164842a3beb02db9ed01e44311f/f6f78/nodeSrc.png 932w\"\n        sizes=\"(max-width: 932px) 100vw, 932px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>node如何加载我们的代码</h2>\n<p>通过都是通过命令行 node server.js来启动一个简单的服务,下面来简单的看node如何加载和执行这个server.js文件<br>\n在node的启动文件src/node_main.cc中有如下这段代码,它调用了node.cc的node的Start方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 945px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABG0lEQVQY032QW27CMBBFs44SE+dhk4Q4YAenBIIoffFH1Q10/7s4VRxRqf3ox9Gdq5k7I00k1ZrWd4wnh2oc286z6yxp7ShbyzDs8d5TVRWJTEiSJctkOetyroOXs48SKZGFpNwW6HYip+4UK5MFKqso6hTVZKGnTY5a55RbxWpTUFqFbvKQV+uMSEqJdTV+aHF+y+PBU7Y1WbNBGYuqNafLkd3eYeyaXKXILCFTkrxMA2khg58IC5/OPa8vA+N45Pr2zqGzbPoL2p3RuuLjdmMcT3TeMc3HsUDEIui9vhPJVGK0waiWbmfoe8PX1fL53OH7R5qmYT/s0VoTx/H8t3+ITGlwtSVN0hAQQvCwECymi+I3U+Cv/iDmhd//Pa9jeahOZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"main\"\n        title=\"main\"\n        src=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png\"\n        srcset=\"/blog/static/10eac200c9ce6ca832351a0ff811340d/63868/nodeMain.png 250w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/0b533/nodeMain.png 500w,\n/blog/static/10eac200c9ce6ca832351a0ff811340d/40601/nodeMain.png 945w\"\n        sizes=\"(max-width: 945px) 100vw, 945px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n在Start方法先对平台进行了初始化操作 主要关注下面的代码<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVQ4y5VUbY6bMBTMLbbi0wYCBtuYGBuyCWxIVlWlXqA/ev9zTGWTRNlmW2l/PD3LFuOZeYM3QgjM84TpeMDr64j9fodx7GCMhLUGfW8wDAP2+z2UUhisBWMMURQhSZKn2nBewfQSvS8BY1owVoGQFJTSe2VZBkKIX6dp+gEkjmNfHjDNKmRlg6auIYT0t2d5hjiKEIUBojBEGAYIgwBhGCKK1orjyLN0e4/Am4o1aLhE27a+hOCoawZabJGVa89LhrKskOcFsiz3ndIM2+0WVVVdGV4lZ5Si19p71XUdrLW+s1ZDmAMaPUDYA6Z5wvvlDafTEfN8wPnyhmEYvafOgrtk58ttw3W/ThIQv06QXqUYs8PhYNDUBRjL0ba19zMIgrvcO6A7cACPphNCr+v1Qr57RdPPyLlFKQxS1oFUClKPsMZgHEfkeX5lSCiSK6ADSh/AbwpcdKZpwnlZ/P4/Y0MoQUkT5CS+Azn6N6BVTgJrB5zeTricz56N1hrO/5vUW3Q2NKP4dZH4/dPi+48T5sni/f2I83LCspyxLG4QM5ZlRte1Po9uuq4/DuPO0B1yLiDlGp2iKPyU21aiU2uXkkGpGkoJb4nL3mOYH0E3Utbouhq7XQO949gWW7y8fPPTC32o1wCvIY6eGD0xdIykFF6OY8M5gxAMVVUiSdJPjf8b5EmyUh3cI+H+krZlnq37W1xk/vfxp4BN2WDgFoop/5qoTkP3wwewr4BuHLNxGH25x6HgGkwfkRelfwC+ws4B/gFXCsyHoBFOiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"init\"\n        title=\"init\"\n        src=\"/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png\"\n        srcset=\"/blog/static/8b7bf7989faf13dade451e000d201e37/63868/init.png 250w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/0b533/init.png 500w,\n/blog/static/8b7bf7989faf13dade451e000d201e37/914c7/init.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这创建了一个node的实例并且传递了一系列的参数(v8_thread_pool_size uv_default_loop 后续会对这些参数进行讲解) 最后调用StartNodeInstance开启了node的实例,然后顺着这个方法往下走发现node继续这行了LoadEnvironment()和下面这段代码\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABmElEQVQoz22R227iMBRF+YtpCSQhsZ2LE99iQoBQOmj6/5+0RrhSpen0YWmf87C395E3tajx0RHPgbh4/GwJJ8dpPWKmnuXmmM+GMGviMnL7PRFPPs3LanFRU6kyIfuKTVVVtG1H23RIoRC1RIqGRikaJRh0g7WaQXeM4yezM1y8YXEj12Dxg0ZJRbbN2MhacD1feH9/436/8XisfHy8sa5HrutMCCPGarR+8gx/hvZpb5oGY0aC97Rty36/Z1MWJZdz4PHnwvV65BgNMfpkMMYyDCN5XqTXs2xHtt2RZVlit/t3zvP88+TyUFDJA/t8z6+XF16320S227LbZxRlTl7kSYuyoCjLZP5OaqiUYL1HjufAss4s68Tl7jldHPEUUJ1E9QLRVMiuTnslqmT+KXQjhCBOE8F/Yo2jazumEPAuMA6Wvu2wpqfvNc46pJDJXBTFf2zKQ4nqJY1WNMNTJbITiUYLulHSGYVsBVJUHA6HH5t9NazrCucdU5ywzuK8ZTQjve4xbiRMOv2yMZppGlBKfZ371O/8BY6zCINLY+oYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"exec\"\n        title=\"exec\"\n        src=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png\"\n        srcset=\"/blog/static/4f29a9df3964a619d5b74cf142d13b0b/63868/execNode.png 250w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/0b533/execNode.png 500w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/00d43/execNode.png 1000w,\n/blog/static/4f29a9df3964a619d5b74cf142d13b0b/29229/execNode.png 1167w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这段代码拿到lib/internal/bootstrap_node.js文件,将它编译解析并且转换成C++的函数最后执行。在lib/internal/bootstrap_node.js中其实就是一个匿名函数<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADBElEQVQ4y52U247bNhRF/RuJdaMkSryKulu+jO2ZuE3TvhT9/39ZhRV7ggkCFOjD1qEAYktrn0NuqlLSeY91Gjf1+MOC2020y4hpFKLMEGVCLhMKmRJtt0RRRBzHJEnyXp/aZGVFNR5pTm8080J/ONKeLoy3v+iWmet15HDes5vHVbVxlEXxS7PVUBQlOoyopke3A9Y5pDLodsR7RRsMJvSoZqD2HaZp0br+bpj8MHyab1JRkEqHChO6nZDKYoY9bn5B9Qest4yDwSrJqEqsLEjT7B07juIP+Js0u2ckyCvxyCtdVdSCLE/fJWRGIcWqUufr+33/fd+HPywyQRM62ssXmt2B7uVCd/nC8HYjHK+E3R7fNmscrg2r4d3s+aFcZj8hJzG5GZDtCeVa+tON/vqN+es/hN2Jy3ngeBgYrKaxlih6YiarogfyB8PCT9TDET8vDK9f2f3xN/3lhh8Xltcby+0bflgYx0DXGZwq6VVBWxfMtqbVFZWUjwzTlLyqkc6g+4Cd7h3XqNCRS0VdlTinMKYmBI31nsoFKutRLmCMJkvTH2OTpglCd6jhSDhcafdnwjhx/e3C8brnfB6YDgfm6xvLaWFsG8ZxRvmOQjtqVT/QoydygrQGN/fooLBjS7MfCYcdzRLwTU3fe3TTkusGpSTBVxhZUGcJeZqsgy6EeCCvhhbdt1RWrcMrTUCFkbI2aFXRd47aWIraonS9RqBKiSpyylxQ/GyoQqBZJtzQEE5nXOdY9h437fDzRCYSkmxLJrZE8ZY4jUjyiG30/VxHa92u6GuGubJUQ4scHfUc8NOE7nu0t/hlwc076qYhHF/QbYcd75Gc1uNZGY+oHMY1a3M294fpF9zhjWbsmI8TTdeTiZIsu5+eilzWJGm2dj0vK0Qu17UoJFlekGY5eVE+LgchEGlCsv1EGkfE289sP396INyHePu+jh6I8QMzfqzj+FljNmUpWE49tz9vvFwXTq9XjA/co/jV9fRf2lhl+P10w40H8tpQNQPKtwiR/S/DfwGj6A9fBUsu3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runCode\"\n        title=\"runCode\"\n        src=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png\"\n        srcset=\"/blog/static/9d09a6081878233d91dfcb7916cc38b2/63868/runOurJs.png 250w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/0b533/runOurJs.png 500w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/00d43/runOurJs.png 1000w,\n/blog/static/9d09a6081878233d91dfcb7916cc38b2/bb2fd/runOurJs.png 1058w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n这里面先做一些挂载的操作(例如给js调用C++代码的挂载), 然后从命令行中获取到文件的名字并且读取文件进行warp,这个函数会被上面提到的位置去执行,这样node就加载并且执行了传入的server.js文件。</p>\n<h2>http.createServer()如何对网络请求提供服务</h2>\n<p>通过对上面代码的理解,node对网络请求提供服务其实是通过lib下的基础模块调用C++模块的代码来实现的,下面跟着http.createServer()来梳理下这个流程\nhttp.createServer(requestListener),它通过调用_http_server.js下的Server(requestListener)方法创建了一个net.Server(继承EventEmitter)并且将传入的构造函数绑定到request事件同时绑定了connection事件<br>\n上面的代码部分主要完成了一个server的创建.最后调用listen()方法的时候才能监听器对应的端口来对外提供服务.server.listen([port],[host],[backlog],[callback])其实调用的是net.Server的listen方法.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 895px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVQoz12Ry27bMAAE/R2NKPH9EEVKtBXbcdQmaeuc+/8/M0WMoKhzWOxtMNjdDcOAdZrDmpn3jTgf8ClRz9+Zt9+4OOK8xTtNLDPT44WyXrDWIISg7/t//ZGdUorRjyST8NphfELFivQTMUVicBjrkL6g4ox0GWstD113A32F7qSSjGGkhILXhtA20vYHt38hn35Sjm8sx43ltFHXjWU58LQUWnQEa2/wO0MpJZ3oEFLQdd/Q0x6/vqFiIZ7fcY9XyvHCus7MS+UwOq7HyuOcyVNGyuEeOAwSFwxln6gtUFogtcq0JlyWSPWAsgPK92gn6GWH8hIdFL4YpPkCFKKntcz79YkfrxdOL6/Mz7/I7YxPE6G02wEhV1I7MS4rxhhE97Fff0vfi8/+NNRakbMnpISJmUEZBu2xccTnijEalzKh7om1obW+s/rf8C9CdsvY254TIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen\"\n        title=\"listen\"\n        src=\"/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png\"\n        srcset=\"/blog/static/ed775f0f74eb21887b354475a2e11427/63868/listen.png 250w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/0b533/listen.png 500w,\n/blog/static/ed775f0f74eb21887b354475a2e11427/fcbaf/listen.png 895w\"\n        sizes=\"(max-width: 895px) 100vw, 895px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在net.Server的方法中主要对参数进行了判断,例如是否存在IP,port以及是否传出handle,通常的调用方法都是server.listen(port,callback) 这样会在特定的端口监听来自IPV4或者\u001cIPV6的网络请求,在listening事件触发的时候响应callback.下面在继续跟进listen方法.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVQoz5WS246bMBRF8xmTcLExBgMGnAAhhHQ6N0XtSJXax/7/j6wKMmmbTKRpH7bOkeWztbyPF3GSUjQDtukpMoN1DbYbKVyLlPIkIRAiJAxDhBBzDeeztz4815BFJCPSWJNaR5xXxIkhLdfEccy6NlQ2odAKZzQm0YRhQBD4BEFwU4tYKkxmyZseWzvc7oBtBxKTka9binYgL2uUUicqGSGEfJOYTc50M+H0nLo9MI4jPx8zjk8D7v5I2Wwpmh1lt8ftH7DdnqzaUEzRbHpM6UhNhu/7l4YqVmQqxeqMwFuxvLtjtVzOF33fI/C9uT+TXBBd0Z0MVYzUCVJF1HWJcyW5tajEEEXyYvhWZufzP0tRiu7lG/3LK8+vXzl+/0G3P6B0Om/3muBa7zKcgq36T1S7zxT9PTqv0HmJzibK9N3AR5oN3eGZ9uELxbohyS2m3mCqDUlWzF/kvwynnKrtSL0dkMLH91Z/yfv9rH8lXURSopOUKcvrL3Aro48MfwFwaTboCCOYlAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"listen2\"\n        title=\"listen2\"\n        src=\"/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png\"\n        srcset=\"/blog/static/5940d58735192e92131a71aab4c797d5/63868/listen2.png 250w,\n/blog/static/5940d58735192e92131a71aab4c797d5/0b533/listen2.png 500w,\n/blog/static/5940d58735192e92131a71aab4c797d5/00d43/listen2.png 1000w,\n/blog/static/5940d58735192e92131a71aab4c797d5/ea64c/listen2.png 1116w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n继续跟进_listen2方法\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.39999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVRIx41VSXLjRhDkMzwigN53NDYCILhqGStCHvsL/v8z0tHNkUYaUbIOFQAOncjKyspe2bFFt5vxcNjix3nG7ejx748Ju7GB6g6w/R6buyf0pz9RjzvE+YTu8ID++B2+m2CbAX7YwtQtlDFYacURG4uNrXAKBYxREHUL6Tx0cFDWwsSYSzl/eXoPaRQYJyjLNYr1GmVR5FoRTkAVAXUca8NBDINwBMJTiMDALYVwFNwSSEehArtUzWEaCek4yrJCVV1qpbjEME2Iw4iH8w63uxHBaSjJ4LWElhxWCzgtwThDRSoQSnI9vyegsiwvgFpp3B8OmIceT02Fp44iaAmvBHqnEY1CNBLBKFBK88Fr9Qy6Yoxh6CNisLgPJe5qAiP5C2jnNIQQWCeNfh68Vi8MCWUgykO5GkwaEBVQlQWK9Q2KoshAN+sCxRtGFapXzF7XKrWhhYJretimRwgB0jUQNsKkSUuBxipYnabKfzH6gOmKEgLjasT5gGEecTxOmHdbLIctlv2UWx/6DZphA+M9XN1c2H0ESCiFoAxCaFTSg+oArgwEo2i1yAwrQrFOXntuufqflhnjGB/+Rnt8ROxnTG1EbTUUZ0gdEELeHvyMYQLkXKCdT2i2R7h2QPQ2MyuK97b4aMqvAAmkVNifntAvZ0idTC1RVeQNwFfAXgC5EKi3J8TlDN9P8N4h+fMrIOVv7a845xfjfvsD65tvKIp19t9X2Fxjv2KUIe2z8jWUNmDSgnKZQfPfiyL/5DlNytfvV/TNPtSuzq12bcB22WAzthiGGt0QEcZ9zjxTd9ChydnnhyUPz4aYXVCWxatdTpsiDYTrIHwLG9us4RA0pmhgnYWQAnlFqwpJomQzJiQoY0g+Jj9D44WhtBFh94A47THNHU63W5zujjjfHbA7LuiGHmGz5C0ZnIaRAi6ldLysq3EhS3DZFELgXcQy3SF4B+8EfLDQsYcKLZSPIMJCGA/t66vTfxNfydRcubxuyjcgLH3bLP4lcdY5fZ6/Xx++lomrZBnCVQbJEZZspA2qqrzE181Nrgz8icl/aSgMuPYwSYvYIQxb1Jsl69P0G5wff+D8+BeGeXnR6dNNYTpANzPa4wO6/T26w32+Hk07QxubB5EqefSjzXljbMIlmHb5vrCGo20sqPSQrobtRgjtYLsJ2vk3Zr52n1w0ZBI2tDA+QAqWbzbKOLiU4FLkPU+eS9omH1YpzijL4UEIfc+QMwHTLQj9iH7TY7ttcdx3mOcWm01A0zUQ2sJJhsZIaJ+2ZwcdInw3vrPRijAGUU+ol1uM3/9BN24wzNuckcVvN135TrP3OfkfVOAewXaWNUwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"handle\"\n        title=\"handle\"\n        src=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png\"\n        srcset=\"/blog/static/10b535ef5e2986609ed19b9e9509d8cb/63868/handle.png 250w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/0b533/handle.png 500w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/00d43/handle.png 1000w,\n/blog/static/10b535ef5e2986609ed19b9e9509d8cb/a9965/handle.png 1171w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在这个方法中主要创建了一个server的handle并且绑定在之前传入的port并且在这个handle上添加onconnection的监听函数并且在nextTick的时候触发listening事件.createServerHandle其实做的是调用的C++层的接口,创建了一个TCP实例,并且将它监听到IPV4或者IPV6端口。node处理网络请求实际是通过触发这个handle的connection事件实现的\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 944px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD5klEQVQ4y4WUWXMaRxSF+RMJzAKzz3TPwizAsAmQwUJCyJJdseUtdvkhVXlO5Q/kn3+paWwsx0J5uNXT25nb59x7Wp7M8fM5opxyv+nz+SLm41rychkjspJAxKT1GcXZhny+Js1LbMui2+3S6/V+ipbt+vj5jHJ1yWDxjHxYUy4uyQZjoqzAdhx10LJsepb19WKXbrf3OKBlOziBJIhT/CAgSjLivERkBSKvsG1bZfPfaEC/gTzMtuU4NotlxbCQ3BVdPtY93g90bssevueqw5b1eDYP4xtoy7EdfMcnjBNCz8XtGThNWCam2UXXDTTNUGMTpqFjdrvoholhNmfMI1gzthzbJkkrqsWaejIgTSRJ6BN4LkKGlGXCYJhRlTF5kREmfbVXyIC+CIki8WOGPauHlBnTasGwLAhDHxl4+K6jvpMkIs2EGmUs8EWM6zjqp8L38Hwf6yiW4tBRB0xNw9B0tE4brdNB1zronQ7tdodOu1nT0Npt9Pavak/TNDRdV9+GutvB0DVaruMSeRGiUTavSAZT4mqMKGpEPiQvCpJyRJhkiHxAOpohqxrRzJMMWQxJBmOS0Yy4rGnZlo2Ufepn14zW1ww3N1TTGfPVjEE9URx5YROReq4vErwoxvUDvCYieViXqVpvWbaFCGPG/Slp3MdyXVV7nmth25ZS0TQMTNM4jI3Kam5+31Nrh1B16Ng9Ou1f0LX2YUM/8Glq+skWOxUt23FxZIG7eYN79QlPpATZCHdQENQVURQdfmIadE3zWCIne7npAlGMGN68J13tyGdrytWO6vme/OwcP4xw/BA3iHA8/wHQCcBe1yRIcsbbOxWT3W/k0xX9yYrybM3g2U6tTa5fUy0vVM09RUOrqcGqnij5D2oluI2qkUCkfcK0IEgygjhTih6ebP5kCkfARvr9/SdW272qv3K5JZAJ9WzB/v4zxWiKrCaq/oJQ4MYVfiiOfD7CoaV8zrLt76NyGBvb9bBth8biLMf56omHc6cN1nGUkfqRVJ3QdEfzfCljGn4f88KH7vIToB+E3P/5F7e//0F1fqVE6A/H1OsdIklVuXx7xY+XT2Toeh7bV+9Ybm8IkgJRjnE9n7A/xAslhq5jGIYyCl3Xnszu6NhVFVMWUnlfWcTUoz5lGTOblQwGKePJiMXFnsniHOsJsCPg9W7O7e2SzWbMze2KF7cr9i+WvH235XI74uWbO778/Q83r99jW/8D2IiyuTxne7Xg8nLOcl6xez5lvRxxdTHh+e6CVx/ecffhC9uX98g4VryeBGxEabhLs4Q0FUjfpR/5ZKGPb/eo5muW+zcImXzlsPckh/8C/oPY8Ao+dPAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"connection\"\n        title=\"connection\"\n        src=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png\"\n        srcset=\"/blog/static/5f06a07159bdcf969f3832a0bf1caf70/63868/connection.png 250w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/0b533/connection.png 500w,\n/blog/static/5f06a07159bdcf969f3832a0bf1caf70/966a0/connection.png 944w\"\n        sizes=\"(max-width: 944px) 100vw, 944px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n在上面的代码中,底层的C++代码会在connetion的时候传入clientHandle,然后node会创建一个Socket实例并且在通过connection事件将这个Socket实例传入对应的回调函数。这样就用回到了lib/_http_server.js中对connection的监听函数中<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/fed65a33502990495432004fc0039796/d0143/request.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB70lEQVQ4y32S2XLjIBRE5zOSCIRYBUKLLTlWvMUz8///dKakJK5yypmHBl5oDt33l1KKqqqwlaHdvDIc35nngctx5Hrccn7bMvcNb0NmHrfM24GubYlNpI41QgjKsrzp183QWjbDzOu0p8mB2lpab+mCo/UaYwyu6fBNR4gJURRIKVeTZf863wwX9bsTp8uZy2XkvBCeJoa+RbmAdh7rHLIoEKK4o/oyuzM0RuNyT+47NkOirQO7XBOMJuQel1rq3FGWCik/qYS8o7wZaq0Z8sAubdDG8VIIlFYIpVC6opQCXUq0FJhSrqqUWmNYYB4SLqX004Hp8ofjYcv7aeLvaeT3ceS4aXnfZg7jwDxNzLuJ9rMYt8Tw0NBatv3MbtyTkiM6y5ACXe3J3hKtRluPjRmXMsa6teGHX/4qpR0PnK8nrtdXDseRfuqxwfNcFBRLXkKs7Yri5W5cfiQ0dSJ3DW1OVOo+m0f6TrcaLsuSQwo1pZA8PT3z/FKsxQgpP2hWFcj1kvzvA6uh955pujDv9/RdJHvHNgWcNR+D3HTUKVN+DvBPuhF65/ExE2JcmwvWkGuLXWYzRlwd8XWNUiXlN6nqQzfCJcMUEmPosa5BNxPaGnSsMKHCpWVXuEZjo8bWGpfMeja+wrcWnw2VUavhP+s9cWr9hXq5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"request\"\n        title=\"request\"\n        src=\"/blog/static/fed65a33502990495432004fc0039796/00d43/request.png\"\n        srcset=\"/blog/static/fed65a33502990495432004fc0039796/63868/request.png 250w,\n/blog/static/fed65a33502990495432004fc0039796/0b533/request.png 500w,\n/blog/static/fed65a33502990495432004fc0039796/00d43/request.png 1000w,\n/blog/static/fed65a33502990495432004fc0039796/d0143/request.png 1025w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n这个方法主要对之前创建的Socket进行一些解析处理和方法绑定最后将生成的req,res通过request事件传入到回调函数中.这样就回到了http.createServer(requsestListener)中来完成特定业务的处理</p>\n<h2>总结</h2>\n<p>从以上的两部分，主要从两方面来整理了下node启动和执行服务代码,node如何处理网络请求，但是node中还有很多有意思的东西还没有说清和弄明白.例如backlog 事件循环 v8_thread_pool_size(node的线程池)等等.</p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"从http.createServer看node是如何提供网络请求服务的","date":"2018-03-22","tags":"Node","path":"/node-basic","top":null,"summary":null}}},{"node":{"id":"18374d92-6b8b-544b-b3eb-b649443d935f","html":"<h2>简介</h2>\n<p>运输层提供了运行在不同主机上的应用进程之间的逻辑通信，应用程序通过逻辑通信，运行在不同进程的主机好像直连一样(例如输出一个URI 就能找到对应主机的资源)。 运输层是直接与应用层打交道的网络层级。通过对运输层协议(TCP/UDP)的了解和传输机制的学习，能更好的帮助我们理解应用程序的行为。在阅读计算机网络自顶向下方法的运输层时整理了如下的笔记。</p>\n<h2>运输层基础</h2>\n<p>运输层通过多路复用与多路分解来实现将主机间的数据交付服务扩展成主机的进程间的交付服务。它对应用层提供了两种服务类型:</p>\n<ul>\n<li>基于连接的，可靠地服务(TCP)</li>\n<li>不基于连接的，不可靠的服务(UDP)</li>\n</ul>\n<h2>TCP</h2>\n<h3>TCP报文段结构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 454px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABu0lEQVQoz22R646rIBRGff9XapM2fYEaTZpevBQUBKEgKBdltCdTck4mJ7N+7nxkf6ydVFU1jqMxZpqm8S9KqWEYmqa53+9SSmttnP/LTNNEKU0opeu6lmUJIeSc0w9a623blFKc82EYiqKglBJCMMaEEEqpEMJam3DOvfcIoThijAkh2rYFAFBKMcaU0izLuq4TQvR9zxjjnAshnHPfm733zjlrrfswjiMAoKoqAEBZlk3T1HVNCNFaG2NizHxI5AdrbQghtoAQXq9XQkhd1xDC2LmqKozxsixxk/d+nufkcrns9/s8zzHGp9Ppdrulabrb7Y7H4+FwiL2893VdAwAej0fbttZapZTWOun7PoTgnBNCZFn2fD4BAEVRCCGmadJaT9N0Pp/zPG+a5vF4RBfbti3LkjDGrLXxVIQQKeXr9YraIIRRct/3SikpZfxRNMIY+348z3PUMM9zLBlCkFKmaRqdjeMYM8MwMMaklAghKWUSpdsfGGO898aYuq4551LKZVmi5+jJex/NJV+/Mc8zQghCiBACAGit13UNP1iWJYSQvH9jXVfOedd1fd9jjJ1z7/d727b/Yn8AH0+bq1J7Cv0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP\"\n        title=\"TCP\"\n        src=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png\"\n        srcset=\"/blog/static/d6b45274cec3b46224cba1930bc6b66d/63868/fragment.png 250w,\n/blog/static/d6b45274cec3b46224cba1930bc6b66d/b3c1d/fragment.png 454w\"\n        sizes=\"(max-width: 454px) 100vw, 454px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>端口和目的端口用于TCP数据的多路复用和多路分解</li>\n<li>序号和确认号用于实现可靠数据传输</li>\n<li>TCP的连接状态保存在端系统中，这种链接的状态对网络层是不可见的。网络层只看到的数据报</li>\n<li>确认号可以理解成发送方期待接受方发送的下一段序列的初始字节编号。例如当A收到B发送的数据是500-600（不包括600）并且在累计确认下(前500的数据都得到确认) B在发送的报文中确认号就是600,A接收到报文后就会发送600之后的数据给B</li>\n<li>接收窗口用于实现拥塞控制(TCP慢启动)</li>\n<li>在6个标志字段中 ACK用于确认上一个已成功报文的确认 RST，SYN,FIN 用于连接的建立和拆除 PSH被设置的时候标志接受方应立即将数据交付给上层</li>\n</ul>\n<h3>流量控制</h3>\n<p>流量控制是发送方与接收方的一种速度匹配服务。在发送方与接收方都维持一个接收窗口的变量。假设该变量的值为rwnd，发送方必须保证LastByteSent - LastByteAcked &#x3C;= rwnd.假设接收方的缓存空间是RcvBuffer,必须保证 rwnd = RcvBuffer - [LastByteRcvd - LastByteRead].该窗口字段在接收端发送报文的时候会写到TCP报文的窗口字段。当接收端的窗口是0的时候，发送方接收到对应的报文将发送只有一个字节的数据报文段，此时接收端将接收这个报文并且清空自己的缓存空间(数据传送给上层)并且回复一个rwnd大于0的报文段</p>\n<h3>TCP连接的建立与中断</h3>\n<h4>TCP连接的建立</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 745px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPElEQVQ4y21Ty07jMBSN+CF2iK/gQ/gdliyQumEkxKpUHakwmpRFxDNNUlJFQigPMrRJWgfHaRLH8R3BRaYwc1b29X2dc681AJBSAsBqtTo8PDw4OCCEKOMmbm9vj46OTNNUFk1KKYRo2xYAtre3d3Z2AKBtW7mBrusAIMuy3d3d8XisHDSsgM/7+/t7e3tFUaBFAVPbtr21taXrOgAIId4qA0BZloQQzvl8PnccJ89zQsi/bQshxuPx6+urIvUW7Pu+bduEEMbYYrFwHKff75v397913TTNNE2rqsLWOOcq11vbm7mbpqmqCs+r5fLx8XHqur90fTgcep6XJEkcx0j4g7MiJqWs67osSyVBJ2WZ56HjZL4/dd2zfv/6+poxZlnWdDrlnGuoR9u2Xdet12tKaVVVrCiuLi6GvV6/17MNw314iOM/nHNKKYqPxTQhBM4DJUmSZDQaDQeDn6enV4bhh2FZfxJWan0EA0CapsvlkjFGKR2NRufn51EUBVGE/HERmqbhnOd5jhaEhrtFCFmv13meB0Hw9PQ0dZwfx8eXl5e2bSdJ0jQNeuMKqCl+UZtzXtc1Tn4+nxuGMRgMTk5OdF2PojBN06Kgm/6a4oCjQrVV7rqugyC4ubmxLOvu7g5H9SnYt8rYIb5hRrUCcRy/vLxg8AfnzTUsy5JS+u1LoSsesiz7D2e8h2HoeR7OTH4FAFBKXddtmka843vbQghK6Ww2WywWz8/Pvu9PJpM4jr13WJbFGNv8sH8BdCuyVQ0e+JcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"三次握手\"\n        title=\"三次握手\"\n        src=\"/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png\"\n        srcset=\"/blog/static/450ef929b273efe5395a856db3581d99/63868/connect.png 250w,\n/blog/static/450ef929b273efe5395a856db3581d99/0b533/connect.png 500w,\n/blog/static/450ef929b273efe5395a856db3581d99/7e509/connect.png 745w\"\n        sizes=\"(max-width: 745px) 100vw, 745px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>客户端在向服务端请求连接的时候，会向服务端发送一个SYN报文段。会随机选取一个client_isn作为序号字段放置在该SYN报文中。</li>\n<li>服务端在收到该报文后，会发送给客户端一个报文并且设置TCP的缓存和变量。该报文的ack字段是client_isn + 1,序号字段为server_isn,SYN比特为设置成1.代表当前服务器已经准备接收数据</li>\n<li>客户端在接收服务端的确认报文后会创建TCP的缓存和变量并且向服务端继续发送报文(此时的报文可以携带上上层的数据),其中ack字段是server_isn + 1,序号字段是client_isn + 1,SYN字段为0(此后的报文中SYN字段都为0).至此TCP连接建立成功。(三次握手是为了确定双方的序号)</li>\n</ol>\n<h4>TCP连接的中断</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACnUlEQVRIx4WVS2pyQRCF7+qyCFcgCK7AUYYhOnfgyEAgDl2BRIMKOjAPiCGaGI3vtyY+ovXzNZS0915/G5qr3V2nTlWdrnZERLbbrfz+/pr59/cn+/2e5cPXHqzp+m63k9lsJtPpVJbLpVl32Oj1elKr1eTj4+PI0A/M/gL49PQkLy8v0m63zZoDO4Cen5+lXC7L29ubrFYrDxs/wE6nI4+Pj5LP58232+2Ks9lsjIdMJiORSEQuLy8PTGHgN3Qd57lcTq6uriQcDsvd3Z04xWJREomExGIxSaVSZhK+bahMbcbNZlOSyaREo1G5vr6Wm5sbSafT4tze3kogEJBgMCj39/fy8PAgk8nEF4ipTkqlkoRCIbm4uJB4PC7ZbNakzcG4UCiYSg2HQ5nP53JquEFRRaVSOVpzKMB6vTZ/+v2+DAYDc3CxWJgvB1utlkm4eyAVdzSOfWA0GhkQNigWzgCGPY5+fn7MRBmcYQ/JHQHaiQYQA/cAkCIgYvYBYb6+vkqj0TgU0AM4Ho8PtwV2ypCQv7+/TX4JU3WKA1+GmlDU/vn5aUAxVPBTgzPk3Rb7EUPyBKNzVdbzhI8y7H0PIF7d1w4VEK4NCHNyXq/XTTo0DY5NlxyqhDQVGCIZDCkOwOSOdCCZ9/d3c1W1mI6CIRM2McQIcK2qtifN59mQVRp0DMIGiAkI4NxtioX+7IYBS9+iaCtCa3ZVMYY5QBQLcDtknGPnkQ2Di03IAJxqsLqOA5XZ19eXPyC5Y9pF8Zv2oLKaQw8gOaT8hOLuzu6urf/dwj4ChBkh24CnGJ4FBIRK8jb87z1xA9qyOWpfhFqtVs0L5s4hldZO4n6sqLz2SU/IDLqvPlCnQraZclP0/fF0G76wRMDnAN2ysn//Aw2QzK7dGbfNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP close\"\n        title=\"TCP close\"\n        src=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png\"\n        srcset=\"/blog/static/bfcc2547154c5a74172a41af7cbca7a1/63868/close.png 250w,\n/blog/static/bfcc2547154c5a74172a41af7cbca7a1/9f933/close.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n(发送方和接受方都可以中断TCP连接)</p>\n<ol>\n<li>终止方向另一端发送一个TCP报文，其FIN比特位被设置成1</li>\n<li>接收方回复一个ACK报文并且发送一个FIN报文</li>\n<li>终止端回复一个ACK报文，至此两方为了维持TCP连接的缓存和变量都将清除(接受FIN端需要把自己剩余的信息发送完 才能发送FIN报文)</li>\n</ol>\n<h4>TCP客户端和服务端的状态转变</h4>\n<h5>TCP客户端客户端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB4klEQVQ4y42U144CMQxF5/8/CF54gDckiui9I3rvHa+OV4YwO0hrKcokE19fXzvxxLF2uy2ZTEaWy6Wuj8ejbDYbGQ6HMhgMZLfbyfV61X/M8XhcstmspNNpCYfD0mq1xHs+n2IDu1wuslqtFIQDs9lMarWaNBoNmU6nMh6PNeBisdAAj8dDwff7vc6eC3Y4HGS9Xr/WFoBxPp91NmMNaLValXq9rmvMc1OGmZkbyDV/Ntvt9uOfd7vdpNvtqhZEIiIsXWe/LMxkMxqNJJlMynw+V71fgFCnIKVSScVHK7QxZ5cBhg/aQoKRSqVU8/v9/k4ZkHK5/Ce9oDWAFIQBEPqx99KQqoVCIcnlcnI6nT6cgxhyHlaJREJisZj0+/23hnYYPYz2N0D/PkDNZvPDR9uGDRoY/aD+DcxfZc7Sn65pUahsPp+XSqWiTQywn6n7TcHoDDSnysw0PPvKEN0AAYy+oh/dKge1DekCVCwWtTsmk8kb0OgT9VuFg1K2m0UL0XofRbHOp4IuE+6nXb2gs0gDkV6v98sQ3SKRiD4EnU5HtSAag6qjbaFQUAfWFIF/3A4YIhfgprnHK8GTRQ8CaMyIxnWyFwbNACI9cwY8Go3q04WOfx6H/7SKewaGsCaYPRI/rcIZxDx6n2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"客户端状态变化\"\n        title=\"客户端状态变化\"\n        src=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png\"\n        srcset=\"/blog/static/28dcf09f263ca815ac261f70aa5afffb/63868/client-status.png 250w,\n/blog/static/28dcf09f263ca815ac261f70aa5afffb/5c6e9/client-status.png 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>连接的建立 初始的时候TCP客户端处于CLOSED，当它需要与服务端建立TCP连接的时候，发送SYN字段，进入SYN_SENT状态. 当收到服务端对SYN报文的确认后，就进入ESTABLISHED状态，此刻TCP客户已经能发送和接收数据了</li>\n<li>连接的中断 客户端发送TCP报文(FIN字段被设置为1),进入FIN_WAIT_1,等待服务端的确认报文然后进入FIN_WAIT_2.等到服务端的FIN报文并且发送确认报文后，进入TIME_WAIT.最后进入CLOSED状态</li>\n</ol>\n<h5>TCP服务端状态的改变</h5>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABxklEQVQ4y42Ux47DMAxE9f+flFOQ5JKDL+k9SO+9Vy4eASqCsIssAcGWRI9myLHc7XYTxuVykdPpJMfjUZ/MebdxOBzkfr9Lu92WdDotmUxGUqmUZLNZGQwGmk+Oq1ar0u12ZTabyfV6FeL5fHrw4XAo4/HYgz4eD1kul9JqtaRYLMp0OpUwXKPRkHK5LJVKRdbrtWe2WCxkv98r4Gg0UpDVaqV7rIfxfr/9cOEGySxavF4vncOYdwvmHGj7BqoMLdHkhCfGEa7vdjsvNwR1sEJ2s9nUuiCb4sdS7CMO3W63UqvVJEkS2Ww2OocYQxkCSqcmk4k2w1iHLO0dubCjppaPS3xT6C5dZJAcA8SSLVABMERo6Hw+FxzjWIQ2nUNOKO83hvYEEGXIxT44pd/vf7psgP9liBrA4j2HmZENdWTjtbDb8QfUF69SPxoJkfP5/Kkhk06no/rr9bomxvYJy2AeRGapVNJuw9QzNGRY2h8QA/1lH5jGJXFhovnpW5CDbcyvgFM6BaR2uVxOXW+mpXt0nxLQvUKhIL1eT+uL8dnHJvl8XnPssqAcDgD+FC4BYwcwtQWAmnI5kEdJ7EbCzBwCofDX+wGhXtIqR2SqKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"服务端变化\"\n        title=\"服务端变化\"\n        src=\"/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png\"\n        srcset=\"/blog/static/884026a29f246f33aa0a88780176d2d5/63868/server-status.png 250w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/0b533/server-status.png 500w,\n/blog/static/884026a29f246f33aa0a88780176d2d5/29492/server-status.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h5>理解TIME_WAIT状态</h5>\n<ol>\n<li>可靠的实现TCP全双工连接的终止 主要close的一端 需要维持状态以防止最后一次的ACK对方收不到来进行网络重传</li>\n<li>TIME_WAIT阶段设置的超时时间会导致网络中迷失的分组丢失,这样在同样的端口创建新的TCP连接时候,不需要判断之前的数据.</li>\n</ol>\n<h3>拥塞控制</h3>\n<p>TCP使用的是端到端的拥塞控制，来防止网络拥塞时发生的各种问题(多余的分组,丢包等)。相比流量控制，拥塞控制是对网络拥塞的一种感知来控制发送的速度。流量控制是对接受方处理速度的一种速度调整。\n在TCP发送方维护一个拥塞窗口的变量来实现拥塞控制<br>\nLastByteSent - LastByteAcked &#x3C;= min { cwnd(接收窗口) , rwnd(拥塞窗口)}</p>\n<ul>\n<li>当发送方正确的收到确认报文的时候，他认为网络中无拥塞，不断的调整 cwnd</li>\n<li>当发送方超时未收到ack或者收到接收方三次冗余,需要降低发送速度</li>\n</ul>\n<h2>基础词汇解释</h2>\n<p>MSS 最大报文段长度<br>\n在不同的链路层协议上，其最大的传输单元(最大链路层帧长度)不同，这就导致了在封装到IP数据报的时候，需要适应底层的链路层长度。</p>\n<h2>TCP UDP 区别</h2>\n<ol>\n<li>TCP提供差错校验,重传等功能 UDP不提供对应的功能,UDP需要在应用程序中添加对应的逻辑来完成相应的功能</li>\n<li>UDP的数据报长度字段会随着数据发送给接收端,TCP是一种字节流协议,没有记录标记的长度(content-length) 主要是两者实现方式上的不同UDP是不面向连接的 也就是可以从一个套接字接受多个数据源 如果没有长度加以区分数据就会混乱.一个TCP套接字只对应着一个数据源,可以由应用层来决定数据的读取.</li>\n</ol>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"计算机基础之运输层","date":"2018-02-21","tags":"计算机基础","path":"/transfer","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":14,"pageCount":15,"additionalContext":{"pageAllCount":87}}},"staticQueryHashes":[]}