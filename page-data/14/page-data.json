{
    "componentChunkName": "component---src-templates-index-js",
    "path": "/14",
    "result": {"pageContext":{"pageAllCount":91,"group":[{"node":{"id":"49d0ecf8-e0ff-5395-8dc8-4d548df3162b","html":"<h2>引言</h2>\n<p>当javascript代码执行从一个函数进入到另一个函数的时候,语言在实现上为当前执行函数保存外部的执行环境(变量),在当前函数进行变量标识符查找的时候,查找的规则是首先在当前的执行环境中查找对应的变量,然后逐步从上级的执行环境中查找.这种对变量实现的存储和查找机制就是javascript中的作用链域.下面先从一些js执行环境的基础知识说起,然后从ECMA的规范上理解javascript的执行环境.</p>\n<h2>基础知识</h2>\n<h3>执行栈</h3>\n<p>执行栈是存储javascript执行上下文的一种结构,它具有后进先出的特点.javascript在执行的时候会创建全局的执行上下文.在执行到函数代码的时候,会创建新的执行上下文,执行完对应函数的时候,会退出当前的上下文回到之前的执行上下文继续代码的执行.</p>\n<h3>声明提升</h3>\n<p>javascript在创建执行上下文的时候,会对当前执行环境声明的变量进行绑定(初始化存储位置),这在一定程度上解决了函数声明的先后顺序问题,下面这段代码是可以正常执行的</p>\n<pre><code>console.log(a);// undefined\nvar a = 0;\n// let const与var的区别是在创建对应的之后环境的时候是let const不会为变量绑定初始值,var会绑定初始值(undefined),引用一个没有初始值的变量会报错\ntest();\nfunction test() { test2(); }\nfunction test2() { console.log(1); }\n</code></pre>\n<h2>从ECMA规范理解js执行环境</h2>\n<p>在javascript进入到函数的执行代码的时候,会创建新的执行上下文,将当前的上下文推入执行栈进行代码的执行.下面先简单的理解执行上下文的基本组件:</p>\n<pre><code>Execution Contexts = {\n  code evaluation state // 代码执行的状态 用户代码的执行暂停和恢复\n  Realm // realm是对javascript执行边界的一些限制\n  LexicalEnvironment:{\n    this  // 会进行this的bind  理解this是当前函数的caller\n    Environment Record  // 用于初始化和存储当前上下文声明的函数声明,变量\n    outer LexicalEnvironment  // 用于从外部的作用域查找标识符(作用域链)\n  }\n  VariableEnvironment: {} // VariableEnvironment和LexicalEnvironment是相似的概念下面会单独进行讲解\n}\n</code></pre>\n<h3>this</h3>\n<p>this是指调用函数的caller.在进入函数执行的时候会创建新的执行上下文并且对this进行绑定<br>\n<strong>箭头函数使用的是Lexical this，即这个函数被创建时的this就是函数内部的this</strong> <strong>箭头函数不能通过new地调用</strong>.</p>\n<h4>如何确定this</h4>\n<pre><code>const obj = {\n  name: 100,\n  test: function() {\n    console.log(this.name);\n  }\n};\nobj.test(); // 100\n\nconst obj2 = {\n  name: 200,\n  test: () => {\n    console.log(this.name);  // 这段代码的执行环境是全局的环境 所以箭头函数中this的指向是window\n  }\n}\nobj2.test(); // undefined \n</code></pre>\n<p>上面的代码块中obj是一个引用类型,在ECMA规范中有引用类型的定义,可以理解成下面的形式</p>\n<pre><code>Reference {\n  the base value component // 引用类型的值 对于上面的例子来说就是obj本身\n  the referenced name component // 引用类型的名字\n  the Boolean-valued strict reference flag\n} \n</code></pre>\n<p>在执行上下文中确认this的指向可以使用如下的规则:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 955px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2klEQVQ4y32UyaoCQQxF+/9/RlDUhbhR3KiI4oiI4DzP85jHCUTqdbcWhC4rqVvJzY3e7XaTx+Px1Z7PpxAzm81kPp/r93A4yOv1CsSdTifxcHxb7/f78x2Px9JsNmUymcj5fA6Nv16v4oFsl1zjIYw9MZvNRm29XsvlcgncYXEeAPy1n06nmoU/+6+A7pflpwP+4POb/2eGZAJvAEB2pVKRVqsltVpNgfEPBgO53+9qPwEJ2O12CkQD4K7X6ylYv99XQC4fj0f1b7dbvfOvKe7a7/eyWCz+nSENLlpD3MXDgFGNR6C1nFe4gDQwA7BG4HcrAYAM0SfdpyrNEBsOh7JcLqXdbkuxWJRyuSz1ev1Tottdt6uj0Ug6nY7GYZ41wM3C9GZnPMh0+AHx53I5iUQiEovFlOMPoKt+/29ooQFhGRJLZeyhKADo6tD2AIZlyLmpAQPYM4cJ1j+CVrL7oOtzH1bZALRarZR4gMMAAcPvn47QWYbIeDwuyWRSut2umIzsT4EyaBDSQJsul/4MFZC2JxIJSafTypNfHugxk8lIoVCQarX6k2sFLJVKks1m9VKj0fjMpXFHEJkjDybI/28TAMzn85JKpSQajerwW8nGl00AX8ztdhjgHySBv0iaXn0uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"this\"\n        title=\"this\"\n        src=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png\"\n        srcset=\"/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/63868/this.png 250w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/0b533/this.png 500w,\n/blog/static/460681b8e463e26d3a1b7f288f0aaf8e/a0b80/this.png 955w\"\n        sizes=\"(max-width: 955px) 100vw, 955px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>理解VariableEnvironment和LexicalEnvironment</h3>\n<p>VariableEnvironment是创建执行上下文的时候进行变量的初始化绑定和存储,LexicalEnvironment(LexicalEnvironment在进行变量初始化后会复制一份VariableEnvironment)主要用于在代码执行阶段对标识符的解析并且随着代码执行(例如产生with语句)会创建新的LexicalEnvironment到当前的LexicalEnvironment之前.可以通过下面的例子来加深对上面例子的理解:</p>\n<pre><code>function test() {\n  var a = 10\n  var obj = {a:20}\n  with(obj) {\n    var test2 = function() {\n      console.log(a)\n    }\n    function test3() {\n      console.log(a)\n    }\n  }\n  return {test2,test3}\n}\nvar hah = test()\nhah.test2() //log 20\nhah.test3()//log 20  \n</code></pre>\n<h3>理解闭包</h3>\n<p>当前的函数存在对外部作用域变量的访问会形成闭包.闭包保存的是生成闭包时候的执行上下文的LexicalEnvironment.\n(Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.)</p>\n<h2>参考   </h2>\n<p><a href=\"https://stackoverflow.com/questions/15031667/clarity-on-the-difference-between-lexicalenvironment-and-variableenvironment\">VariableEnvironment和LexicalEnvironment的区别</a><br>\n<a href=\"http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/\">lexical-environments-ecmascript-implementation</a><br>\n<a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-intro\">ECMAScript2017</a><br>\n<a href=\"https://stackoverflow.com/questions/49832187/how-to-understand-js-realms\">how-to-understand-js-realms</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"深入理解javascript系列之执行环境","date":"2019-01-15","tags":"JavaScript","path":"/javascript-call","top":null,"summary":null}}},{"node":{"id":"16f13582-3dfd-5fca-8a6c-cd780c714f5f","html":"<h2>简介</h2>\n<p>最近在做业务中,需求的场景是需要在原有的组件上添加点击事件并且需要维护一些新增的内部状态,想到的方案就是通过高阶组件来实现.通过高阶组件能减少对原有组件的侵入性.高阶组件它是一个接收组件并且返回包装组件的函数.实现高阶组件有如下几种方式:</p>\n<ol>\n<li>属性代理(操控props,增加state)</li>\n<li>反向继承</li>\n</ol>\n<h2>使用</h2>\n<h3>属性代理</h3>\n<p>下面这个例子,通过在高阶组件中创建新的state完成了新的业务逻辑的添加,通过控制props的传递可以向组件加入新的props.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  componentDidMount() {\n    console.log('Wrapped');// wrappedComponent先Didmount(子组件先DidMount)\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent{this.props.name}&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Component {\n    constructor(...args) {\n      super(...args)\n      this.state = { count: 0 }  // 创建新的state,来添加新的业务逻辑\n    }\n    componentDidMount() {\n      console.log(\"HOC\");\n    }\n    render() {\n      return (&#x3C;div\n        onClick={() => { this.setState({ count: this.state.count + 1 }, () => {\n          console.log(this.state.count);\n        }) }}\n      >\n        &#x3C;Wrapped {...this.props} name=\"HOC\" />  // 在这里可以给传入的组件添加新的props\n      &#x3C;/div>)\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;  \n</code></pre>\n<h3>反向继承</h3>\n<p>反向继承指的是在高阶组件中继承包裹的组件,在对包裹组件的方法进行调用的时候,要通过super来实现反向的调用.通过这种方式可以拿到包裹组件的state,props以及相关声明周期的调用,但是它不保证完整的子组件被渲染.</p>\n<pre><code>import React, { Component } from 'react';\nclass WrappedComponent extends Component {\n  constructor(...args) {\n    super(...agrs);\n    this.state = { name: 1 };\n  }\n  componentDidMount() {\n    console.log('Wrapped');\n  }\n  render() {\n    return (&#x3C;div>WrappedComponent&#x3C;/div>)\n  }\n}\nconst HOC = (Wrapped) => {\n  return class extends Wrapped {\n    static displayName = 'HOC' //定义高阶组件的名字\n    componentDidMount() {\n      console.log(\"HOC\");\n      console.log(this.state) // { name: 1 }\n      super.componentDidMount();// 通过super调用(如果没有调用,不会执行Wrapped的DidMount)\n    }\n    render() {\n      return super.render() //在这个可以实现渲染劫持,例如常规的loading态加载\n    }\n  }\n}\nconst HOCComponent = HOC(WrappedComponent);\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div\n      >\n      &#x3C;HOCComponent/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default App;\n</code></pre>\n<h2>代码复用其他方案</h2>\n<h3>render props</h3>\n<p>render props能一定程度的实现代码逻辑的封装和复用.在定义组件的时候通过在定义一个render函数来决定组件的具体内容.(children API)</p>\n<pre><code>import React, { Component } from 'react';\nclass Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &#x3C;div>\n        {mouse.x}\n        {mouse.y}\n      &#x3C;/div>\n    );\n  }\n}\nclass Mouse extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  render() {\n    return (\n      &#x3C;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n      {this.props.render(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &#x3C;div>\n          &#x3C;Mouse render={(mouse) => (\n            &#x3C;Cat mouse={mouse} />\n          )}//  这里每次都会生成一个新的方法,可以定义一个实例的方法\n          />\n      &#x3C;/div>\n    );\n  }\n}\nexport default MouseTracker;\n</code></pre>\n<h2>总结</h2>\n<p>react通过组件之间的组合来生成页面,通过高阶组件的可以复用已有的逻辑并且减少对原来代码的入侵性.在进行系统的设计的时候,也应该考虑对原有逻辑的改造问题.如何能让剔除业务逻辑的其他相关组件之前依赖性降低是一个值得好好考虑的问题.</p>\n<h2>参考</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a><br>\n<a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"React高阶组件","date":"2018-12-11","tags":"React","path":"/react-hoc","top":null,"summary":null}}},{"node":{"id":"efc0f5b3-aa07-511b-a4cf-49525fafa951","html":"<h2>简介</h2>\n<p>如何利用缓存在计算机系统或者网络服务中都是提升系统体验的的一个很重要的思考方向.相对于网络(磁盘)的I/O,直接将需要的数据存储到一个相对较快的获取位置,这样就能尽快的获取到需要的资源.这里主要总结下在前端开发中一些缓存方面的知识.</p>\n<h2>请求资源</h2>\n<p>下面这个图总结了网络请求中缓存涉及的几个方面,下面将具体的从每个方面进行展开.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvTUgo/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQITFh/9oACAEBAAE/IWxwjVLNf//aAAwDAQACAAMAAAAQO8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJVpB//EABsQAQADAQADAAAAAAAAAAAAAAEAEUEhMVFx/9oACAEBAAE/EKAD7uLzWqMJSlfrK2AtzJQeCf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"缓存\"\n        title=\"缓存\"\n        src=\"/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg\"\n        srcset=\"/blog/static/25876b65ff2b21059308d346235fde05/0479a/cache.jpg 250w,\n/blog/static/25876b65ff2b21059308d346235fde05/41099/cache.jpg 500w,\n/blog/static/25876b65ff2b21059308d346235fde05/a2510/cache.jpg 1000w,\n/blog/static/25876b65ff2b21059308d346235fde05/a9cfd/cache.jpg 1259w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>本地-强缓存</h3>\n<p>强缓存是浏览器在请求具体的资源的时候,直接使用本地缓存的资源的副本而不通过服务器去验证资源的相关信息的一种方式.通常有通过expires和Cache-Control中的max-age来控制.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"right\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>expires</td>\n<td align=\"center\">指定缓存的过期时间(与客户端的时间设置相关)</td>\n<td align=\"right\">HTTP 1.0  max-age优先expires</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">指定请求资源过后多少秒后资源过期</td>\n<td align=\"right\">HTTP 1.1 max-age有优先expires</td>\n</tr>\n</tbody>\n</table>\n<p>当请求的资源存在本地缓存副本并且处于新鲜期的时候,直接返回本地资源.<br>\n当请求的资源没有本地缓存的时候,向服务器拉取对应的资源.<br>\n当资源存在缓存但是已经过期的时候,通过缓存协商去服务器获取资源.</p>\n<h3>请求-缓存协商</h3>\n<p>缓存协商是指通过与服务端交互缓存资源的信息来判断当前缓存是否可用的一种机制.<br>\n当通过缓存协商服务端认为当前的资源是可用的,返回304(响应体是空).客户端可以使用当前缓存资源并且更新缓存相关信息.<br>\n当服务端认为资源不可用的时候,返回200(响应体中包含请求的资源).</p>\n<h4>Cache-Control</h4>\n<p>Cache-Control 被用于在http请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求设置的指令,在响应中不一定包含相同的指令.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td align=\"center\">下次请求是强制验证资源有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td align=\"center\">不进行缓存</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td align=\"center\">相对于请求时间设置的最大过期时间</td>\n</tr>\n<tr>\n<td>public</td>\n<td align=\"center\">可以被客户端和代理缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">只能客户端缓存,不能被代理缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td align=\"center\">缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源</td>\n</tr>\n</tbody>\n</table>\n<h4>last-modified和Etag</h4>\n<p>last-modified和Etag(Etag还可以结合If-Match来判断当前提交的内容跟服务端存储的内容是否一致)都是在响应头中返回的对资源的一些设置信息,可以通过这两个值来缓存协商当前缓存资源时候可用.</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th align=\"center\">意义</th>\n<th align=\"center\">作用方式</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>last-modified</td>\n<td align=\"center\">资源在服务端的上次修改时间</td>\n<td align=\"center\">通过在请求头中设置If-Modified-Since的值为缓存资源的last-modified值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td align=\"center\">代表资源的实体标识,当资源的内容在服务端修改的时候,需要重新生成Etag</td>\n<td align=\"center\">通过在请求头中设置If-None-Match的值为缓存资源的Etag值来与服务端询问缓存的新鲜度</td>\n<td align=\"center\">服务端优先验证Etag</td>\n</tr>\n</tbody>\n</table>\n<h5>last-modified和Etag的区分</h5>\n<p>Etag的出现更像是为了弥补last-modified的不足.例如:</p>\n<ol>\n<li>last-modified的时间只能精确到秒</li>\n<li>一个资源的频繁修改但是内容并没有修改</li>\n</ol>\n<h2>存储-协商存储</h2>\n<p>协商存储就是根据上面学习的相关字段来决定获取到的资源是否可以被存储被下次请求使用的策略.上文已经对相应的字段进行了说明.</p>\n<h2>CDN</h2>\n<h3>CDN简介</h3>\n<p>CDN(内容分发网络)指的是一组分布在各个地区的服务器.这些服务器存储着数据的副本,当用户访问资源的时候,CDN服务器可以根据用户的IP,服务集群的负载状态等信息尽快的返回给用户所需要的资源.</p>\n<h3>CDN优点</h3>\n<p>CDN主要的功能是托管静态资源,项目中对静态资源进行CDN的配置已经是标配,使用CDN主要有以下优点:</p>\n<ol>\n<li>将静态资源托管给CDN起到给源站分流的作用,降低服务端负载,解决网络网络带宽问题和不同服务商网络速度不同的问题.</li>\n<li>对资源的请求大部分都在CDN的边缘节点完成,访问延迟降低,用户能尽快的看到内容.</li>\n<li>CDN域名与源站域名不同,源站的cookie不会随着静态资源的请求发送,能一定程度上减少网络数据的发送.</li>\n</ol>\n<h3>CDN请求资源流程</h3>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器.</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户.</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求.</li>\n<li>CDN全局负载均衡设备根据用户IP地址,以及用户请求的内容URL,选择一台用户所属区域的区域负载均衡设备,告诉用户向这台设备发起请求.</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近;根据用户所请求的URL中携带的内容名称,判断哪一台服务器上有用户所需内容;查询各个服务器当前的负载情况,判断哪一台服务器尚有服务能力.基于以上这些条件的综合分析之后,区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址.</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户.</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地.</li>\n</ol>\n<h3>CDN优化</h3>\n<ol>\n<li>合理设置CDN节点的缓存时间，保证用户能及时同步到最新的内容</li>\n<li>根据不同的路径 配置不同的缓存规则，实现缓存的最大化</li>\n<li>CDN缓存节点预热</li>\n</ol>\n<h2>缓存的意义</h2>\n<ol>\n<li>\n<p>资源或者服务的尽快到达和可用</p>\n</li>\n<li>\n<p>解决网络带宽问题和服务负载</p>\n</li>\n<li>\n<p>减少网络流量,让流量做更加有意义的事</p>\n</li>\n</ol>\n<h2>思考</h2>\n<p>缓存能给应用带来一定的好处,同时也给服务增加了一些负载(保证资源的更新,增加缓存的成本等等).在对系统的一些基础服务做修改的时候,先要把这些有可能出现问题的点考虑清楚或者为什么这么做想好,在去做事.</p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"缓存那些事","date":"2018-10-28","tags":"计算机基础","path":"/web-store","top":null,"summary":null}}},{"node":{"id":"cd56cd7c-4adc-5c34-be0f-983b3549de82","html":"<h2>简介</h2>\n<p>事件循环是不同的宿主环境(浏览器或node)对javascript任务进行调度的一种机制,在讨论事件循环的时候首先应该区分node和浏览器(不同宿主环境实现的事件循环机制不同).下面通过介绍一些javascript的基础知识,进而简单的介绍浏览器中的事件循环和node中事件循环.</p>\n<h2>基本概念</h2>\n<ol>\n<li>javascript程序的执行机制是通过栈来管理的.当进入一个函数,就创建了这个函数的执行环境并将这个执行环境推入栈顶,执行完当前的函数后,从栈顶移除对应的执行环境,进入到外层的执行环境.</li>\n</ol>\n<p><img src=\"/blog/ee34151d44d3f796b1f1436e0926a2a7/stack.gif\" alt=\"stack\">\n2. javascript的执行是单线程的.但是由于整个事件循环的调度,赋予了javascript对异步任务的强大处理能力.对于异步任务(网络请求,按钮点击)javascript代码调用宿主环境提供的api,将异步任务交给其他的线程去完成.当对应的异步任务完成的时候,将回调函数添加到\n回调函数的队列中,由事件循环来实现会回调函数的调用.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>marcotasks microtasks</h2>\n<p>将macrotasks和micortasks单拉出来讲解,是因为理解好这点能更好的理解浏览器或node的任务队列.在实际的实现环境中不同的任务可以放置在不同的任务队列中,然后通过对多个任务队列的调用来完成整个事件循环.</p>\n<ol>\n<li>macrotasks:</li>\n</ol>\n<ul>\n<li>定时器(timer) setTimeout setInterval setImmediate</li>\n<li>message channel  (message channel执行的优先级高于timer)</li>\n<li>I/O</li>\n<li>UI rendering</li>\n</ul>\n<ol start=\"2\">\n<li>microtasks:</li>\n</ol>\n<ul>\n<li>Promises</li>\n<li>MutationObserver(监听DOM)</li>\n</ul>\n<ol start=\"3\">\n<li>其他api</li>\n</ol>\n<ul>\n<li>\n<p>queueMicrotask(fn)\n将Fn推入微任务执行队列</p>\n</li>\n<li>\n<p>requestAnimationFrame<br>\n通知浏览器在下次重绘之前调用传入的回调函数，回调函数默认传入函数执行的时间戳.requestAnimationFrame不属于宏任务和微任务，在微任务执行之后执行</p>\n</li>\n<li>\n<p>process.nextTick\nprocess.nextTick是node上的api，具体的执行时机是在微任务之前执行。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVQ4y42T227aQBRF+QwItudqjw12bGyMuQQCCRENtE9VK7X//x+r8uSiRkmkPGwdzRnN1lkzewbKWHTeYos5dTujW9V0q4Z6XhPHCWEYEkXRO33WHyilUPGUpKjJ2xVuWpBVDWlRkkxywiB4o6Cvz2YfmQ6klBTJFCcNURgiTYxU2ktEEUJIdOzQxqJih4kdSsp3Zi9rP6GWirbdUa9vqfcn2rszy8svuvtHqs2B+eEbi/szy4fv1G1Hf+YjXG+otSYMxuTdlmb/SN4sqW6OlMs9Rbcju679lFJZpFSeIhj3+CFBEPrqFT5poLTyaPEkIy0zXJkxbUuS3CFtgHEC4xQ2lWgnsZnGpMrXF/X7QkZE4hlZCIGOIyYzTT43ZJUiKxVZZUgrS1Zb3LV+rUlumC4crrToRL2aSiN6ZEUQRtzXhr+nip93Bb+PBX+OBZdDQ96tmcwaqps7quWaOE3xVEr4Owv+R++Re8MoEuTOcbqcOP04s9jsKNuOax+jkrSYkbcbf7/5fIW1sY/PpznUShEnFmsVUghGwxHD4ZDRaMT46upJoyHjq5FX+GoWvovPoH+5fsrH84bLZcf2Zk5TF1jT9yVKPSkS4ms/pX+Q1CXcrjs22479w579ccf2sGW9W7FoSxZd47P3mcnbHBqNS1KcchibYLMCk05J8hk2nWKtJUliH62vGP4DF253f3L9M/QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nextTick\"\n        title=\"nextTick\"\n        src=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png\"\n        srcset=\"/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/63868/nextTick.png 250w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/0b533/nextTick.png 500w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/00d43/nextTick.png 1000w,\n/blog/static/d9d3d44ff5dfea2d5baad24c7faf598d/33d1d/nextTick.png 1150w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>setTimeout(function(){\n  console.log(1);\n});\nnew Promise(function(resolve){\n  console.log(2)\n  for( var i=100000 ; i>0 ; i-- ){\n      i==1 &#x26;&#x26; resolve()\n  }\n  console.log(3)\n}).then(function(){\n  console.log(4)\n});  \n\nconsole.log(5);\nprocess.nextTick(() => { console.log('nextTick'); })\n输出的顺序依次是 2 3 5 nextTick 4 1 \n</code></pre>\n</li>\n<li>\n<p>requestIdleCallback\nwindow.requestIdleCallback(callback[, options])</p>\n<ol>\n<li>callback是一个在事件循环空闲时即将被调用的函数的引用，接收一个IdleDeadline参数，通过该参数可以获取当前空闲时间(timeRemaining())以及回调是否在超时时间前已执行的状态(didTimeout)</li>\n<li>options 可选参数 可以配置timeout  表示超时毫秒数未调用回调函数，回调函数将在下一次空闲期间被强制执行。</li>\n</ol>\n</li>\n</ul>\n<p>在具体的实现中只会有一个microTasks队列,简单的理解事件循:</p>\n<ol>\n<li>浏览器或者node会按照顺序执行自己环境的多个macrotasks队列</li>\n<li>每执行完一个macrotask队列就会拿出micortasks队列的任务全部执行，然后继续执行下一个macrotask队列</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.400000000000006%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd1CLID/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAE/IRR5Ef/aAAwDAQACAAMAAAAQ48//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAAAATFBEVEhcfD/2gAIAQEAAT8Qy3TXN2M1O2ZJuxz7aIH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"runTask\"\n        title=\"runTask\"\n        src=\"/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg\"\n        srcset=\"/blog/static/9a253bb0db2af3498f93ce723c928568/0479a/runTask.jpg 250w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/41099/runTask.jpg 500w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/a2510/runTask.jpg 1000w,\n/blog/static/9a253bb0db2af3498f93ce723c928568/46d48/runTask.jpg 1098w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in browser</h2>\n<p>其实通过对上面相关的知识的介绍,已经可以大致的了解浏览器中事件循环的任务队列 主要有以下几种macrotasks队列</p>\n<ol>\n<li>事件callback</li>\n<li>I/O(xhr)</li>\n<li>timers</li>\n<li>UI渲染</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.199999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQoz1WQS2vbQBSF9XcL3aXQf1BCUkiz7KKLLNqSdV8QCIUGQgu149qpYluWrOc8pRnNSLIkezS3FaXQftzFXZzDuec6h4PdNy7zn6+nJ8H8xJse6/Sl6UtjBgALXQ8GbOPy5WkwOauCM1NObA+224O1DomDyPMX07mkec4KPwhns/to6+c0A2MHpJAfZ+sEdrDjdfQQd8XO6nbAynYHB619EuNos+UR9kPkRckmjP04TRACYxVXpFF5VUrT46rkWoiuMQCgW9vunWztSSnLSnFMwpDqqtG6yXMZZ2NyxfQoBZB9vzPj2hnTWwtVP2DlYM9XolKlKogKvWsZP5PRKQvOZutlxIY8uqvoeYtfFPpe0LdtdqyLT50FU9ZDIp1w6W7QakPcNCOR90GFj3V4xDdPo2QFBmTyVaMnbXqU6++CnLfJI52/2Y9n72y5c5azbzeT9zfTd+5i4i9vg/Wr9cOF715EsQcWpP9TJJc6vszpiidXOnot0e1hN1iixs4FY5Lm46sp5YwhXPzcMkbzUgqwsK9N20BbQ6t7kvJGm1bvD1Vrmx4G60gpxd8pS0UpCQJfSkEytHU/ZtvPqX+Nt1ecBATnjHJGc5SxrusBwCn+QQjhed5iPkcYi0Kg+AEnqyxyF3df7n/MVg8blGJGOM5o13ajef8/VVVVda2VzEkqOG/qxgxQ1a3SI33f/5ENw/Db/Auzl1Sw4SbonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"loop\"\n        title=\"loop\"\n        src=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png\"\n        srcset=\"/blog/static/9199d327119d3626ea1ef4a942f78acf/63868/loop.png 250w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/0b533/loop.png 500w,\n/blog/static/9199d327119d3626ea1ef4a942f78acf/9a86a/loop.png 792w\"\n        sizes=\"(max-width: 792px) 100vw, 792px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>event loop in node</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 141.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAACzklEQVRIx5WVC0/qQBCF/f//RQMKUfAJCpIoAYxBBBGjEfABgkApbWFuviHbFCwpt8lkutvu2TMzZ2d3ZO1ZLBbqHceRwWAg39/fav1+X/3Pz498fX2ptyxL7NlM/505jsznc9kBYN14AMtmsxKLxdQODw/l4OBAfTKZlKOjI3l5eZHp1JbZbKbg0+l0CRjG0LZt+fz89BliMMN4//j4kNFo5K+DnQUgA8/zlLbruiugwYdv/LMpRa7rLQH56f39XVqtlry9vfm7MgcLE/7d3Z1cX18rw263K8/PzysbQ0oBf39/5fb2Vs7Pz6VQKMjr66tY1lR6vZ70en2ZTCZSq9UknU5r/vgX0E6nqyB/AAnl/v5erq6u5ObmRobD4Z+wmON7JpNR5ibHoYBGIhQANptyOB6P/RQsx5NwwE1VZhPySehojjySnuAYmYQyDNMhi4rFomru5ORE9vf3VXtYIpGQXC6nRQwFXAflQaxGc0Ed4mFJikjDRsD1cBuNhhYL//j4KA8PD9JsNrXiSIi5arXqy4zibgTkGCEhQj07O1N/enoqx8fH+h70aDISkI+Eg1F5NsB4pxDG+E5qVk5KGCALn56eVMQwoQCpVEouLy+VMYXh1BA2+YxkyO4AYuTM5NB4rF6v65i2FglIxdAZlUQ+sGBh0PONE2QaRmTI+Xze73tokJ5o+iHjvb09LRTAWxUFJrCEISckaMxjMKVYkYAc/E6no5Jot9tSKpWkUqlozsrlsrYuzjXfttIhIQOAAUB1MaqNUX3EzdE0DSOyKGiMpOON7sy9wYbMw24rHbKQ8Eg6zLis0OHFxYU2YpotY1j+tw7RmznPeIw5o0OKtlWVCcd0F3P7UXkKZW4/UrJVyOSHxKNDY/F4XEPd3d3VdzTJlWCagxPF0HTooPZgSUFgjzFnGIb2w033iXlY4HlzcT1PAXh3HFdBl0qw5R8VVUHLG1SyuAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node\"\n        title=\"node\"\n        src=\"/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png\"\n        srcset=\"/blog/static/624c9768d8888b109a4649298c0cb091/63868/node.png 250w,\n/blog/static/624c9768d8888b109a4649298c0cb091/0b533/node.png 500w,\n/blog/static/624c9768d8888b109a4649298c0cb091/29492/node.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>注意点</h2>\n<ol>\n<li>在浏览器或者node中某些代码的执行会导致event loop失效(停留在处理一个事件队列导致无法进入其他的事件队列的处理).比如浏览器中javascript的长时间执行会导致UI无法交互,node中process.nextTick的递归调用</li>\n</ol>\n<h2>相关资料</h2>\n<p><a href=\"https://tuobaye.com/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/\">通过microtasks和macrotasks看JavaScript异步任务执行顺序</a><br>\n<a href=\"http://docs.libuv.org/en/v1.x/design.html\">libuv Design overview</a>\n<a href=\"https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f\">How JavaScript works in browser and node?</a>\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&#x26;utm_medium=email\">Tasks, microtasks, queues and schedules</a><br>\n<a href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\">Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018</a>\n<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;t=55s\">菲利普·罗伯茨：到底什么是Event Loop呢？ | 欧洲 JSConf 2014</a></p>","fields":{"readingTime":{"text":"6 min read"}},"frontmatter":{"title":"事件循环","date":"2018-09-17","tags":"JavaScript","path":"/event-loop","top":null,"summary":null}}},{"node":{"id":"d9a2727c-f773-51a0-ae91-74deed50be73","html":"<h2>简介</h2>\n<p>最近在做需求的时候,需要在页面上实现进度条的展示.功能上很简单但是发现自己对XMLHttpRequest的相关事件并不是很熟练,下面把发送xhr过程中的相关过程和方法梳理下。最后给出简单的实现进度条展示的方案。</p>\n<h2>Ajax与XMLHttpRequest对象</h2>\n<p>Ajax(Asyncchronous JavaScript + XML)是利用XMLHttpRequest对象来实现动态网页的一种技术(方式).(本文所涉及到的API都是基于XMLHttpRequest Level 2)</p>\n<h2>使用</h2>\n<p>下面从一个例子逐步的展开XMLHttpRequest的基本使用方法</p>\n<pre><code>const xhr = new XMLHttpRequest();\nconst formdata = new FormData();\nformdata.append('name', 'haha');\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  // 超时处理\n  console.log('timeout');\n}\n// 设置返回类型 例如json blob等\nxhr.responseType = 'text'\n// xhr完成时候的回调\nxhr.onload = () => {\n  if(xhr.status >= 200 &#x26;&#x26; xhr.status &#x3C; 300 || xhr.status === 304) {\n    console.log(xhr.responseText);\n  } else {\n    console.log('something error');\n  }\n}\n// 数据上传的进度 默认每50ms触发\nxhr.upload.onprogress = (event) => { \n  console.log(event);\n}\n// 数据下载(响应)进度 \nxhr.onprogress = (event) => {\n  console.log(event);\n}\nxhr.open('POST', '/testurl', false);\n// 设置请求头\nxhr.setRequestHeader('Content-EnCoding', 'UTF-8');\nxhr.send(formdata);  \n</code></pre>\n<p>上面的例子创建了一个XMLHttpRequest对象,然后创建了一个表单类型的数据对象并对超时时间和超时时触发的回调函数进行的设置.对xhr完成时onload事件,数据上传的upload.onprogress事件和数据接收事件的回调进行了设置.最后调用open方法设置请求的方法和地址,最后通过send方法将创建的表单类型数据发送出去.下面从几个方面来拆分这个小例子来重新学习下XMLHttpRequest</p>\n<h3>xhr的阶段</h3>\n<p>xhr(XMLHttpRequest)有5个阶段,可以结合调用的方法和数据发送的过程状态来综合理解这5个阶段</p>\n<ul>\n<li>0 未启动 未调用open方法</li>\n<li>1 启动  调用open方法,未调用send方法</li>\n<li>2 发送  调用send方法，未接受收到响应</li>\n<li>3 接受  接受到部分响应</li>\n<li>4 完成  接受到全部的响应信息,可以在客户端对数据进行处理</li>\n</ul>\n<p>每当xhr的状态(readyState)变化都会触发onreadystatechange时间,因此可以通过onreadystatechange事件和readyState结合来完成数据的接收处理过程</p>\n<h3>xhr方法与属性</h3>\n<h4>open</h4>\n<p>open方法接受三个参数,顺序对应着请求的方法、地址、是否是同步请求</p>\n<ul>\n<li>当请求方法是GET的时候,可以通过在url中增加query的方法进行数据的发送并且在调用send方法时必须send(null). POST方法发送数据通过send函数 只有在调用send方法的时候才实际发送对应的xhr请求</li>\n<li>第三个参数指定请求时候是同步异步请求</li>\n</ul>\n<h4>setRequestHeader</h4>\n<p>设置请求头信息, 注意在这个方法必须在open和send之间调用</p>\n<h4>进度事件</h4>\n<ul>\n<li>loadstart 接收到响应第一个字节时触发</li>\n<li>onload 请求返回时候的监听函数,注意此时需要对相应的状态码,需要区分服务器的正常返回和错误返回做不同的处理</li>\n<li>abort 取消请求的发送</li>\n<li>onprogress upload.onprogress onprogress是对数据响应过程的监听,有个小点是请求响应头的content-length必须指定为非0,onprogress获取到的event事件的event.lengthComputable属性才是true. upload.onprogress事件是对上传数据过程的监听. 必须在调用open之前对onprogress和upload.onprogress添加事件处理程序否则无效</li>\n<li>error 请求发生错误的时候的监听函数</li>\n<li>loadend 当触发error load abort事件后触发</li>\n</ul>\n<h4>xhr.responseType xhr.response| xhr.responseXML | xhr.responseText</h4>\n<p>通过xhr.responseType的设置来获取不同的返回数据类型. 一个简单的例子,通常前端会通过href标签指定download属性来进行文件的下载并且可以通过download进行文件名的设置.这种方式在处理同源的文件是没有问题的,但是在处理不同域的文件的时候文件名字是无法重置的,只会是服务端存储的文件名,这个时候可以通过设置responseType为blob,生成File定义文件名并且进行文件的保存,可以使用<a href=\"https://github.com/eligrey/FileSaver.js\">fileSaver</a>这个库来实现这个功能.当然也可以通过借助后端设置响应头 content-disposition: attachment并且指定filename来实现文件的下载</p>\n<h4>实现进度条的思路</h4>\n<p>在实现进度条的时候其实用户感知的时数据上传和数据响应这两个过程,在实际操作的时候我发现upload.onprogress这个阶段是相对来说比较快的,也就是数据在服务端处理返回这个过程是整个请求用户感知最长的时间端.\n那么可以在upload.onprogress这个阶段去mock数据发送的过程.假设整体进度条是0-100.那么上传阶段完成是mock到50%,然后通过onprogress来完成后面50%的进度展示.更加细分的话是根据数据量来动态的切分上传阶段和数据接收阶段的比例来完成对用户接受更合理的进度展示.</p>\n<h2>跨域</h2>\n<p>默认情况下xhr只能访问相同域下的资源,通过CORS(跨源资源共享)可以访问到其他域的资源.CROS可以理解为浏览器和服务端的一种沟通方式来判断对应的请求是否成功</p>\n<h2>总结</h2>\n<p>作为一个web前端开发者离不开XMLHttpRequest的使用,以上通过对xhr基础的介绍和自己在项目中遇到的问题的来复习了下xhr,希望自己静下来把基础打牢.</p>","fields":{"readingTime":{"text":"8 min read"}},"frontmatter":{"title":"XMLHttpRequest之查缺补漏","date":"2018-08-12","tags":"JavaScript","path":"/xhr","top":null,"summary":null}}},{"node":{"id":"627714b4-755f-5558-b731-9a17d8bbe360","html":"<h2>简介</h2>\n<p>在看深入浅出node.js这本书的过程中,遇到了几个容易迷糊的概念,例如阻塞I/O、非阻塞I/O、同步、异步。下面主要从I/O模型上对上面的概念进行理解.</p>\n<h2>基本概念</h2>\n<p>I/O复用指的是内核具有当进程指定的I/O条件就位的时候通知进程的能力.</p>\n<h2>I/O模型</h2>\n<ol>\n<li>阻塞式I/O 在发生系统调用(I/O)的时候,对应的系统调用直到相应的操作完成或者错误时才返回.(例如在进行网络IO时,需要等待网络数据的就绪完成读取才会完成系统调用的返回)</li>\n<li>非阻塞式I/O 进程可以把一个套接字设置成非阻塞模式.这样当通过该套接字进行相关I/O操作并且需要进程进行等待的时候(例如通过网络读取数据,但是数据并没有就绪的时候), 内核不能将该进程投入睡眠而是返回一个错误标识(轮询)</li>\n<li>I/O复用模型 通过select或者poll来对多个相关的描述符进行监听(此时进程阻塞在select和 poll的调用上)),当描述符状态就绪的时候,返回可读条件然后在通过系统调用来完成对应的I/O操作</li>\n<li>信号驱动式I/O模型 通过开启套接字的信号驱动式I/O的功能并且添加相应的信号处理函数,当套接字准备好读取的时候,通过信号通知进程来完成响应的I/O操作.这种模式进程是不被阻塞的</li>\n<li>异步I/O模型  通告系统调用告知内核相应的操作,然后内核在完成相应的操作后会通知进程.这个过程中进程是不被阻塞的.</li>\n</ol>\n<h2>同步VS异步</h2>\n<p>同步,异步的概念区分上在于实际上发生系统I/O的时候,是否会阻塞进程.因此上面的前四种模式都是同步I/O,只有最后一种是异步I/O</p>\n<h2>select</h2>\n<p>int select(int maxfdpl, fd_set *readset, fd_set *writeset,fd_set *exceptset, const struct timeeval *timeout) 该函数允许进程指示内核等待多个事件中的任何一个发生,在其实一个或者多个事件发生后或者经历了一定时间后唤起进程.该函数的当有描述符就位的时候返回描述符的数目,超时返回0,若出错返回-1,下面对主要的参数进行分析</p>\n<ul>\n<li>timeout 告知内核等待所指定的描述符中任何一个就绪所花的时间.\n<ol>\n<li>当该timeout结构的代表的值均为0的时候,表示无需等待直接返回</li>\n<li>当设定一定时间的时候,表示当select返回的时候,不能超过该时间</li>\n<li>当设置为空指针的时候,表示select会一直等待直至有响应的描述符就绪</li>\n</ol>\n</li>\n<li>readset writeset  exceptset  表示让内核检测响应的读,写,异常描述符,当有响应的描述符就位时返回.</li>\n<li>maxfdpl 指定待测试的描述符的个数</li>\n</ul>\n<h2>node如何实现高性能的异步I/O</h2>\n<p>参考自己之前整理的一篇blog<a href=\"https://www.cnblogs.com/tiantianwaigong/p/6234961.html\">node的异步I/O</a></p>","fields":{"readingTime":{"text":"5 min read"}},"frontmatter":{"title":"I/O","date":"2018-07-29","tags":"计算机基础","path":"/computer-io","top":null,"summary":null}}}],"pathPrefix":"","first":false,"last":false,"index":14,"pageCount":16,"additionalContext":{"pageAllCount":91}}},
    "staticQueryHashes": []}