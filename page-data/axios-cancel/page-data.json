{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/axios-cancel",
    "result": {"data":{"markdownRemark":{"html":"<p>本文梳理axios中使用CancelToken来实现中断请求的源码实现.\r\n(CancelToken已经是deprecated, axios已支持AbortController实现相应的功能)</p>\n<h2>简单使用</h2>\n<pre><code>    const CancelToken = axios.CancelToken;\r\n    // 创建cancelToken\r\n    const source = CancelToken.source();\r\n\r\n    axios.get('/user/12345', {\r\n        // 请求的时候 传入创建的cancelToken\r\n        cancelToken: source.token\r\n    }).catch(function (thrown) {\r\n        if (axios.isCancel(thrown)) {\r\n            console.log('Request canceled', thrown.message);\r\n        } else {\r\n            // handle error\r\n        }\r\n    });\r\n\r\n\r\n    // 调用cancelToken的cancel方法 取消请求\r\n    source.cancel('Operation canceled by the user.');\n</code></pre>\n<p>上面是axios官网的上使用CancelToken的例子，可以看到通过将创建的cancelToken传入对应的请求对象，就实现了请求控制能力暴露给外部的能力。</p>\n<h2>源码分析</h2>\n<p>XMLHttpRequest支持使用abort方法实现请求的终止，axios底层封装了XMLHttpRequest来实现请求的处理，通过将调用abort方法的能力暴露给外部就实现了请求中断的控制。axios引入了cancelToken来实现这个过程的解耦。下面从具体的源码来看实现的过程</p>\n<h3>创建cancelToken对象</h3>\n<pre><code>// 调用source方法 生成CancelToken 导出token和取消请求的cancel方法\r\nCancelToken.source = function source() {\r\n    var cancel;\r\n    var token = new CancelToken(function executor(c) {\r\n        cancel = c;\r\n    });\r\n    return {\r\n        token: token,\r\n        cancel: cancel\r\n    };\r\n};\r\n\r\nfunction CancelToken(executor) {\r\n    if (typeof executor !== 'function') {\r\n        throw new TypeError('executor must be a function.');\r\n    }\r\n\r\n    var resolvePromise;\r\n    // 设置CancelToken的promise函数\r\n    this.promise = new Promise(function promiseExecutor(resolve) {\r\n        resolvePromise = resolve;\r\n    });\r\n\r\n    var token = this;\r\n    // cancel函数的执行逻辑 在调用cancel接口的时候 执行下面的逻辑\r\n    executor(function cancel(message) {\r\n        if (token.reason) {\r\n            // Cancellation has already been requested\r\n            return;\r\n        }\r\n\r\n        token.reason = new Cancel(message);\r\n        resolvePromise(token.reason);\r\n    });\r\n}\n</code></pre>\n<h3>cancelToken与XMLHttpRequest绑定</h3>\n<pre><code>    // 代码是axios封装XMLHttpRequest的部分逻辑\r\n    if (config.cancelToken) {\r\n        // 如果传入的配置有cancelToken 就调用cancelToken的promise方法 \r\n        // 通过promise实现控制流的流转 调用cancelToken方法的时候 将resolve时机暴露给cancelToken\r\n        // 调用cancelToken的cancel方法时,resolve了当前的promise，控制流程回到当前的后续流程，执行request.abort()从而完成请求的终止\r\n        config.cancelToken.promise.then(function onCanceled(cancel) {\r\n            if (!request) {\r\n                return;\r\n            }\r\n\r\n            request.abort();\r\n            reject(cancel);\r\n            // Clean up request\r\n            request = null;\r\n        });\r\n    }\r\n\r\n    if (!requestData) {\r\n        requestData = null;\r\n    }\r\n\r\n    // Send the request\r\n    request.send(requestData);\n</code></pre>\n<p>通过对实现流程的源码梳理，在类似的功能中可以利用promise来完成流程的控制。</p>","frontmatter":{"date":"2022-06-22","path":"/axios-cancel","title":"axios的cancel功能源码解读"}}},"pageContext":{"readingTime":"3 min read"}},
    "staticQueryHashes": []}