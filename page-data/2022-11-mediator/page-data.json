{"componentChunkName":"component---src-templates-post-js","path":"/2022-11-mediator","result":{"data":{"markdownRemark":{"html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\n    logMessage(user, message) {\n        const sender = user.getName();\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\n    }\n}\nclass User {\n    constructor(name, chatroom) {\n        this.name = name;\n        this.chatroom = chatroom;\n    }\n\n    getName() {\n        return this.name;\n    }\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\n    send(message) {\n        this.chatroom.logMessage(this, message);\n    }\n}\nconst chatroom = new ChatRoom();\nconst user1 = new User(\"John Doe\", chatroom);\nconst user2 = new User(\"Jane Doe\", chatroom);\nuser1.send(\"Hi there!\");\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\nconst books = new Map();\nconst createBook = (title, author, isbn) => {\n    const existingBook = books.has(isbn);\n    if (existingBook) {\n        // 已存在就查找返回\n        return books.get(isbn);\n    }\n    // 不存在新建返回\n    const book = new Book(title, author, isbn);\n    books.set(isbn, book);\n    return book;\n};\n//  存储书的列表\nconst bookList = [];\nconst addBook = (title, author, isbn, availability, sales) => {\n    const book = {\n        // 利用之前的共享对象创建新的实力\n        ...createBook(title, author, isbn),\n        sales,\n        availability,\n        isbn\n    };\n    bookList.push(book);\n    return book;\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\n    class OrderManager {\n        constructor() {\n            // 指令处理的对象\n            this.orders = [];\n        }\n\n        execute(command, ...args) {\n            // 匹配指令和指令处理的对象\n            return command.execute(this.orders, ...args);\n        }\n    }\n    // 指令创建类\n    class Command {\n        constructor(execute) {\n            this.execute = execute;\n        }\n    }\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\n    function PlaceOrderCommand(order, id) {\n        return new Command(orders => {\n            orders.push(id);\n            return `You have successfully ordered ${order} (${id})`;\n        });\n    }\n    const manager = new OrderManager();\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","frontmatter":{"date":"2022-11-04","path":"/2022-11-mediator","title":"5分钟速读系列-中介模式/享元模式/指令模式"}}},"pageContext":{"readingTime":"5 min read"}},"staticQueryHashes":[]}