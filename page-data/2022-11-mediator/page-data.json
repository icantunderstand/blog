{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/2022-11-mediator",
    "result": {"data":{"markdownRemark":{"html":"<p>这个系列是<a href=\"https://www.patterns.dev/\">Improve how you architect webapps</a>上文章的读书笔记。</p>\n<h2>中介模式</h2>\n<p>中介模式用中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。聊天室就是一个很好的中介模式，用户通过接口与聊天室对接就可以完成跟其他用户的聊天。</p>\n<pre><code>class ChatRoom {\r\n    // 中介者封装的对象交互逻辑，需要关注对交互逻辑的封装，减少复杂度\r\n    logMessage(user, message) {\r\n        const sender = user.getName();\r\n        console.log(`${new Date().toLocaleString()} [${sender}]: ${message}`);\r\n    }\r\n}\r\nclass User {\r\n    constructor(name, chatroom) {\r\n        this.name = name;\r\n        this.chatroom = chatroom;\r\n    }\r\n\r\n    getName() {\r\n        return this.name;\r\n    }\r\n    // 对象直接与中介对接，不需要感知交互对象的细节(交互细节封装到中介中)\r\n    send(message) {\r\n        this.chatroom.logMessage(this, message);\r\n    }\r\n}\r\nconst chatroom = new ChatRoom();\r\nconst user1 = new User(\"John Doe\", chatroom);\r\nconst user2 = new User(\"Jane Doe\", chatroom);\r\nuser1.send(\"Hi there!\");\r\nuser2.send(\"Hey!\");\n</code></pre>\n<p>前端的MVC/MVP/MVVM架构都可以理解是中介模式的一种扩展，中介实现UI与数据的交互逻辑(渲染/绑定等)</p>\n<h2>享元模式</h2>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象，能有效的避免大量相同对象创建的开销。这里以书店的书为例子，书店的书同一本有多本库存，在维护图书库存的时候，就可以通过享元模式利用之前创建的书实例来创建新的书实例。</p>\n<pre><code>// 存储享元模式的Map结构\r\nconst books = new Map();\r\nconst createBook = (title, author, isbn) => {\r\n    const existingBook = books.has(isbn);\r\n    if (existingBook) {\r\n        // 已存在就查找返回\r\n        return books.get(isbn);\r\n    }\r\n    // 不存在新建返回\r\n    const book = new Book(title, author, isbn);\r\n    books.set(isbn, book);\r\n    return book;\r\n};\r\n//  存储书的列表\r\nconst bookList = [];\r\nconst addBook = (title, author, isbn, availability, sales) => {\r\n    const book = {\r\n        // 利用之前的共享对象创建新的实力\r\n        ...createBook(title, author, isbn),\r\n        sales,\r\n        availability,\r\n        isbn\r\n    };\r\n    bookList.push(book);\r\n    return book;\r\n};\n</code></pre>\n<h3>享元模式跟单例模式的区别</h3>\n<ul>\n<li>单例模式确保某个类只有一个实例并且这个实例是全局访问的。单例模式是对象创建型模式</li>\n<li>享元模式中一个类可以创建多个对象，对象可以被多处代码引用共享</li>\n</ul>\n<h2>指令模式</h2>\n<p>指令模式是一种行为型模式，通过将处理逻辑封装到命令中传递给调用对象，调用对象负责匹配相应的处理对象并执行指令。指令模式的优点是解耦合，可以方便的在系统中加入新的指令。缺点是容易产生过多的命令类和重复代码。下面以订餐中订单、查询订单、取消订单的例子来解释指令模式。</p>\n<pre><code>    // 指令调用对象 负责为指令匹配需要处理的对象和执行指令\r\n    class OrderManager {\r\n        constructor() {\r\n            // 指令处理的对象\r\n            this.orders = [];\r\n        }\r\n\r\n        execute(command, ...args) {\r\n            // 匹配指令和指令处理的对象\r\n            return command.execute(this.orders, ...args);\r\n        }\r\n    }\r\n    // 指令创建类\r\n    class Command {\r\n        constructor(execute) {\r\n            this.execute = execute;\r\n        }\r\n    }\r\n    // 生成订单指令 预置了参数以便指令调用对象传入需要处理的对象\r\n    function PlaceOrderCommand(order, id) {\r\n        return new Command(orders => {\r\n            orders.push(id);\r\n            return `You have successfully ordered ${order} (${id})`;\r\n        });\r\n    }\r\n    const manager = new OrderManager();\r\n    manager.execute(new PlaceOrderCommand(\"Pad Thai\", \"1234\"));\n</code></pre>","frontmatter":{"date":"2022-11-04","path":"/2022-11-mediator","title":"5分钟速读系列-中介模式/享元模式/指令模式"}}},"pageContext":{"readingTime":"5 min read"}},
    "staticQueryHashes": []}