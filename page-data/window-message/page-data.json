{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/window-message",
    "result": {"data":{"markdownRemark":{"html":"<p>在浏览器中会涉及到一些跨页面的通信来完成一些特定的业务逻辑，下面梳理下一些跨页面通信相关的技术点。</p>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">postMessage</a></h2>\n<h3>postMessage用法解释</h3>\n<pre><code>otherWindow.postMessage(message, targetOrigin, [transfer]);\n</code></pre>\n<ul>\n<li>otherWindow 其他窗口的引用，比如iframe的contentWindow、执行window.open的返回的窗口对象、window.parent获取的父窗口对象。利用window.open返回的窗口对象可以实现跟新窗口的通信</li>\n<li>message 需要发送的数据，它会被结构化克隆算法序列化,无法被结构化克隆的数据会导致异常或者丢失属性，比如函数/原型链的丢失等</li>\n<li>targetOrigin 指定哪些源可以接收数据，这里就可以实现跨源的通信和安全控制</li>\n<li>transfer 可选的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Transferable_objects\">Transferable</a>对象</li>\n</ul>\n<h3>父子窗口通信</h3>\n<h4>父窗口发送消息给子窗口</h4>\n<p>在父窗口通过获取子iframe的conentWindow获取子窗口的引用，调用postMessage方法就可以实现对子窗口发送消息</p>\n<pre><code>// 父窗口发送消息\niframe.contentWindow.postMessage('message from parent', '*')\n\n// 子窗口监听消息\nwindow.addEventListener('message', function(event) {\n    // 处理接收到的消息\n    console.log(event.data);\n});\n</code></pre>\n<h4>子窗口发送消息给父窗口</h4>\n<p>子窗口通过window.parent获取父窗口的引用，调用postMesage方法就可以实现对父窗口发送消息</p>\n<pre><code>// 子窗口发送消息\nwindow.parent.postMessage('message from child', '*')\n\n // 父窗口监听消息\nwindow.addEventListener('message', function(event) {\n    // 处理接收到的消息\n    console.log(event.data);\n});\n</code></pre>\n<h2>浏览器不同tab间通信</h2>\n<p>跨tab通信有可能涉及到不同tab的数据同步逻辑，是一个相对常见的场景</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">localStorage</a></h3>\n<p>sessionStrage在chrome中打开同源的tab时候不会共享sessionStorage,所以主要介绍localStorage的实现方案.localStorage是在同域名下共享的浏览器存储，在同域的不同tab下监听localStorage的storage事件就可以实现跨tab通信</p>\n<pre><code>// 在第一个标签页中设置数据到 sessionStorage 中\nsessionStorage.setItem('message', 'Hello from Tab 1!');\n\n// 第二个标签页也打开当前页面 监听 storage 事件 接收其他标签页的数据\nwindow.addEventListener('storage', function(event) {\n    if (event.key === 'message') {\n        console.log('Received message in Tab 1:', event.newValue);\n    }\n});\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket\">WebSocket</a></h3>\n<p>这种方案依赖需要依赖服务服务端</p>\n<pre><code>// 建立websocke连接\nconst socket = new WebSocket(\"ws://localhost:8080\");\n\n// 连接建立，跟服务端发送事件，服务端对所有连接的websocket client广播事件\nsocket.addEventListener(\"open\", function (event) {\n    socket.send(\"Hello Server!\");\n});\n\n// 接收事件消息\nsocket.addEventListener(\"message\", function (event) {\n    console.log(\"Message from server \", event.data);\n});\n</code></pre>\n<p>使用websocket这种方案相对重，除非已有websocket长连接并且需要考虑websocket的断连造成的通信失败</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel\">BroadcastChannel</a></h3>\n<p>BroadcastChannel可以做到同源窗口间的通信能力.它基于发布-订阅的模式实现消息通知。</p>\n<pre><code>// 发送方逻辑\n// 创建BroadcastChannel 在实现跨tab通信的时候，创建BroadcastChannel的channelName需要是一个\nconst channel = new BroadcastChannel('myChannel');\n\n// 发送消息到其他标签页 \nchannel.postMessage('Hello from Tab 1!');\n\n// 监听方逻辑\n// 创建BroadcastChannel 与发送方channelName一致\nconst channe2 = new BroadcastChannel('myChannel');\n// 监听消息\nchanne2.onmessage = function(event) {\n    console.log('Received message in Tab 2:', event.data);\n};\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\">Service Worker</a>/<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker\">SharedWorker</a></h3>\n<p>Service Worker和SharedWorker方案类似，都是运行worker实现消息通信，下面主要举例SharedWorker的实现方案。</p>\n<h4>定义worker脚本</h4>\n<pre><code>// shared-worker.js\n// 定义一个变量来保存所有连接的客户端\nlet clients = [];\n\n// 监听连接事件\nself.addEventListener('connect', function(event) {\n    // 获取与该连接关联的端口\n    const port = event.ports[0];\n\n    // 将端口添加到客户端列表中\n    clients.push(port);\n\n    // 监听来自客户端的消息\n    port.addEventListener('message', function(event) {\n        // 广播消息给所有其他客户端\n        clients.forEach(function(client) {\n        if (client !== port) {\n            client.postMessage(event.data);\n        }\n        });\n    });\n\n    // 监听客户端关闭事件\n    port.addEventListener('close', function() {\n        // 从客户端列表中移除关闭的端口\n        clients = clients.filter(function(client) {\n        return client !== port;\n        });\n    });\n\n    // 向客户端发送连接成功消息\n    port.postMessage('Connected to SharedWorker.');\n});\n</code></pre>\n<h4>页面中加载脚本</h4>\n<pre><code>    // 在你的网页中连接到 SharedWorker\n    const worker = new SharedWorker('shared-worker.js');\n\n    // 监听连接成功事件\n    worker.port.addEventListener('message', function(event) {\n        console.log('Received message:', event.data);\n    });\n</code></pre>\n<h3>cookies</h3>\n<p>这种方案不大推荐，涉及到js可以通过脚本对cookies进行读写</p>","frontmatter":{"date":"2024-04-05","path":"/window-message","title":"聊聊页面间的通信机制"}}},"pageContext":{"readingTime":"6 min read"}},
    "staticQueryHashes": []}