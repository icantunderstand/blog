<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/blog/styles.4705bef5c6bce8450df3.css" data-identity="gatsby-global-css">.blog-post{width:100%}.blog-post-content{margin:0 auto;max-width:960px;padding:0 1.0875rem 1.45rem}.blog-footer{align-items:center;display:flex;flex-direction:column;justify-content:flex-start;margin-bottom:30px}.paginate-container{align-items:center;display:flex;flex-direction:row;flex-wrap:wrap;justify-content:center;margin-top:20px;padding-bottom:10px}.paginate-item,.top-post{margin-left:10px}.top-post{color:#1e80ff;display:inline-block;font-size:15px}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;box-sizing:border-box;font:112.5%/1.45em georgia,serif,sans-serif;overflow-y:scroll}body{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;word-wrap:break-word;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:georgia,serif;font-kerning:normal;font-weight:400;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent;text-decoration:none}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help;text-decoration:none}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}img{border-style:none;margin:0 0 1.45rem;max-width:100%;padding:0}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}hr{background:rgba(0,0,0,.2);border:none;box-sizing:content-box;height:1px;margin:0 0 calc(1.45rem - 1px);overflow:visible;padding:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*,:after,:before{box-sizing:inherit}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem}ol,p,ul{padding:0}p,pre{margin:0 0 1.45rem}pre{word-wrap:normal;background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;overflow:auto;padding:1.45rem}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;margin:0 0 1.45rem;padding:0;width:100%}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,noscript{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}td,th,thead{text-align:left}td,th{font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}</style><meta name="generator" content="Gatsby 3.15.0"/><style data-emotion="mantine "></style><title data-react-helmet="true"></title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="/blog/favicon-32x32.png?v=1a4023285f20ec8ca43a96875f92c5b2" type="image/png"/><link rel="manifest" href="/blog/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/blog/icons/icon-48x48.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="72x72" href="/blog/icons/icon-72x72.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="96x96" href="/blog/icons/icon-96x96.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="144x144" href="/blog/icons/icon-144x144.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="192x192" href="/blog/icons/icon-192x192.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="256x256" href="/blog/icons/icon-256x256.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="384x384" href="/blog/icons/icon-384x384.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link rel="apple-touch-icon" sizes="512x512" href="/blog/icons/icon-512x512.png?v=1a4023285f20ec8ca43a96875f92c5b2"/><link as="script" rel="preload" href="/blog/webpack-runtime-af6ac126a20e6b95bddb.js"/><link as="script" rel="preload" href="/blog/framework-30c1cbcd4309881b11c5.js"/><link as="script" rel="preload" href="/blog/app-4b62d492ee1645380565.js"/><link as="script" rel="preload" href="/blog/ef6529d7-5809e26836cfb9703dbc.js"/><link as="script" rel="preload" href="/blog/a26abbfb03f25b9cd2b611d1d937ab5e796b3999-976c7162f0c1b8304de6.js"/><link as="script" rel="preload" href="/blog/6ba5cc0c8669d68fb0f844125a981d8f12367a97-f9ea3b3dbbe28c42596b.js"/><link as="script" rel="preload" href="/blog/component---src-templates-post-js-3bee0697db9b9af656a6.js"/><link as="fetch" rel="preload" href="/blog/page-data/base-js-summary/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="mantine-AppShell-root mantine-1272lc7" data-barba="wrapper"><header class="mantine-Header-root mantine-1elgxm6"><a href="/blog/"><div class="mantine-1ln4pgh"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-ghost" width="30" height="30" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 11a7 7 0 0 1 14 0v7a1.78 1.78 0 0 1 -3.1 1.4a1.65 1.65 0 0 0 -2.6 0a1.65 1.65 0 0 1 -2.6 0a1.65 1.65 0 0 0 -2.6 0a1.78 1.78 0 0 1 -3.1 -1.4v-7"></path><line x1="10" y1="10" x2="10.01" y2="10"></line><line x1="14" y1="10" x2="14.01" y2="10"></line><path d="M10 14a3.5 3.5 0 0 0 4 0"></path></svg><div class="mantine-Text-root mantine-1pbxw0k">noodles的笔记本</div></div></a><style data-emotion="css-global nn3xf4">:root{--mantine-header-height:70px;}</style></header><div class="mantine-ibbm6b mantine-AppShell-body"><main class="mantine-d5iwcx mantine-AppShell-main"><div class="mantine-1w0809u"><div class="blog-post"><h1 class="blog-post-content">JavaScript基础梳理</h1><div class="blog-post-content">24 min read</div><div class="blog-post-content"><h2><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">AsyncFunction</a></h2>
<p>在项目中需要根据配置生成Async Function来保证配置的串行执行，Async Function在创建的时候只能访问到全局作用域的变量，需要注意。在node中可以通过<a href="https://github.com/nodejs/node/issues/9474">vm.runInNewContext</a>来解决。</p>
<h2>变量</h2>
<p>在javascript中声明变量有下面的几种方式: var  / const(let)  下面来梳理下这几种声明变量方式的区别。</p>
<table>
<thead>
<tr>
<th>声明方式</th>
<th>声明提升</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>let/const</td>
<td>Temporal Dead Zone</td>
<td>块级作用域</td>
</tr>
<tr>
<td>var</td>
<td>提升</td>
<td>函数作用域, 进入到声明该变量的函数作用域分配空间并且初始化值为undefined,执行到赋值语句后进行赋值</td>
</tr>
</tbody>
</table>
<h3>var</h3>
<p>在进入声明该变量的函数作用域的时候,会为其分配空间并且初始化值为undefined,在执行到对var赋值的语句的时候会对该变量进行赋值(如果没有赋值就是undefined)</p>
<h3>let</h3>
<p>在进入声明该变量的块级作用域的时候,会为其分配空间此时这个变量是未初始化的(引用一个未初始化的变量会导致引用错误),到达对该变量的赋值语句的时候进行变量的赋值(否则为undefined)。</p>
<h3>const</h3>
<p>跟let的行为类似,但是需要进行初始化的值(不允许修改指向)</p>
<p>下面是一些简单的例子来帮助理解上面的点</p>
<pre><code>let tmp = true;
if (true) {
    // 引用未初始化的变量引用错误
    //  console.log(tmp); // ReferenceError

    let tmp; // 初始化为undefined
    console.log(tmp); // undefined

    tmp = 123;
    console.log(tmp); // 123
}
console.log(tmp);// true

if (true) {
  const func = function () {
    console.log(myVar); // 3
  };
  let myVar = 3; 
  func();  
}
</code></pre>
<p>在循环中var和let/const的表现</p>
<pre><code>const arr = [];
for (var i=0; i &#x3C; 3; i++) {
    arr.push(() => i);
}
arr.map(x => x()); // [3,3,3]  每个变量都指向一个绑定i 所以都为3

const arr = [];
for (var i of [0, 1, 2]) {
    arr.push(() => i);
}
arr.map(x => x()); // [2,2,2]

const arr = [];
for (let i=0; i &#x3C; 3; i++) {
    arr.push(() => i);
}
arr.map(x => x()); // [0,1,2]   每次为let创建一个当前值的绑定 所以为[0,1,2]

const arr = [];
for (const i of [0, 1, 2]) {
    arr.push(() => i);
}
arr.map(x => x()); // [0,1,2]
</code></pre>
<h3>var和let声明变量对参数的影响</h3>
<table>
<thead>
<tr>
<th>声明方式</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>声明的变量会覆盖函数的参数</td>
</tr>
<tr>
<td>let/const</td>
<td>重复定义</td>
</tr>
</tbody>
</table>
<h4>理解默认参数的行为</h4>
<p>默认参数可以理解成let的行为  默认参数的访问范围是与函数体内部相隔离开的,只能访问到外部的变量</p>
<pre><code>// OK: `y` accesses `x` after it has been declared
function foo(x=1, y=x) {
    return [x, y];
}
foo(); // [1,1]

// 在初始化x=y的时候 y处于TDZ 出现引用错误
function bar(x=y, y=2) {
    return [x, y];
}
bar(); // ReferenceError


const foo = 'outer';
function bar(func = x => foo) {
    const foo = 'inner';
    console.log(func()); // outer
}
bar();  //  如果在这个例子的外部不存在foo 会引用错误

function noParameter() {
    throw new Error('no parameter');
}
function test(a = noParameter()) {
    return a;
}  // 使用默认参数来做参数的校验
</code></pre>
<h2>解构</h2>
<p>解构是跟变量的操作关联到一起的,主要用于变量的声明,赋值,函数参数的定义以及提供默认值。对象解构的时候,会把右边的操作值转化成对象。数组解构的时候相当于调用数组的迭代器实现</p>
<pre><code>const { length } = 'aaa';
console.log(length) // 3
const [x, y] = new Set([1,2]);
console.log(x,y); // 1 2  
</code></pre>
<p>在对数组进行解构的时候,还可以通过越过某些数组项或者通过剩余参数获取数组后面的值</p>
<pre><code>const [,, x, y] = ['a', 'b', 'c', 'd']; // x = 'c'; y = 'd'
const [x,...y] = [1,2,3] // x 1 y [2,3]

const num = [1,2,3];
const b = [];
b.push(...num); // 扩展符
</code></pre>
<p>也可以通过解构来进行赋值(解构的声明和赋值不能同步进行并且解构的赋值需要在外边包上括号)</p>
<pre><code>const arr = [];
({ bar: arr[0] } = { bar: true });
console.log(arr); // [true]  
</code></pre>
<h2>ES6 模块</h2>
<p>ES6模块本质上是一种规定静态化的加载和导出代码的方式,通过编译时加载使基于代码的静态分析成为可能(webapck中的tree Shaking).CommonJs的模块(运行时加载)就是对象.</p>
<h3>ES6模块的特点和CommonJs的对比</h3>
<p>不能动态的引入并且引入是有提升的</p>
<pre><code>// 不能动态的引入
if (Math.random()) {
  import 'foo'; // SyntaxError
}  
{
  import 'foo'; // SyntaxError
}
// 引入的提升
foo();
import { foo } from 'my_module';
</code></pre>
<p>引入是只读的引用</p>
<pre><code>// a.js 
export let a = 100;
export const count = () => {
  a++;
}
// b.js
import { a, count } from './a.js'
console.log(a); // 100
count();
console.log(a); // 101
a = 100; // error  a是只读的

// CommonJs是值的复制,相当于修改一个值.
</code></pre>
<p>ES6的模块可以导出单个值,CommonJS必须导出一个对象.ES6的引入是只读的引用,CommonJs的引入对于基本类型是值的复制,复杂类型是引用.</p>
<pre><code>// a.js  CommonJS值拷贝的例子
let a = 100;
module.exports = { 
  a,
  count: () => { a++ },
};
// b.js
let { a, count } = require('./a.js')
console.log(a); //100
count();
console.log(a); //100
a++; // 相当于对本模块的a变量进行了赋值
console.log(a);  // 101
const b = require('./a.js'); // 会使用第一次require的结果
console.log(b.a);  // 100

// a.js  CommonJs 引用的例子
let a = {
  name: 'haha',
};
module.exports = { 
  a,
  setStr: (str) => { a.name = str; },
};
// b.js  
let { a, setStr } = require('./a.js')
console.log(a); // { name: 'haha' }
setStr('ss');
console.log(a); // { name: 'ss' }
a.name = 100;
console.log(a);  // { name: 100 }
const b = require('./a.js');  // 仍然使用的是第一次的缓存结果 但是由于引用的设置 导致原来的值被修改了
console.log(b);  // { a: { name: 100 }, setStr: function() {} }
</code></pre>
<p>CommonJs循环加载时,属于加载时执行.即脚本代码在require的时候,就会全部执行.一旦出现某个模块被循环加载,就只输出已经执行的部分,还未执行的部分不会输出.ES6模块属于动态只读引用. CommonJs在引用同一个模块的时候存在会使用第一次的缓存.</p>
<pre><code>// b.js
exports.done = false
let a = require('./a.js')
console.log('b.js-1', a.done)
exports.done = true
console.log('b.js-2', '执行完毕')
// a.js
exports.done = false
let b = require('./b.js')
console.log('a.js-1', b.done)
exports.done = true
console.log('a.js-2', '执行完毕')
// c.js
let a = require('./a.js')
let b = require('./b.js')
console.log('c.js-1', '执行完毕', a.done, b.done)

输出:
node c.js
b.js-1 false
b.js-2 执行完毕
a.js-1 true
a.js-2 执行完毕
c.js-1 执行完毕 true true

// ES6 循环依赖 a.js
import { bar } from './b.js';
bar(); // 'bar'
export function foo() {
    console.log('foo');
}
bar(); // 'bar'

// b.js
import {foo} from './a.js'; 
export function bar() {
   console.log('bar');
}

// CommonJs循环依赖  a.js
const { bar } = require('./b.js');
module.exports = {
  test: 1,
}
// b.js
const { test } = require('./a.js')
console.log(test); // undefined
</code></pre>
<h3>动态引入</h3>
<p>可以通过按需引入模块来优化首屏代体积</p>
<pre><code>    import("module").then(module => {
        module.default();
        module.namedExport();
    });

    // Or with async/await
    (async () => {
        const module = await import("module");
        module.default();
        module.namedExport();
    })();
</code></pre>
<h2>iterator(迭代器)</h2>
<p>在ES6中的可以使用数组解构,for of等语句遍历数组、Map、Set是因为在ES6中默认为这些结构创建了[Symbol.iterator]方法.通过这个方法的调用返回一个可以遍历该数据结构的对象(iterator),通过这个对象来遍历数据结构的属性.
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 883px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 26.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAy0lEQVQY05VQy4qEQAyc//8eb3rwrBcVRXwrKr4QFRVBxBoqyy64zGUCRSfV6UqnXgAwjiMcx0HTNCxx3/dHMKqqgud5WNf10Xtdl5wvksMwwDRN2LaNMAwRBAGSJEHf9/gfZVnCsiwRzrIMaZoK4jjGtm0/gl3XYZ5nHMch5L7vaNsW53liWRZ5QJ61YRjQdR1RFAnv+z7quv77rQiSVBRFGjVNg6qqcF1XBAgO4koEbaFQnucoikJyDn0I0g9ech2C+TRN+CZ+PX4DVbt5trPU9noAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="iterator"
        title="iterator"
        src="/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png"
        srcset="/blog/static/0bcb228576a7ca1967151733aba51136/63868/iterator.png 250w,
/blog/static/0bcb228576a7ca1967151733aba51136/0b533/iterator.png 500w,
/blog/static/0bcb228576a7ca1967151733aba51136/fe9f1/iterator.png 883w"
        sizes="(max-width: 883px) 100vw, 883px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
        decoding="async"
      />
  </a>
    </span></p>
<pre><code>const iterable = {
  [Symbol.iterator]() {
      let step = 0;
      const iterator = {
          // iterators that are iterable
          [Symbol.iterator]() {
            return this;
          }
          next() {
              if (step &#x3C;= 2) { step++;}
              switch (step) {
                  case 1:
                      return { value: 'hello', done: false };
                  case 2:
                      return { value: 'world', done: false };
                  default:
                      // done表示是否到尾
                      return { value: undefined, done: true };
              }
          }
      };
      return iterator;
  }
};
const iterator = iterable[Symbol.iterator]();
iterator.next();  // {  done: false, value: 'hello' }
iterator === iterator[Symbol.iterator]() // true
iterator.next();  // { done: false, value: 'world' }
</code></pre>
<h2>generator</h2>
<p>生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。</p>
<h3>generator方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Generator.prototype.next(value)</td>
<td>返回一个{ done: true/false, value: 执行结果 }的对象,value是当次执行的入参</td>
</tr>
<tr>
<td>Generator.prototype.return(value)</td>
<td>返回给定的value值并结束生成器</td>
</tr>
<tr>
<td>Generator.prototype.throw(exception)</td>
<td>向生成器抛出异常，并恢复生成器的执行</td>
</tr>
</tbody>
</table>
<p>生成器函数有如下特性:</p>
<ol>
<li>
<p>当一个generator函数被调用，函数体内代码并不立即执行。它返回一个遵循了迭代器协议的迭代器对象:它有next方法.</p>
</li>
<li>
<p>执行生成器函数体内代码的唯一方法就是在返回的迭代器对象上调用next方法.每一次调用next，函数体内代码就执行到一个yield表达式处，这个表达式的右值赋值给迭代器。</p>
</li>
<li>
<p>next方法也可以接受参数，使用参数调用将会用参数值替换上一条yield表达式的左值，然后执行并返回当前yield表达式的右值</p>
<pre><code> function* func() {
     const y = yield 1;
     yield 2 + y;
 }
 const generator = func();
 generator.next() // { value: 1, done: false }
 generator.next(100) // { value: 102, done: false }  
</code></pre>
</li>
</ol>
<h2>async function</h2>
<p>async function是ES7提出的对异步调用的一种解决方案.通常可以通过下面的方式生成async function</p>
<pre><code>async function foo() {
}
const a = async function() {}
let obj = { async foo() { return 1; }}
const b = async () => { return 1 }
</code></pre>
<p>async函数执行结果返回<strong>promise</strong>.在async函数体内可以使用await来等待一个promise的状态变成settled(fulfilled or rejected)</p>
<pre><code>async function foo() {
  console.log('async func');
  // await已经是一个微任务  
  const ret = await 1
  // const ret = await Promise.resove(1)
  return ret;
}
foo().then(value => {
  console.log(value)
})
console.log('main')
// 上面代码的输出是  async func  main 1
</code></pre>
<h3>通过generator + promise来模拟async function</h3>
<p>async function可以通过generator + promise来模拟。</p>
<pre><code>function spawn(genF) {
  return new Promise((resolve, reject) => {
    const itr = genF()
    function step(nextFn) {
        let next;
        try {
            next = nextFn()
        } catch(e) {
            return reject(e)
        }
        if(next.done) {
            return resolve(next.value)
        }
        Promise.resolve(next.value).then(function(v) {
            step(function(){ return itr.next(v) });
        }, function(v) {
            step(function() { return itr.throw(v); })
        })
    }
    step(function() { return itr.next(undefined); })
  })
}
</code></pre>
<h2>Reflect</h2>
<p>Reflect是一个内置对象，提供了一些方法来完成javascript的操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reflect.apply(target, thisArg, args )</td>
<td>用户给函数绑定this并执行</td>
</tr>
<tr>
<td>Reflect.get(target, name, receiver)</td>
<td>返回target上的name属性，没有undefined，如果name在target上设置了getter，则读取函数的this绑定receiver</td>
</tr>
<tr>
<td>Reflect.set(target, name, value, receiver)</td>
<td>设置target对象的name属性的值为value, 如果name属性有setter函数，则setter函数的this绑定receiver</td>
</tr>
<tr>
<td>Reflect.has(obj,name)</td>
<td>判断对象上是否有对应的属性 相当于 name in obj</td>
</tr>
<tr>
<td>Reflect.deleteProperty(obj,name)</td>
<td>删除对象的属性 相当于 delete obj[name]</td>
</tr>
<tr>
<td>Reflect.construct(target, args)</td>
<td>target是对象的构造函数，args是参数数组，相当于new target(...args)</td>
</tr>
<tr>
<td>Reflect.getPrototypeOf(obj)</td>
<td>返回对象的__proto__属性, 相当于Object.getPrototypeof(obj)</td>
</tr>
<tr>
<td>Reflect.setPrototypeOf(obj,newProto)</td>
<td>设置对象的原型， 相当于Object.setPrototypeOf(obj, newProto)</td>
</tr>
<tr>
<td>Reflect.defineProperty(target,propertyKey, attributes)</td>
<td>相当于Object.defineProperty, 定义对象的属性</td>
</tr>
</tbody>
</table>
<pre><code>const myObject = {
    foo: 1,
    get name() {
        return this.name
    }
}
const test = {
    name: 'haha'
}
Reflect.get(myObject, 'name', test) // haha 
</code></pre>
<h2>Set和Map</h2>
<h3>Set</h3>
<p>Set对象是值的集合，可以按照拆入的顺序迭代它的元素且Set中的元素是唯一的。</p>
<table>
<thead>
<tr>
<th>方法(属性)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set.prototype.size</td>
<td>返回Set对象中的值的个数</td>
</tr>
<tr>
<td>Set.prototype.add(value)</td>
<td>在set对象尾部添加一个元素，<strong>返回该set对象</strong></td>
</tr>
<tr>
<td>Set.prototype.clear()</td>
<td>移除set对象内的所有元素</td>
</tr>
<tr>
<td>Set.prototype.delete(value)</td>
<td>移除set中与这个值相等的元素</td>
</tr>
<tr>
<td>Set.prototype.has(value)</td>
<td>返回一个布尔值, 表示该值是否在set中</td>
</tr>
<tr>
<td>Set.prototype.keys()</td>
<td>返回键值的遍历器 <strong>遍历顺序是插入顺序</strong></td>
</tr>
<tr>
<td>Set.prototype.values()</td>
<td>返回键值的遍历器</td>
</tr>
<tr>
<td>Set.prototype.entries()</td>
<td>返回键值对的遍历器</td>
</tr>
<tr>
<td>Set.prototype.forEach()</td>
<td>使用回调函数遍历每个成员</td>
</tr>
</tbody>
</table>
<h3>WeakSet</h3>
<p>WeakSet与Set类似</p>
<ol>
<li>WeakSet的成员只能是对象不能是其他类型的值。</li>
<li>WeakSet对对象的引用是弱引用,不能阻止垃圾回收机制。</li>
<li>WeakSet不支持遍历</li>
</ol>
<table>
<thead>
<tr>
<th>方法(属性)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>WeakSet.prototype.add(value)</td>
<td>在WeakSet对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>
</tr>
<tr>
<td>WeakSet.prototype.delete(value)</td>
<td>移除WeakSet对象内的所有元素</td>
</tr>
<tr>
<td>WeakSet.prototype.has(value)</td>
<td>返回一个布尔值, 表示该值是否在WeakSet中</td>
</tr>
</tbody>
</table>
<h3>Map</h3>
<p>Map对象可以保存键值对并且能够记住键的原始插入顺序，任何值(对象或者原始值)都可以作为Map的一个键或者值。在频繁删除键值或者对键值对的顺序有要求的场景，使用Map对象更加合适。</p>
<table>
<thead>
<tr>
<th>方法(属性)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map(new Map(args))</td>
<td>构造函数, 具有Iterator接口且每个成员都是一个双元素数组的数据结构可以作为Map的构造函数参数</td>
</tr>
<tr>
<td>Map.prototype.size</td>
<td>返回Map对象中的值的个数</td>
</tr>
<tr>
<td>Map.prototype.set(key,value)</td>
<td>设置键名对应的键值为value(存在键名则更新键值), <strong>返回当前的Map对象</strong></td>
</tr>
<tr>
<td>Map.prototype.get(key)</td>
<td>读取对应key的键值，没有key返回undefined</td>
</tr>
<tr>
<td>Map.prototype.has(key)</td>
<td>返回布尔值，判断该键是否存在Map中</td>
</tr>
<tr>
<td>Map.prototype.delete(key)</td>
<td>如果Map对象中存在该元素，则移除它并返回true否则返回false</td>
</tr>
<tr>
<td>Map.prototype.clear()</td>
<td>移除Map对象内的所有元素</td>
</tr>
<tr>
<td>Map.prototype.keys()</td>
<td>返回键名的遍历器<strong>遍历顺序是插入顺序</strong></td>
</tr>
<tr>
<td>Map.prototype.values()</td>
<td>返回键值的遍历器</td>
</tr>
<tr>
<td>Map.prototype.entries()</td>
<td>返回键值对的遍历器</td>
</tr>
<tr>
<td>Map.prototype.forEach()</td>
<td>使用回调函数遍历每个成员</td>
</tr>
</tbody>
</table>
<h3>WeakMap</h3>
<p>WeakMap与Map类似。</p>
<ol>
<li>WeakMap的键值只能是对象不能是其他类型的值。</li>
<li>WeakMap对对象的引用是弱引用,不能阻止垃圾回收机制。</li>
<li>WeakMap不支持遍历</li>
</ol>
<table>
<thead>
<tr>
<th>方法(属性)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>WeakMap.prototype.set(key,value)</td>
<td>在WeakMap对象尾部添加一个元素，<strong>返回该WeakSet对象</strong></td>
</tr>
<tr>
<td>WeakMap.prototype.delete(value)</td>
<td>移除WeakMap对象内的所有元素</td>
</tr>
<tr>
<td>WeakMap.prototype.has(value)</td>
<td>返回一个布尔值, 表示该值是否在WeakMap中</td>
</tr>
<tr>
<td>WeakMap.prototype.get(key)</td>
<td>读取对应key的键值，没有key返回undefined</td>
</tr>
</tbody>
</table>
<h2>node中模块加载机制</h2>
<ul>
<li>
<p>路径解析(Resolution) 根据模块标识找出对应模块入口的绝对路径</p>
<ul>
<li>如果是文件，会自动按照后缀.js、.json、.node进行文件后缀补齐</li>
<li>如果是目录 会查找目录下的package.json,读取main字段并加载指定的模块，如果没有package.json就尝试加载目录下的index.js、index.json、index.node</li>
<li>非文件路径 非原生模块会按照node_modules目录逐级查找，在查找全局目录</li>
</ul>
</li>
<li>
<p>加载(Loading) 如果是JSON或者js文件,将文件读入内存。如果是内置原生模块将其动态链接库加载动当前Node.js进程</p>
</li>
<li>
<p>包装(Wrapping) 将文件内容包装进一个函数，建立模块作用域，将exports, require, module等作为参数注入</p>
<pre><code>  (function(exports, require, module, __filename, __dirname) {
      // Module code actually lives in here
  });
</code></pre>
</li>
<li>
<p>执行(Evaluation) 传入参数，执行包装得到的参数</p>
</li>
<li>
<p>缓存(Caching) 函数执行完毕后，将module缓存起来，并将module.exports作为require的返回值</p>
</li>
</ul>
<h2>node部署实现大规模并发处理</h2>
<ul>
<li>容器化技术 使用Docker或者Kubernetes部署多个Node.js实例</li>
<li>使用反向代理技术将请求转发给多个Node.js实例</li>
<li>使用PM2(cluster)管理node.js进程的启动, PM2会创建多个子进程来运行同一个应用程序的多个实现，每个子进程会监听相同的端口</li>
</ul>
<h2>monorepo</h2>
<p>monorepo是一种单一仓库的软件开发结构，通过将相同业务的多个项目集合一个项目中进行版本控制。主要解决了以下的问题:</p>
<ul>
<li>代码共享 对于跨项目的共享模块、组件、库有好处</li>
<li>一致的构建和部署 monorepo为项目提供一致的构建和部署流程，减少项目之间的差异</li>
<li>统一的版本控制 所用项目共享相同的版本控制历史，使得跨项目的版本控制更好管理能统一的进行版本回退等</li>
<li>原子提交 提交是原子性的，避免了跨项目的不一致性</li>
<li>协同开发 开发者可以很容易的访问和修改整个仓库的代码，提供了工作的效率</li>
<li>统一的依赖管理 monorepo允许仓库级别的管理依赖项，确保所有版本使用相同的依赖项版本</li>
<li>一体化测试 可以实施一体化测试</li>
</ul>
<h2>webpack模块联邦</h2>
<p>模块联邦用于解决模块的共享和加载的问题。它允许你在不同的webpack构建之间共享JavaScript模块，相比npm包管理的方式它实现更加灵活的代码共享方式，可以实现动态加载并减少的依赖管理等问题</p>
<pre><code>// 主应用
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
    // ...
    plugins: [
        new ModuleFederationPlugin({
            name: "mainApp", // 主应用的名字
            remotes: { // 远程模块配置 名称入口文件
                remoteApp: "remoteApp@http://localhost:3001/remoteEntry.js",
            },
            // 共享模块
            shared: ["lodash"],
        }),
    ],
};

// 远程应用
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
    // ...
    plugins: [
        new ModuleFederationPlugin({
            name: "remoteApp", // 远程应用的名字
            filename: "remoteEntry.js", // 远程应用的入口文件
            exposes: { // 指定要共享出去的模块
                "./Button": "./src/Button",
            },
            // 共享模块
            shared: ["lodash"],
        }),
    ],
};

// 主应用中的代码 动态加载远程模块

const remoteApp = import("remoteApp/Button");

remoteApp.then((Button) => {
    // 使用远程模块
    const button = new Button();
    document.body.appendChild(button);
});
</code></pre>
<h3>webpack模块联邦的优势</h3>
<ul>
<li>动态加载模块 模块联邦可以在运行时加载模块，从而实现更加灵活的模块加载</li>
<li>模块共享 不需要通过npm管理依赖项，降级了项目依赖关系的复杂性同时提高的构建效率</li>
<li>独立部署和自治  不同应用可独立部署和自治</li>
<li>可细粒度控制 选择性的共享模块</li>
</ul>
<h2>babel编译React代码生成AST的过程</h2>
<ul>
<li>词法分析(Lexical Analysis) 将源代码字符串分解成一系列令牌，包括JSX语法中的标签、属性等</li>
<li>语法分析(Parsing) 将令牌序列转换成抽象语法树(AST),其中每个节点代表JSX的元素属性等</li>
<li>转换(Transformation) 对AST进行遍历修改，将JSX语法转换成对应的JavaScript代码(这里可以添加babel插件,  @babel/preset-env  @babel/preset-react @babel/plugin-transform-runtime)</li>
<li>生成(Code Generation) 将修改后的AST装换成最终的JavaScript代码</li>
</ul>
<h2>造成内存泄露一些情况</h2>
<ul>
<li>
<p>未释放的事件监听器 当DOM元素被删除和替换时，未移除相应事件的监听器，导致相应的DOM节点无法回收</p>
<pre><code>  var element = document.getElementById('example');
  element.addEventListener('click', function() {
      // 一些处理代码
  });

  // 移除DOM元素
  document.body.removeChild(element);
</code></pre>
</li>
<li>
<p>循环引用 两个对象相互引用，当对象不在使用的时候但是他们的引用关系让JavaScript引擎认为他们仍在使用中，所以不会被回收</p>
<pre><code>  let obj1 = {};
  let obj2 = {};

  obj1.ref = obj2;
  obj2.ref = obj1;

  // 解除引用
  obj1 = null;
  obj2 = null;
</code></pre>
</li>
<li>
<p>定时器/IntersectionObserver/ResizeObserver/MutationObserver 等在不需要的时候 需要清除</p>
</li>
<li>
<p>Promises，Observables，EventEmitters 设置监听器的模型都有可能造成内存泄露</p>
</li>
<li>
<p>全局对象存储 相当于不断增加内存</p>
</li>
<li>
<p>新增DOM结构</p>
</li>
</ul>
<h2>参考</h2>
<p><a href="http://exploringjs.com/es2016-es2017/ch_async-functions.html">Async functions</a><br>
<a href="https://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">async函数的实现原理</a><br>
<a href="http://www.ayqy.net/blog/node%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">Node模块加载机制</a></p></div><div class="blog-footer"><div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:344px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;344&#x27; width=&#x27;344&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="/blog/static/fea72b8bb6c1352a510a256c539d4702/ff4dd/qrcode.webp 86w,/blog/static/fea72b8bb6c1352a510a256c539d4702/d6c07/qrcode.webp 172w,/blog/static/fea72b8bb6c1352a510a256c539d4702/0f0fa/qrcode.webp 344w" sizes="(min-width: 344px) 344px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 344px) 344px, 100vw" decoding="async" loading="lazy" data-src="/blog/static/fea72b8bb6c1352a510a256c539d4702/6ee52/qrcode.jpg" data-srcset="/blog/static/fea72b8bb6c1352a510a256c539d4702/8025c/qrcode.jpg 86w,/blog/static/fea72b8bb6c1352a510a256c539d4702/15bb5/qrcode.jpg 172w,/blog/static/fea72b8bb6c1352a510a256c539d4702/6ee52/qrcode.jpg 344w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="/blog/static/fea72b8bb6c1352a510a256c539d4702/ff4dd/qrcode.webp 86w,/blog/static/fea72b8bb6c1352a510a256c539d4702/d6c07/qrcode.webp 172w,/blog/static/fea72b8bb6c1352a510a256c539d4702/0f0fa/qrcode.webp 344w" sizes="(min-width: 344px) 344px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 344px) 344px, 100vw" decoding="async" loading="lazy" src="/blog/static/fea72b8bb6c1352a510a256c539d4702/6ee52/qrcode.jpg" srcSet="/blog/static/fea72b8bb6c1352a510a256c539d4702/8025c/qrcode.jpg 86w,/blog/static/fea72b8bb6c1352a510a256c539d4702/15bb5/qrcode.jpg 172w,/blog/static/fea72b8bb6c1352a510a256c539d4702/6ee52/qrcode.jpg 344w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1)}}</script></div><div>欢迎大家关注我的公众号-前端小板凳 一起学习进步！</div></div><div style="width:700px;margin:0 auto" id="vcomment"></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8259624032507561" crossorigin="anonymous"></script></div></div></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/base-js-summary";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-4b62d492ee1645380565.js"],"component---src-pages-404-js":["/component---src-pages-404-js-ac9e0c200e4b3806caa8.js"],"component---src-pages-category-js":["/component---src-pages-category-js-73e978b017ffb816af19.js"],"component---src-templates-category-detail-js":["/component---src-templates-category-detail-js-1887a8ea3ac79138d03b.js"],"component---src-templates-index-js":["/component---src-templates-index-js-e507aa66ee477ce7547c.js"],"component---src-templates-post-js":["/component---src-templates-post-js-3bee0697db9b9af656a6.js"]};/*]]>*/</script><script src="/blog/component---src-templates-post-js-3bee0697db9b9af656a6.js" async=""></script><script src="/blog/6ba5cc0c8669d68fb0f844125a981d8f12367a97-f9ea3b3dbbe28c42596b.js" async=""></script><script src="/blog/a26abbfb03f25b9cd2b611d1d937ab5e796b3999-976c7162f0c1b8304de6.js" async=""></script><script src="/blog/ef6529d7-5809e26836cfb9703dbc.js" async=""></script><script src="/blog/app-4b62d492ee1645380565.js" async=""></script><script src="/blog/framework-30c1cbcd4309881b11c5.js" async=""></script><script src="/blog/webpack-runtime-af6ac126a20e6b95bddb.js" async=""></script></body></html>